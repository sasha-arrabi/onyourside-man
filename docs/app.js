/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/onyourside-man/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/ansi-html/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ansi-html/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),

/***/ "./node_modules/ansi-regex/index.js":
/*!******************************************!*\
  !*** ./node_modules/ansi-regex/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),

/***/ "./node_modules/box2dweb/box2d.js":
/*!****************************************!*\
  !*** ./node_modules/box2dweb/box2d.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
* Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/


var Box2D = {};

(function (a2j, undefined) {
   
   function emptyFn() {};
   a2j.inherit = function(cls, base) {
      var tmpCtr = cls;
      emptyFn.prototype = base.prototype;
      cls.prototype = new emptyFn;
      cls.prototype.constructor = tmpCtr;
   };
   
   a2j.generateCallback = function generateCallback(context, cb) {
      return function () {
         cb.apply(context, arguments);
      };
   };
   
   a2j.NVector = function NVector(length) {
      if (length === undefined) length = 0;
      var tmp = new Array(length || 0);
      for (var i = 0; i < length; ++i)
      tmp[i] = 0;
      return tmp;
   };
   
   a2j.is = function is(o1, o2) {
      if (o1 === null) return false;
      if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
      if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
      return false;
   };
   
   a2j.parseUInt = function(v) {
      return Math.abs(parseInt(v));
   }
   
})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
   Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

   function b2AABB() {
      b2AABB.b2AABB.apply(this, arguments);
   };
   Box2D.Collision.b2AABB = b2AABB;

   function b2Bound() {
      b2Bound.b2Bound.apply(this, arguments);
   };
   Box2D.Collision.b2Bound = b2Bound;

   function b2BoundValues() {
      b2BoundValues.b2BoundValues.apply(this, arguments);
      if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
   };
   Box2D.Collision.b2BoundValues = b2BoundValues;

   function b2Collision() {
      b2Collision.b2Collision.apply(this, arguments);
   };
   Box2D.Collision.b2Collision = b2Collision;

   function b2ContactID() {
      b2ContactID.b2ContactID.apply(this, arguments);
      if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
   };
   Box2D.Collision.b2ContactID = b2ContactID;

   function b2ContactPoint() {
      b2ContactPoint.b2ContactPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ContactPoint = b2ContactPoint;

   function b2Distance() {
      b2Distance.b2Distance.apply(this, arguments);
   };
   Box2D.Collision.b2Distance = b2Distance;

   function b2DistanceInput() {
      b2DistanceInput.b2DistanceInput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceInput = b2DistanceInput;

   function b2DistanceOutput() {
      b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

   function b2DistanceProxy() {
      b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

   function b2DynamicTree() {
      b2DynamicTree.b2DynamicTree.apply(this, arguments);
      if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTree = b2DynamicTree;

   function b2DynamicTreeBroadPhase() {
      b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

   function b2DynamicTreeNode() {
      b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

   function b2DynamicTreePair() {
      b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

   function b2Manifold() {
      b2Manifold.b2Manifold.apply(this, arguments);
      if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
   };
   Box2D.Collision.b2Manifold = b2Manifold;

   function b2ManifoldPoint() {
      b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
      if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

   function b2Point() {
      b2Point.b2Point.apply(this, arguments);
   };
   Box2D.Collision.b2Point = b2Point;

   function b2RayCastInput() {
      b2RayCastInput.b2RayCastInput.apply(this, arguments);
      if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastInput = b2RayCastInput;

   function b2RayCastOutput() {
      b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

   function b2Segment() {
      b2Segment.b2Segment.apply(this, arguments);
   };
   Box2D.Collision.b2Segment = b2Segment;

   function b2SeparationFunction() {
      b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
   };
   Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

   function b2Simplex() {
      b2Simplex.b2Simplex.apply(this, arguments);
      if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
   };
   Box2D.Collision.b2Simplex = b2Simplex;

   function b2SimplexCache() {
      b2SimplexCache.b2SimplexCache.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexCache = b2SimplexCache;

   function b2SimplexVertex() {
      b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

   function b2TimeOfImpact() {
      b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
   };
   Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

   function b2TOIInput() {
      b2TOIInput.b2TOIInput.apply(this, arguments);
   };
   Box2D.Collision.b2TOIInput = b2TOIInput;

   function b2WorldManifold() {
      b2WorldManifold.b2WorldManifold.apply(this, arguments);
      if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
   };
   Box2D.Collision.b2WorldManifold = b2WorldManifold;

   function ClipVertex() {
      ClipVertex.ClipVertex.apply(this, arguments);
   };
   Box2D.Collision.ClipVertex = ClipVertex;

   function Features() {
      Features.Features.apply(this, arguments);
   };
   Box2D.Collision.Features = Features;

   function b2CircleShape() {
      b2CircleShape.b2CircleShape.apply(this, arguments);
      if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

   function b2EdgeChainDef() {
      b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
      if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

   function b2EdgeShape() {
      b2EdgeShape.b2EdgeShape.apply(this, arguments);
      if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

   function b2MassData() {
      b2MassData.b2MassData.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2MassData = b2MassData;

   function b2PolygonShape() {
      b2PolygonShape.b2PolygonShape.apply(this, arguments);
      if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

   function b2Shape() {
      b2Shape.b2Shape.apply(this, arguments);
      if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2Shape = b2Shape;
   Box2D.Common.b2internal = 'Box2D.Common.b2internal';

   function b2Color() {
      b2Color.b2Color.apply(this, arguments);
      if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
   };
   Box2D.Common.b2Color = b2Color;

   function b2Settings() {
      b2Settings.b2Settings.apply(this, arguments);
   };
   Box2D.Common.b2Settings = b2Settings;

   function b2Mat22() {
      b2Mat22.b2Mat22.apply(this, arguments);
      if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat22 = b2Mat22;

   function b2Mat33() {
      b2Mat33.b2Mat33.apply(this, arguments);
      if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat33 = b2Mat33;

   function b2Math() {
      b2Math.b2Math.apply(this, arguments);
   };
   Box2D.Common.Math.b2Math = b2Math;

   function b2Sweep() {
      b2Sweep.b2Sweep.apply(this, arguments);
   };
   Box2D.Common.Math.b2Sweep = b2Sweep;

   function b2Transform() {
      b2Transform.b2Transform.apply(this, arguments);
      if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
   };
   Box2D.Common.Math.b2Transform = b2Transform;

   function b2Vec2() {
      b2Vec2.b2Vec2.apply(this, arguments);
      if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec2 = b2Vec2;

   function b2Vec3() {
      b2Vec3.b2Vec3.apply(this, arguments);
      if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec3 = b2Vec3;

   function b2Body() {
      b2Body.b2Body.apply(this, arguments);
      if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
   };
   Box2D.Dynamics.b2Body = b2Body;

   function b2BodyDef() {
      b2BodyDef.b2BodyDef.apply(this, arguments);
      if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2BodyDef = b2BodyDef;

   function b2ContactFilter() {
      b2ContactFilter.b2ContactFilter.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

   function b2ContactImpulse() {
      b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

   function b2ContactListener() {
      b2ContactListener.b2ContactListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactListener = b2ContactListener;

   function b2ContactManager() {
      b2ContactManager.b2ContactManager.apply(this, arguments);
      if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactManager = b2ContactManager;

   function b2DebugDraw() {
      b2DebugDraw.b2DebugDraw.apply(this, arguments);
      if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
   };
   Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

   function b2DestructionListener() {
      b2DestructionListener.b2DestructionListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

   function b2FilterData() {
      b2FilterData.b2FilterData.apply(this, arguments);
   };
   Box2D.Dynamics.b2FilterData = b2FilterData;

   function b2Fixture() {
      b2Fixture.b2Fixture.apply(this, arguments);
      if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
   };
   Box2D.Dynamics.b2Fixture = b2Fixture;

   function b2FixtureDef() {
      b2FixtureDef.b2FixtureDef.apply(this, arguments);
      if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

   function b2Island() {
      b2Island.b2Island.apply(this, arguments);
      if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
   };
   Box2D.Dynamics.b2Island = b2Island;

   function b2TimeStep() {
      b2TimeStep.b2TimeStep.apply(this, arguments);
   };
   Box2D.Dynamics.b2TimeStep = b2TimeStep;

   function b2World() {
      b2World.b2World.apply(this, arguments);
      if (this.constructor === b2World) this.b2World.apply(this, arguments);
   };
   Box2D.Dynamics.b2World = b2World;

   function b2CircleContact() {
      b2CircleContact.b2CircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

   function b2Contact() {
      b2Contact.b2Contact.apply(this, arguments);
      if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2Contact = b2Contact;

   function b2ContactConstraint() {
      b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
      if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

   function b2ContactConstraintPoint() {
      b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

   function b2ContactEdge() {
      b2ContactEdge.b2ContactEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

   function b2ContactFactory() {
      b2ContactFactory.b2ContactFactory.apply(this, arguments);
      if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

   function b2ContactRegister() {
      b2ContactRegister.b2ContactRegister.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

   function b2ContactResult() {
      b2ContactResult.b2ContactResult.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

   function b2ContactSolver() {
      b2ContactSolver.b2ContactSolver.apply(this, arguments);
      if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

   function b2EdgeAndCircleContact() {
      b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

   function b2NullContact() {
      b2NullContact.b2NullContact.apply(this, arguments);
      if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

   function b2PolyAndCircleContact() {
      b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

   function b2PolyAndEdgeContact() {
      b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

   function b2PolygonContact() {
      b2PolygonContact.b2PolygonContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

   function b2PositionSolverManifold() {
      b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
      if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

   function b2BuoyancyController() {
      b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

   function b2ConstantAccelController() {
      b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

   function b2ConstantForceController() {
      b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

   function b2Controller() {
      b2Controller.b2Controller.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2Controller = b2Controller;

   function b2ControllerEdge() {
      b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

   function b2GravityController() {
      b2GravityController.b2GravityController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

   function b2TensorDampingController() {
      b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

   function b2DistanceJoint() {
      b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
      if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

   function b2DistanceJointDef() {
      b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
      if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

   function b2FrictionJoint() {
      b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
      if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

   function b2FrictionJointDef() {
      b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
      if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

   function b2GearJoint() {
      b2GearJoint.b2GearJoint.apply(this, arguments);
      if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

   function b2GearJointDef() {
      b2GearJointDef.b2GearJointDef.apply(this, arguments);
      if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

   function b2Jacobian() {
      b2Jacobian.b2Jacobian.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

   function b2Joint() {
      b2Joint.b2Joint.apply(this, arguments);
      if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Joint = b2Joint;

   function b2JointDef() {
      b2JointDef.b2JointDef.apply(this, arguments);
      if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

   function b2JointEdge() {
      b2JointEdge.b2JointEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

   function b2LineJoint() {
      b2LineJoint.b2LineJoint.apply(this, arguments);
      if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

   function b2LineJointDef() {
      b2LineJointDef.b2LineJointDef.apply(this, arguments);
      if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

   function b2MouseJoint() {
      b2MouseJoint.b2MouseJoint.apply(this, arguments);
      if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

   function b2MouseJointDef() {
      b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
      if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

   function b2PrismaticJoint() {
      b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
      if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

   function b2PrismaticJointDef() {
      b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
      if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

   function b2PulleyJoint() {
      b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
      if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

   function b2PulleyJointDef() {
      b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
      if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

   function b2RevoluteJoint() {
      b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
      if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

   function b2RevoluteJointDef() {
      b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
      if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

   function b2WeldJoint() {
      b2WeldJoint.b2WeldJoint.apply(this, arguments);
      if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

   function b2WeldJointDef() {
      b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
      if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   b2AABB.b2AABB = function () {
      this.lowerBound = new b2Vec2();
      this.upperBound = new b2Vec2();
   };
   b2AABB.prototype.IsValid = function () {
      var dX = this.upperBound.x - this.lowerBound.x;
      var dY = this.upperBound.y - this.lowerBound.y;
      var valid = dX >= 0.0 && dY >= 0.0;
      valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
      return valid;
   }
   b2AABB.prototype.GetCenter = function () {
      return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
   }
   b2AABB.prototype.GetExtents = function () {
      return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
   }
   b2AABB.prototype.Contains = function (aabb) {
      var result = true;
      result = result && this.lowerBound.x <= aabb.lowerBound.x;
      result = result && this.lowerBound.y <= aabb.lowerBound.y;
      result = result && aabb.upperBound.x <= this.upperBound.x;
      result = result && aabb.upperBound.y <= this.upperBound.y;
      return result;
   }
   b2AABB.prototype.RayCast = function (output, input) {
      var tmin = (-Number.MAX_VALUE);
      var tmax = Number.MAX_VALUE;
      var pX = input.p1.x;
      var pY = input.p1.y;
      var dX = input.p2.x - input.p1.x;
      var dY = input.p2.y - input.p1.y;
      var absDX = Math.abs(dX);
      var absDY = Math.abs(dY);
      var normal = output.normal;
      var inv_d = 0;
      var t1 = 0;
      var t2 = 0;
      var t3 = 0;
      var s = 0; {
         if (absDX < Number.MIN_VALUE) {
            if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
         }
         else {
            inv_d = 1.0 / dX;
            t1 = (this.lowerBound.x - pX) * inv_d;
            t2 = (this.upperBound.x - pX) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.x = s;
               normal.y = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      } {
         if (absDY < Number.MIN_VALUE) {
            if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
         }
         else {
            inv_d = 1.0 / dY;
            t1 = (this.lowerBound.y - pY) * inv_d;
            t2 = (this.upperBound.y - pY) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.y = s;
               normal.x = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      }
      output.fraction = tmin;
      return true;
   }
   b2AABB.prototype.TestOverlap = function (other) {
      var d1X = other.lowerBound.x - this.upperBound.x;
      var d1Y = other.lowerBound.y - this.upperBound.y;
      var d2X = this.lowerBound.x - other.upperBound.x;
      var d2Y = this.lowerBound.y - other.upperBound.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   b2AABB.Combine = function (aabb1, aabb2) {
      var aabb = new b2AABB();
      aabb.Combine(aabb1, aabb2);
      return aabb;
   }
   b2AABB.prototype.Combine = function (aabb1, aabb2) {
      this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
      this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
      this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
      this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
   }
   b2Bound.b2Bound = function () {};
   b2Bound.prototype.IsLower = function () {
      return (this.value & 1) == 0;
   }
   b2Bound.prototype.IsUpper = function () {
      return (this.value & 1) == 1;
   }
   b2Bound.prototype.Swap = function (b) {
      var tempValue = this.value;
      var tempProxy = this.proxy;
      var tempStabbingCount = this.stabbingCount;
      this.value = b.value;
      this.proxy = b.proxy;
      this.stabbingCount = b.stabbingCount;
      b.value = tempValue;
      b.proxy = tempProxy;
      b.stabbingCount = tempStabbingCount;
   }
   b2BoundValues.b2BoundValues = function () {};
   b2BoundValues.prototype.b2BoundValues = function () {
      this.lowerValues = new Vector_a2j_Number();
      this.lowerValues[0] = 0.0;
      this.lowerValues[1] = 0.0;
      this.upperValues = new Vector_a2j_Number();
      this.upperValues[0] = 0.0;
      this.upperValues[1] = 0.0;
   }
   b2Collision.b2Collision = function () {};
   b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
      if (offset === undefined) offset = 0;
      var cv;
      var numOut = 0;
      cv = vIn[0];
      var vIn0 = cv.v;
      cv = vIn[1];
      var vIn1 = cv.v;
      var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
      var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
      if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
      if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
      if (distance0 * distance1 < 0.0) {
         var interp = distance0 / (distance0 - distance1);
         cv = vOut[numOut];
         var tVec = cv.v;
         tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
         tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
         cv = vOut[numOut];
         var cv2;
         if (distance0 > 0.0) {
            cv2 = vIn[0];
            cv.id = cv2.id;
         }
         else {
            cv2 = vIn[1];
            cv.id = cv2.id;
         }++numOut;
      }
      return numOut;
   }
   b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
      var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = vertices2[i];
         var dot = tVec.x * normal1X + tVec.y * normal1Y;
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      tVec = vertices1[edge1];
      tMat = xf1.R;
      var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = vertices2[index];
      tMat = xf2.R;
      var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      v2X -= v1X;
      v2Y -= v1Y;
      var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
      return separation;
   }
   b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = poly2.m_centroid;
      var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf1.R;
      tVec = poly1.m_centroid;
      dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
      var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
      var edge = 0;
      var maxDot = (-Number.MAX_VALUE);
      for (var i = 0; i < count1; ++i) {
         tVec = normals1[i];
         var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
         if (dot > maxDot) {
            maxDot = dot;
            edge = i;
         }
      }
      var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
      var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
      var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
      var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
      var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
      var bestEdge = 0;
      var bestSeparation = 0;
      var increment = 0;
      if (sPrev > s && sPrev > sNext) {
         increment = (-1);
         bestEdge = prevEdge;
         bestSeparation = sPrev;
      }
      else if (sNext > s) {
         increment = 1;
         bestEdge = nextEdge;
         bestSeparation = sNext;
      }
      else {
         edgeIndex[0] = edge;
         return s;
      }
      while (true) {
         if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
         else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
         if (s > bestSeparation) {
            bestEdge = edge;
            bestSeparation = s;
         }
         else {
            break;
         }
      }
      edgeIndex[0] = bestEdge;
      return bestSeparation;
   }
   b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var normals2 = poly2.m_normals;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
      normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
      normal1X = tX;
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = normals2[i];
         var dot = (normal1X * tVec.x + normal1Y * tVec.y);
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      var tClip;
      var i1 = parseInt(index);
      var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
      tClip = c[0];
      tVec = vertices2[i1];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i1;
      tClip.id.features.incidentVertex = 0;
      tClip = c[1];
      tVec = vertices2[i2];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i2;
      tClip.id.features.incidentVertex = 1;
   }
   b2Collision.MakeClipPointVector = function () {
      var r = new Vector(2);
      r[0] = new ClipVertex();
      r[1] = new ClipVertex();
      return r;
   }
   b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
      var cv;
      manifold.m_pointCount = 0;
      var totalRadius = polyA.m_radius + polyB.m_radius;
      var edgeA = 0;
      b2Collision.s_edgeAO[0] = edgeA;
      var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
      edgeA = b2Collision.s_edgeAO[0];
      if (separationA > totalRadius) return;
      var edgeB = 0;
      b2Collision.s_edgeBO[0] = edgeB;
      var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
      edgeB = b2Collision.s_edgeBO[0];
      if (separationB > totalRadius) return;
      var poly1;
      var poly2;
      var xf1;
      var xf2;
      var edge1 = 0;
      var flip = 0;
      var k_relativeTol = 0.98;
      var k_absoluteTol = 0.001;
      var tMat;
      if (separationB > k_relativeTol * separationA + k_absoluteTol) {
         poly1 = polyB;
         poly2 = polyA;
         xf1 = xfB;
         xf2 = xfA;
         edge1 = edgeB;
         manifold.m_type = b2Manifold.e_faceB;
         flip = 1;
      }
      else {
         poly1 = polyA;
         poly2 = polyB;
         xf1 = xfA;
         xf2 = xfB;
         edge1 = edgeA;
         manifold.m_type = b2Manifold.e_faceA;
         flip = 0;
      }
      var incidentEdge = b2Collision.s_incidentEdge;
      b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var local_v11 = vertices1[edge1];
      var local_v12;
      if (edge1 + 1 < count1) {
         local_v12 = vertices1[parseInt(edge1 + 1)];
      }
      else {
         local_v12 = vertices1[0];
      }
      var localTangent = b2Collision.s_localTangent;
      localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
      localTangent.Normalize();
      var localNormal = b2Collision.s_localNormal;
      localNormal.x = localTangent.y;
      localNormal.y = (-localTangent.x);
      var planePoint = b2Collision.s_planePoint;
      planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
      var tangent = b2Collision.s_tangent;
      tMat = xf1.R;
      tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
      tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
      var tangent2 = b2Collision.s_tangent2;
      tangent2.x = (-tangent.x);
      tangent2.y = (-tangent.y);
      var normal = b2Collision.s_normal;
      normal.x = tangent.y;
      normal.y = (-tangent.x);
      var v11 = b2Collision.s_v11;
      var v12 = b2Collision.s_v12;
      v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
      v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
      v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
      v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
      var frontOffset = normal.x * v11.x + normal.y * v11.y;
      var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
      var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
      var clipPoints1 = b2Collision.s_clipPoints1;
      var clipPoints2 = b2Collision.s_clipPoints2;
      var np = 0;
      np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
      if (np < 2) return;
      np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
      if (np < 2) return;
      manifold.m_localPlaneNormal.SetV(localNormal);
      manifold.m_localPoint.SetV(planePoint);
      var pointCount = 0;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
         cv = clipPoints2[i];
         var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
         if (separation <= totalRadius) {
            var cp = manifold.m_points[pointCount];
            tMat = xf2.R;
            var tX = cv.v.x - xf2.position.x;
            var tY = cv.v.y - xf2.position.y;
            cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
            cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
            cp.m_id.Set(cv.id);
            cp.m_id.features.flip = flip;
            ++pointCount;
         }
      }
      manifold.m_pointCount = pointCount;
   }
   b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
      manifold.m_pointCount = 0;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = circle1.m_p;
      var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      tVec = circle2.m_p;
      var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var distSqr = dX * dX + dY * dY;
      var radius = circle1.m_radius + circle2.m_radius;
      if (distSqr > radius * radius) {
         return;
      }
      manifold.m_type = b2Manifold.e_circles;
      manifold.m_localPoint.SetV(circle1.m_p);
      manifold.m_localPlaneNormal.SetZero();
      manifold.m_pointCount = 1;
      manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
      manifold.m_points[0].m_id.key = 0;
   }
   b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
      manifold.m_pointCount = 0;
      var tPoint;
      var dX = 0;
      var dY = 0;
      var positionX = 0;
      var positionY = 0;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = circle.m_p;
      var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      dX = cX - xf1.position.x;
      dY = cY - xf1.position.y;
      tMat = xf1.R;
      var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
      var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
      var dist = 0;
      var normalIndex = 0;
      var separation = (-Number.MAX_VALUE);
      var radius = polygon.m_radius + circle.m_radius;
      var vertexCount = parseInt(polygon.m_vertexCount);
      var vertices = polygon.m_vertices;
      var normals = polygon.m_normals;
      for (var i = 0; i < vertexCount; ++i) {
         tVec = vertices[i];
         dX = cLocalX - tVec.x;
         dY = cLocalY - tVec.y;
         tVec = normals[i];
         var s = tVec.x * dX + tVec.y * dY;
         if (s > radius) {
            return;
         }
         if (s > separation) {
            separation = s;
            normalIndex = i;
         }
      }
      var vertIndex1 = parseInt(normalIndex);
      var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
      var v1 = vertices[vertIndex1];
      var v2 = vertices[vertIndex2];
      if (separation < Number.MIN_VALUE) {
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
         manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
         manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
         return;
      }
      var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
      var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
      if (u1 <= 0.0) {
         if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v1.x;
         manifold.m_localPlaneNormal.y = cLocalY - v1.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v1);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else if (u2 <= 0) {
         if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v2.x;
         manifold.m_localPlaneNormal.y = cLocalY - v2.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v2);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else {
         var faceCenterX = 0.5 * (v1.x + v2.x);
         var faceCenterY = 0.5 * (v1.y + v2.y);
         separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
         if (separation > radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
         manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.Set(faceCenterX, faceCenterY);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
   }
   b2Collision.TestOverlap = function (a, b) {
      var t1 = b.lowerBound;
      var t2 = a.upperBound;
      var d1X = t1.x - t2.x;
      var d1Y = t1.y - t2.y;
      t1 = a.lowerBound;
      t2 = b.upperBound;
      var d2X = t1.x - t2.x;
      var d2Y = t1.y - t2.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
      Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
      Box2D.Collision.b2Collision.s_normal = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
      Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
      Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
   });
   b2ContactID.b2ContactID = function () {
      this.features = new Features();
   };
   b2ContactID.prototype.b2ContactID = function () {
      this.features._m_id = this;
   }
   b2ContactID.prototype.Set = function (id) {
      this.key = id._key;
   }
   b2ContactID.prototype.Copy = function () {
      var id = new b2ContactID();
      id.key = this.key;
      return id;
   }
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._key;
      }
   });
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._key = value;
         this.features._referenceEdge = this._key & 0x000000ff;
         this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
         this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
         this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
      }
   });
   b2ContactPoint.b2ContactPoint = function () {
      this.position = new b2Vec2();
      this.velocity = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2Distance.b2Distance = function () {};
   b2Distance.Distance = function (output, cache, input) {
      ++b2Distance.b2_gjkCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var transformA = input.transformA;
      var transformB = input.transformB;
      var simplex = b2Distance.s_simplex;
      simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
      var vertices = simplex.m_vertices;
      var k_maxIters = 20;
      var saveA = b2Distance.s_saveA;
      var saveB = b2Distance.s_saveB;
      var saveCount = 0;
      var closestPoint = simplex.GetClosestPoint();
      var distanceSqr1 = closestPoint.LengthSquared();
      var distanceSqr2 = distanceSqr1;
      var i = 0;
      var p;
      var iter = 0;
      while (iter < k_maxIters) {
         saveCount = simplex.m_count;
         for (i = 0;
         i < saveCount; i++) {
            saveA[i] = vertices[i].indexA;
            saveB[i] = vertices[i].indexB;
         }
         switch (simplex.m_count) {
         case 1:
            break;
         case 2:
            simplex.Solve2();
            break;
         case 3:
            simplex.Solve3();
            break;
         default:
            b2Settings.b2Assert(false);
         }
         if (simplex.m_count == 3) {
            break;
         }
         p = simplex.GetClosestPoint();
         distanceSqr2 = p.LengthSquared();
         if (distanceSqr2 > distanceSqr1) {}
         distanceSqr1 = distanceSqr2;
         var d = simplex.GetSearchDirection();
         if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
            break;
         }
         var vertex = vertices[simplex.m_count];
         vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
         vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
         vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
         vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
         vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
         ++iter;
         ++b2Distance.b2_gjkIters;
         var duplicate = false;
         for (i = 0;
         i < saveCount; i++) {
            if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
               duplicate = true;
               break;
            }
         }
         if (duplicate) {
            break;
         }++simplex.m_count;
      }
      b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
      simplex.GetWitnessPoints(output.pointA, output.pointB);
      output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
      output.iterations = iter;
      simplex.WriteCache(cache);
      if (input.useRadii) {
         var rA = proxyA.m_radius;
         var rB = proxyB.m_radius;
         if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
            output.distance -= rA + rB;
            var normal = b2Math.SubtractVV(output.pointB, output.pointA);
            normal.Normalize();
            output.pointA.x += rA * normal.x;
            output.pointA.y += rA * normal.y;
            output.pointB.x -= rB * normal.x;
            output.pointB.y -= rB * normal.y;
         }
         else {
            p = new b2Vec2();
            p.x = .5 * (output.pointA.x + output.pointB.x);
            p.y = .5 * (output.pointA.y + output.pointB.y);
            output.pointA.x = output.pointB.x = p.x;
            output.pointA.y = output.pointB.y = p.y;
            output.distance = 0.0;
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
      Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
      Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
   });
   b2DistanceInput.b2DistanceInput = function () {};
   b2DistanceOutput.b2DistanceOutput = function () {
      this.pointA = new b2Vec2();
      this.pointB = new b2Vec2();
   };
   b2DistanceProxy.b2DistanceProxy = function () {};
   b2DistanceProxy.prototype.Set = function (shape) {
      switch (shape.GetType()) {
      case b2Shape.e_circleShape:
         {
            var circle = (shape instanceof b2CircleShape ? shape : null);
            this.m_vertices = new Vector(1, true);
            this.m_vertices[0] = circle.m_p;
            this.m_count = 1;
            this.m_radius = circle.m_radius;
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var polygon = (shape instanceof b2PolygonShape ? shape : null);
            this.m_vertices = polygon.m_vertices;
            this.m_count = polygon.m_vertexCount;
            this.m_radius = polygon.m_radius;
         }
         break;
      default:
         b2Settings.b2Assert(false);
      }
   }
   b2DistanceProxy.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2DistanceProxy.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2DistanceProxy.prototype.GetVertexCount = function () {
      return this.m_count;
   }
   b2DistanceProxy.prototype.GetVertex = function (index) {
      if (index === undefined) index = 0;
      b2Settings.b2Assert(0 <= index && index < this.m_count);
      return this.m_vertices[index];
   }
   b2DynamicTree.b2DynamicTree = function () {};
   b2DynamicTree.prototype.b2DynamicTree = function () {
      this.m_root = null;
      this.m_freeList = null;
      this.m_path = 0;
      this.m_insertionCount = 0;
   }
   b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
      var node = this.AllocateNode();
      var extendX = b2Settings.b2_aabbExtension;
      var extendY = b2Settings.b2_aabbExtension;
      node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      node.aabb.upperBound.x = aabb.upperBound.x + extendX;
      node.aabb.upperBound.y = aabb.upperBound.y + extendY;
      node.userData = userData;
      this.InsertLeaf(node);
      return node;
   }
   b2DynamicTree.prototype.DestroyProxy = function (proxy) {
      this.RemoveLeaf(proxy);
      this.FreeNode(proxy);
   }
   b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
      b2Settings.b2Assert(proxy.IsLeaf());
      if (proxy.aabb.Contains(aabb)) {
         return false;
      }
      this.RemoveLeaf(proxy);
      var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
      var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
      proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
      proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
      this.InsertLeaf(proxy);
      return true;
   }
   b2DynamicTree.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      if (this.m_root == null) return;
      for (var i = 0; i < iterations; i++) {
         var node = this.m_root;
         var bit = 0;
         while (node.IsLeaf() == false) {
            node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
            bit = (bit + 1) & 31;
         }++this.m_path;
         this.RemoveLeaf(node);
         this.InsertLeaf(node);
      }
   }
   b2DynamicTree.prototype.GetFatAABB = function (proxy) {
      return proxy.aabb;
   }
   b2DynamicTree.prototype.GetUserData = function (proxy) {
      return proxy.userData;
   }
   b2DynamicTree.prototype.Query = function (callback, aabb) {
      if (this.m_root == null) return;
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(aabb)) {
            if (node.IsLeaf()) {
               var proceed = callback(node);
               if (!proceed) return;
            }
            else {
               stack[count++] = node.child1;
               stack[count++] = node.child2;
            }
         }
      }
   }
   b2DynamicTree.prototype.RayCast = function (callback, input) {
      if (this.m_root == null) return;
      var p1 = input.p1;
      var p2 = input.p2;
      var r = b2Math.SubtractVV(p1, p2);
      r.Normalize();
      var v = b2Math.CrossFV(1.0, r);
      var abs_v = b2Math.AbsV(v);
      var maxFraction = input.maxFraction;
      var segmentAABB = new b2AABB();
      var tX = 0;
      var tY = 0; {
         tX = p1.x + maxFraction * (p2.x - p1.x);
         tY = p1.y + maxFraction * (p2.y - p1.y);
         segmentAABB.lowerBound.x = Math.min(p1.x, tX);
         segmentAABB.lowerBound.y = Math.min(p1.y, tY);
         segmentAABB.upperBound.x = Math.max(p1.x, tX);
         segmentAABB.upperBound.y = Math.max(p1.y, tY);
      }
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(segmentAABB) == false) {
            continue;
         }
         var c = node.aabb.GetCenter();
         var h = node.aabb.GetExtents();
         var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
         if (separation > 0.0) continue;
         if (node.IsLeaf()) {
            var subInput = new b2RayCastInput();
            subInput.p1 = input.p1;
            subInput.p2 = input.p2;
            subInput.maxFraction = input.maxFraction;
            maxFraction = callback(subInput, node);
            if (maxFraction == 0.0) return;
            if (maxFraction > 0.0) {
               tX = p1.x + maxFraction * (p2.x - p1.x);
               tY = p1.y + maxFraction * (p2.y - p1.y);
               segmentAABB.lowerBound.x = Math.min(p1.x, tX);
               segmentAABB.lowerBound.y = Math.min(p1.y, tY);
               segmentAABB.upperBound.x = Math.max(p1.x, tX);
               segmentAABB.upperBound.y = Math.max(p1.y, tY);
            }
         }
         else {
            stack[count++] = node.child1;
            stack[count++] = node.child2;
         }
      }
   }
   b2DynamicTree.prototype.AllocateNode = function () {
      if (this.m_freeList) {
         var node = this.m_freeList;
         this.m_freeList = node.parent;
         node.parent = null;
         node.child1 = null;
         node.child2 = null;
         return node;
      }
      return new b2DynamicTreeNode();
   }
   b2DynamicTree.prototype.FreeNode = function (node) {
      node.parent = this.m_freeList;
      this.m_freeList = node;
   }
   b2DynamicTree.prototype.InsertLeaf = function (leaf) {
      ++this.m_insertionCount;
      if (this.m_root == null) {
         this.m_root = leaf;
         this.m_root.parent = null;
         return;
      }
      var center = leaf.aabb.GetCenter();
      var sibling = this.m_root;
      if (sibling.IsLeaf() == false) {
         do {
            var child1 = sibling.child1;
            var child2 = sibling.child2;
            var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
            var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
            if (norm1 < norm2) {
               sibling = child1;
            }
            else {
               sibling = child2;
            }
         }
         while (sibling.IsLeaf() == false)
      }
      var node1 = sibling.parent;
      var node2 = this.AllocateNode();
      node2.parent = node1;
      node2.userData = null;
      node2.aabb.Combine(leaf.aabb, sibling.aabb);
      if (node1) {
         if (sibling.parent.child1 == sibling) {
            node1.child1 = node2;
         }
         else {
            node1.child2 = node2;
         }
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         do {
            if (node1.aabb.Contains(node2.aabb)) break;
            node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
            node2 = node1;
            node1 = node1.parent;
         }
         while (node1)
      }
      else {
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         this.m_root = node2;
      }
   }
   b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
      if (leaf == this.m_root) {
         this.m_root = null;
         return;
      }
      var node2 = leaf.parent;
      var node1 = node2.parent;
      var sibling;
      if (node2.child1 == leaf) {
         sibling = node2.child2;
      }
      else {
         sibling = node2.child1;
      }
      if (node1) {
         if (node1.child1 == node2) {
            node1.child1 = sibling;
         }
         else {
            node1.child2 = sibling;
         }
         sibling.parent = node1;
         this.FreeNode(node2);
         while (node1) {
            var oldAABB = node1.aabb;
            node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
            if (oldAABB.Contains(node1.aabb)) break;
            node1 = node1.parent;
         }
      }
      else {
         this.m_root = sibling;
         sibling.parent = null;
         this.FreeNode(node2);
      }
   }
   b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
      this.m_tree = new b2DynamicTree();
      this.m_moveBuffer = new Vector();
      this.m_pairBuffer = new Vector();
      this.m_pairCount = 0;
   };
   b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
      var proxy = this.m_tree.CreateProxy(aabb, userData);
      ++this.m_proxyCount;
      this.BufferMove(proxy);
      return proxy;
   }
   b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
      this.UnBufferMove(proxy);
      --this.m_proxyCount;
      this.m_tree.DestroyProxy(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
      var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
      if (buffer) {
         this.BufferMove(proxy);
      }
   }
   b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
      var aabbA = this.m_tree.GetFatAABB(proxyA);
      var aabbB = this.m_tree.GetFatAABB(proxyB);
      return aabbA.TestOverlap(aabbB);
   }
   b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
      return this.m_tree.GetUserData(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
      return this.m_tree.GetFatAABB(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
      return this.m_proxyCount;
   }
   b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
      var __this = this;
      __this.m_pairCount = 0;
      var i = 0,
         queryProxy;
       function QueryCallback(proxy) {
          if (proxy == queryProxy) return true;
          if (__this.m_pairCount == __this.m_pairBuffer.length) {
             __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
          }
          var pair = __this.m_pairBuffer[__this.m_pairCount];
          pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
          pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
          return true;
       };
      for (i = 0;
      i < __this.m_moveBuffer.length; ++i) {
         queryProxy = __this.m_moveBuffer[i];
         var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
         __this.m_tree.Query(QueryCallback, fatAABB);
      }
      __this.m_moveBuffer.length = 0;
      for (var i = 0; i < __this.m_pairCount;) {
         var primaryPair = __this.m_pairBuffer[i];
         var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
         var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
         callback(userDataA, userDataB);
         ++i;
         while (i < __this.m_pairCount) {
            var pair = __this.m_pairBuffer[i];
            if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
               break;
            }++i;
         }
      }
   }
   b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
      this.m_tree.Query(callback, aabb);
   }
   b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
      this.m_tree.RayCast(callback, input);
   }
   b2DynamicTreeBroadPhase.prototype.Validate = function () {}
   b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      this.m_tree.Rebalance(iterations);
   }
   b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
      this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
   }
   b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
      var i = parseInt(this.m_moveBuffer.indexOf(proxy));
      this.m_moveBuffer.splice(i, 1);
   }
   b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
      return 0;
   }
   b2DynamicTreeBroadPhase.__implements = {};
   b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
   b2DynamicTreeNode.b2DynamicTreeNode = function () {
      this.aabb = new b2AABB();
   };
   b2DynamicTreeNode.prototype.IsLeaf = function () {
      return this.child1 == null;
   }
   b2DynamicTreePair.b2DynamicTreePair = function () {};
   b2Manifold.b2Manifold = function () {
      this.m_pointCount = 0;
   };
   b2Manifold.prototype.b2Manifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2ManifoldPoint();
      }
      this.m_localPlaneNormal = new b2Vec2();
      this.m_localPoint = new b2Vec2();
   }
   b2Manifold.prototype.Reset = function () {
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
      }
      this.m_localPlaneNormal.SetZero();
      this.m_localPoint.SetZero();
      this.m_type = 0;
      this.m_pointCount = 0;
   }
   b2Manifold.prototype.Set = function (m) {
      this.m_pointCount = m.m_pointCount;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
      }
      this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_type = m.m_type;
   }
   b2Manifold.prototype.Copy = function () {
      var copy = new b2Manifold();
      copy.Set(this);
      return copy;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Manifold.e_circles = 0x0001;
      Box2D.Collision.b2Manifold.e_faceA = 0x0002;
      Box2D.Collision.b2Manifold.e_faceB = 0x0004;
   });
   b2ManifoldPoint.b2ManifoldPoint = function () {
      this.m_localPoint = new b2Vec2();
      this.m_id = new b2ContactID();
   };
   b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
      this.Reset();
   }
   b2ManifoldPoint.prototype.Reset = function () {
      this.m_localPoint.SetZero();
      this.m_normalImpulse = 0.0;
      this.m_tangentImpulse = 0.0;
      this.m_id.key = 0;
   }
   b2ManifoldPoint.prototype.Set = function (m) {
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_normalImpulse = m.m_normalImpulse;
      this.m_tangentImpulse = m.m_tangentImpulse;
      this.m_id.Set(m.m_id);
   }
   b2Point.b2Point = function () {
      this.p = new b2Vec2();
   };
   b2Point.prototype.Support = function (xf, vX, vY) {
      if (vX === undefined) vX = 0;
      if (vY === undefined) vY = 0;
      return this.p;
   }
   b2Point.prototype.GetFirstVertex = function (xf) {
      return this.p;
   }
   b2RayCastInput.b2RayCastInput = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
      if (p1 === undefined) p1 = null;
      if (p2 === undefined) p2 = null;
      if (maxFraction === undefined) maxFraction = 1;
      if (p1) this.p1.SetV(p1);
      if (p2) this.p2.SetV(p2);
      this.maxFraction = maxFraction;
   }
   b2RayCastOutput.b2RayCastOutput = function () {
      this.normal = new b2Vec2();
   };
   b2Segment.b2Segment = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
      if (maxLambda === undefined) maxLambda = 0;
      var s = segment.p1;
      var rX = segment.p2.x - s.x;
      var rY = segment.p2.y - s.y;
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var nX = dY;
      var nY = (-dX);
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = s.x - this.p1.x;
         var bY = s.y - this.p1.y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= maxLambda * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               nX /= nLen;
               nY /= nLen;
               lambda[0] = a;
               normal.Set(nX, nY);
               return true;
            }
         }
      }
      return false;
   }
   b2Segment.prototype.Extend = function (aabb) {
      this.ExtendForward(aabb);
      this.ExtendBackward(aabb);
   }
   b2Segment.prototype.ExtendForward = function (aabb) {
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
      this.p2.x = this.p1.x + dX * lambda;
      this.p2.y = this.p1.y + dY * lambda;
   }
   b2Segment.prototype.ExtendBackward = function (aabb) {
      var dX = (-this.p2.x) + this.p1.x;
      var dY = (-this.p2.y) + this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
      this.p1.x = this.p2.x + dX * lambda;
      this.p1.y = this.p2.y + dY * lambda;
   }
   b2SeparationFunction.b2SeparationFunction = function () {
      this.m_localPoint = new b2Vec2();
      this.m_axis = new b2Vec2();
   };
   b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
      this.m_proxyA = proxyA;
      this.m_proxyB = proxyB;
      var count = parseInt(cache.count);
      b2Settings.b2Assert(0 < count && count < 3);
      var localPointA;
      var localPointA1;
      var localPointA2;
      var localPointB;
      var localPointB1;
      var localPointB2;
      var pointAX = 0;
      var pointAY = 0;
      var pointBX = 0;
      var pointBY = 0;
      var normalX = 0;
      var normalY = 0;
      var tMat;
      var tVec;
      var s = 0;
      var sgn = 0;
      if (count == 1) {
         this.m_type = b2SeparationFunction.e_points;
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         this.m_axis.x = pointBX - pointAX;
         this.m_axis.y = pointBY - pointAY;
         this.m_axis.Normalize();
      }
      else if (cache.indexB[0] == cache.indexB[1]) {
         this.m_type = b2SeparationFunction.e_faceA;
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
         this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformA.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else if (cache.indexA[0] == cache.indexA[0]) {
         this.m_type = b2SeparationFunction.e_faceB;
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
         this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformB.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else {
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         var pA = b2Math.MulX(transformA, localPointA);
         var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
         var pB = b2Math.MulX(transformB, localPointB);
         var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
         var a = dA.x * dA.x + dA.y * dA.y;
         var e = dB.x * dB.x + dB.y * dB.y;
         var r = b2Math.SubtractVV(dB, dA);
         var c = dA.x * r.x + dA.y * r.y;
         var f = dB.x * r.x + dB.y * r.y;
         var b = dA.x * dB.x + dA.y * dB.y;
         var denom = a * e - b * b;
         s = 0.0;
         if (denom != 0.0) {
            s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
         }
         var t = (b * s + f) / e;
         if (t < 0.0) {
            t = 0.0;
            s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
         }
         localPointA = new b2Vec2();
         localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
         localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
         localPointB = new b2Vec2();
         localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
         localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
         if (s == 0.0 || s == 1.0) {
            this.m_type = b2SeparationFunction.e_faceB;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            this.m_localPoint = localPointB;
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
         else {
            this.m_type = b2SeparationFunction.e_faceA;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_localPoint = localPointA;
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
      }
   }
   b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
      var axisA;
      var axisB;
      var localPointA;
      var localPointB;
      var pointA;
      var pointB;
      var seperation = 0;
      var normal;
      switch (this.m_type) {
      case b2SeparationFunction.e_points:
         {
            axisA = b2Math.MulTMV(transformA.R, this.m_axis);
            axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointA = b2Math.MulX(transformA, localPointA);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceA:
         {
            normal = b2Math.MulMV(transformA.R, this.m_axis);
            pointA = b2Math.MulX(transformA, this.m_localPoint);
            axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceB:
         {
            normal = b2Math.MulMV(transformB.R, this.m_axis);
            pointB = b2Math.MulX(transformB, this.m_localPoint);
            axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            pointA = b2Math.MulX(transformA, localPointA);
            seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
            return seperation;
         }
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2SeparationFunction.e_points = 0x01;
      Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
      Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
   });
   b2Simplex.b2Simplex = function () {
      this.m_v1 = new b2SimplexVertex();
      this.m_v2 = new b2SimplexVertex();
      this.m_v3 = new b2SimplexVertex();
      this.m_vertices = new Vector(3);
   };
   b2Simplex.prototype.b2Simplex = function () {
      this.m_vertices[0] = this.m_v1;
      this.m_vertices[1] = this.m_v2;
      this.m_vertices[2] = this.m_v3;
   }
   b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
      b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
      var wALocal;
      var wBLocal;
      this.m_count = cache.count;
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         var v = vertices[i];
         v.indexA = cache.indexA[i];
         v.indexB = cache.indexB[i];
         wALocal = proxyA.GetVertex(v.indexA);
         wBLocal = proxyB.GetVertex(v.indexB);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         v.a = 0;
      }
      if (this.m_count > 1) {
         var metric1 = cache.metric;
         var metric2 = this.GetMetric();
         if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
            this.m_count = 0;
         }
      }
      if (this.m_count == 0) {
         v = vertices[0];
         v.indexA = 0;
         v.indexB = 0;
         wALocal = proxyA.GetVertex(0);
         wBLocal = proxyB.GetVertex(0);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         this.m_count = 1;
      }
   }
   b2Simplex.prototype.WriteCache = function (cache) {
      cache.metric = this.GetMetric();
      cache.count = Box2D.parseUInt(this.m_count);
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
         cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
      }
   }
   b2Simplex.prototype.GetSearchDirection = function () {
      switch (this.m_count) {
      case 1:
         return this.m_v1.w.GetNegative();
      case 2:
         {
            var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
            var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
            if (sgn > 0.0) {
               return b2Math.CrossFV(1.0, e12);
            }
            else {
               return b2Math.CrossVF(e12, 1.0);
            }
         }
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetClosestPoint = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      case 1:
         return this.m_v1.w;
      case 2:
         return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         break;
      case 1:
         pA.SetV(this.m_v1.wA);
         pB.SetV(this.m_v1.wB);
         break;
      case 2:
         pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
         pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
         pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
         pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
         break;
      case 3:
         pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
         pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
         break;
      default:
         b2Settings.b2Assert(false);
         break;
      }
   }
   b2Simplex.prototype.GetMetric = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return 0.0;
      case 1:
         return 0.0;
      case 2:
         return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
      case 3:
         return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   b2Simplex.prototype.Solve2 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
      if (d12_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      var d12_1 = (w2.x * e12.x + w2.y * e12.y);
      if (d12_1 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      var inv_d12 = 1.0 / (d12_1 + d12_2);
      this.m_v1.a = d12_1 * inv_d12;
      this.m_v2.a = d12_2 * inv_d12;
      this.m_count = 2;
   }
   b2Simplex.prototype.Solve3 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var w3 = this.m_v3.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var w1e12 = b2Math.Dot(w1, e12);
      var w2e12 = b2Math.Dot(w2, e12);
      var d12_1 = w2e12;
      var d12_2 = (-w1e12);
      var e13 = b2Math.SubtractVV(w3, w1);
      var w1e13 = b2Math.Dot(w1, e13);
      var w3e13 = b2Math.Dot(w3, e13);
      var d13_1 = w3e13;
      var d13_2 = (-w1e13);
      var e23 = b2Math.SubtractVV(w3, w2);
      var w2e23 = b2Math.Dot(w2, e23);
      var w3e23 = b2Math.Dot(w3, e23);
      var d23_1 = w3e23;
      var d23_2 = (-w2e23);
      var n123 = b2Math.CrossVV(e12, e13);
      var d123_1 = n123 * b2Math.CrossVV(w2, w3);
      var d123_2 = n123 * b2Math.CrossVV(w3, w1);
      var d123_3 = n123 * b2Math.CrossVV(w1, w2);
      if (d12_2 <= 0.0 && d13_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
         var inv_d12 = 1.0 / (d12_1 + d12_2);
         this.m_v1.a = d12_1 * inv_d12;
         this.m_v2.a = d12_2 * inv_d12;
         this.m_count = 2;
         return;
      }
      if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
         var inv_d13 = 1.0 / (d13_1 + d13_2);
         this.m_v1.a = d13_1 * inv_d13;
         this.m_v3.a = d13_2 * inv_d13;
         this.m_count = 2;
         this.m_v2.Set(this.m_v3);
         return;
      }
      if (d12_1 <= 0.0 && d23_2 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      if (d13_1 <= 0.0 && d23_1 <= 0.0) {
         this.m_v3.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v3);
         return;
      }
      if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
         var inv_d23 = 1.0 / (d23_1 + d23_2);
         this.m_v2.a = d23_1 * inv_d23;
         this.m_v3.a = d23_2 * inv_d23;
         this.m_count = 2;
         this.m_v1.Set(this.m_v3);
         return;
      }
      var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
      this.m_v1.a = d123_1 * inv_d123;
      this.m_v2.a = d123_2 * inv_d123;
      this.m_v3.a = d123_3 * inv_d123;
      this.m_count = 3;
   }
   b2SimplexCache.b2SimplexCache = function () {
      this.indexA = new Vector_a2j_Number(3);
      this.indexB = new Vector_a2j_Number(3);
   };
   b2SimplexVertex.b2SimplexVertex = function () {};
   b2SimplexVertex.prototype.Set = function (other) {
      this.wA.SetV(other.wA);
      this.wB.SetV(other.wB);
      this.w.SetV(other.w);
      this.a = other.a;
      this.indexA = other.indexA;
      this.indexB = other.indexB;
   }
   b2TimeOfImpact.b2TimeOfImpact = function () {};
   b2TimeOfImpact.TimeOfImpact = function (input) {
      ++b2TimeOfImpact.b2_toiCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var sweepA = input.sweepA;
      var sweepB = input.sweepB;
      b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
      b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
      var radius = proxyA.m_radius + proxyB.m_radius;
      var tolerance = input.tolerance;
      var alpha = 0.0;
      var k_maxIterations = 1000;
      var iter = 0;
      var target = 0.0;
      b2TimeOfImpact.s_cache.count = 0;
      b2TimeOfImpact.s_distanceInput.useRadii = false;
      for (;;) {
         sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
         sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
         b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
         b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
         b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
         b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
         b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
         if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
            alpha = 1.0;
            break;
         }
         b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
         var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
         if (separation <= 0.0) {
            alpha = 1.0;
            break;
         }
         if (iter == 0) {
            if (separation > radius) {
               target = b2Math.Max(radius - tolerance, 0.75 * radius);
            }
            else {
               target = b2Math.Max(separation - tolerance, 0.02 * radius);
            }
         }
         if (separation - target < 0.5 * tolerance) {
            if (iter == 0) {
               alpha = 1.0;
               break;
            }
            break;
         }
         var newAlpha = alpha; {
            var x1 = alpha;
            var x2 = 1.0;
            var f1 = separation;
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
            var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (f2 >= target) {
               alpha = 1.0;
               break;
            }
            var rootIterCount = 0;
            for (;;) {
               var x = 0;
               if (rootIterCount & 1) {
                  x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
               }
               else {
                  x = 0.5 * (x1 + x2);
               }
               sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
               sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
               var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
               if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                  newAlpha = x;
                  break;
               }
               if (f > target) {
                  x1 = x;
                  f1 = f;
               }
               else {
                  x2 = x;
                  f2 = f;
               }++rootIterCount;
               ++b2TimeOfImpact.b2_toiRootIters;
               if (rootIterCount == 50) {
                  break;
               }
            }
            b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
         }
         if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha) {
            break;
         }
         alpha = newAlpha;
         iter++;
         ++b2TimeOfImpact.b2_toiIters;
         if (iter == k_maxIterations) {
            break;
         }
      }
      b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
      return alpha;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
      Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
      Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
      Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
   });
   b2TOIInput.b2TOIInput = function () {
      this.proxyA = new b2DistanceProxy();
      this.proxyB = new b2DistanceProxy();
      this.sweepA = new b2Sweep();
      this.sweepB = new b2Sweep();
   };
   b2WorldManifold.b2WorldManifold = function () {
      this.m_normal = new b2Vec2();
   };
   b2WorldManifold.prototype.b2WorldManifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
      if (radiusA === undefined) radiusA = 0;
      if (radiusB === undefined) radiusB = 0;
      if (manifold.m_pointCount == 0) {
         return;
      }
      var i = 0;
      var tVec;
      var tMat;
      var normalX = 0;
      var normalY = 0;
      var planePointX = 0;
      var planePointY = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      switch (manifold.m_type) {
      case b2Manifold.e_circles:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_points[0].m_localPoint;
            var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1;
               this.m_normal.y = 0;
            }
            var cAX = pointAX + radiusA * this.m_normal.x;
            var cAY = pointAY + radiusA * this.m_normal.y;
            var cBX = pointBX - radiusB * this.m_normal.x;
            var cBY = pointBY - radiusB * this.m_normal.y;
            this.m_points[0].x = 0.5 * (cAX + cBX);
            this.m_points[0].y = 0.5 * (cAY + cBY);
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = normalX;
            this.m_normal.y = normalY;
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfB.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = xfB.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_localPoint;
            planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = (-normalX);
            this.m_normal.y = (-normalY);
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfA.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
            }
         }
         break;
      }
   }
   ClipVertex.ClipVertex = function () {
      this.v = new b2Vec2();
      this.id = new b2ContactID();
   };
   ClipVertex.prototype.Set = function (other) {
      this.v.SetV(other.v);
      this.id.Set(other.id);
   }
   Features.Features = function () {};
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._referenceEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._referenceEdge = value;
         this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentEdge = value;
         this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentVertex;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentVertex = value;
         this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._flip;
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._flip = value;
         this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
      }
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
   b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2CircleShape.b2CircleShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.m_p = new b2Vec2();
   };
   b2CircleShape.prototype.Copy = function () {
      var s = new b2CircleShape();
      s.Set(this);
      return s;
   }
   b2CircleShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2CircleShape)) {
         var other2 = (other instanceof b2CircleShape ? other : null);
         this.m_p.SetV(other2.m_p);
      }
   }
   b2CircleShape.prototype.TestPoint = function (transform, p) {
      var tMat = transform.R;
      var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      dX = p.x - dX;
      dY = p.y - dY;
      return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
   }
   b2CircleShape.prototype.RayCast = function (output, input, transform) {
      var tMat = transform.R;
      var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      var sX = input.p1.x - positionX;
      var sY = input.p1.y - positionY;
      var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      var c = (sX * rX + sY * rY);
      var rr = (rX * rX + rY * rY);
      var sigma = c * c - rr * b;
      if (sigma < 0.0 || rr < Number.MIN_VALUE) {
         return false;
      }
      var a = (-(c + Math.sqrt(sigma)));
      if (0.0 <= a && a <= input.maxFraction * rr) {
         a /= rr;
         output.fraction = a;
         output.normal.x = sX + a * rX;
         output.normal.y = sY + a * rY;
         output.normal.Normalize();
         return true;
      }
      return false;
   }
   b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
      aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
   }
   b2CircleShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
      massData.center.SetV(this.m_p);
      massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
   }
   b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var p = b2Math.MulX(xf, this.m_p);
      var l = (-(b2Math.Dot(normal, p) - offset));
      if (l < (-this.m_radius) + Number.MIN_VALUE) {
         return 0;
      }
      if (l > this.m_radius) {
         c.SetV(p);
         return Math.PI * this.m_radius * this.m_radius;
      }
      var r2 = this.m_radius * this.m_radius;
      var l2 = l * l;
      var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
      var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
      c.x = p.x + normal.x * com;
      c.y = p.y + normal.y * com;
      return area;
   }
   b2CircleShape.prototype.GetLocalPosition = function () {
      return this.m_p;
   }
   b2CircleShape.prototype.SetLocalPosition = function (position) {
      this.m_p.SetV(position);
   }
   b2CircleShape.prototype.GetRadius = function () {
      return this.m_radius;
   }
   b2CircleShape.prototype.SetRadius = function (radius) {
      if (radius === undefined) radius = 0;
      this.m_radius = radius;
   }
   b2CircleShape.prototype.b2CircleShape = function (radius) {
      if (radius === undefined) radius = 0;
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_circleShape;
      this.m_radius = radius;
   }
   b2EdgeChainDef.b2EdgeChainDef = function () {};
   b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
      this.vertexCount = 0;
      this.isALoop = true;
      this.vertices = [];
   }
   Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
   b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2EdgeShape.b2EdgeShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.s_supportVec = new b2Vec2();
      this.m_v1 = new b2Vec2();
      this.m_v2 = new b2Vec2();
      this.m_coreV1 = new b2Vec2();
      this.m_coreV2 = new b2Vec2();
      this.m_normal = new b2Vec2();
      this.m_direction = new b2Vec2();
      this.m_cornerDir1 = new b2Vec2();
      this.m_cornerDir2 = new b2Vec2();
   };
   b2EdgeShape.prototype.TestPoint = function (transform, p) {
      return false;
   }
   b2EdgeShape.prototype.RayCast = function (output, input, transform) {
      var tMat;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
      var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = input.p1.x - v1X;
         var bY = input.p1.y - v1Y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= input.maxFraction * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               output.fraction = a;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               output.normal.x = nX / nLen;
               output.normal.y = nY / nLen;
               return true;
            }
         }
      }
      return false;
   }
   b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
      var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
      if (v1X < v2X) {
         aabb.lowerBound.x = v1X;
         aabb.upperBound.x = v2X;
      }
      else {
         aabb.lowerBound.x = v2X;
         aabb.upperBound.x = v1X;
      }
      if (v1Y < v2Y) {
         aabb.lowerBound.y = v1Y;
         aabb.upperBound.y = v2Y;
      }
      else {
         aabb.lowerBound.y = v2Y;
         aabb.upperBound.y = v1Y;
      }
   }
   b2EdgeShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = 0;
      massData.center.SetV(this.m_v1);
      massData.I = 0;
   }
   b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
      var v1 = b2Math.MulX(xf, this.m_v1);
      var v2 = b2Math.MulX(xf, this.m_v2);
      var d1 = b2Math.Dot(normal, v1) - offset;
      var d2 = b2Math.Dot(normal, v2) - offset;
      if (d1 > 0) {
         if (d2 > 0) {
            return 0;
         }
         else {
            v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
      }
      else {
         if (d2 > 0) {
            v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
         else {}
      }
      c.x = (v0.x + v1.x + v2.x) / 3;
      c.y = (v0.y + v1.y + v2.y) / 3;
      return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
   }
   b2EdgeShape.prototype.GetLength = function () {
      return this.m_length;
   }
   b2EdgeShape.prototype.GetVertex1 = function () {
      return this.m_v1;
   }
   b2EdgeShape.prototype.GetVertex2 = function () {
      return this.m_v2;
   }
   b2EdgeShape.prototype.GetCoreVertex1 = function () {
      return this.m_coreV1;
   }
   b2EdgeShape.prototype.GetCoreVertex2 = function () {
      return this.m_coreV2;
   }
   b2EdgeShape.prototype.GetNormalVector = function () {
      return this.m_normal;
   }
   b2EdgeShape.prototype.GetDirectionVector = function () {
      return this.m_direction;
   }
   b2EdgeShape.prototype.GetCorner1Vector = function () {
      return this.m_cornerDir1;
   }
   b2EdgeShape.prototype.GetCorner2Vector = function () {
      return this.m_cornerDir2;
   }
   b2EdgeShape.prototype.Corner1IsConvex = function () {
      return this.m_cornerConvex1;
   }
   b2EdgeShape.prototype.Corner2IsConvex = function () {
      return this.m_cornerConvex2;
   }
   b2EdgeShape.prototype.GetFirstVertex = function (xf) {
      var tMat = xf.R;
      return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
   }
   b2EdgeShape.prototype.GetNextEdge = function () {
      return this.m_nextEdge;
   }
   b2EdgeShape.prototype.GetPrevEdge = function () {
      return this.m_prevEdge;
   }
   b2EdgeShape.prototype.Support = function (xf, dX, dY) {
      if (dX === undefined) dX = 0;
      if (dY === undefined) dY = 0;
      var tMat = xf.R;
      var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
      var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
      var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
      var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
      if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
         this.s_supportVec.x = v1X;
         this.s_supportVec.y = v1Y;
      }
      else {
         this.s_supportVec.x = v2X;
         this.s_supportVec.y = v2Y;
      }
      return this.s_supportVec;
   }
   b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_edgeShape;
      this.m_prevEdge = null;
      this.m_nextEdge = null;
      this.m_v1 = v1;
      this.m_v2 = v2;
      this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
      this.m_length = this.m_direction.Normalize();
      this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
      this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
      this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
      this.m_cornerDir1 = this.m_normal;
      this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
   }
   b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
      this.m_prevEdge = edge;
      this.m_coreV1 = core;
      this.m_cornerDir1 = cornerDir;
      this.m_cornerConvex1 = convex;
   }
   b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
      this.m_nextEdge = edge;
      this.m_coreV2 = core;
      this.m_cornerDir2 = cornerDir;
      this.m_cornerConvex2 = convex;
   }
   b2MassData.b2MassData = function () {
      this.mass = 0.0;
      this.center = new b2Vec2(0, 0);
      this.I = 0.0;
   };
   Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
   b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2PolygonShape.b2PolygonShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
   };
   b2PolygonShape.prototype.Copy = function () {
      var s = new b2PolygonShape();
      s.Set(this);
      return s;
   }
   b2PolygonShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2PolygonShape)) {
         var other2 = (other instanceof b2PolygonShape ? other : null);
         this.m_centroid.SetV(other2.m_centroid);
         this.m_vertexCount = other2.m_vertexCount;
         this.Reserve(this.m_vertexCount);
         for (var i = 0; i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(other2.m_vertices[i]);
            this.m_normals[i].SetV(other2.m_normals[i]);
         }
      }
   }
   b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var v = new Vector();
      var i = 0,
         tVec;
      for (i = 0;
      i < vertices.length; ++i) {
         tVec = vertices[i];
         v.push(tVec);
      }
      this.SetAsVector(v, vertexCount);
   }
   b2PolygonShape.AsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsArray(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      if (vertexCount == 0) vertexCount = vertices.length;
      b2Settings.b2Assert(2 <= vertexCount);
      this.m_vertexCount = vertexCount;
      this.Reserve(vertexCount);
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; i++) {
         this.m_vertices[i].SetV(vertices[i]);
      }
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         var i1 = parseInt(i);
         var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
         var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
         b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
         this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
         this.m_normals[i].Normalize();
      }
      this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
   }
   b2PolygonShape.AsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsVector(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid.SetZero();
   }
   b2PolygonShape.AsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsBox(hx, hy);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid = center;
      var xf = new b2Transform();
      xf.position = center;
      xf.R.Set(angle);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
         this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
      }
   }
   b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsOrientedBox(hx, hy, center, angle);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
      this.m_vertexCount = 2;
      this.Reserve(2);
      this.m_vertices[0].SetV(v1);
      this.m_vertices[1].SetV(v2);
      this.m_centroid.x = 0.5 * (v1.x + v2.x);
      this.m_centroid.y = 0.5 * (v1.y + v2.y);
      this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
      this.m_normals[0].Normalize();
      this.m_normals[1].x = (-this.m_normals[0].x);
      this.m_normals[1].y = (-this.m_normals[0].y);
   }
   b2PolygonShape.AsEdge = function (v1, v2) {
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsEdge(v1, v2);
      return polygonShape;
   }
   b2PolygonShape.prototype.TestPoint = function (xf, p) {
      var tVec;
      var tMat = xf.R;
      var tX = p.x - xf.position.x;
      var tY = p.y - xf.position.y;
      var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
      var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = pLocalX - tVec.x;
         tY = pLocalY - tVec.y;
         tVec = this.m_normals[i];
         var dot = (tVec.x * tX + tVec.y * tY);
         if (dot > 0.0) {
            return false;
         }
      }
      return true;
   }
   b2PolygonShape.prototype.RayCast = function (output, input, transform) {
      var lower = 0.0;
      var upper = input.maxFraction;
      var tX = 0;
      var tY = 0;
      var tMat;
      var tVec;
      tX = input.p1.x - transform.position.x;
      tY = input.p1.y - transform.position.y;
      tMat = transform.R;
      var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      tX = input.p2.x - transform.position.x;
      tY = input.p2.y - transform.position.y;
      tMat = transform.R;
      var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var index = parseInt((-1));
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = tVec.x - p1X;
         tY = tVec.y - p1Y;
         tVec = this.m_normals[i];
         var numerator = (tVec.x * tX + tVec.y * tY);
         var denominator = (tVec.x * dX + tVec.y * dY);
         if (denominator == 0.0) {
            if (numerator < 0.0) {
               return false;
            }
         }
         else {
            if (denominator < 0.0 && numerator < lower * denominator) {
               lower = numerator / denominator;
               index = i;
            }
            else if (denominator > 0.0 && numerator < upper * denominator) {
               upper = numerator / denominator;
            }
         }
         if (upper < lower - Number.MIN_VALUE) {
            return false;
         }
      }
      if (index >= 0) {
         output.fraction = lower;
         tMat = transform.R;
         tVec = this.m_normals[index];
         output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         return true;
      }
      return false;
   }
   b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
      var tMat = xf.R;
      var tVec = this.m_vertices[0];
      var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var upperX = lowerX;
      var upperY = lowerY;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         lowerX = lowerX < vX ? lowerX : vX;
         lowerY = lowerY < vY ? lowerY : vY;
         upperX = upperX > vX ? upperX : vX;
         upperY = upperY > vY ? upperY : vY;
      }
      aabb.lowerBound.x = lowerX - this.m_radius;
      aabb.lowerBound.y = lowerY - this.m_radius;
      aabb.upperBound.x = upperX + this.m_radius;
      aabb.upperBound.y = upperY + this.m_radius;
   }
   b2PolygonShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      if (this.m_vertexCount == 2) {
         massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
         massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
         massData.mass = 0.0;
         massData.I = 0.0;
         return;
      }
      var centerX = 0.0;
      var centerY = 0.0;
      var area = 0.0;
      var I = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var k_inv3 = 1.0 / 3.0;
      for (var i = 0; i < this.m_vertexCount; ++i) {
         var p2 = this.m_vertices[i];
         var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = e1X * e2Y - e1Y * e2X;
         var triangleArea = 0.5 * D;area += triangleArea;
         centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
         centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
         var px = p1X;
         var py = p1Y;
         var ex1 = e1X;
         var ey1 = e1Y;
         var ex2 = e2X;
         var ey2 = e2Y;
         var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
         var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
      }
      massData.mass = density * area;
      centerX *= 1.0 / area;
      centerY *= 1.0 / area;
      massData.center.Set(centerX, centerY);
      massData.I = density * I;
   }
   b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var normalL = b2Math.MulTMV(xf.R, normal);
      var offsetL = offset - b2Math.Dot(normal, xf.position);
      var depths = new Vector_a2j_Number();
      var diveCount = 0;
      var intoIndex = parseInt((-1));
      var outoIndex = parseInt((-1));
      var lastSubmerged = false;
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
         var isSubmerged = depths[i] < (-Number.MIN_VALUE);
         if (i > 0) {
            if (isSubmerged) {
               if (!lastSubmerged) {
                  intoIndex = i - 1;
                  diveCount++;
               }
            }
            else {
               if (lastSubmerged) {
                  outoIndex = i - 1;
                  diveCount++;
               }
            }
         }
         lastSubmerged = isSubmerged;
      }
      switch (diveCount) {
      case 0:
         if (lastSubmerged) {
            var md = new b2MassData();
            this.ComputeMass(md, 1);
            c.SetV(b2Math.MulX(xf, md.center));
            return md.mass;
         }
         else {
            return 0;
         }
         break;
      case 1:
         if (intoIndex == (-1)) {
            intoIndex = this.m_vertexCount - 1;
         }
         else {
            outoIndex = this.m_vertexCount - 1;
         }
         break;
      }
      var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
      var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
      var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
      var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
      var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
      var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
      var area = 0;
      var center = new b2Vec2();
      var p2 = this.m_vertices[intoIndex2];
      var p3;
      i = intoIndex2;
      while (i != outoIndex2) {
         i = (i + 1) % this.m_vertexCount;
         if (i == outoIndex2) p3 = outoVec;
         else p3 = this.m_vertices[i];
         var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
         area += triangleArea;
         center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
         center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
         p2 = p3;
      }
      center.Multiply(1 / area);
      c.SetV(b2Math.MulX(xf, center));
      return area;
   }
   b2PolygonShape.prototype.GetVertexCount = function () {
      return this.m_vertexCount;
   }
   b2PolygonShape.prototype.GetVertices = function () {
      return this.m_vertices;
   }
   b2PolygonShape.prototype.GetNormals = function () {
      return this.m_normals;
   }
   b2PolygonShape.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2PolygonShape.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2PolygonShape.prototype.Validate = function () {
      return false;
   }
   b2PolygonShape.prototype.b2PolygonShape = function () {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_polygonShape;
      this.m_centroid = new b2Vec2();
      this.m_vertices = new Vector();
      this.m_normals = new Vector();
   }
   b2PolygonShape.prototype.Reserve = function (count) {
      if (count === undefined) count = 0;
      for (var i = parseInt(this.m_vertices.length); i < count; i++) {
         this.m_vertices[i] = new b2Vec2();
         this.m_normals[i] = new b2Vec2();
      }
   }
   b2PolygonShape.ComputeCentroid = function (vs, count) {
      if (count === undefined) count = 0;
      var c = new b2Vec2();
      var area = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var inv3 = 1.0 / 3.0;
      for (var i = 0; i < count; ++i) {
         var p2 = vs[i];
         var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = (e1X * e2Y - e1Y * e2X);
         var triangleArea = 0.5 * D;area += triangleArea;
         c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
         c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
      }
      c.x *= 1.0 / area;
      c.y *= 1.0 / area;
      return c;
   }
   b2PolygonShape.ComputeOBB = function (obb, vs, count) {
      if (count === undefined) count = 0;
      var i = 0;
      var p = new Vector(count + 1);
      for (i = 0;
      i < count; ++i) {
         p[i] = vs[i];
      }
      p[count] = p[0];
      var minArea = Number.MAX_VALUE;
      for (i = 1;
      i <= count; ++i) {
         var root = p[parseInt(i - 1)];
         var uxX = p[i].x - root.x;
         var uxY = p[i].y - root.y;
         var length = Math.sqrt(uxX * uxX + uxY * uxY);
         uxX /= length;
         uxY /= length;
         var uyX = (-uxY);
         var uyY = uxX;
         var lowerX = Number.MAX_VALUE;
         var lowerY = Number.MAX_VALUE;
         var upperX = (-Number.MAX_VALUE);
         var upperY = (-Number.MAX_VALUE);
         for (var j = 0; j < count; ++j) {
            var dX = p[j].x - root.x;
            var dY = p[j].y - root.y;
            var rX = (uxX * dX + uxY * dY);
            var rY = (uyX * dX + uyY * dY);
            if (rX < lowerX) lowerX = rX;
            if (rY < lowerY) lowerY = rY;
            if (rX > upperX) upperX = rX;
            if (rY > upperY) upperY = rY;
         }
         var area = (upperX - lowerX) * (upperY - lowerY);
         if (area < 0.95 * minArea) {
            minArea = area;
            obb.R.col1.x = uxX;
            obb.R.col1.y = uxY;
            obb.R.col2.x = uyX;
            obb.R.col2.y = uyY;
            var centerX = 0.5 * (lowerX + upperX);
            var centerY = 0.5 * (lowerY + upperY);
            var tMat = obb.R;
            obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
            obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
            obb.extents.x = 0.5 * (upperX - lowerX);
            obb.extents.y = 0.5 * (upperY - lowerY);
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
   });
   b2Shape.b2Shape = function () {};
   b2Shape.prototype.Copy = function () {
      return null;
   }
   b2Shape.prototype.Set = function (other) {
      this.m_radius = other.m_radius;
   }
   b2Shape.prototype.GetType = function () {
      return this.m_type;
   }
   b2Shape.prototype.TestPoint = function (xf, p) {
      return false;
   }
   b2Shape.prototype.RayCast = function (output, input, transform) {
      return false;
   }
   b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
   b2Shape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
   }
   b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      return 0;
   }
   b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
      var input = new b2DistanceInput();
      input.proxyA = new b2DistanceProxy();
      input.proxyA.Set(shape1);
      input.proxyB = new b2DistanceProxy();
      input.proxyB.Set(shape2);
      input.transformA = transform1;
      input.transformB = transform2;
      input.useRadii = true;
      var simplexCache = new b2SimplexCache();
      simplexCache.count = 0;
      var output = new b2DistanceOutput();
      b2Distance.Distance(output, simplexCache, input);
      return output.distance < 10.0 * Number.MIN_VALUE;
   }
   b2Shape.prototype.b2Shape = function () {
      this.m_type = b2Shape.e_unknownShape;
      this.m_radius = b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
      Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
      Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
      Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
      Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
      Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
      Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
      Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Color.b2Color = function () {
      this._r = 0;
      this._g = 0;
      this._b = 0;
   };
   b2Color.prototype.b2Color = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   b2Color.prototype.Set = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   Object.defineProperty(b2Color.prototype, 'r', {
      enumerable: false,
      configurable: true,
      set: function (rr) {
         if (rr === undefined) rr = 0;
         this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'g', {
      enumerable: false,
      configurable: true,
      set: function (gg) {
         if (gg === undefined) gg = 0;
         this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'b', {
      enumerable: false,
      configurable: true,
      set: function (bb) {
         if (bb === undefined) bb = 0;
         this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'color', {
      enumerable: false,
      configurable: true,
      get: function () {
         return (this._r << 16) | (this._g << 8) | (this._b);
      }
   });
   b2Settings.b2Settings = function () {};
   b2Settings.b2MixFriction = function (friction1, friction2) {
      if (friction1 === undefined) friction1 = 0;
      if (friction2 === undefined) friction2 = 0;
      return Math.sqrt(friction1 * friction2);
   }
   b2Settings.b2MixRestitution = function (restitution1, restitution2) {
      if (restitution1 === undefined) restitution1 = 0;
      if (restitution2 === undefined) restitution2 = 0;
      return restitution1 > restitution2 ? restitution1 : restitution2;
   }
   b2Settings.b2Assert = function (a) {
      if (!a) {
         throw "Assertion Failed";
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.b2Settings.VERSION = "2.1alpha";
      Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
      Box2D.Common.b2Settings.b2_pi = Math.PI;
      Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
      Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
      Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
      Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_linearSlop = 0.005;
      Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
      Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
      Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
      Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
      Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
      Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
      Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
      Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
      Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
      Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
      Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
   });
})();
(function () {
   var b2AABB = Box2D.Collision.b2AABB,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Mat22.b2Mat22 = function () {
      this.col1 = new b2Vec2();
      this.col2 = new b2Vec2();
   };
   b2Mat22.prototype.b2Mat22 = function () {
      this.SetIdentity();
   }
   b2Mat22.FromAngle = function (angle) {
      if (angle === undefined) angle = 0;
      var mat = new b2Mat22();
      mat.Set(angle);
      return mat;
   }
   b2Mat22.FromVV = function (c1, c2) {
      var mat = new b2Mat22();
      mat.SetVV(c1, c2);
      return mat;
   }
   b2Mat22.prototype.Set = function (angle) {
      if (angle === undefined) angle = 0;
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      this.col1.x = c;
      this.col2.x = (-s);
      this.col1.y = s;
      this.col2.y = c;
   }
   b2Mat22.prototype.SetVV = function (c1, c2) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
   }
   b2Mat22.prototype.Copy = function () {
      var mat = new b2Mat22();
      mat.SetM(this);
      return mat;
   }
   b2Mat22.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
   }
   b2Mat22.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
   }
   b2Mat22.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
   }
   b2Mat22.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
   }
   b2Mat22.prototype.GetAngle = function () {
      return Math.atan2(this.col1.y, this.col1.x);
   }
   b2Mat22.prototype.GetInverse = function (out) {
      var a = this.col1.x;
      var b = this.col2.x;
      var c = this.col1.y;
      var d = this.col2.y;
      var det = a * d - b * c;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.col1.x = det * d;
      out.col2.x = (-det * b);
      out.col1.y = (-det * c);
      out.col2.y = det * a;
      return out;
   }
   b2Mat22.prototype.Solve = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat22.prototype.Abs = function () {
      this.col1.Abs();
      this.col2.Abs();
   }
   b2Mat33.b2Mat33 = function () {
      this.col1 = new b2Vec3();
      this.col2 = new b2Vec3();
      this.col3 = new b2Vec3();
   };
   b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
      if (c1 === undefined) c1 = null;
      if (c2 === undefined) c2 = null;
      if (c3 === undefined) c3 = null;
      if (!c1 && !c2 && !c3) {
         this.col1.SetZero();
         this.col2.SetZero();
         this.col3.SetZero();
      }
      else {
         this.col1.SetV(c1);
         this.col2.SetV(c2);
         this.col3.SetV(c3);
      }
   }
   b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
      this.col3.SetV(c3);
   }
   b2Mat33.prototype.Copy = function () {
      return new b2Mat33(this.col1, this.col2, this.col3);
   }
   b2Mat33.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
      this.col3.SetV(m.col3);
   }
   b2Mat33.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col1.z += m.col1.z;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
      this.col2.z += m.col2.z;
      this.col3.x += m.col3.x;
      this.col3.y += m.col3.y;
      this.col3.z += m.col3.z;
   }
   b2Mat33.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 1.0;
   }
   b2Mat33.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 0.0;
   }
   b2Mat33.prototype.Solve22 = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      if (bZ === undefined) bZ = 0;
      var a11 = this.col1.x;
      var a21 = this.col1.y;
      var a31 = this.col1.z;
      var a12 = this.col2.x;
      var a22 = this.col2.y;
      var a32 = this.col2.z;
      var a13 = this.col3.x;
      var a23 = this.col3.y;
      var a33 = this.col3.z;
      var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
      out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
      out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
      return out;
   }
   b2Math.b2Math = function () {};
   b2Math.IsValid = function (x) {
      if (x === undefined) x = 0;
      return isFinite(x);
   }
   b2Math.Dot = function (a, b) {
      return a.x * b.x + a.y * b.y;
   }
   b2Math.CrossVV = function (a, b) {
      return a.x * b.y - a.y * b.x;
   }
   b2Math.CrossVF = function (a, s) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.y, (-s * a.x));
      return v;
   }
   b2Math.CrossFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2((-s * a.y), s * a.x);
      return v;
   }
   b2Math.MulMV = function (A, v) {
      var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
      return u;
   }
   b2Math.MulTMV = function (A, v) {
      var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
      return u;
   }
   b2Math.MulX = function (T, v) {
      var a = b2Math.MulMV(T.R, v);
      a.x += T.position.x;
      a.y += T.position.y;
      return a;
   }
   b2Math.MulXT = function (T, v) {
      var a = b2Math.SubtractVV(v, T.position);
      var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
      a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
      a.x = tX;
      return a;
   }
   b2Math.AddVV = function (a, b) {
      var v = new b2Vec2(a.x + b.x, a.y + b.y);
      return v;
   }
   b2Math.SubtractVV = function (a, b) {
      var v = new b2Vec2(a.x - b.x, a.y - b.y);
      return v;
   }
   b2Math.Distance = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return Math.sqrt(cX * cX + cY * cY);
   }
   b2Math.DistanceSquared = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return (cX * cX + cY * cY);
   }
   b2Math.MulFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.x, s * a.y);
      return v;
   }
   b2Math.AddMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
      return C;
   }
   b2Math.MulMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
      return C;
   }
   b2Math.MulTMM = function (A, B) {
      var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
      var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
      var C = b2Mat22.FromVV(c1, c2);
      return C;
   }
   b2Math.Abs = function (a) {
      if (a === undefined) a = 0;
      return a > 0.0 ? a : (-a);
   }
   b2Math.AbsV = function (a) {
      var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
      return b;
   }
   b2Math.AbsM = function (A) {
      var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
      return B;
   }
   b2Math.Min = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a < b ? a : b;
   }
   b2Math.MinV = function (a, b) {
      var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
      return c;
   }
   b2Math.Max = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a > b ? a : b;
   }
   b2Math.MaxV = function (a, b) {
      var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
      return c;
   }
   b2Math.Clamp = function (a, low, high) {
      if (a === undefined) a = 0;
      if (low === undefined) low = 0;
      if (high === undefined) high = 0;
      return a < low ? low : a > high ? high : a;
   }
   b2Math.ClampV = function (a, low, high) {
      return b2Math.MaxV(low, b2Math.MinV(a, high));
   }
   b2Math.Swap = function (a, b) {
      var tmp = a[0];
      a[0] = b[0];
      b[0] = tmp;
   }
   b2Math.Random = function () {
      return Math.random() * 2 - 1;
   }
   b2Math.RandomRange = function (lo, hi) {
      if (lo === undefined) lo = 0;
      if (hi === undefined) hi = 0;
      var r = Math.random();
      r = (hi - lo) * r + lo;
      return r;
   }
   b2Math.NextPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      x |= (x >> 1) & 0x7FFFFFFF;
      x |= (x >> 2) & 0x3FFFFFFF;
      x |= (x >> 4) & 0x0FFFFFFF;
      x |= (x >> 8) & 0x00FFFFFF;
      x |= (x >> 16) & 0x0000FFFF;
      return x + 1;
   }
   b2Math.IsPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      var result = x > 0 && (x & (x - 1)) == 0;
      return result;
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
      Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
      Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
   });
   b2Sweep.b2Sweep = function () {
      this.localCenter = new b2Vec2();
      this.c0 = new b2Vec2;
      this.c = new b2Vec2();
   };
   b2Sweep.prototype.Set = function (other) {
      this.localCenter.SetV(other.localCenter);
      this.c0.SetV(other.c0);
      this.c.SetV(other.c);
      this.a0 = other.a0;
      this.a = other.a;
      this.t0 = other.t0;
   }
   b2Sweep.prototype.Copy = function () {
      var copy = new b2Sweep();
      copy.localCenter.SetV(this.localCenter);
      copy.c0.SetV(this.c0);
      copy.c.SetV(this.c);
      copy.a0 = this.a0;
      copy.a = this.a;
      copy.t0 = this.t0;
      return copy;
   }
   b2Sweep.prototype.GetTransform = function (xf, alpha) {
      if (alpha === undefined) alpha = 0;
      xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
      xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
      var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
      xf.R.Set(angle);
      var tMat = xf.R;
      xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
      xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
   }
   b2Sweep.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE) {
         var alpha = (t - this.t0) / (1.0 - this.t0);
         this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
         this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
         this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
         this.t0 = t;
      }
   }
   b2Transform.b2Transform = function () {
      this.position = new b2Vec2;
      this.R = new b2Mat22();
   };
   b2Transform.prototype.b2Transform = function (pos, r) {
      if (pos === undefined) pos = null;
      if (r === undefined) r = null;
      if (pos) {
         this.position.SetV(pos);
         this.R.SetM(r);
      }
   }
   b2Transform.prototype.Initialize = function (pos, r) {
      this.position.SetV(pos);
      this.R.SetM(r);
   }
   b2Transform.prototype.SetIdentity = function () {
      this.position.SetZero();
      this.R.SetIdentity();
   }
   b2Transform.prototype.Set = function (x) {
      this.position.SetV(x.position);
      this.R.SetM(x.R);
   }
   b2Transform.prototype.GetAngle = function () {
      return Math.atan2(this.R.col1.y, this.R.col1.x);
   }
   b2Vec2.b2Vec2 = function () {};
   b2Vec2.prototype.b2Vec2 = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetZero = function () {
      this.x = 0.0;
      this.y = 0.0;
   }
   b2Vec2.prototype.Set = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
   }
   b2Vec2.prototype.GetNegative = function () {
      return new b2Vec2((-this.x), (-this.y));
   }
   b2Vec2.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
   }
   b2Vec2.Make = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      return new b2Vec2(x_, y_);
   }
   b2Vec2.prototype.Copy = function () {
      return new b2Vec2(this.x, this.y);
   }
   b2Vec2.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
   }
   b2Vec2.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
   }
   b2Vec2.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
   }
   b2Vec2.prototype.MulM = function (A) {
      var tX = this.x;
      this.x = A.col1.x * tX + A.col2.x * this.y;
      this.y = A.col1.y * tX + A.col2.y * this.y;
   }
   b2Vec2.prototype.MulTM = function (A) {
      var tX = b2Math.Dot(this, A.col1);
      this.y = b2Math.Dot(this, A.col2);
      this.x = tX;
   }
   b2Vec2.prototype.CrossVF = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = s * this.y;
      this.y = (-s * tX);
   }
   b2Vec2.prototype.CrossFV = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = (-s * this.y);
      this.y = s * tX;
   }
   b2Vec2.prototype.MinV = function (b) {
      this.x = this.x < b.x ? this.x : b.x;
      this.y = this.y < b.y ? this.y : b.y;
   }
   b2Vec2.prototype.MaxV = function (b) {
      this.x = this.x > b.x ? this.x : b.x;
      this.y = this.y > b.y ? this.y : b.y;
   }
   b2Vec2.prototype.Abs = function () {
      if (this.x < 0) this.x = (-this.x);
      if (this.y < 0) this.y = (-this.y);
   }
   b2Vec2.prototype.Length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.LengthSquared = function () {
      return (this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.Normalize = function () {
      var length = Math.sqrt(this.x * this.x + this.y * this.y);
      if (length < Number.MIN_VALUE) {
         return 0.0;
      }
      var invLength = 1.0 / length;
      this.x *= invLength;
      this.y *= invLength;
      return length;
   }
   b2Vec2.prototype.IsValid = function () {
      return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
   }
   b2Vec3.b2Vec3 = function () {};
   b2Vec3.prototype.b2Vec3 = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetZero = function () {
      this.x = this.y = this.z = 0.0;
   }
   b2Vec3.prototype.Set = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
   }
   b2Vec3.prototype.GetNegative = function () {
      return new b2Vec3((-this.x), (-this.y), (-this.z));
   }
   b2Vec3.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
      this.z = (-this.z);
   }
   b2Vec3.prototype.Copy = function () {
      return new b2Vec3(this.x, this.y, this.z);
   }
   b2Vec3.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
   }
   b2Vec3.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
   }
   b2Vec3.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
      this.z *= a;
   }
})();
(function () {
   var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

   b2Body.b2Body = function () {
      this.m_xf = new b2Transform();
      this.m_sweep = new b2Sweep();
      this.m_linearVelocity = new b2Vec2();
      this.m_force = new b2Vec2();
   };
   b2Body.prototype.connectEdges = function (s1, s2, angle1) {
      if (angle1 === undefined) angle1 = 0;
      var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
      var coreOffset = Math.tan((angle2 - angle1) * 0.5);
      var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
      core = b2Math.SubtractVV(core, s2.GetNormalVector());
      core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
      core = b2Math.AddVV(core, s2.GetVertex1());
      var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
      cornerDir.Normalize();
      var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
      s1.SetNextEdge(s2, core, cornerDir, convex);
      s2.SetPrevEdge(s1, core, cornerDir, convex);
      return angle2;
   }
   b2Body.prototype.CreateFixture = function (def) {
      if (this.m_world.IsLocked() == true) {
         return null;
      }
      var fixture = new b2Fixture();
      fixture.Create(this, this.m_xf, def);
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.CreateProxy(broadPhase, this.m_xf);
      }
      fixture.m_next = this.m_fixtureList;
      this.m_fixtureList = fixture;
      ++this.m_fixtureCount;
      fixture.m_body = this;
      if (fixture.m_density > 0.0) {
         this.ResetMassData();
      }
      this.m_world.m_flags |= b2World.e_newFixture;
      return fixture;
   }
   b2Body.prototype.CreateFixture2 = function (shape, density) {
      if (density === undefined) density = 0.0;
      var def = new b2FixtureDef();
      def.shape = shape;
      def.density = density;
      return this.CreateFixture(def);
   }
   b2Body.prototype.DestroyFixture = function (fixture) {
      if (this.m_world.IsLocked() == true) {
         return;
      }
      var node = this.m_fixtureList;
      var ppF = null;
      var found = false;
      while (node != null) {
         if (node == fixture) {
            if (ppF) ppF.m_next = fixture.m_next;
            else this.m_fixtureList = fixture.m_next;
            found = true;
            break;
         }
         ppF = node;
         node = node.m_next;
      }
      var edge = this.m_contactList;
      while (edge) {
         var c = edge.contact;
         edge = edge.next;
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         if (fixture == fixtureA || fixture == fixtureB) {
            this.m_world.m_contactManager.Destroy(c);
         }
      }
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.DestroyProxy(broadPhase);
      }
      else {}
      fixture.Destroy();
      fixture.m_body = null;
      fixture.m_next = null;
      --this.m_fixtureCount;
      this.ResetMassData();
   }
   b2Body.prototype.SetPositionAndAngle = function (position, angle) {
      if (angle === undefined) angle = 0;
      var f;
      if (this.m_world.IsLocked() == true) {
         return;
      }
      this.m_xf.R.Set(angle);
      this.m_xf.position.SetV(position);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_sweep.a0 = this.m_sweep.a = angle;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, this.m_xf, this.m_xf);
      }
      this.m_world.m_contactManager.FindNewContacts();
   }
   b2Body.prototype.SetTransform = function (xf) {
      this.SetPositionAndAngle(xf.position, xf.GetAngle());
   }
   b2Body.prototype.GetTransform = function () {
      return this.m_xf;
   }
   b2Body.prototype.GetPosition = function () {
      return this.m_xf.position;
   }
   b2Body.prototype.SetPosition = function (position) {
      this.SetPositionAndAngle(position, this.GetAngle());
   }
   b2Body.prototype.GetAngle = function () {
      return this.m_sweep.a;
   }
   b2Body.prototype.SetAngle = function (angle) {
      if (angle === undefined) angle = 0;
      this.SetPositionAndAngle(this.GetPosition(), angle);
   }
   b2Body.prototype.GetWorldCenter = function () {
      return this.m_sweep.c;
   }
   b2Body.prototype.GetLocalCenter = function () {
      return this.m_sweep.localCenter;
   }
   b2Body.prototype.SetLinearVelocity = function (v) {
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_linearVelocity.SetV(v);
   }
   b2Body.prototype.GetLinearVelocity = function () {
      return this.m_linearVelocity;
   }
   b2Body.prototype.SetAngularVelocity = function (omega) {
      if (omega === undefined) omega = 0;
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_angularVelocity = omega;
   }
   b2Body.prototype.GetAngularVelocity = function () {
      return this.m_angularVelocity;
   }
   b2Body.prototype.GetDefinition = function () {
      var bd = new b2BodyDef();
      bd.type = this.GetType();
      bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
      bd.angle = this.GetAngle();
      bd.angularDamping = this.m_angularDamping;
      bd.angularVelocity = this.m_angularVelocity;
      bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
      bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
      bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
      bd.linearDamping = this.m_linearDamping;
      bd.linearVelocity.SetV(this.GetLinearVelocity());
      bd.position = this.GetPosition();
      bd.userData = this.GetUserData();
      return bd;
   }
   b2Body.prototype.ApplyForce = function (force, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_force.x += force.x;
      this.m_force.y += force.y;
      this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
   }
   b2Body.prototype.ApplyTorque = function (torque) {
      if (torque === undefined) torque = 0;
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_torque += torque;
   }
   b2Body.prototype.ApplyImpulse = function (impulse, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_linearVelocity.x += this.m_invMass * impulse.x;
      this.m_linearVelocity.y += this.m_invMass * impulse.y;
      this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
   }
   b2Body.prototype.Split = function (callback) {
      var linearVelocity = this.GetLinearVelocity().Copy();
      var angularVelocity = this.GetAngularVelocity();
      var center = this.GetWorldCenter();
      var body1 = this;
      var body2 = this.m_world.CreateBody(this.GetDefinition());
      var prev;
      for (var f = body1.m_fixtureList; f;) {
         if (callback(f)) {
            var next = f.m_next;
            if (prev) {
               prev.m_next = next;
            }
            else {
               body1.m_fixtureList = next;
            }
            body1.m_fixtureCount--;
            f.m_next = body2.m_fixtureList;
            body2.m_fixtureList = f;
            body2.m_fixtureCount++;
            f.m_body = body2;
            f = next;
         }
         else {
            prev = f;
            f = f.m_next;
         }
      }
      body1.ResetMassData();
      body2.ResetMassData();
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
      var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
      body1.SetLinearVelocity(velocity1);
      body2.SetLinearVelocity(velocity2);
      body1.SetAngularVelocity(angularVelocity);
      body2.SetAngularVelocity(angularVelocity);
      body1.SynchronizeFixtures();
      body2.SynchronizeFixtures();
      return body2;
   }
   b2Body.prototype.Merge = function (other) {
      var f;
      for (f = other.m_fixtureList;
      f;) {
         var next = f.m_next;
         other.m_fixtureCount--;
         f.m_next = this.m_fixtureList;
         this.m_fixtureList = f;
         this.m_fixtureCount++;
         f.m_body = body2;
         f = next;
      }
      body1.m_fixtureCount = 0;
      var body1 = this;
      var body2 = other;
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = body1.GetLinearVelocity().Copy();
      var velocity2 = body2.GetLinearVelocity().Copy();
      var angular1 = body1.GetAngularVelocity();
      var angular = body2.GetAngularVelocity();
      body1.ResetMassData();
      this.SynchronizeFixtures();
   }
   b2Body.prototype.GetMass = function () {
      return this.m_mass;
   }
   b2Body.prototype.GetInertia = function () {
      return this.m_I;
   }
   b2Body.prototype.GetMassData = function (data) {
      data.mass = this.m_mass;
      data.I = this.m_I;
      data.center.SetV(this.m_sweep.localCenter);
   }
   b2Body.prototype.SetMassData = function (massData) {
      b2Settings.b2Assert(this.m_world.IsLocked() == false);
      if (this.m_world.IsLocked() == true) {
         return;
      }
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_mass = massData.mass;
      if (this.m_mass <= 0.0) {
         this.m_mass = 1.0;
      }
      this.m_invMass = 1.0 / this.m_mass;
      if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
         this.m_invI = 1.0 / this.m_I;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(massData.center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.ResetMassData = function () {
      this.m_mass = 0.0;
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_sweep.localCenter.SetZero();
      if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
         return;
      }
      var center = b2Vec2.Make(0, 0);
      for (var f = this.m_fixtureList; f; f = f.m_next) {
         if (f.m_density == 0.0) {
            continue;
         }
         var massData = f.GetMassData();
         this.m_mass += massData.mass;
         center.x += massData.center.x * massData.mass;
         center.y += massData.center.y * massData.mass;
         this.m_I += massData.I;
      }
      if (this.m_mass > 0.0) {
         this.m_invMass = 1.0 / this.m_mass;
         center.x *= this.m_invMass;
         center.y *= this.m_invMass;
      }
      else {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
         this.m_I *= this.m_inertiaScale;
         b2Settings.b2Assert(this.m_I > 0);
         this.m_invI = 1.0 / this.m_I;
      }
      else {
         this.m_I = 0.0;
         this.m_invI = 0.0;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.GetWorldPoint = function (localPoint) {
      var A = this.m_xf.R;
      var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      u.x += this.m_xf.position.x;
      u.y += this.m_xf.position.y;
      return u;
   }
   b2Body.prototype.GetWorldVector = function (localVector) {
      return b2Math.MulMV(this.m_xf.R, localVector);
   }
   b2Body.prototype.GetLocalPoint = function (worldPoint) {
      return b2Math.MulXT(this.m_xf, worldPoint);
   }
   b2Body.prototype.GetLocalVector = function (worldVector) {
      return b2Math.MulTMV(this.m_xf.R, worldVector);
   }
   b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
      var A = this.m_xf.R;
      var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      worldPoint.x += this.m_xf.position.x;
      worldPoint.y += this.m_xf.position.y;
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearDamping = function () {
      return this.m_linearDamping;
   }
   b2Body.prototype.SetLinearDamping = function (linearDamping) {
      if (linearDamping === undefined) linearDamping = 0;
      this.m_linearDamping = linearDamping;
   }
   b2Body.prototype.GetAngularDamping = function () {
      return this.m_angularDamping;
   }
   b2Body.prototype.SetAngularDamping = function (angularDamping) {
      if (angularDamping === undefined) angularDamping = 0;
      this.m_angularDamping = angularDamping;
   }
   b2Body.prototype.SetType = function (type) {
      if (type === undefined) type = 0;
      if (this.m_type == type) {
         return;
      }
      this.m_type = type;
      this.ResetMassData();
      if (this.m_type == b2Body.b2_staticBody) {
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
      }
      this.SetAwake(true);
      this.m_force.SetZero();
      this.m_torque = 0.0;
      for (var ce = this.m_contactList; ce; ce = ce.next) {
         ce.contact.FlagForFiltering();
      }
   }
   b2Body.prototype.GetType = function () {
      return this.m_type;
   }
   b2Body.prototype.SetBullet = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_bulletFlag;
      }
   }
   b2Body.prototype.IsBullet = function () {
      return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
   }
   b2Body.prototype.SetSleepingAllowed = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_allowSleepFlag;
         this.SetAwake(true);
      }
   }
   b2Body.prototype.SetAwake = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
      }
      else {
         this.m_flags &= ~b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
         this.m_force.SetZero();
         this.m_torque = 0.0;
      }
   }
   b2Body.prototype.IsAwake = function () {
      return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
   }
   b2Body.prototype.SetFixedRotation = function (fixed) {
      if (fixed) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_fixedRotationFlag;
      }
      this.ResetMassData();
   }
   b2Body.prototype.IsFixedRotation = function () {
      return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
   }
   b2Body.prototype.SetActive = function (flag) {
      if (flag == this.IsActive()) {
         return;
      }
      var broadPhase;
      var f;
      if (flag) {
         this.m_flags |= b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.CreateProxy(broadPhase, this.m_xf);
         }
      }
      else {
         this.m_flags &= ~b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.DestroyProxy(broadPhase);
         }
         var ce = this.m_contactList;
         while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_world.m_contactManager.Destroy(ce0.contact);
         }
         this.m_contactList = null;
      }
   }
   b2Body.prototype.IsActive = function () {
      return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
   }
   b2Body.prototype.IsSleepingAllowed = function () {
      return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
   }
   b2Body.prototype.GetFixtureList = function () {
      return this.m_fixtureList;
   }
   b2Body.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2Body.prototype.GetControllerList = function () {
      return this.m_controllerList;
   }
   b2Body.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2Body.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Body.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Body.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Body.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Body.prototype.b2Body = function (bd, world) {
      this.m_flags = 0;
      if (bd.bullet) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      if (bd.fixedRotation) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      if (bd.allowSleep) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      if (bd.awake) {
         this.m_flags |= b2Body.e_awakeFlag;
      }
      if (bd.active) {
         this.m_flags |= b2Body.e_activeFlag;
      }
      this.m_world = world;
      this.m_xf.position.SetV(bd.position);
      this.m_xf.R.Set(bd.angle);
      this.m_sweep.localCenter.SetZero();
      this.m_sweep.t0 = 1.0;
      this.m_sweep.a0 = this.m_sweep.a = bd.angle;
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_contactList = null;
      this.m_controllerCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_linearVelocity.SetV(bd.linearVelocity);
      this.m_angularVelocity = bd.angularVelocity;
      this.m_linearDamping = bd.linearDamping;
      this.m_angularDamping = bd.angularDamping;
      this.m_force.Set(0.0, 0.0);
      this.m_torque = 0.0;
      this.m_sleepTime = 0.0;
      this.m_type = bd.type;
      if (this.m_type == b2Body.b2_dynamicBody) {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      else {
         this.m_mass = 0.0;
         this.m_invMass = 0.0;
      }
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_inertiaScale = bd.inertiaScale;
      this.m_userData = bd.userData;
      this.m_fixtureList = null;
      this.m_fixtureCount = 0;
   }
   b2Body.prototype.SynchronizeFixtures = function () {
      var xf1 = b2Body.s_xf1;
      xf1.R.Set(this.m_sweep.a0);
      var tMat = xf1.R;
      var tVec = this.m_sweep.localCenter;
      xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var f;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, xf1, this.m_xf);
      }
   }
   b2Body.prototype.SynchronizeTransform = function () {
      this.m_xf.R.Set(this.m_sweep.a);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
   }
   b2Body.prototype.ShouldCollide = function (other) {
      if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
         return false;
      }
      for (var jn = this.m_jointList; jn; jn = jn.next) {
         if (jn.other == other) if (jn.joint.m_collideConnected == false) {
            return false;
         }
      }
      return true;
   }
   b2Body.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      this.m_sweep.Advance(t);
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_sweep.a = this.m_sweep.a0;
      this.SynchronizeTransform();
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
      Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
      Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
      Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
      Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
      Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
      Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
      Box2D.Dynamics.b2Body.b2_staticBody = 0;
      Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
      Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
   });
   b2BodyDef.b2BodyDef = function () {
      this.position = new b2Vec2();
      this.linearVelocity = new b2Vec2();
   };
   b2BodyDef.prototype.b2BodyDef = function () {
      this.userData = null;
      this.position.Set(0.0, 0.0);
      this.angle = 0.0;
      this.linearVelocity.Set(0, 0);
      this.angularVelocity = 0.0;
      this.linearDamping = 0.0;
      this.angularDamping = 0.0;
      this.allowSleep = true;
      this.awake = true;
      this.fixedRotation = false;
      this.bullet = false;
      this.type = b2Body.b2_staticBody;
      this.active = true;
      this.inertiaScale = 1.0;
   }
   b2ContactFilter.b2ContactFilter = function () {};
   b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
      var filter1 = fixtureA.GetFilterData();
      var filter2 = fixtureB.GetFilterData();
      if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
         return filter1.groupIndex > 0;
      }
      var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
      return collide;
   }
   b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
      if (!userData) return true;
      return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
   });
   b2ContactImpulse.b2ContactImpulse = function () {
      this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
   };
   b2ContactListener.b2ContactListener = function () {};
   b2ContactListener.prototype.BeginContact = function (contact) {}
   b2ContactListener.prototype.EndContact = function (contact) {}
   b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
   b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
   });
   b2ContactManager.b2ContactManager = function () {};
   b2ContactManager.prototype.b2ContactManager = function () {
      this.m_world = null;
      this.m_contactCount = 0;
      this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
      this.m_contactListener = b2ContactListener.b2_defaultListener;
      this.m_contactFactory = new b2ContactFactory(this.m_allocator);
      this.m_broadPhase = new b2DynamicTreeBroadPhase();
   }
   b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
      var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
      var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA == bodyB) return;
      var edge = bodyB.GetContactList();
      while (edge) {
         if (edge.other == bodyA) {
            var fA = edge.contact.GetFixtureA();
            var fB = edge.contact.GetFixtureB();
            if (fA == fixtureA && fB == fixtureB) return;
            if (fA == fixtureB && fB == fixtureA) return;
         }
         edge = edge.next;
      }
      if (bodyB.ShouldCollide(bodyA) == false) {
         return;
      }
      if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
         return;
      }
      var c = this.m_contactFactory.Create(fixtureA, fixtureB);
      fixtureA = c.GetFixtureA();
      fixtureB = c.GetFixtureB();
      bodyA = fixtureA.m_body;
      bodyB = fixtureB.m_body;
      c.m_prev = null;
      c.m_next = this.m_world.m_contactList;
      if (this.m_world.m_contactList != null) {
         this.m_world.m_contactList.m_prev = c;
      }
      this.m_world.m_contactList = c;
      c.m_nodeA.contact = c;
      c.m_nodeA.other = bodyB;
      c.m_nodeA.prev = null;
      c.m_nodeA.next = bodyA.m_contactList;
      if (bodyA.m_contactList != null) {
         bodyA.m_contactList.prev = c.m_nodeA;
      }
      bodyA.m_contactList = c.m_nodeA;
      c.m_nodeB.contact = c;
      c.m_nodeB.other = bodyA;
      c.m_nodeB.prev = null;
      c.m_nodeB.next = bodyB.m_contactList;
      if (bodyB.m_contactList != null) {
         bodyB.m_contactList.prev = c.m_nodeB;
      }
      bodyB.m_contactList = c.m_nodeB;
      ++this.m_world.m_contactCount;
      return;
   }
   b2ContactManager.prototype.FindNewContacts = function () {
      this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
   }
   b2ContactManager.prototype.Destroy = function (c) {
      var fixtureA = c.GetFixtureA();
      var fixtureB = c.GetFixtureB();
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (c.IsTouching()) {
         this.m_contactListener.EndContact(c);
      }
      if (c.m_prev) {
         c.m_prev.m_next = c.m_next;
      }
      if (c.m_next) {
         c.m_next.m_prev = c.m_prev;
      }
      if (c == this.m_world.m_contactList) {
         this.m_world.m_contactList = c.m_next;
      }
      if (c.m_nodeA.prev) {
         c.m_nodeA.prev.next = c.m_nodeA.next;
      }
      if (c.m_nodeA.next) {
         c.m_nodeA.next.prev = c.m_nodeA.prev;
      }
      if (c.m_nodeA == bodyA.m_contactList) {
         bodyA.m_contactList = c.m_nodeA.next;
      }
      if (c.m_nodeB.prev) {
         c.m_nodeB.prev.next = c.m_nodeB.next;
      }
      if (c.m_nodeB.next) {
         c.m_nodeB.next.prev = c.m_nodeB.prev;
      }
      if (c.m_nodeB == bodyB.m_contactList) {
         bodyB.m_contactList = c.m_nodeB.next;
      }
      this.m_contactFactory.Destroy(c);
      --this.m_contactCount;
   }
   b2ContactManager.prototype.Collide = function () {
      var c = this.m_world.m_contactList;
      while (c) {
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         var bodyA = fixtureA.GetBody();
         var bodyB = fixtureB.GetBody();
         if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
            c = c.GetNext();
            continue;
         }
         if (c.m_flags & b2Contact.e_filterFlag) {
            if (bodyB.ShouldCollide(bodyA) == false) {
               var cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
               cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            c.m_flags &= ~b2Contact.e_filterFlag;
         }
         var proxyA = fixtureA.m_proxy;
         var proxyB = fixtureB.m_proxy;
         var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
         if (overlap == false) {
            cNuke = c;
            c = cNuke.GetNext();
            this.Destroy(cNuke);
            continue;
         }
         c.Update(this.m_contactListener);
         c = c.GetNext();
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
   });
   b2DebugDraw.b2DebugDraw = function () {};
   b2DebugDraw.prototype.b2DebugDraw = function () {}
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.GetFlags = function () {}
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.SetSprite = function (sprite) {}
   b2DebugDraw.prototype.GetSprite = function () {}
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
   }
   b2DebugDraw.prototype.GetDrawScale = function () {}
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
   }
   b2DebugDraw.prototype.GetLineThickness = function () {}
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetAlpha = function () {}
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetFillAlpha = function () {}
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
   }
   b2DebugDraw.prototype.GetXFormScale = function () {}
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
   b2DebugDraw.prototype.DrawTransform = function (xf) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
      Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
      Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
      Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
      Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
      Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
   });
   b2DestructionListener.b2DestructionListener = function () {};
   b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
   b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
   b2FilterData.b2FilterData = function () {
      this.categoryBits = 0x0001;
      this.maskBits = 0xFFFF;
      this.groupIndex = 0;
   };
   b2FilterData.prototype.Copy = function () {
      var copy = new b2FilterData();
      copy.categoryBits = this.categoryBits;
      copy.maskBits = this.maskBits;
      copy.groupIndex = this.groupIndex;
      return copy;
   }
   b2Fixture.b2Fixture = function () {
      this.m_filter = new b2FilterData();
   };
   b2Fixture.prototype.GetType = function () {
      return this.m_shape.GetType();
   }
   b2Fixture.prototype.GetShape = function () {
      return this.m_shape;
   }
   b2Fixture.prototype.SetSensor = function (sensor) {
      if (this.m_isSensor == sensor) return;
      this.m_isSensor = sensor;
      if (this.m_body == null) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
         edge = edge.next;
      }
   }
   b2Fixture.prototype.IsSensor = function () {
      return this.m_isSensor;
   }
   b2Fixture.prototype.SetFilterData = function (filter) {
      this.m_filter = filter.Copy();
      if (this.m_body) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
         edge = edge.next;
      }
   }
   b2Fixture.prototype.GetFilterData = function () {
      return this.m_filter.Copy();
   }
   b2Fixture.prototype.GetBody = function () {
      return this.m_body;
   }
   b2Fixture.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Fixture.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Fixture.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Fixture.prototype.TestPoint = function (p) {
      return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
   }
   b2Fixture.prototype.RayCast = function (output, input) {
      return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
   }
   b2Fixture.prototype.GetMassData = function (massData) {
      if (massData === undefined) massData = null;
      if (massData == null) {
         massData = new b2MassData();
      }
      this.m_shape.ComputeMass(massData, this.m_density);
      return massData;
   }
   b2Fixture.prototype.SetDensity = function (density) {
      if (density === undefined) density = 0;
      this.m_density = density;
   }
   b2Fixture.prototype.GetDensity = function () {
      return this.m_density;
   }
   b2Fixture.prototype.GetFriction = function () {
      return this.m_friction;
   }
   b2Fixture.prototype.SetFriction = function (friction) {
      if (friction === undefined) friction = 0;
      this.m_friction = friction;
   }
   b2Fixture.prototype.GetRestitution = function () {
      return this.m_restitution;
   }
   b2Fixture.prototype.SetRestitution = function (restitution) {
      if (restitution === undefined) restitution = 0;
      this.m_restitution = restitution;
   }
   b2Fixture.prototype.GetAABB = function () {
      return this.m_aabb;
   }
   b2Fixture.prototype.b2Fixture = function () {
      this.m_aabb = new b2AABB();
      this.m_userData = null;
      this.m_body = null;
      this.m_next = null;
      this.m_shape = null;
      this.m_density = 0.0;
      this.m_friction = 0.0;
      this.m_restitution = 0.0;
   }
   b2Fixture.prototype.Create = function (body, xf, def) {
      this.m_userData = def.userData;
      this.m_friction = def.friction;
      this.m_restitution = def.restitution;
      this.m_body = body;
      this.m_next = null;
      this.m_filter = def.filter.Copy();
      this.m_isSensor = def.isSensor;
      this.m_shape = def.shape.Copy();
      this.m_density = def.density;
   }
   b2Fixture.prototype.Destroy = function () {
      this.m_shape = null;
   }
   b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
      this.m_shape.ComputeAABB(this.m_aabb, xf);
      this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
   }
   b2Fixture.prototype.DestroyProxy = function (broadPhase) {
      if (this.m_proxy == null) {
         return;
      }
      broadPhase.DestroyProxy(this.m_proxy);
      this.m_proxy = null;
   }
   b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
      if (!this.m_proxy) return;
      var aabb1 = new b2AABB();
      var aabb2 = new b2AABB();
      this.m_shape.ComputeAABB(aabb1, transform1);
      this.m_shape.ComputeAABB(aabb2, transform2);
      this.m_aabb.Combine(aabb1, aabb2);
      var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
      broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
   }
   b2FixtureDef.b2FixtureDef = function () {
      this.filter = new b2FilterData();
   };
   b2FixtureDef.prototype.b2FixtureDef = function () {
      this.shape = null;
      this.userData = null;
      this.friction = 0.2;
      this.restitution = 0.0;
      this.density = 0.0;
      this.filter.categoryBits = 0x0001;
      this.filter.maskBits = 0xFFFF;
      this.filter.groupIndex = 0;
      this.isSensor = false;
   }
   b2Island.b2Island = function () {};
   b2Island.prototype.b2Island = function () {
      this.m_bodies = new Vector();
      this.m_contacts = new Vector();
      this.m_joints = new Vector();
   }
   b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
      if (bodyCapacity === undefined) bodyCapacity = 0;
      if (contactCapacity === undefined) contactCapacity = 0;
      if (jointCapacity === undefined) jointCapacity = 0;
      var i = 0;
      this.m_bodyCapacity = bodyCapacity;
      this.m_contactCapacity = contactCapacity;
      this.m_jointCapacity = jointCapacity;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_allocator = allocator;
      this.m_listener = listener;
      this.m_contactSolver = contactSolver;
      for (i = this.m_bodies.length;
      i < bodyCapacity; i++)
      this.m_bodies[i] = null;
      for (i = this.m_contacts.length;
      i < contactCapacity; i++)
      this.m_contacts[i] = null;
      for (i = this.m_joints.length;
      i < jointCapacity; i++)
      this.m_joints[i] = null;
   }
   b2Island.prototype.Clear = function () {
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
   }
   b2Island.prototype.Solve = function (step, gravity, allowSleep) {
      var i = 0;
      var j = 0;
      var b;
      var joint;
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() != b2Body.b2_dynamicBody) continue;
         b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
         b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
         b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
         b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
         b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
      }
      this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      contactSolver.InitVelocityConstraints(step);
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.InitVelocityConstraints(step);
      }
      for (i = 0;
      i < step.velocityIterations; ++i) {
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            joint.SolveVelocityConstraints(step);
         }
         contactSolver.SolveVelocityConstraints();
      }
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.FinalizeVelocityConstraints();
      }
      contactSolver.FinalizeVelocityConstraints();
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = step.dt * b.m_linearVelocity.x;
         var translationY = step.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
         }
         var rotation = step.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
         b.m_sweep.a += step.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      for (i = 0;
      i < step.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
      if (allowSleep) {
         var minSleepTime = Number.MAX_VALUE;
         var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
         var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
         for (i = 0;
         i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            else {
               b.m_sleepTime += step.dt;
               minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
            }
         }
         if (minSleepTime >= b2Settings.b2_timeToSleep) {
            for (i = 0;
            i < this.m_bodyCount; ++i) {
               b = this.m_bodies[i];
               b.SetAwake(false);
            }
         }
      }
   }
   b2Island.prototype.SolveTOI = function (subStep) {
      var i = 0;
      var j = 0;
      this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      for (i = 0;
      i < this.m_jointCount; ++i) {
         this.m_joints[i].InitVelocityConstraints(subStep);
      }
      for (i = 0;
      i < subStep.velocityIterations; ++i) {
         contactSolver.SolveVelocityConstraints();
         for (j = 0;
         j < this.m_jointCount; ++j) {
            this.m_joints[j].SolveVelocityConstraints(subStep);
         }
      }
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         var b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = subStep.dt * b.m_linearVelocity.x;
         var translationY = subStep.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
         }
         var rotation = subStep.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
         b.m_sweep.a += subStep.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      var k_toiBaumgarte = 0.75;
      for (i = 0;
      i < subStep.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
   }
   b2Island.prototype.Report = function (constraints) {
      if (this.m_listener == null) {
         return;
      }
      for (var i = 0; i < this.m_contactCount; ++i) {
         var c = this.m_contacts[i];
         var cc = constraints[i];
         for (var j = 0; j < cc.pointCount; ++j) {
            b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
            b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
         }
         this.m_listener.PostSolve(c, b2Island.s_impulse);
      }
   }
   b2Island.prototype.AddBody = function (body) {
      body.m_islandIndex = this.m_bodyCount;
      this.m_bodies[this.m_bodyCount++] = body;
   }
   b2Island.prototype.AddContact = function (contact) {
      this.m_contacts[this.m_contactCount++] = contact;
   }
   b2Island.prototype.AddJoint = function (joint) {
      this.m_joints[this.m_jointCount++] = joint;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
   });
   b2TimeStep.b2TimeStep = function () {};
   b2TimeStep.prototype.Set = function (step) {
      this.dt = step.dt;
      this.inv_dt = step.inv_dt;
      this.positionIterations = step.positionIterations;
      this.velocityIterations = step.velocityIterations;
      this.warmStarting = step.warmStarting;
   }
   b2World.b2World = function () {
      this.s_stack = new Vector();
      this.m_contactManager = new b2ContactManager();
      this.m_contactSolver = new b2ContactSolver();
      this.m_island = new b2Island();
   };
   b2World.prototype.b2World = function (gravity, doSleep) {
      this.m_destructionListener = null;
      this.m_debugDraw = null;
      this.m_bodyList = null;
      this.m_contactList = null;
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_controllerCount = 0;
      b2World.m_warmStarting = true;
      b2World.m_continuousPhysics = true;
      this.m_allowSleep = doSleep;
      this.m_gravity = gravity;
      this.m_inv_dt0 = 0.0;
      this.m_contactManager.m_world = this;
      var bd = new b2BodyDef();
      this.m_groundBody = this.CreateBody(bd);
   }
   b2World.prototype.SetDestructionListener = function (listener) {
      this.m_destructionListener = listener;
   }
   b2World.prototype.SetContactFilter = function (filter) {
      this.m_contactManager.m_contactFilter = filter;
   }
   b2World.prototype.SetContactListener = function (listener) {
      this.m_contactManager.m_contactListener = listener;
   }
   b2World.prototype.SetDebugDraw = function (debugDraw) {
      this.m_debugDraw = debugDraw;
   }
   b2World.prototype.SetBroadPhase = function (broadPhase) {
      var oldBroadPhase = this.m_contactManager.m_broadPhase;
      this.m_contactManager.m_broadPhase = broadPhase;
      for (var b = this.m_bodyList; b; b = b.m_next) {
         for (var f = b.m_fixtureList; f; f = f.m_next) {
            f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
         }
      }
   }
   b2World.prototype.Validate = function () {
      this.m_contactManager.m_broadPhase.Validate();
   }
   b2World.prototype.GetProxyCount = function () {
      return this.m_contactManager.m_broadPhase.GetProxyCount();
   }
   b2World.prototype.CreateBody = function (def) {
      if (this.IsLocked() == true) {
         return null;
      }
      var b = new b2Body(def, this);
      b.m_prev = null;
      b.m_next = this.m_bodyList;
      if (this.m_bodyList) {
         this.m_bodyList.m_prev = b;
      }
      this.m_bodyList = b;
      ++this.m_bodyCount;
      return b;
   }
   b2World.prototype.DestroyBody = function (b) {
      if (this.IsLocked() == true) {
         return;
      }
      var jn = b.m_jointList;
      while (jn) {
         var jn0 = jn;
         jn = jn.next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
         }
         this.DestroyJoint(jn0.joint);
      }
      var coe = b.m_controllerList;
      while (coe) {
         var coe0 = coe;
         coe = coe.nextController;
         coe0.controller.RemoveBody(b);
      }
      var ce = b.m_contactList;
      while (ce) {
         var ce0 = ce;
         ce = ce.next;
         this.m_contactManager.Destroy(ce0.contact);
      }
      b.m_contactList = null;
      var f = b.m_fixtureList;
      while (f) {
         var f0 = f;
         f = f.m_next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeFixture(f0);
         }
         f0.DestroyProxy(this.m_contactManager.m_broadPhase);
         f0.Destroy();
      }
      b.m_fixtureList = null;
      b.m_fixtureCount = 0;
      if (b.m_prev) {
         b.m_prev.m_next = b.m_next;
      }
      if (b.m_next) {
         b.m_next.m_prev = b.m_prev;
      }
      if (b == this.m_bodyList) {
         this.m_bodyList = b.m_next;
      }--this.m_bodyCount;
   }
   b2World.prototype.CreateJoint = function (def) {
      var j = b2Joint.Create(def, null);
      j.m_prev = null;
      j.m_next = this.m_jointList;
      if (this.m_jointList) {
         this.m_jointList.m_prev = j;
      }
      this.m_jointList = j;
      ++this.m_jointCount;
      j.m_edgeA.joint = j;
      j.m_edgeA.other = j.m_bodyB;
      j.m_edgeA.prev = null;
      j.m_edgeA.next = j.m_bodyA.m_jointList;
      if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
      j.m_bodyA.m_jointList = j.m_edgeA;
      j.m_edgeB.joint = j;
      j.m_edgeB.other = j.m_bodyA;
      j.m_edgeB.prev = null;
      j.m_edgeB.next = j.m_bodyB.m_jointList;
      if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
      j.m_bodyB.m_jointList = j.m_edgeB;
      var bodyA = def.bodyA;
      var bodyB = def.bodyB;
      if (def.collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
      return j;
   }
   b2World.prototype.DestroyJoint = function (j) {
      var collideConnected = j.m_collideConnected;
      if (j.m_prev) {
         j.m_prev.m_next = j.m_next;
      }
      if (j.m_next) {
         j.m_next.m_prev = j.m_prev;
      }
      if (j == this.m_jointList) {
         this.m_jointList = j.m_next;
      }
      var bodyA = j.m_bodyA;
      var bodyB = j.m_bodyB;
      bodyA.SetAwake(true);
      bodyB.SetAwake(true);
      if (j.m_edgeA.prev) {
         j.m_edgeA.prev.next = j.m_edgeA.next;
      }
      if (j.m_edgeA.next) {
         j.m_edgeA.next.prev = j.m_edgeA.prev;
      }
      if (j.m_edgeA == bodyA.m_jointList) {
         bodyA.m_jointList = j.m_edgeA.next;
      }
      j.m_edgeA.prev = null;
      j.m_edgeA.next = null;
      if (j.m_edgeB.prev) {
         j.m_edgeB.prev.next = j.m_edgeB.next;
      }
      if (j.m_edgeB.next) {
         j.m_edgeB.next.prev = j.m_edgeB.prev;
      }
      if (j.m_edgeB == bodyB.m_jointList) {
         bodyB.m_jointList = j.m_edgeB.next;
      }
      j.m_edgeB.prev = null;
      j.m_edgeB.next = null;
      b2Joint.Destroy(j, null);
      --this.m_jointCount;
      if (collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
   }
   b2World.prototype.AddController = function (c) {
      c.m_next = this.m_controllerList;
      c.m_prev = null;
      this.m_controllerList = c;
      c.m_world = this;
      this.m_controllerCount++;
      return c;
   }
   b2World.prototype.RemoveController = function (c) {
      if (c.m_prev) c.m_prev.m_next = c.m_next;
      if (c.m_next) c.m_next.m_prev = c.m_prev;
      if (this.m_controllerList == c) this.m_controllerList = c.m_next;
      this.m_controllerCount--;
   }
   b2World.prototype.CreateController = function (controller) {
      if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
      controller.m_next = this.m_controllerList;
      controller.m_prev = null;
      if (this.m_controllerList) this.m_controllerList.m_prev = controller;
      this.m_controllerList = controller;
      ++this.m_controllerCount;
      controller.m_world = this;
      return controller;
   }
   b2World.prototype.DestroyController = function (controller) {
      controller.Clear();
      if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
      if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
      if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
      --this.m_controllerCount;
   }
   b2World.prototype.SetWarmStarting = function (flag) {
      b2World.m_warmStarting = flag;
   }
   b2World.prototype.SetContinuousPhysics = function (flag) {
      b2World.m_continuousPhysics = flag;
   }
   b2World.prototype.GetBodyCount = function () {
      return this.m_bodyCount;
   }
   b2World.prototype.GetJointCount = function () {
      return this.m_jointCount;
   }
   b2World.prototype.GetContactCount = function () {
      return this.m_contactCount;
   }
   b2World.prototype.SetGravity = function (gravity) {
      this.m_gravity = gravity;
   }
   b2World.prototype.GetGravity = function () {
      return this.m_gravity;
   }
   b2World.prototype.GetGroundBody = function () {
      return this.m_groundBody;
   }
   b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
      if (dt === undefined) dt = 0;
      if (velocityIterations === undefined) velocityIterations = 0;
      if (positionIterations === undefined) positionIterations = 0;
      if (this.m_flags & b2World.e_newFixture) {
         this.m_contactManager.FindNewContacts();
         this.m_flags &= ~b2World.e_newFixture;
      }
      this.m_flags |= b2World.e_locked;
      var step = b2World.s_timestep2;
      step.dt = dt;
      step.velocityIterations = velocityIterations;
      step.positionIterations = positionIterations;
      if (dt > 0.0) {
         step.inv_dt = 1.0 / dt;
      }
      else {
         step.inv_dt = 0.0;
      }
      step.dtRatio = this.m_inv_dt0 * dt;
      step.warmStarting = b2World.m_warmStarting;
      this.m_contactManager.Collide();
      if (step.dt > 0.0) {
         this.Solve(step);
      }
      if (b2World.m_continuousPhysics && step.dt > 0.0) {
         this.SolveTOI(step);
      }
      if (step.dt > 0.0) {
         this.m_inv_dt0 = step.inv_dt;
      }
      this.m_flags &= ~b2World.e_locked;
   }
   b2World.prototype.ClearForces = function () {
      for (var body = this.m_bodyList; body; body = body.m_next) {
         body.m_force.SetZero();
         body.m_torque = 0.0;
      }
   }
   b2World.prototype.DrawDebugData = function () {
      if (this.m_debugDraw == null) {
         return;
      }
      this.m_debugDraw.m_sprite.graphics.clear();
      var flags = this.m_debugDraw.GetFlags();
      var i = 0;
      var b;
      var f;
      var s;
      var j;
      var bp;
      var invQ = new b2Vec2;
      var x1 = new b2Vec2;
      var x2 = new b2Vec2;
      var xf;
      var b1 = new b2AABB();
      var b2 = new b2AABB();
      var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
      var color = new b2Color(0, 0, 0);
      if (flags & b2DebugDraw.e_shapeBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b.m_xf;
            for (f = b.GetFixtureList();
            f; f = f.m_next) {
               s = f.GetShape();
               if (b.IsActive() == false) {
                  color.Set(0.5, 0.5, 0.3);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_staticBody) {
                  color.Set(0.5, 0.9, 0.5);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_kinematicBody) {
                  color.Set(0.5, 0.5, 0.9);
                  this.DrawShape(s, xf, color);
               }
               else if (b.IsAwake() == false) {
                  color.Set(0.6, 0.6, 0.6);
                  this.DrawShape(s, xf, color);
               }
               else {
                  color.Set(0.9, 0.7, 0.7);
                  this.DrawShape(s, xf, color);
               }
            }
         }
      }
      if (flags & b2DebugDraw.e_jointBit) {
         for (j = this.m_jointList;
         j; j = j.m_next) {
            this.DrawJoint(j);
         }
      }
      if (flags & b2DebugDraw.e_controllerBit) {
         for (var c = this.m_controllerList; c; c = c.m_next) {
            c.Draw(this.m_debugDraw);
         }
      }
      if (flags & b2DebugDraw.e_pairBit) {
         color.Set(0.3, 0.9, 0.9);
         for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            var cA = fixtureA.GetAABB().GetCenter();
            var cB = fixtureB.GetAABB().GetCenter();
            this.m_debugDraw.DrawSegment(cA, cB, color);
         }
      }
      if (flags & b2DebugDraw.e_aabbBit) {
         bp = this.m_contactManager.m_broadPhase;
         vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
         for (b = this.m_bodyList;
         b; b = b.GetNext()) {
            if (b.IsActive() == false) {
               continue;
            }
            for (f = b.GetFixtureList();
            f; f = f.GetNext()) {
               var aabb = bp.GetFatAABB(f.m_proxy);
               vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
               vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
               vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
               vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
               this.m_debugDraw.DrawPolygon(vs, 4, color);
            }
         }
      }
      if (flags & b2DebugDraw.e_centerOfMassBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b2World.s_xf;
            xf.R = b.m_xf.R;
            xf.position = b.GetWorldCenter();
            this.m_debugDraw.DrawTransform(xf);
         }
      }
   }
   b2World.prototype.QueryAABB = function (callback, aabb) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         return callback(broadPhase.GetUserData(proxy));
      };
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryShape = function (callback, shape, transform) {
      var __this = this;
      if (transform === undefined) transform = null;
      if (transform == null) {
         transform = new b2Transform();
         transform.SetIdentity();
      }
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      shape.ComputeAABB(aabb, transform);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryPoint = function (callback, p) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (fixture.TestPoint(p)) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
      aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.RayCast = function (callback, point1, point2) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;
      var output = new b2RayCastOutput;

      function RayCastWrapper(input, proxy) {
         var userData = broadPhase.GetUserData(proxy);
         var fixture = (userData instanceof b2Fixture ? userData : null);
         var hit = fixture.RayCast(output, input);
         if (hit) {
            var fraction = output.fraction;
            var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
            return callback(fixture, point, output.normal, fraction);
         }
         return input.maxFraction;
      };
      var input = new b2RayCastInput(point1, point2);
      broadPhase.RayCast(RayCastWrapper, input);
   }
   b2World.prototype.RayCastOne = function (point1, point2) {
      var __this = this;
      var result;

      function RayCastOneWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result = fixture;
         return fraction;
      };
      __this.RayCast(RayCastOneWrapper, point1, point2);
      return result;
   }
   b2World.prototype.RayCastAll = function (point1, point2) {
      var __this = this;
      var result = new Vector();

      function RayCastAllWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result[result.length] = fixture;
         return 1;
      };
      __this.RayCast(RayCastAllWrapper, point1, point2);
      return result;
   }
   b2World.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2World.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2World.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2World.prototype.IsLocked = function () {
      return (this.m_flags & b2World.e_locked) > 0;
   }
   b2World.prototype.Solve = function (step) {
      var b;
      for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
         controller.Step(step);
      }
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
      }
      for (var c = this.m_contactList; c; c = c.m_next) {
         c.m_flags &= ~b2Contact.e_islandFlag;
      }
      for (var j = this.m_jointList; j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      var stackSize = parseInt(this.m_bodyCount);
      var stack = this.s_stack;
      for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
         if (seed.m_flags & b2Body.e_islandFlag) {
            continue;
         }
         if (seed.IsAwake() == false || seed.IsActive() == false) {
            continue;
         }
         if (seed.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         island.Clear();
         var stackCount = 0;
         stack[stackCount++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (stackCount > 0) {
            b = stack[--stackCount];
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            var other;
            for (var ce = b.m_contactList; ce; ce = ce.next) {
               if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(ce.contact);
               ce.contact.m_flags |= b2Contact.e_islandFlag;
               other = ce.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jn = b.m_jointList; jn; jn = jn.next) {
               if (jn.joint.m_islandFlag == true) {
                  continue;
               }
               other = jn.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jn.joint);
               jn.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         island.Solve(step, this.m_gravity, this.m_allowSleep);
         for (var i = 0; i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               b.m_flags &= ~b2Body.e_islandFlag;
            }
         }
      }
      for (i = 0;
      i < stack.length; ++i) {
         if (!stack[i]) break;
         stack[i] = null;
      }
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         if (b.IsAwake() == false || b.IsActive() == false) {
            continue;
         }
         if (b.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         b.SynchronizeFixtures();
      }
      this.m_contactManager.FindNewContacts();
   }
   b2World.prototype.SolveTOI = function (step) {
      var b;
      var fA;
      var fB;
      var bA;
      var bB;
      var cEdge;
      var j;
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      var queue = b2World.s_queue;
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
         b.m_sweep.t0 = 0.0;
      }
      var c;
      for (c = this.m_contactList;
      c; c = c.m_next) {
         c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
      }
      for (j = this.m_jointList;
      j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      for (;;) {
         var minContact = null;
         var minTOI = 1.0;
         for (c = this.m_contactList;
         c; c = c.m_next) {
            if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
               continue;
            }
            var toi = 1.0;
            if (c.m_flags & b2Contact.e_toiFlag) {
               toi = c.m_toi;
            }
            else {
               fA = c.m_fixtureA;
               fB = c.m_fixtureB;
               bA = fA.m_body;
               bB = fB.m_body;
               if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                  continue;
               }
               var t0 = bA.m_sweep.t0;
               if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                  t0 = bB.m_sweep.t0;
                  bA.m_sweep.Advance(t0);
               }
               else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                  t0 = bA.m_sweep.t0;
                  bB.m_sweep.Advance(t0);
               }
               toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
               b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
               if (toi > 0.0 && toi < 1.0) {
                  toi = (1.0 - toi) * t0 + toi;
                  if (toi > 1) toi = 1;
               }
               c.m_toi = toi;
               c.m_flags |= b2Contact.e_toiFlag;
            }
            if (Number.MIN_VALUE < toi && toi < minTOI) {
               minContact = c;
               minTOI = toi;
            }
         }
         if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
            break;
         }
         fA = minContact.m_fixtureA;
         fB = minContact.m_fixtureB;
         bA = fA.m_body;
         bB = fB.m_body;
         b2World.s_backupA.Set(bA.m_sweep);
         b2World.s_backupB.Set(bB.m_sweep);
         bA.Advance(minTOI);
         bB.Advance(minTOI);
         minContact.Update(this.m_contactManager.m_contactListener);
         minContact.m_flags &= ~b2Contact.e_toiFlag;
         if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
            bA.m_sweep.Set(b2World.s_backupA);
            bB.m_sweep.Set(b2World.s_backupB);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
            continue;
         }
         if (minContact.IsTouching() == false) {
            continue;
         }
         var seed = bA;
         if (seed.GetType() != b2Body.b2_dynamicBody) {
            seed = bB;
         }
         island.Clear();
         var queueStart = 0;
         var queueSize = 0;
         queue[queueStart + queueSize++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (queueSize > 0) {
            b = queue[queueStart++];
            --queueSize;
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               if (island.m_contactCount == island.m_contactCapacity) {
                  break;
               }
               if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(cEdge.contact);
               cEdge.contact.m_flags |= b2Contact.e_islandFlag;
               var other = cEdge.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
               if (island.m_jointCount == island.m_jointCapacity) continue;
               if (jEdge.joint.m_islandFlag == true) continue;
               other = jEdge.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jEdge.joint);
               jEdge.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) continue;
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         var subStep = b2World.s_timestep;
         subStep.warmStarting = false;
         subStep.dt = (1.0 - minTOI) * step.dt;
         subStep.inv_dt = 1.0 / subStep.dt;
         subStep.dtRatio = 0.0;
         subStep.velocityIterations = step.velocityIterations;
         subStep.positionIterations = step.positionIterations;
         island.SolveTOI(subStep);
         var i = 0;
         for (i = 0;
         i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            b.m_flags &= ~b2Body.e_islandFlag;
            if (b.IsAwake() == false) {
               continue;
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            b.SynchronizeFixtures();
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
            }
         }
         for (i = 0;
         i < island.m_contactCount; ++i) {
            c = island.m_contacts[i];
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
         }
         for (i = 0;
         i < island.m_jointCount; ++i) {
            j = island.m_joints[i];
            j.m_islandFlag = false;
         }
         this.m_contactManager.FindNewContacts();
      }
   }
   b2World.prototype.DrawJoint = function (joint) {
      var b1 = joint.GetBodyA();
      var b2 = joint.GetBodyB();
      var xf1 = b1.m_xf;
      var xf2 = b2.m_xf;
      var x1 = xf1.position;
      var x2 = xf2.position;
      var p1 = joint.GetAnchorA();
      var p2 = joint.GetAnchorB();
      var color = b2World.s_jointColor;
      switch (joint.m_type) {
      case b2Joint.e_distanceJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      case b2Joint.e_pulleyJoint:
         {
            var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
            var s1 = pulley.GetGroundAnchorA();
            var s2 = pulley.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(s1, p1, color);
            this.m_debugDraw.DrawSegment(s2, p2, color);
            this.m_debugDraw.DrawSegment(s1, s2, color);
         }
         break;
      case b2Joint.e_mouseJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      default:
         if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
         this.m_debugDraw.DrawSegment(p1, p2, color);
         if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
      }
   }
   b2World.prototype.DrawShape = function (shape, xf, color) {
      switch (shape.m_type) {
      case b2Shape.e_circleShape:
         {
            var circle = ((shape instanceof b2CircleShape ? shape : null));
            var center = b2Math.MulX(xf, circle.m_p);
            var radius = circle.m_radius;
            var axis = xf.R.col1;
            this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var i = 0;
            var poly = ((shape instanceof b2PolygonShape ? shape : null));
            var vertexCount = parseInt(poly.GetVertexCount());
            var localVertices = poly.GetVertices();
            var vertices = new Vector(vertexCount);
            for (i = 0;
            i < vertexCount; ++i) {
               vertices[i] = b2Math.MulX(xf, localVertices[i]);
            }
            this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
         }
         break;
      case b2Shape.e_edgeShape:
         {
            var edge = (shape instanceof b2EdgeShape ? shape : null);
            this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
      Box2D.Dynamics.b2World.s_xf = new b2Transform();
      Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
      Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
      Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
      Box2D.Dynamics.b2World.s_queue = new Vector();
      Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
      Box2D.Dynamics.b2World.e_newFixture = 0x0001;
      Box2D.Dynamics.b2World.e_locked = 0x0002;
   });
})();
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2CircleContact.b2CircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2CircleContact.Create = function (allocator) {
      return new b2CircleContact();
   }
   b2CircleContact.Destroy = function (contact, allocator) {}
   b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2CircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2Contact.b2Contact = function () {
      this.m_nodeA = new b2ContactEdge();
      this.m_nodeB = new b2ContactEdge();
      this.m_manifold = new b2Manifold();
      this.m_oldManifold = new b2Manifold();
   };
   b2Contact.prototype.GetManifold = function () {
      return this.m_manifold;
   }
   b2Contact.prototype.GetWorldManifold = function (worldManifold) {
      var bodyA = this.m_fixtureA.GetBody();
      var bodyB = this.m_fixtureB.GetBody();
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
   }
   b2Contact.prototype.IsTouching = function () {
      return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
   }
   b2Contact.prototype.IsContinuous = function () {
      return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
   }
   b2Contact.prototype.SetSensor = function (sensor) {
      if (sensor) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_sensorFlag;
      }
   }
   b2Contact.prototype.IsSensor = function () {
      return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
   }
   b2Contact.prototype.SetEnabled = function (flag) {
      if (flag) {
         this.m_flags |= b2Contact.e_enabledFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_enabledFlag;
      }
   }
   b2Contact.prototype.IsEnabled = function () {
      return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
   }
   b2Contact.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Contact.prototype.GetFixtureA = function () {
      return this.m_fixtureA;
   }
   b2Contact.prototype.GetFixtureB = function () {
      return this.m_fixtureB;
   }
   b2Contact.prototype.FlagForFiltering = function () {
      this.m_flags |= b2Contact.e_filterFlag;
   }
   b2Contact.prototype.b2Contact = function () {}
   b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
      if (fixtureA === undefined) fixtureA = null;
      if (fixtureB === undefined) fixtureB = null;
      this.m_flags = b2Contact.e_enabledFlag;
      if (!fixtureA || !fixtureB) {
         this.m_fixtureA = null;
         this.m_fixtureB = null;
         return;
      }
      if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
         this.m_flags |= b2Contact.e_continuousFlag;
      }
      this.m_fixtureA = fixtureA;
      this.m_fixtureB = fixtureB;
      this.m_manifold.m_pointCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_nodeA.contact = null;
      this.m_nodeA.prev = null;
      this.m_nodeA.next = null;
      this.m_nodeA.other = null;
      this.m_nodeB.contact = null;
      this.m_nodeB.prev = null;
      this.m_nodeB.next = null;
      this.m_nodeB.other = null;
   }
   b2Contact.prototype.Update = function (listener) {
      var tManifold = this.m_oldManifold;
      this.m_oldManifold = this.m_manifold;
      this.m_manifold = tManifold;
      this.m_flags |= b2Contact.e_enabledFlag;
      var touching = false;
      var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
      var bodyA = this.m_fixtureA.m_body;
      var bodyB = this.m_fixtureB.m_body;
      var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
      if (this.m_flags & b2Contact.e_sensorFlag) {
         if (aabbOverlap) {
            var shapeA = this.m_fixtureA.GetShape();
            var shapeB = this.m_fixtureB.GetShape();
            var xfA = bodyA.GetTransform();
            var xfB = bodyB.GetTransform();
            touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
         }
         this.m_manifold.m_pointCount = 0;
      }
      else {
         if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
         }
         else {
            this.m_flags &= ~b2Contact.e_continuousFlag;
         }
         if (aabbOverlap) {
            this.Evaluate();
            touching = this.m_manifold.m_pointCount > 0;
            for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
               var mp2 = this.m_manifold.m_points[i];
               mp2.m_normalImpulse = 0.0;
               mp2.m_tangentImpulse = 0.0;
               var id2 = mp2.m_id;
               for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                  var mp1 = this.m_oldManifold.m_points[j];
                  if (mp1.m_id.key == id2.key) {
                     mp2.m_normalImpulse = mp1.m_normalImpulse;
                     mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                     break;
                  }
               }
            }
         }
         else {
            this.m_manifold.m_pointCount = 0;
         }
         if (touching != wasTouching) {
            bodyA.SetAwake(true);
            bodyB.SetAwake(true);
         }
      }
      if (touching) {
         this.m_flags |= b2Contact.e_touchingFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_touchingFlag;
      }
      if (wasTouching == false && touching == true) {
         listener.BeginContact(this);
      }
      if (wasTouching == true && touching == false) {
         listener.EndContact(this);
      }
      if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
         listener.PreSolve(this, this.m_oldManifold);
      }
   }
   b2Contact.prototype.Evaluate = function () {}
   b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
      b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
      b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
      b2Contact.s_input.sweepA = sweepA;
      b2Contact.s_input.sweepB = sweepB;
      b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
      return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
      Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
      Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
      Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
      Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
      Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
      Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
      Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
   });
   b2ContactConstraint.b2ContactConstraint = function () {
      this.localPlaneNormal = new b2Vec2();
      this.localPoint = new b2Vec2();
      this.normal = new b2Vec2();
      this.normalMass = new b2Mat22();
      this.K = new b2Mat22();
   };
   b2ContactConstraint.prototype.b2ContactConstraint = function () {
      this.points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.points[i] = new b2ContactConstraintPoint();
      }
   }
   b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
      this.localPoint = new b2Vec2();
      this.rA = new b2Vec2();
      this.rB = new b2Vec2();
   };
   b2ContactEdge.b2ContactEdge = function () {};
   b2ContactFactory.b2ContactFactory = function () {};
   b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
      this.m_allocator = allocator;
      this.InitializeRegisters();
   }
   b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
      if (type1 === undefined) type1 = 0;
      if (type2 === undefined) type2 = 0;
      this.m_registers[type1][type2].createFcn = createFcn;
      this.m_registers[type1][type2].destroyFcn = destroyFcn;
      this.m_registers[type1][type2].primary = true;
      if (type1 != type2) {
         this.m_registers[type2][type1].createFcn = createFcn;
         this.m_registers[type2][type1].destroyFcn = destroyFcn;
         this.m_registers[type2][type1].primary = false;
      }
   }
   b2ContactFactory.prototype.InitializeRegisters = function () {
      this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
      for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
         this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
         for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
            this.m_registers[i][j] = new b2ContactRegister();
         }
      }
      this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
      this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
      this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
   }
   b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
      var type1 = parseInt(fixtureA.GetType());
      var type2 = parseInt(fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      var c;
      if (reg.pool) {
         c = reg.pool;
         reg.pool = c.m_next;
         reg.poolCount--;
         c.Reset(fixtureA, fixtureB);
         return c;
      }
      var createFcn = reg.createFcn;
      if (createFcn != null) {
         if (reg.primary) {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureA, fixtureB);
            return c;
         }
         else {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureB, fixtureA);
            return c;
         }
      }
      else {
         return null;
      }
   }
   b2ContactFactory.prototype.Destroy = function (contact) {
      if (contact.m_manifold.m_pointCount > 0) {
         contact.m_fixtureA.m_body.SetAwake(true);
         contact.m_fixtureB.m_body.SetAwake(true);
      }
      var type1 = parseInt(contact.m_fixtureA.GetType());
      var type2 = parseInt(contact.m_fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      if (true) {
         reg.poolCount++;
         contact.m_next = reg.pool;
         reg.pool = contact;
      }
      var destroyFcn = reg.destroyFcn;
      destroyFcn(contact, this.m_allocator);
   }
   b2ContactRegister.b2ContactRegister = function () {};
   b2ContactResult.b2ContactResult = function () {
      this.position = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2ContactSolver.b2ContactSolver = function () {
      this.m_step = new b2TimeStep();
      this.m_constraints = new Vector();
   };
   b2ContactSolver.prototype.b2ContactSolver = function () {}
   b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
      if (contactCount === undefined) contactCount = 0;
      var contact;
      this.m_step.Set(step);
      this.m_allocator = allocator;
      var i = 0;
      var tVec;
      var tMat;
      this.m_constraintCount = contactCount;
      while (this.m_constraints.length < this.m_constraintCount) {
         this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
      }
      for (i = 0;
      i < contactCount; ++i) {
         contact = contacts[i];
         var fixtureA = contact.m_fixtureA;
         var fixtureB = contact.m_fixtureB;
         var shapeA = fixtureA.m_shape;
         var shapeB = fixtureB.m_shape;
         var radiusA = shapeA.m_radius;
         var radiusB = shapeB.m_radius;
         var bodyA = fixtureA.m_body;
         var bodyB = fixtureB.m_body;
         var manifold = contact.GetManifold();
         var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
         var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
         var vAX = bodyA.m_linearVelocity.x;
         var vAY = bodyA.m_linearVelocity.y;
         var vBX = bodyB.m_linearVelocity.x;
         var vBY = bodyB.m_linearVelocity.y;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         b2Settings.b2Assert(manifold.m_pointCount > 0);
         b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
         var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
         var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
         var cc = this.m_constraints[i];
         cc.bodyA = bodyA;
         cc.bodyB = bodyB;
         cc.manifold = manifold;
         cc.normal.x = normalX;
         cc.normal.y = normalY;
         cc.pointCount = manifold.m_pointCount;
         cc.friction = friction;
         cc.restitution = restitution;
         cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
         cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
         cc.localPoint.x = manifold.m_localPoint.x;
         cc.localPoint.y = manifold.m_localPoint.y;
         cc.radius = radiusA + radiusB;
         cc.type = manifold.m_type;
         for (var k = 0; k < cc.pointCount; ++k) {
            var cp = manifold.m_points[k];
            var ccp = cc.points[k];
            ccp.normalImpulse = cp.m_normalImpulse;
            ccp.tangentImpulse = cp.m_tangentImpulse;
            ccp.localPoint.SetV(cp.m_localPoint);
            var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
            var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
            var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
            var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
            var rnA = rAX * normalY - rAY * normalX;
            var rnB = rBX * normalY - rBY * normalX;
            rnA *= rnA;
            rnB *= rnB;
            var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
            ccp.normalMass = 1.0 / kNormal;
            var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
            kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
            ccp.equalizedMass = 1.0 / kEqualized;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var rtA = rAX * tangentY - rAY * tangentX;
            var rtB = rBX * tangentY - rBY * tangentX;
            rtA *= rtA;
            rtB *= rtB;
            var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
            ccp.tangentMass = 1.0 / kTangent;
            ccp.velocityBias = 0.0;
            var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
            var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
            var vRel = cc.normal.x * tX + cc.normal.y * tY;
            if (vRel < (-b2Settings.b2_velocityThreshold)) {
               ccp.velocityBias += (-cc.restitution * vRel);
            }
         }
         if (cc.pointCount == 2) {
            var ccp1 = cc.points[0];
            var ccp2 = cc.points[1];
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
            var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
            var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
            var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
            var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
            var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
            var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
            var k_maxConditionNumber = 100.0;
            if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
               cc.K.col1.Set(k11, k12);
               cc.K.col2.Set(k12, k22);
               cc.K.GetInverse(cc.normalMass);
            }
            else {
               cc.pointCount = 1;
            }
         }
      }
   }
   b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
      var tVec;
      var tVec2;
      var tMat;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var tX = 0;
         var j = 0;
         var tCount = 0;
         if (step.warmStarting) {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp = c.points[j];
               ccp.normalImpulse *= step.dtRatio;
               ccp.tangentImpulse *= step.dtRatio;
               var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
               var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
               bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
               bodyA.m_linearVelocity.x -= invMassA * PX;
               bodyA.m_linearVelocity.y -= invMassA * PY;
               bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
               bodyB.m_linearVelocity.x += invMassB * PX;
               bodyB.m_linearVelocity.y += invMassB * PY;
            }
         }
         else {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp2 = c.points[j];
               ccp2.normalImpulse = 0.0;
               ccp2.tangentImpulse = 0.0;
            }
         }
      }
   }
   b2ContactSolver.prototype.SolveVelocityConstraints = function () {
      var j = 0;
      var ccp;
      var rAX = 0;
      var rAY = 0;
      var rBX = 0;
      var rBY = 0;
      var dvX = 0;
      var dvY = 0;
      var vn = 0;
      var vt = 0;
      var lambda = 0;
      var maxFriction = 0;
      var newImpulse = 0;
      var PX = 0;
      var PY = 0;
      var dX = 0;
      var dY = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var tMat;
      var tVec;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         var vA = bodyA.m_linearVelocity;
         var vB = bodyB.m_linearVelocity;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var friction = c.friction;
         var tX = 0;
         for (j = 0;
         j < c.pointCount; j++) {
            ccp = c.points[j];
            dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
            dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
            vt = dvX * tangentX + dvY * tangentY;
            lambda = ccp.tangentMass * (-vt);
            maxFriction = friction * ccp.normalImpulse;
            newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
            lambda = newImpulse - ccp.tangentImpulse;
            PX = lambda * tangentX;
            PY = lambda * tangentY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.tangentImpulse = newImpulse;
         }
         var tCount = parseInt(c.pointCount);
         if (c.pointCount == 1) {
            ccp = c.points[0];
            dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
            dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
            vn = dvX * normalX + dvY * normalY;
            lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
            newImpulse = ccp.normalImpulse + lambda;
            newImpulse = newImpulse > 0 ? newImpulse : 0.0;
            lambda = newImpulse - ccp.normalImpulse;
            PX = lambda * normalX;
            PY = lambda * normalY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.normalImpulse = newImpulse;
         }
         else {
            var cp1 = c.points[0];
            var cp2 = c.points[1];
            var aX = cp1.normalImpulse;
            var aY = cp2.normalImpulse;
            var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
            var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
            var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
            var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
            var vn1 = dv1X * normalX + dv1Y * normalY;
            var vn2 = dv2X * normalX + dv2Y * normalY;
            var bX = vn1 - cp1.velocityBias;
            var bY = vn2 - cp2.velocityBias;
            tMat = c.K;
            bX -= tMat.col1.x * aX + tMat.col2.x * aY;
            bY -= tMat.col1.y * aX + tMat.col2.y * aY;
            var k_errorTol = 0.001;
            for (;;) {
               tMat = c.normalMass;
               var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
               var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
               if (xX >= 0.0 && xY >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = (-cp1.normalMass * bX);
               xY = 0.0;
               vn1 = 0.0;
               vn2 = c.K.col1.y * xX + bY;
               if (xX >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = (-cp2.normalMass * bY);
               vn1 = c.K.col2.x * xY + bX;
               vn2 = 0.0;
               if (xY >= 0.0 && vn1 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = 0.0;
               vn1 = bX;
               vn2 = bY;
               if (vn1 >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               break;
            }
         }
         bodyA.m_angularVelocity = wA;
         bodyB.m_angularVelocity = wB;
      }
   }
   b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var m = c.manifold;
         for (var j = 0; j < c.pointCount; ++j) {
            var point1 = m.m_points[j];
            var point2 = c.points[j];
            point1.m_normalImpulse = point2.normalImpulse;
            point1.m_tangentImpulse = point2.tangentImpulse;
         }
      }
   }
   b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var minSeparation = 0.0;
      for (var i = 0; i < this.m_constraintCount; i++) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_mass * bodyA.m_invMass;
         var invIA = bodyA.m_mass * bodyA.m_invI;
         var invMassB = bodyB.m_mass * bodyB.m_invMass;
         var invIB = bodyB.m_mass * bodyB.m_invI;
         b2ContactSolver.s_psm.Initialize(c);
         var normal = b2ContactSolver.s_psm.m_normal;
         for (var j = 0; j < c.pointCount; j++) {
            var ccp = c.points[j];
            var point = b2ContactSolver.s_psm.m_points[j];
            var separation = b2ContactSolver.s_psm.m_separations[j];
            var rAX = point.x - bodyA.m_sweep.c.x;
            var rAY = point.y - bodyA.m_sweep.c.y;
            var rBX = point.x - bodyB.m_sweep.c.x;
            var rBY = point.y - bodyB.m_sweep.c.y;
            minSeparation = minSeparation < separation ? minSeparation : separation;
            var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
            var impulse = (-ccp.equalizedMass * C);
            var PX = impulse * normal.x;
            var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
            bodyA.m_sweep.c.y -= invMassA * PY;
            bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
            bodyA.SynchronizeTransform();
            bodyB.m_sweep.c.x += invMassB * PX;
            bodyB.m_sweep.c.y += invMassB * PY;
            bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
            bodyB.SynchronizeTransform();
         }
      }
      return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
      Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
   });
   Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2EdgeAndCircleContact.Create = function (allocator) {
      return new b2EdgeAndCircleContact();
   }
   b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
   b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2EdgeAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {}
   Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
   b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2NullContact.b2NullContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2NullContact.prototype.b2NullContact = function () {
      this.__super.b2Contact.call(this);
   }
   b2NullContact.prototype.Evaluate = function () {}
   Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndCircleContact.Create = function (allocator) {
      return new b2PolyAndCircleContact();
   }
   b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
   b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
   }
   b2PolyAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.m_body;
      var bB = this.m_fixtureB.m_body;
      b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndEdgeContact.Create = function (allocator) {
      return new b2PolyAndEdgeContact();
   }
   b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
   b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
   }
   b2PolyAndEdgeContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
   Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolygonContact.b2PolygonContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolygonContact.Create = function (allocator) {
      return new b2PolygonContact();
   }
   b2PolygonContact.Destroy = function (contact, allocator) {}
   b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2PolygonContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PositionSolverManifold.b2PositionSolverManifold = function () {};
   b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
      this.m_normal = new b2Vec2();
      this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2PositionSolverManifold.prototype.Initialize = function (cc) {
      b2Settings.b2Assert(cc.pointCount > 0);
      var i = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      var tMat;
      var tVec;
      var planePointX = 0;
      var planePointY = 0;
      switch (cc.type) {
      case b2Manifold.e_circles:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.points[0].localPoint;
            var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1.0;
               this.m_normal.y = 0.0;
            }
            this.m_points[0].x = 0.5 * (pointAX + pointBX);
            this.m_points[0].y = 0.5 * (pointAY + pointBY);
            this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].x = clipPointX;
               this.m_points[i].y = clipPointY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyA.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].Set(clipPointX, clipPointY);
            }
            this.m_normal.x *= (-1);
            this.m_normal.y *= (-1);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
   });
})();
(function () {
   var b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
      b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
      b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
      b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

   Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
   b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2BuoyancyController.b2BuoyancyController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.normal = new b2Vec2(0, (-1));
      this.offset = 0;
      this.density = 0;
      this.velocity = new b2Vec2(0, 0);
      this.linearDrag = 2;
      this.angularDrag = 1;
      this.useDensity = false;
      this.useWorldGravity = true;
      this.gravity = null;
   };
   b2BuoyancyController.prototype.Step = function (step) {
      if (!this.m_bodyList) return;
      if (this.useWorldGravity) {
         this.gravity = this.GetWorld().GetGravity().Copy();
      }
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (body.IsAwake() == false) {
            continue;
         }
         var areac = new b2Vec2();
         var massc = new b2Vec2();
         var area = 0.0;
         var mass = 0.0;
         for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
            var sc = new b2Vec2();
            var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
            area += sarea;
            areac.x += sarea * sc.x;
            areac.y += sarea * sc.y;
            var shapeDensity = 0;
            if (this.useDensity) {
               shapeDensity = 1;
            }
            else {
               shapeDensity = 1;
            }
            mass += sarea * shapeDensity;
            massc.x += sarea * sc.x * shapeDensity;
            massc.y += sarea * sc.y * shapeDensity;
         }
         areac.x /= area;
         areac.y /= area;
         massc.x /= mass;
         massc.y /= mass;
         if (area < Number.MIN_VALUE) continue;
         var buoyancyForce = this.gravity.GetNegative();
         buoyancyForce.Multiply(this.density * area);
         body.ApplyForce(buoyancyForce, massc);
         var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
         dragForce.Subtract(this.velocity);
         dragForce.Multiply((-this.linearDrag * area));
         body.ApplyForce(dragForce, areac);
         body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
      }
   }
   b2BuoyancyController.prototype.Draw = function (debugDraw) {
      var r = 1000;
      var p1 = new b2Vec2();
      var p2 = new b2Vec2();
      p1.x = this.normal.x * this.offset + this.normal.y * r;
      p1.y = this.normal.y * this.offset - this.normal.x * r;
      p2.x = this.normal.x * this.offset - this.normal.y * r;
      p2.y = this.normal.y * this.offset + this.normal.x * r;
      var color = new b2Color(0, 0, 1);
      debugDraw.DrawSegment(p1, p2, color);
   }
   Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantAccelController.b2ConstantAccelController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.A = new b2Vec2(0, 0);
   };
   b2ConstantAccelController.prototype.Step = function (step) {
      var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
      }
   }
   Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantForceController.b2ConstantForceController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.F = new b2Vec2(0, 0);
   };
   b2ConstantForceController.prototype.Step = function (step) {
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.ApplyForce(this.F, body.GetWorldCenter());
      }
   }
   b2Controller.b2Controller = function () {};
   b2Controller.prototype.Step = function (step) {}
   b2Controller.prototype.Draw = function (debugDraw) {}
   b2Controller.prototype.AddBody = function (body) {
      var edge = new b2ControllerEdge();
      edge.controller = this;
      edge.body = body;
      edge.nextBody = this.m_bodyList;
      edge.prevBody = null;
      this.m_bodyList = edge;
      if (edge.nextBody) edge.nextBody.prevBody = edge;
      this.m_bodyCount++;
      edge.nextController = body.m_controllerList;
      edge.prevController = null;
      body.m_controllerList = edge;
      if (edge.nextController) edge.nextController.prevController = edge;
      body.m_controllerCount++;
   }
   b2Controller.prototype.RemoveBody = function (body) {
      var edge = body.m_controllerList;
      while (edge && edge.controller != this)
      edge = edge.nextController;
      if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
      if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
      if (edge.nextController) edge.nextController.prevController = edge.prevController;
      if (edge.prevController) edge.prevController.nextController = edge.nextController;
      if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
      if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
      body.m_controllerCount--;
      this.m_bodyCount--;
   }
   b2Controller.prototype.Clear = function () {
      while (this.m_bodyList)
      this.RemoveBody(this.m_bodyList.body);
   }
   b2Controller.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Controller.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Controller.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2ControllerEdge.b2ControllerEdge = function () {};
   Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
   b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2GravityController.b2GravityController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.G = 1;
      this.invSqr = true;
   };
   b2GravityController.prototype.Step = function (step) {
      var i = null;
      var body1 = null;
      var p1 = null;
      var mass1 = 0;
      var j = null;
      var body2 = null;
      var p2 = null;
      var dx = 0;
      var dy = 0;
      var r2 = 0;
      var f = null;
      if (this.invSqr) {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
      else {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
   }
   Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
   b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2TensorDampingController.b2TensorDampingController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.T = new b2Mat22();
      this.maxTimestep = 0;
   };
   b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
      if (xDamping === undefined) xDamping = 0;
      if (yDamping === undefined) yDamping = 0;
      this.T.col1.x = (-xDamping);
      this.T.col1.y = 0;
      this.T.col2.x = 0;
      this.T.col2.y = (-yDamping);
      if (xDamping > 0 || yDamping > 0) {
         this.maxTimestep = 1 / Math.max(xDamping, yDamping);
      }
      else {
         this.maxTimestep = 0;
      }
   }
   b2TensorDampingController.prototype.Step = function (step) {
      var timestep = step.dt;
      if (timestep <= Number.MIN_VALUE) return;
      if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) {
            continue;
         }
         var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
      }
   }
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World;

   Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
   b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2DistanceJoint.b2DistanceJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u = new b2Vec2();
   };
   b2DistanceJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2DistanceJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
   }
   b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2DistanceJoint.prototype.GetLength = function () {
      return this.m_length;
   }
   b2DistanceJoint.prototype.SetLength = function (length) {
      if (length === undefined) length = 0;
      this.m_length = length;
   }
   b2DistanceJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2DistanceJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2DistanceJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_length = def.length;
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_impulse = 0.0;
      this.m_gamma = 0.0;
      this.m_bias = 0.0;
   }
   b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
      if (length > b2Settings.b2_linearSlop) {
         this.m_u.Multiply(1.0 / length);
      }
      else {
         this.m_u.SetZero();
      }
      var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
      var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
      var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
      if (this.m_frequencyHz > 0.0) {
         var C = length - this.m_length;
         var omega = 2.0 * Math.PI * this.m_frequencyHz;
         var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
         var k = this.m_mass * omega * omega;
         this.m_gamma = step.dt * (d + step.dt * k);
         this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
         this.m_bias = C * step.dt * k * this.m_gamma;
         this.m_mass = invMass + this.m_gamma;
         this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         var PX = this.m_impulse * this.m_u.x;
         var PY = this.m_impulse * this.m_u.y;
         bA.m_linearVelocity.x -= bA.m_invMass * PX;
         bA.m_linearVelocity.y -= bA.m_invMass * PY;
         bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
         bB.m_linearVelocity.x += bB.m_invMass * PX;
         bB.m_linearVelocity.y += bB.m_invMass * PY;
         bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
      var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
      var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
      var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
      var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
      var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
      this.m_impulse += impulse;
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_linearVelocity.x -= bA.m_invMass * PX;
      bA.m_linearVelocity.y -= bA.m_invMass * PY;
      bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_linearVelocity.x += bB.m_invMass * PX;
      bB.m_linearVelocity.y += bB.m_invMass * PY;
      bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
   }
   b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      if (this.m_frequencyHz > 0.0) {
         return true;
      }
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(dX * dX + dY * dY);
      dX /= length;
      dY /= length;
      var C = length - this.m_length;
      C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
      var impulse = (-this.m_mass * C);
      this.m_u.Set(dX, dY);
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_sweep.c.x -= bA.m_invMass * PX;
      bA.m_sweep.c.y -= bA.m_invMass * PY;
      bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_sweep.c.x += bB.m_invMass * PX;
      bB.m_sweep.c.y += bB.m_invMass * PY;
      bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return b2Math.Abs(C) < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2DistanceJointDef.b2DistanceJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_distanceJoint;
      this.length = 1.0;
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
      var dX = anchorB.x - anchorA.x;
      var dY = anchorB.y - anchorA.y;
      this.length = Math.sqrt(dX * dX + dY * dY);
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
   b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2FrictionJoint.b2FrictionJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_linearMass = new b2Mat22();
      this.m_linearImpulse = new b2Vec2();
   };
   b2FrictionJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2FrictionJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
   }
   b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_angularImpulse;
   }
   b2FrictionJoint.prototype.SetMaxForce = function (force) {
      if (force === undefined) force = 0;
      this.m_maxForce = force;
   }
   b2FrictionJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxTorque = torque;
   }
   b2FrictionJoint.prototype.GetMaxTorque = function () {
      return this.m_maxTorque;
   }
   b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_linearMass.SetZero();
      this.m_angularMass = 0.0;
      this.m_linearImpulse.SetZero();
      this.m_angularImpulse = 0.0;
      this.m_maxForce = def.maxForce;
      this.m_maxTorque = def.maxTorque;
   }
   b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var K = new b2Mat22();
      K.col1.x = mA + mB;
      K.col2.x = 0.0;
      K.col1.y = 0.0;
      K.col2.y = mA + mB;
      K.col1.x += iA * rAY * rAY;
      K.col2.x += (-iA * rAX * rAY);
      K.col1.y += (-iA * rAX * rAY);
      K.col2.y += iA * rAX * rAX;
      K.col1.x += iB * rBY * rBY;
      K.col2.x += (-iB * rBX * rBY);
      K.col1.y += (-iB * rBX * rBY);
      K.col2.y += iB * rBX * rBX;
      K.GetInverse(this.m_linearMass);
      this.m_angularMass = iA + iB;
      if (this.m_angularMass > 0.0) {
         this.m_angularMass = 1.0 / this.m_angularMass;
      }
      if (step.warmStarting) {
         this.m_linearImpulse.x *= step.dtRatio;
         this.m_linearImpulse.y *= step.dtRatio;
         this.m_angularImpulse *= step.dtRatio;
         var P = this.m_linearImpulse;
         bA.m_linearVelocity.x -= mA * P.x;
         bA.m_linearVelocity.y -= mA * P.y;
         bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
         bB.m_linearVelocity.x += mB * P.x;
         bB.m_linearVelocity.y += mB * P.y;
         bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
      }
      else {
         this.m_linearImpulse.SetZero();
         this.m_angularImpulse = 0.0;
      }
   }
   b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var maxImpulse = 0; {
         var Cdot = wB - wA;
         var impulse = (-this.m_angularMass * Cdot);
         var oldImpulse = this.m_angularImpulse;
         maxImpulse = step.dt * this.m_maxTorque;
         this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_angularImpulse - oldImpulse;
         wA -= iA * impulse;
         wB += iB * impulse;
      } {
         var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
         var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
         var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
         var oldImpulseV = this.m_linearImpulse.Copy();
         this.m_linearImpulse.Add(impulseV);
         maxImpulse = step.dt * this.m_maxForce;
         if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.Multiply(maxImpulse);
         }
         impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
         vA.x -= mA * impulseV.x;
         vA.y -= mA * impulseV.y;
         wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
         vB.x += mB * impulseV.x;
         vB.y += mB * impulseV.y;
         wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
      }
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2FrictionJointDef.b2FrictionJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_frictionJoint;
      this.maxForce = 0.0;
      this.maxTorque = 0.0;
   }
   b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
   }
   Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
   b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2GearJoint.b2GearJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_J = new b2Jacobian();
   };
   b2GearJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2GearJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
   }
   b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      var tMat = this.m_bodyB.m_xf.R;
      var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
      var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
      var tX = tMat.col1.x * rX + tMat.col2.x * rY;
      rY = tMat.col1.y * rX + tMat.col2.y * rY;
      rX = tX;
      var PX = this.m_impulse * this.m_J.linearB.x;
      var PY = this.m_impulse * this.m_J.linearB.y;
      return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
   }
   b2GearJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2GearJoint.prototype.SetRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_ratio = ratio;
   }
   b2GearJoint.prototype.b2GearJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var type1 = parseInt(def.joint1.m_type);
      var type2 = parseInt(def.joint2.m_type);
      this.m_revolute1 = null;
      this.m_prismatic1 = null;
      this.m_revolute2 = null;
      this.m_prismatic2 = null;
      var coordinate1 = 0;
      var coordinate2 = 0;
      this.m_ground1 = def.joint1.GetBodyA();
      this.m_bodyA = def.joint1.GetBodyB();
      if (type1 == b2Joint.e_revoluteJoint) {
         this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      this.m_ground2 = def.joint2.GetBodyA();
      this.m_bodyB = def.joint2.GetBodyB();
      if (type2 == b2Joint.e_revoluteJoint) {
         this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      this.m_ratio = def.ratio;
      this.m_constant = coordinate1 + this.m_ratio * coordinate2;
      this.m_impulse = 0.0;
   }
   b2GearJoint.prototype.InitVelocityConstraints = function (step) {
      var g1 = this.m_ground1;
      var g2 = this.m_ground2;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var ugX = 0;
      var ugY = 0;
      var rX = 0;
      var rY = 0;
      var tMat;
      var tVec;
      var crug = 0;
      var tX = 0;
      var K = 0.0;
      this.m_J.SetZero();
      if (this.m_revolute1) {
         this.m_J.angularA = (-1.0);
         K += bA.m_invI;
      }
      else {
         tMat = g1.m_xf.R;
         tVec = this.m_prismatic1.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bA.m_xf.R;
         rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearA.Set((-ugX), (-ugY));
         this.m_J.angularA = (-crug);
         K += bA.m_invMass + bA.m_invI * crug * crug;
      }
      if (this.m_revolute2) {
         this.m_J.angularB = (-this.m_ratio);
         K += this.m_ratio * this.m_ratio * bB.m_invI;
      }
      else {
         tMat = g2.m_xf.R;
         tVec = this.m_prismatic2.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bB.m_xf.R;
         rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
         this.m_J.angularB = (-this.m_ratio * crug);
         K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
      }
      this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
      if (step.warmStarting) {
         bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
         bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
         bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
         bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
         bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
         bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
      var impulse = (-this.m_mass * Cdot);
      this.m_impulse += impulse;
      bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
   }
   b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var linearError = 0.0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var coordinate1 = 0;
      var coordinate2 = 0;
      if (this.m_revolute1) {
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      if (this.m_revolute2) {
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
      var impulse = (-this.m_mass * C);
      bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2GearJointDef.b2GearJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
   };
   b2GearJointDef.prototype.b2GearJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_gearJoint;
      this.joint1 = null;
      this.joint2 = null;
      this.ratio = 1.0;
   }
   b2Jacobian.b2Jacobian = function () {
      this.linearA = new b2Vec2();
      this.linearB = new b2Vec2();
   };
   b2Jacobian.prototype.SetZero = function () {
      this.linearA.SetZero();
      this.angularA = 0.0;
      this.linearB.SetZero();
      this.angularB = 0.0;
   }
   b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      this.linearA.SetV(x1);
      this.angularA = a1;
      this.linearB.SetV(x2);
      this.angularB = a2;
   }
   b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
   }
   b2Joint.b2Joint = function () {
      this.m_edgeA = new b2JointEdge();
      this.m_edgeB = new b2JointEdge();
      this.m_localCenterA = new b2Vec2();
      this.m_localCenterB = new b2Vec2();
   };
   b2Joint.prototype.GetType = function () {
      return this.m_type;
   }
   b2Joint.prototype.GetAnchorA = function () {
      return null;
   }
   b2Joint.prototype.GetAnchorB = function () {
      return null;
   }
   b2Joint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return null;
   }
   b2Joint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2Joint.prototype.GetBodyA = function () {
      return this.m_bodyA;
   }
   b2Joint.prototype.GetBodyB = function () {
      return this.m_bodyB;
   }
   b2Joint.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Joint.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Joint.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Joint.prototype.IsActive = function () {
      return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
   }
   b2Joint.Create = function (def, allocator) {
      var joint = null;
      switch (def.type) {
      case b2Joint.e_distanceJoint:
         {
            joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
         }
         break;
      case b2Joint.e_mouseJoint:
         {
            joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
         }
         break;
      case b2Joint.e_prismaticJoint:
         {
            joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
         }
         break;
      case b2Joint.e_revoluteJoint:
         {
            joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
         }
         break;
      case b2Joint.e_pulleyJoint:
         {
            joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
         }
         break;
      case b2Joint.e_gearJoint:
         {
            joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
         }
         break;
      case b2Joint.e_lineJoint:
         {
            joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
         }
         break;
      case b2Joint.e_weldJoint:
         {
            joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
         }
         break;
      case b2Joint.e_frictionJoint:
         {
            joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
         }
         break;
      default:
         break;
      }
      return joint;
   }
   b2Joint.Destroy = function (joint, allocator) {}
   b2Joint.prototype.b2Joint = function (def) {
      b2Settings.b2Assert(def.bodyA != def.bodyB);
      this.m_type = def.type;
      this.m_prev = null;
      this.m_next = null;
      this.m_bodyA = def.bodyA;
      this.m_bodyB = def.bodyB;
      this.m_collideConnected = def.collideConnected;
      this.m_islandFlag = false;
      this.m_userData = def.userData;
   }
   b2Joint.prototype.InitVelocityConstraints = function (step) {}
   b2Joint.prototype.SolveVelocityConstraints = function (step) {}
   b2Joint.prototype.FinalizeVelocityConstraints = function () {}
   b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return false;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
      Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
      Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
      Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
      Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
      Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
      Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
      Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
      Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
      Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
      Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
      Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
      Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
      Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
   });
   b2JointDef.b2JointDef = function () {};
   b2JointDef.prototype.b2JointDef = function () {
      this.type = b2Joint.e_unknownJoint;
      this.userData = null;
      this.bodyA = null;
      this.bodyB = null;
      this.collideConnected = false;
   }
   b2JointEdge.b2JointEdge = function () {};
   Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
   b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2LineJoint.b2LineJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat22();
      this.m_impulse = new b2Vec2();
   };
   b2LineJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2LineJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
   }
   b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2LineJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2LineJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2LineJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2LineJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2LineJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2LineJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2LineJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2LineJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2LineJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2LineJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2LineJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2LineJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2LineJoint.prototype.GetMaxMotorForce = function () {
      return this.m_maxMotorForce;
   }
   b2LineJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2LineJoint.prototype.b2LineJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2LineJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.y = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
         }
         var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
         var f2r = 0;
         if (this.m_K.col1.x != 0.0) {
            f2r = b / this.m_K.col1.x + f1.x;
         }
         else {
            f2r = f1.x;
         }
         this.m_impulse.x = f2r;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y * this.m_a1;
         L2 = df.x * this.m_s2 + df.y * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = 0;
         if (this.m_K.col1.x != 0.0) {
            df2 = ((-Cdot1)) / this.m_K.col1.x;
         }
         else {
            df2 = 0.0;
         }
         this.m_impulse.x += df2;
         PX = df2 * this.m_perp.x;
         PY = df2 * this.m_perp.y;
         L1 = df2 * this.m_s1;
         L2 = df2 * this.m_s2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec2();
      var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1));
      angularError = 0.0;
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve(impulse, (-C1), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var impulse1 = 0;
         if (k11 != 0.0) {
            impulse1 = ((-C1)) / k11;
         }
         else {
            impulse1 = 0.0;
         }
         impulse.x = impulse1;
         impulse.y = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2LineJointDef.b2LineJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2LineJointDef.prototype.b2LineJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_lineJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
   }
   Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
   b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2MouseJoint.b2MouseJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.m_localAnchor = new b2Vec2();
      this.m_target = new b2Vec2();
      this.m_impulse = new b2Vec2();
      this.m_mass = new b2Mat22();
      this.m_C = new b2Vec2();
   };
   b2MouseJoint.prototype.GetAnchorA = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
   }
   b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2MouseJoint.prototype.GetTarget = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.SetTarget = function (target) {
      if (this.m_bodyB.IsAwake() == false) {
         this.m_bodyB.SetAwake(true);
      }
      this.m_target = target;
   }
   b2MouseJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
      if (maxForce === undefined) maxForce = 0;
      this.m_maxForce = maxForce;
   }
   b2MouseJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2MouseJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2MouseJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2MouseJoint.prototype.b2MouseJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_target.SetV(def.target);
      var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
      var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
      var tMat = this.m_bodyB.m_xf.R;
      this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
      this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
      this.m_maxForce = def.maxForce;
      this.m_impulse.SetZero();
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_beta = 0.0;
      this.m_gamma = 0.0;
   }
   b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var mass = b.GetMass();
      var omega = 2.0 * Math.PI * this.m_frequencyHz;
      var d = 2.0 * mass * this.m_dampingRatio * omega;
      var k = mass * omega * omega;
      this.m_gamma = step.dt * (d + step.dt * k);
      this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
      this.m_beta = step.dt * k * this.m_gamma;
      var tMat;tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var invMass = b.m_invMass;
      var invI = b.m_invI;this.K1.col1.x = invMass;
      this.K1.col2.x = 0.0;
      this.K1.col1.y = 0.0;
      this.K1.col2.y = invMass;
      this.K2.col1.x = invI * rY * rY;
      this.K2.col2.x = (-invI * rX * rY);
      this.K2.col1.y = (-invI * rX * rY);
      this.K2.col2.y = invI * rX * rX;
      this.K.SetM(this.K1);
      this.K.AddM(this.K2);
      this.K.col1.x += this.m_gamma;
      this.K.col2.y += this.m_gamma;
      this.K.GetInverse(this.m_mass);
      this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
      this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
      b.m_angularVelocity *= 0.98;
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      b.m_linearVelocity.x += invMass * this.m_impulse.x;
      b.m_linearVelocity.y += invMass * this.m_impulse.y;
      b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
   }
   b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var tMat;
      var tX = 0;
      var tY = 0;
      tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rX + tMat.col2.x * rY);
      rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
      var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
      tMat = this.m_mass;
      tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
      tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
      var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
      var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
      var oldImpulseX = this.m_impulse.x;
      var oldImpulseY = this.m_impulse.y;
      this.m_impulse.x += impulseX;
      this.m_impulse.y += impulseY;
      var maxImpulse = step.dt * this.m_maxForce;
      if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
         this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
      }
      impulseX = this.m_impulse.x - oldImpulseX;
      impulseY = this.m_impulse.y - oldImpulseY;
      b.m_linearVelocity.x += b.m_invMass * impulseX;
      b.m_linearVelocity.y += b.m_invMass * impulseY;
      b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
   }
   b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2MouseJointDef.b2MouseJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.target = new b2Vec2();
   };
   b2MouseJointDef.prototype.b2MouseJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_mouseJoint;
      this.maxForce = 0.0;
      this.frequencyHz = 5.0;
      this.dampingRatio = 0.7;
   }
   Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PrismaticJoint.b2PrismaticJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat33();
      this.m_impulse = new b2Vec3();
   };
   b2PrismaticJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PrismaticJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
   }
   b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2PrismaticJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2PrismaticJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2PrismaticJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2PrismaticJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2PrismaticJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2PrismaticJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2PrismaticJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2PrismaticJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2PrismaticJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2PrismaticJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_refAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      var Cdot1Y = w2 - w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
         }
         var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
         var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
         var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
         f2r.x += f1.x;
         f2r.y += f1.y;
         this.m_impulse.x = f2r.x;
         this.m_impulse.y = f2r.y;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         df.z = this.m_impulse.z - f1.z;
         PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
         L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
         this.m_impulse.x += df2.x;
         this.m_impulse.y += df2.y;
         PX = df2.x * this.m_perp.x;
         PY = df2.x * this.m_perp.y;
         L1 = df2.x * this.m_s1 + df2.y;
         L2 = df2.x * this.m_s2 + df2.y;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec3();
      var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
      var C1Y = a2 - a1 - this.m_refAngle;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
      angularError = b2Math.Abs(C1Y);
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var k12 = i1 * this.m_s1 + i2 * this.m_s2;
         var k22 = i1 + i2;
         this.m_K.col1.Set(k11, k12, 0.0);
         this.m_K.col2.Set(k12, k22, 0.0);
         var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
         impulse.x = impulse1.x;
         impulse.y = impulse1.y;
         impulse.z = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PrismaticJointDef.b2PrismaticJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_prismaticJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.referenceAngle = 0.0;
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PulleyJoint.b2PulleyJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u1 = new b2Vec2();
      this.m_u2 = new b2Vec2();
   };
   b2PulleyJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PulleyJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
   }
   b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2PulleyJoint.prototype.GetGroundAnchorA = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor1);
      return a;
   }
   b2PulleyJoint.prototype.GetGroundAnchorB = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor2);
      return a;
   }
   b2PulleyJoint.prototype.GetLength1 = function () {
      var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetLength2 = function () {
      var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_ground = this.m_bodyA.m_world.m_groundBody;
      this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
      this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_ratio = def.ratio;
      this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
      this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
      this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
      this.m_impulse = 0.0;
      this.m_limitImpulse1 = 0.0;
      this.m_limitImpulse2 = 0.0;
   }
   b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      this.m_u1.Set(p1X - s1X, p1Y - s1Y);
      this.m_u2.Set(p2X - s2X, p2Y - s2Y);
      var length1 = this.m_u1.Length();
      var length2 = this.m_u2.Length();
      if (length1 > b2Settings.b2_linearSlop) {
         this.m_u1.Multiply(1.0 / length1);
      }
      else {
         this.m_u1.SetZero();
      }
      if (length2 > b2Settings.b2_linearSlop) {
         this.m_u2.Multiply(1.0 / length2);
      }
      else {
         this.m_u2.SetZero();
      }
      var C = this.m_constant - length1 - this.m_ratio * length2;
      if (C > 0.0) {
         this.m_state = b2Joint.e_inactiveLimit;
         this.m_impulse = 0.0;
      }
      else {
         this.m_state = b2Joint.e_atUpperLimit;
      }
      if (length1 < this.m_maxLength1) {
         this.m_limitState1 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse1 = 0.0;
      }
      else {
         this.m_limitState1 = b2Joint.e_atUpperLimit;
      }
      if (length2 < this.m_maxLength2) {
         this.m_limitState2 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse2 = 0.0;
      }
      else {
         this.m_limitState2 = b2Joint.e_atUpperLimit;
      }
      var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
      var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
      this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
      this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
      this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
      this.m_limitMass1 = 1.0 / this.m_limitMass1;
      this.m_limitMass2 = 1.0 / this.m_limitMass2;
      this.m_pulleyMass = 1.0 / this.m_pulleyMass;
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         this.m_limitImpulse1 *= step.dtRatio;
         this.m_limitImpulse2 *= step.dtRatio;
         var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
         var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
         var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
         var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      else {
         this.m_impulse = 0.0;
         this.m_limitImpulse1 = 0.0;
         this.m_limitImpulse2 = 0.0;
      }
   }
   b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = 0;
      var v1Y = 0;
      var v2X = 0;
      var v2Y = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var Cdot = 0;
      var impulse = 0;
      var oldImpulse = 0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
         impulse = this.m_pulleyMass * ((-Cdot));
         oldImpulse = this.m_impulse;
         this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
         impulse = this.m_impulse - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         P2X = (-this.m_ratio * impulse * this.m_u2.x);
         P2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
         impulse = (-this.m_limitMass1 * Cdot);
         oldImpulse = this.m_limitImpulse1;
         this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
         impulse = this.m_limitImpulse1 - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
         impulse = (-this.m_limitMass2 * Cdot);
         oldImpulse = this.m_limitImpulse2;
         this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
         impulse = this.m_limitImpulse2 - oldImpulse;
         P2X = (-impulse * this.m_u2.x);
         P2Y = (-impulse * this.m_u2.y);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
   }
   b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var p1X = 0;
      var p1Y = 0;
      var p2X = 0;
      var p2Y = 0;
      var length1 = 0;
      var length2 = 0;
      var C = 0;
      var impulse = 0;
      var oldImpulse = 0;
      var oldLimitPositionImpulse = 0;
      var tX = 0;
      var linearError = 0.0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length1 = this.m_u1.Length();
         length2 = this.m_u2.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
         }
         else {
            this.m_u1.SetZero();
         }
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_constant - length1 - this.m_ratio * length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_pulleyMass * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         p2X = (-this.m_ratio * impulse * this.m_u2.x);
         p2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         length1 = this.m_u1.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.x *= 1.0 / length1;
            this.m_u1.y *= 1.0 / length1;
         }
         else {
            this.m_u1.SetZero();
         }
         C = this.m_maxLength1 - length1;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass1 * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bA.SynchronizeTransform();
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length2 = this.m_u2.Length();
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.x *= 1.0 / length2;
            this.m_u2.y *= 1.0 / length2;
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_maxLength2 - length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass2 * C);
         p2X = (-impulse * this.m_u2.x);
         p2Y = (-impulse * this.m_u2.y);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bB.SynchronizeTransform();
      }
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
   });
   Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PulleyJointDef.b2PulleyJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.groundAnchorA = new b2Vec2();
      this.groundAnchorB = new b2Vec2();
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_pulleyJoint;
      this.groundAnchorA.Set((-1.0), 1.0);
      this.groundAnchorB.Set(1.0, 1.0);
      this.localAnchorA.Set((-1.0), 0.0);
      this.localAnchorB.Set(1.0, 0.0);
      this.lengthA = 0.0;
      this.maxLengthA = 0.0;
      this.lengthB = 0.0;
      this.maxLengthB = 0.0;
      this.ratio = 1.0;
      this.collideConnected = true;
   }
   b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
      if (r === undefined) r = 0;
      this.bodyA = bA;
      this.bodyB = bB;
      this.groundAnchorA.SetV(gaA);
      this.groundAnchorB.SetV(gaB);
      this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
      var d1X = anchorA.x - gaA.x;
      var d1Y = anchorA.y - gaA.y;
      this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
      var d2X = anchorB.x - gaB.x;
      var d2Y = anchorB.y - gaB.y;
      this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
      this.ratio = r;
      var C = this.lengthA + this.ratio * this.lengthB;
      this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
      this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
   }
   Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
   b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2RevoluteJoint.b2RevoluteJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.K3 = new b2Mat22();
      this.impulse3 = new b2Vec3();
      this.impulse2 = new b2Vec2();
      this.reduced = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2RevoluteJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2RevoluteJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2RevoluteJoint.prototype.GetJointAngle = function () {
      return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
   }
   b2RevoluteJoint.prototype.GetJointSpeed = function () {
      return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
   }
   b2RevoluteJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2RevoluteJoint.prototype.EnableLimit = function (flag) {
      this.m_enableLimit = flag;
   }
   b2RevoluteJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerAngle;
   }
   b2RevoluteJoint.prototype.GetUpperLimit = function () {
      return this.m_upperAngle;
   }
   b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_lowerAngle = lower;
      this.m_upperAngle = upper;
   }
   b2RevoluteJoint.prototype.IsMotorEnabled = function () {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      return this.m_enableMotor;
   }
   b2RevoluteJoint.prototype.EnableMotor = function (flag) {
      this.m_enableMotor = flag;
   }
   b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2RevoluteJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxMotorTorque = torque;
   }
   b2RevoluteJoint.prototype.GetMotorTorque = function () {
      return this.m_maxMotorTorque;
   }
   b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
      this.m_lowerAngle = def.lowerAngle;
      this.m_upperAngle = def.upperAngle;
      this.m_maxMotorTorque = def.maxMotorTorque;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
   }
   b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      if (this.m_enableMotor || this.m_enableLimit) {}
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
      this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
      this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
      this.m_mass.col3.y = r1X * i1 + r2X * i2;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = i1 + i2;
      this.m_motorMass = 1.0 / (i1 + i2);
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (this.m_enableLimit) {
         var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointAngle <= this.m_lowerAngle) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atLowerLimit;
         }
         else if (jointAngle >= this.m_upperAngle) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atUpperLimit;
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x;
         var PY = this.m_impulse.y;
         bA.m_linearVelocity.x -= m1 * PX;
         bA.m_linearVelocity.y -= m1 * PY;
         bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
         bB.m_linearVelocity.x += m2 * PX;
         bB.m_linearVelocity.y += m2 * PY;
         bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      var newImpulse = 0;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = w2 - w1 - this.m_motorSpeed;
         var impulse = this.m_motorMass * ((-Cdot));
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorTorque;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         w1 -= i1 * impulse;
         w2 += i2 * impulse;
      }
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         var Cdot2 = w2 - w1;
         this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
         if (this.m_limitState == b2Joint.e_equalLimits) {
            this.m_impulse.Add(this.impulse3);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse < 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse > 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         v1.x -= m1 * this.impulse3.x;
         v1.y -= m1 * this.impulse3.y;
         w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
         v2.x += m2 * this.impulse3.x;
         v2.y += m2 * this.impulse3.y;
         w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
      }
      else {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
         this.m_impulse.x += this.impulse2.x;
         this.m_impulse.y += this.impulse2.y;
         v1.x -= m1 * this.impulse2.x;
         v1.y -= m1 * this.impulse2.y;
         w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
         v2.x += m2 * this.impulse2.x;
         v2.y += m2 * this.impulse2.y;
         w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var oldLimitImpulse = 0;
      var C = 0;
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var angularError = 0.0;
      var positionError = 0.0;
      var tX = 0;
      var impulseX = 0;
      var impulseY = 0;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         var limitImpulse = 0.0;
         if (this.m_limitState == b2Joint.e_equalLimits) {
            C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
            angularError = b2Math.Abs(C);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            C = angle - this.m_lowerAngle;
            angularError = (-C);
            C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
            limitImpulse = (-this.m_motorMass * C);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            C = angle - this.m_upperAngle;
            angularError = C;
            C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
         }
         bA.m_sweep.a -= bA.m_invI * limitImpulse;
         bB.m_sweep.a += bB.m_invI * limitImpulse;
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      } {
         tMat = bA.m_xf.R;
         var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
         var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         var CLengthSquared = CX * CX + CY * CY;
         var CLength = Math.sqrt(CLengthSquared);
         positionError = CLength;
         var invMass1 = bA.m_invMass;
         var invMass2 = bB.m_invMass;
         var invI1 = bA.m_invI;
         var invI2 = bB.m_invI;
         var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
         if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
            var uX = CX / CLength;
            var uY = CY / CLength;
            var k = invMass1 + invMass2;
            var m = 1.0 / k;
            impulseX = m * ((-CX));
            impulseY = m * ((-CY));
            var k_beta = 0.5;
            bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
            bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
            bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
            bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
            CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         }
         this.K1.col1.x = invMass1 + invMass2;
         this.K1.col2.x = 0.0;
         this.K1.col1.y = 0.0;
         this.K1.col2.y = invMass1 + invMass2;
         this.K2.col1.x = invI1 * r1Y * r1Y;
         this.K2.col2.x = (-invI1 * r1X * r1Y);
         this.K2.col1.y = (-invI1 * r1X * r1Y);
         this.K2.col2.y = invI1 * r1X * r1X;
         this.K3.col1.x = invI2 * r2Y * r2Y;
         this.K3.col2.x = (-invI2 * r2X * r2Y);
         this.K3.col1.y = (-invI2 * r2X * r2Y);
         this.K3.col2.y = invI2 * r2X * r2X;
         this.K.SetM(this.K1);
         this.K.AddM(this.K2);
         this.K.AddM(this.K3);
         this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
         impulseX = b2RevoluteJoint.tImpulse.x;
         impulseY = b2RevoluteJoint.tImpulse.y;
         bA.m_sweep.c.x -= bA.m_invMass * impulseX;
         bA.m_sweep.c.y -= bA.m_invMass * impulseY;
         bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
         bB.m_sweep.c.x += bB.m_invMass * impulseX;
         bB.m_sweep.c.y += bB.m_invMass * impulseY;
         bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
   });
   Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2RevoluteJointDef.b2RevoluteJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_revoluteJoint;
      this.localAnchorA.Set(0.0, 0.0);
      this.localAnchorB.Set(0.0, 0.0);
      this.referenceAngle = 0.0;
      this.lowerAngle = 0.0;
      this.upperAngle = 0.0;
      this.maxMotorTorque = 0.0;
      this.motorSpeed = 0.0;
      this.enableLimit = false;
      this.enableMotor = false;
   }
   b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
   b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2WeldJoint.b2WeldJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2WeldJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2WeldJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2WeldJoint.prototype.b2WeldJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_mass = new b2Mat33();
   }
   b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_impulse.z *= step.dtRatio;
         bA.m_linearVelocity.x -= mA * this.m_impulse.x;
         bA.m_linearVelocity.y -= mA * this.m_impulse.y;
         bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
         bB.m_linearVelocity.x += mB * this.m_impulse.x;
         bB.m_linearVelocity.y += mB * this.m_impulse.y;
         bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
      }
   }
   b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
      var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
      var Cdot2 = wB - wA;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
      this.m_impulse.Add(impulse);
      vA.x -= mA * impulse.x;
      vA.y -= mA * impulse.y;
      wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      vB.x += mB * impulse.x;
      vB.y += mB * impulse.y;
      wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
      var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
      var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
      var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
      var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
      var angularError = b2Math.Abs(C2);
      if (positionError > k_allowedStretch) {
         iA *= 1.0;
         iB *= 1.0;
      }
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      bA.m_sweep.c.x -= mA * impulse.x;
      bA.m_sweep.c.y -= mA * impulse.y;
      bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      bB.m_sweep.c.x += mB * impulse.x;
      bB.m_sweep.c.y += mB * impulse.y;
      bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2WeldJointDef.b2WeldJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2WeldJointDef.prototype.b2WeldJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_weldJoint;
      this.referenceAngle = 0.0;
   }
   b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
})();
(function () {
   var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
   b2DebugDraw.b2DebugDraw = function () {
      this.m_drawScale = 1.0;
      this.m_lineThickness = 1.0;
      this.m_alpha = 1.0;
      this.m_fillAlpha = 1.0;
      this.m_xformScale = 1.0;
      var __this = this;
      //#WORKAROUND
      this.m_sprite = {
         graphics: {
            clear: function () {
               __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
            }
         }
      };
   };
   b2DebugDraw.prototype._color = function (color, alpha) {
      return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
   };
   b2DebugDraw.prototype.b2DebugDraw = function () {
      this.m_drawFlags = 0;
   };
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags = flags;
   };
   b2DebugDraw.prototype.GetFlags = function () {
      return this.m_drawFlags;
   };
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags |= flags;
   };
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags &= ~flags;
   };
   b2DebugDraw.prototype.SetSprite = function (sprite) {
      this.m_ctx = sprite;
   };
   b2DebugDraw.prototype.GetSprite = function () {
      return this.m_ctx;
   };
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
      this.m_drawScale = drawScale;
   };
   b2DebugDraw.prototype.GetDrawScale = function () {
      return this.m_drawScale;
   };
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
      this.m_lineThickness = lineThickness;
      this.m_ctx.strokeWidth = lineThickness;
   };
   b2DebugDraw.prototype.GetLineThickness = function () {
      return this.m_lineThickness;
   };
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_alpha = alpha;
   };
   b2DebugDraw.prototype.GetAlpha = function () {
      return this.m_alpha;
   };
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_fillAlpha = alpha;
   };
   b2DebugDraw.prototype.GetFillAlpha = function () {
      return this.m_fillAlpha;
   };
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
      this.m_xformScale = xformScale;
   };
   b2DebugDraw.prototype.GetXFormScale = function () {
      return this.m_xformScale;
   };
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (!radius) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (!radius) return;
      var s = this.m_ctx,
         drawScale = this.m_drawScale,
         cx = center.x * drawScale,
         cy = center.y * drawScale;
      s.moveTo(0, 0);
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
      s.moveTo(cx, cy);
      s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.beginPath();
      s.moveTo(p1.x * drawScale, p1.y * drawScale);
      s.lineTo(p2.x * drawScale, p2.y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawTransform = function (xf) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(0xff0000, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

      s.strokeStyle = this._color(0xff00, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
      s.closePath();
      s.stroke();
   };
})();
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();

module.exports = Box2D

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "./node_modules/html-entities/index.js":
/*!*********************************************!*\
  !*** ./node_modules/html-entities/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(/*! ./lib/xml-entities.js */ "./node_modules/html-entities/lib/xml-entities.js"),
  Html4Entities: __webpack_require__(/*! ./lib/html4-entities.js */ "./node_modules/html-entities/lib/html4-entities.js"),
  Html5Entities: __webpack_require__(/*! ./lib/html5-entities.js */ "./node_modules/html-entities/lib/html5-entities.js"),
  AllHtmlEntities: __webpack_require__(/*! ./lib/html5-entities.js */ "./node_modules/html-entities/lib/html5-entities.js")
};


/***/ }),

/***/ "./node_modules/html-entities/lib/html4-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html4-entities.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),

/***/ "./node_modules/html-entities/lib/html5-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html5-entities.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),

/***/ "./node_modules/html-entities/lib/xml-entities.js":
/*!********************************************************!*\
  !*** ./node_modules/html-entities/lib/xml-entities.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/punycode/punycode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/quintus/extra/quintus_dom.js":
/*!***************************************************!*\
  !*** ./node_modules/quintus/extra/quintus_dom.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */
/*global $:false */

module.exports = function(Q) {
  
  Q.setupDOM = function(id,options) {
    options = options || {};
    id = id || "quintus";
    Q.el = $(Q._isString(id) ? "#" + id : id);
    if(Q.el.length === 0) {
      Q.el = $("<div>")
                .attr('id',id)
                .css({width: 320, height:420 })
                .appendTo("body");
    }
    if(options.maximize) {
      var w = $(window).width();
      var h = $(window).height();
      Q.el.css({width:w,height:h});
    }
   Q.wrapper = Q.el
                 .wrap("<div id='" + id + "_container'/>")
                 .parent()
                 .css({ width: Q.el.width(),
                        height: Q.el.height(),
                        margin: '0 auto' });
    Q.el.css({ position:'relative', overflow: 'hidden' });
    Q.width = Q.el.width();
    Q.height = Q.el.height();
    setTimeout(function() { window.scrollTo(0,1); }, 0);
    $(window).bind('orientationchange',function() {
      setTimeout(function() { window.scrollTo(0,1); }, 0);
    });
    return Q;
  };

(function() { 
    function translateBuilder(attribute) {
      return function(dom,x,y) {
        dom.style[attribute] = 
        "translate(" + Math.floor(x) + "px," +
        Math.floor(y) + "px)";
      };
    }
    function translate3DBuilder(attribute) {
      return function(dom,x,y) {
        dom.style[attribute] = 
        "translate3d(" + Math.floor(x) + "px," +
        Math.floor(y) + "px,0px)";
      };
    }
    function scaleBuilder(attribute) {
      return function(dom,scale) {
        dom.style[attribute + 'Origin'] = "0% 0%";
        dom.style[attribute] = "scale(" + scale + ")";
      };
    }
    function fallbackTranslate(dom,x,y) {
      dom.style.left = x + "px";
      dom.style.top = y + "px";
    }
    var has3d =  ('WebKitCSSMatrix' in window && 
                  'm11' in new window.WebKitCSSMatrix());
    var dummyStyle = $("<div>")[0].style;
    var transformMethods = ['transform',
                            'webkitTransform',
                            'MozTransform',
                            'msTransform' ];
    for(var i=0;i<transformMethods.length;i++) {
      var transformName = transformMethods[i];
      if(!Q._isUndefined(dummyStyle[transformName])) {
        if(has3d) {
          Q.positionDOM = translate3DBuilder(transformName);
        } else {
          Q.positionDOM = translateBuilder(transformName); 
        }
        Q.scaleDOM = scaleBuilder(transformName);
        break;
      }
    }
    Q.positionDOM = Q.positionDOM || fallbackTranslate;
    Q.scaleDOM = Q.scaleDOM || function(scale) {};
  }());

  (function() {
     function transitionBuilder(attribute,prefix){
      return function(dom,property,sec,easing) {
        easing = easing || "";
        if(property === 'transform') {
          property = prefix + property;
        }
        sec = sec || "1s";
        dom.style[attribute] = property + " " + sec + " " + easing;
      };
    }
    // Dummy method
    function fallbackTransition() { }
    var dummyStyle = $("<div>")[0].style;
    var transitionMethods = ['transition',
                            'webkitTransition',
                            'MozTransition',
                            'msTransition' ];
    var prefixNames = [ '', '-webkit-', '-moz-', '-ms-' ];
    for(var i=0;i<transitionMethods.length;i++) {
      var transitionName = transitionMethods[i];
      var prefixName = prefixNames[i];
      if(!Q._isUndefined(dummyStyle[transitionName])) {
        Q.transitionDOM = transitionBuilder(transitionName,prefixName); 
        break;
      }
    }
    Q.transitionDOM = Q.transitionDOM || fallbackTransition;
  }());

  Q.DOMSprite = Q.Sprite.extend({
    init: function(props) {
      this._super(props);
      this.el = $("<div>").css({
        width: this.p.w,
        height: this.p.h,
        zIndex: this.p.z || 0,
        position: 'absolute'
      });
      this.dom = this.el[0];
      this.rp = {};
      this.setImage();
      this.setTransform();
    },
  
    setImage: function() {
      var asset;
      if(this.sheet()) {
        asset = Q.asset(this.sheet().asset);
      } else {
        asset = this.asset();
      }
      if(asset) {
        this.dom.style.backgroundImage = "url(" + asset.src + ")";
      }
    },
  
    setTransform: function() {
      var p = this.p;
      var rp = this.rp;
      if(rp.frame !== p.frame) {
        if(p.sheet) {
          this.dom.style.backgroundPosition = 
              (-this.sheet().fx(p.frame)) + "px " + 
              (-this.sheet().fy(p.frame)) + "px";
        } else {
          this.dom.style.backgroundPosition = "0px 0px";
        }
        rp.frame = p.frame;
      }
      if(rp.x !== p.x || rp.y !== p.y) {
        Q.positionDOM(this.dom,p.x,p.y);
        rp.x = p.x;
        rp.y = p.y;
      } 
    },

    hide: function() {
      this.dom.style.display = 'none';
    },

    show: function() {
      this.dom.style.display = 'block';
    },

    draw: function(ctx) {
      this.trigger('draw');
    },

    step: function(dt) {
      this.trigger('step',dt);
      this.setTransform();
    },

    destroy: function() {
      if(this.destroyed) { return false; }
      this._super();
      this.el.remove();
    }
  });
  

  if(Q.Stage) {
    Q.DOMStage = Q.Stage.extend({
      init: function(scene) {
        this.el = $("<div>").css({
          top:0,
          position:'relative'
        }).appendTo(Q.el);
        this.dom = this.el[0];
        this.wrapper = this.el.wrap('<div>').parent().css({
          position:'absolute',
          left:0,
          top:0
        });
        this.scale = 1;
        this.wrapper_dom = this.wrapper[0];
        this._super(scene);
      },

      insert: function(itm) {
        if(itm.dom) { this.dom.appendChild(itm.dom); }
        return this._super(itm);
      },

      destroy: function() {
        this.wrapper.remove();
        this._super();
      },

      rescale: function(scale) {
        this.scale = scale;
        Q.scaleDOM(this.wrapper_dom,scale);
      },

      centerOn: function(x,y) {
        this.x = Q.width/2/this.scale -  x;
        this.y = Q.height/2/this.scale - y;
        Q.positionDOM(this.dom,this.x,this.y);
      }
    });
  }

  Q.domOnly = function() {
    Q.Stage = Q.DOMStage;
    Q.setup = Q.setupDOM;
    Q.Sprite = Q.DOMSprite;
    return Q;
  };
  
  Q.DOMTileMap = Q.DOMSprite.extend({
    // Expects a sprite sheet, along with cols and rows properties
    init:function(props) {
      var sheet = Q.sheet(props.sheet);
      this._super(Q._extend(props,{
        w: props.cols * sheet.tilew,
        h: props.rows * sheet.tileh,
        tilew: sheet.tilew,
        tileh: sheet.tileh
      }));
      this.shown = [];
      this.domTiles = [];
    },

    setImage: function() { },
  
    setup: function(tiles,hide) {
      this.tiles = tiles;
      for(var y=0,height=tiles.length;y<height;y++) {
        this.domTiles.push([]);
        this.shown.push([]);
        for(var x=0,width=tiles[0].length;x<width;x++) {
          var domTile = this._addTile(tiles[y][x]);
          if(hide) { domTile.style.visibility = 'hidden'; }
          this.shown.push(hide ? false : true);
          this.domTiles[y].push(domTile);
        }
      }
    },

    _addTile: function(frame) {
      var p = this.p;
      var div = document.createElement('div');
      div.style.width = p.tilew + "px";
      div.style.height = p.tileh + "px";
      div.style.styleFloat = div.style.cssFloat = 'left';
      this._setTile(div,frame);
      this.dom.appendChild(div);
      return div;
    },

    _setTile: function(dom,frame) {
      var asset = Q.asset(this.sheet().asset);
      dom.style.backgroundImage = "url(" + asset.src + ")";
      dom.style.backgroundPosition = (-this.sheet().fx(frame)) +"px " + (-this.sheet().fy(frame)) + "px";
    },

    validTile: function(x,y) {
      return (y >= 0 && y < this.p.rows) && 
             (x >= 0 && x < this.p.cols);
    },

    get: function(x,y) { return this.validTile(x,y) ? 
                                this.tiles[y][x] : null; },

    getDom: function(x,y) { return this.validTile(x,y) ? 
                                   this.domTiles[y][x] : null; },
    set: function(x,y,frame) {
      if(!this.validTile(x,y)) { return; }
      this.tiles[y][x] = frame;
      var domTile = this.getDom(x,y);
      this._setFile(domTile,frame);
    },

    show: function(x,y) {
      if(!this.validTile(x,y)) { return; }
      if(this.shown[y][x]) { return; }
      this.getDom(x,y).style.visibility = 'visible';
      this.shown[y][x] = true;
    },

    hide: function(x,y) {
      if(!this.validTile(x,y)) { return; }
      if(!this.shown[y][x]) { return; }
      this.getDom(x,y).style.visibility = 'hidden';
      this.shown[y][x] = false;
    }
  }); 




};



/***/ }),

/***/ "./node_modules/quintus/extra/quintus_physics.js":
/*!*******************************************************!*\
  !*** ./node_modules/quintus/extra/quintus_physics.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*global Quintus:false */
/*global Box2D:false */

var Box2D = __webpack_require__(/*! box2dweb */ "./node_modules/box2dweb/box2d.js")

module.exports = function(Q) {
  var B2d = Q.B2d = {
      World: Box2D.Dynamics.b2World,
      Vec: Box2D.Common.Math.b2Vec2,
      BodyDef: Box2D.Dynamics.b2BodyDef,
      Body: Box2D.Dynamics.b2Body,
      FixtureDef: Box2D.Dynamics.b2FixtureDef,
      Fixture: Box2D.Dynamics.b2Fixture,
      PolygonShape: Box2D.Collision.Shapes.b2PolygonShape,
      CircleShape: Box2D.Collision.Shapes.b2CircleShape,
      Listener:  Box2D.Dynamics.b2ContactListener
    };

  var defOpts = Q.PhysicsDefaults = {
    gravityX: 0,
    gravityY: 9.8,
    scale: 30,
    velocityIterations: 8,
    positionIterations: 3
  };

  Q.component('world',{
    added: function() {
      this.opts = Q._extend({},defOpts);
      this._gravity = new B2d.Vec(this.opts.gravityX,
                                 this.opts.gravityY);
      this._world = new B2d.World(this._gravity, true);

      var physics = this,
          boundBegin = function(contact) { physics.beginContact(contact); },
          boundEnd = function(contact) { physics.endContact(contact); },
          boundPostSolve = function(contact,impulse) { physics.postSolve(contact,impulse); };
  
      this._listener = new B2d.Listener();
      this._listener.BeginContact = boundBegin;
      this._listener.EndContact = boundEnd;
      this._listener.PostSolve = boundPostSolve;
      this._world.SetContactListener(this._listener);
      
      this.col = {};
      this.scale = this.opts.scale;
      this.entity.on('step',this,'boxStep');
    },

    setCollisionData: function(contact,impulse) {
      var spriteA = contact.GetFixtureA().GetBody().GetUserData(),
          spriteB = contact.GetFixtureB().GetBody().GetUserData();
       
      this.col["a"] = spriteA;
      this.col["b"] = spriteB;
      this.col["impulse"] = impulse;
      this.col["sprite"] = null;
    },

    beginContact: function(contact) {
      this.setCollisionData(contact,null);
      this.col.a.trigger("contact",this.col.b);
      this.col.b.trigger("contact",this.col.a);
      this.entity.trigger("contact",this.col);
    },

    endContact: function(contact) {
      this.setCollisionData(contact,null);
      this.col.a.trigger("endContact",this.col.b);
      this.col.b.trigger("endContact",this.col.a);
      this.entity.trigger("endContact",this.col);
    },

    postSolve: function(contact, impulse) {
      this.setCollisionData(contact,impulse);
      this.col["sprite"] = this.col.b;
      this.col.a.trigger("impulse",this.col);
      this.col["sprite"] = this.col.a;
      this.col.b.trigger("impulse",this.col);
      this.entity.trigger("impulse",this.col);
    },

    createBody: function(def) {
      return this._world.CreateBody(def);
    },

    destroyBody: function(body) {
      return this._world.DestroyBody(body);
    },

    boxStep: function(dt) {
      if(dt > 1/20) { dt = 1/20; }
      this._world.Step(dt, 
                      this.opts.velocityIterations,
                      this.opts.positionIterations);
    }
  });

  var entityDefaults = Q.PhysicsEntityDefaults = {
    density: 1,
    friction: 1,
    restitution: 0.1
  };

  Q.component('physics',{
    added: function() {
      if(this.entity.stage) {
        this.inserted();
      } else {
        this.entity.on('inserted',this,'inserted');
      }
      this.entity.on('step',this,'step');
      this.entity.on('removed',this,'removed');
    },

    position: function(x,y) {
      var stage = this.entity.stage;
      this._body.SetAwake(true);
      this._body.SetPosition(new B2d.Vec(x / stage.world.scale,
                                         y / stage.world.scale));
    },

    angle: function(angle) {
      this._body.SetAngle(angle / 180 * Math.PI);
    },

    velocity: function(x,y) {
      var stage = this.entity.stage;
      this._body.SetAwake(true);
      this._body.SetLinearVelocity(new B2d.Vec(x / stage.world.scale,
                                               y / stage.world.scale));
    },
 
    inserted: function() {
      var entity = this.entity,
          stage = entity.stage,
          scale = stage.world.scale,
          p = entity.p,
          ops = entityDefaults,
          def = this._def = new B2d.BodyDef(),
          fixtureDef = this._fixture = new B2d.FixtureDef();
            
      def.position.x = p.x / scale;
      def.position.y = p.y / scale;
      def.type = p.type === 'static' ? 
                 B2d.Body.b2_staticBody :
                 B2d.Body.b2_dynamicBody;
      def.active = true;
      
      this._body = stage.world.createBody(def); 
      this._body.SetUserData(entity);
      fixtureDef.density = p.density || ops.density;
      fixtureDef.friction = p.friction || ops.friction;
      fixtureDef.restitution = p.restitution || ops.restitution;
      
      switch(p.shape) {
        case "block":
          fixtureDef.shape = new B2d.PolygonShape();
          fixtureDef.shape.SetAsBox(p.w/2/scale, p.h/2/scale);
          break;
        case "circle":
          fixtureDef.shape = new B2d.CircleShape(p.r/scale);
          break;
        case "polygon":
          fixtureDef.shape = new B2d.PolygonShape();
          var pointsObj = Q._map(p.points,function(pt) {
            return { x: pt[0] / scale, y: pt[1] / scale };
          });
          fixtureDef.shape.SetAsArray(pointsObj, p.points.length);
          break;
      }
      
      this._body.CreateFixture(fixtureDef);
      this._body._bbid = p.id;
    },

    removed: function() {
      var entity = this.entity,
          stage = entity.parent;
      stage.world.destroyBody(this._body);
    },

    step: function() {
      var p = this.entity.p,
          stage = this.entity.stage,
          pos = this._body.GetPosition(),
          angle = this._body.GetAngle();
      p.x = pos.x * stage.world.scale;
      p.y = pos.y * stage.world.scale;
      p.angle = angle / Math.PI * 180;
    }
  });


};


/***/ }),

/***/ "./node_modules/quintus/extra/quintus_svg.js":
/*!***************************************************!*\
  !*** ./node_modules/quintus/extra/quintus_svg.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */
/*global $:false */

module.exports = function(Q) {
  var SVG_NS ="http://www.w3.org/2000/svg"; 
  Q.setupSVG = function(id,options) {
    options = options || {};
    id = id || "quintus";
    Q.svg =Q._isString(id) ? document.getElementById(id) : id;
    
    if(!Q.svg) {
      Q.svg = document.createElementNS(SVG_NS,'svg');
      Q.svg.setAttribute('width',320);
      Q.svg.setAttribute('height',420);
      document.body.appendChild(Q.svg);
    }

    if(options.maximize) {
      var w = window.innerWidth-1;
      var h = window.innerHeight-10;
      Q.svg.setAttribute('width',w);
      Q.svg.setAttribute('height',h);
    }
	Q.width = Q.svg.getAttribute('width');
    Q.height = Q.svg.getAttribute('height');
    var parent=Q.svg.parentNode;
    var container=document.createElement('div');
    container.setAttribute('id',id+'_container');
    container.style.width=Q.width;
    container.style.height=Q.height;
    container.style.margin='0 auto';
    container.appendChild(Q.svg);
    parent.appendChild(container);
    Q.wrapper=container;
 
    setTimeout(function() { window.scrollTo(0,1); }, 0);
    window.addEventListener('orientationchange',function() {
      setTimeout(function() { window.scrollTo(0,1); }, 0);
    });
    return Q;
  };

  Q.Sprite.extend("SVGSprite",{
    init: function(props) {
      this._super(Q._defaults(props,{
        shape: 'block',
        color: 'black',
        angle: 0,
        active: true,
        cx: 0,
        cy: 0
      }));
      this.createShape();
      this.svg.sprite = this;
      this.rp = {};
      this.setTransform();
    },

    set: function(attr) {
      Q._each(attr,function(value,key) {
        this.svg.setAttribute(key,value);
      },this);
    },
    
    createShape: function() {
      var p = this.p;
      switch(p.shape) {
        case 'block':
          this.svg = document.createElementNS(SVG_NS,'rect');
          Q._extend(p,{ cx: p.w/2, cy: p.h/2 });
          this.set({ width: p.w, height: p.h });
          break;
        case 'circle':
          this.svg = document.createElementNS(SVG_NS,'circle');
          this.set({ r: p.r, cx: 0, cy: 0 });
          break;
        case 'polygon':
          this.svg = document.createElementNS(SVG_NS,'polygon');
          var pts = Q._map(p.points, 
                          function(pt) { 
                            return pt[0] + "," + pt[1];
                          }).join(" ");
          this.set({ points: pts });
          break;
          
      }
      this.set({ fill: p.color });
      if(p.outline) {
        this.set({
          stroke: p.outline,
          "stroke-width": p.outlineWidth || 1
        });
      }
    },

    setTransform: function() {
      var p = this.p;
      var rp = this.rp;
      if(rp.x !== p.x || 
         rp.y !== p.y || 
         rp.angle !== p.angle ) {
        var transform = "translate(" + (p.x - p.cx) + "," +
                                       (p.y - p.cy) + ") " +
                        "rotate(" + p.angle + 
                                "," + p.cx +
                                "," + p.cy +
                                ")";
        this.svg.setAttribute('transform',transform);
        rp.angle = p.angle;
        rp.x = p.x;
        rp.y = p.y;
      } 
    },
    render: function(ctx) {
    	
    	this.trigger('predraw',ctx);
    	this.trigger('beforedraw',ctx);
    	this.draw(ctx);
    	this.trigger('beforedraw',ctx);
    },
    draw: function(ctx) {
    },

    step: function(dt) {
      this.trigger('step',dt);
      this.setTransform();
    }
  });


  Q.Stage.extend("SVGStage",{
    init: function(scene) {
      this.svg = document.createElementNS(SVG_NS,'svg');
      this.svg.setAttribute('width',Q.width);
      this.svg.setAttribute('height',Q.height);
      Q.svg.appendChild(this.svg);
      
      this.viewBox = { x: 0, y: 0, w: Q.width, h: Q.height };
      this._super(scene);
    },
    remove:function(itm){
	  if(itm.svg) { this.svg.removeChild(itm.svg); }
	  return this._super(itm);
    },
    insert: function(itm) {
      if(itm.svg) { this.svg.appendChild(itm.svg); }
      return this._super(itm);
    },

    destroy: function() {
      Q.svg.removeChild(this.svg);
      this._super();
    },

    viewport: function(w,h) {
      this.viewBox.w = w;
      this.viewBox.h = h;
      if(this.viewBox.cx || this.viewBox.cy) {
        this.centerOn(this.viewBox.cx,
                      this.viewBox.cy);
      } else {
        this.setViewBox();
      }
    },

    centerOn: function(x,y) {
      this.viewBox.cx = x;
      this.viewBox.cy = y;
      this.viewBox.x = x - this.viewBox.w/2;
      this.viewBox.y = y - this.viewBox.h/2;
      this.setViewBox();
    },

    setViewBox: function() {
      this.svg.setAttribute('viewBox',
                            this.viewBox.x + " " + this.viewBox.y + " " +
                            this.viewBox.w + " " + this.viewBox.h);
    },

    browserToWorld: function(x,y) {
      var m = this.svg.getScreenCTM();
      var p = this.svg.createSVGPoint();
      p.x = x; p.y = y;
      return p.matrixTransform(m.inverse());
    }
  });

  Q.svgOnly = function() {
    Q.Stage = Q.SVGStage;
    Q.setup = Q.setupSVG;
    Q.Sprite = Q.SVGSprite;
    return Q;
  };


};



/***/ }),

/***/ "./node_modules/quintus/index.js":
/*!***************************************!*\
  !*** ./node_modules/quintus/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/quintus */ "./node_modules/quintus/lib/quintus.js")

/***/ }),

/***/ "./node_modules/quintus/lib/quintus.js":
/*!*********************************************!*\
  !*** ./node_modules/quintus/lib/quintus.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//     Quintus Game Engine
//     (c) 2012 Pascal Rettig, Cykod LLC
//     Quintus may be freely distributed under the MIT license or GPLv2 License.
//     For all details and documentation:
//     http://html5quintus.com
//
/**
Quintus HTML5 Game Engine 

The code in `quintus.js` defines the base `Quintus()` method
which create an instance of the engine. The basic engine doesn't
do a whole lot - it provides an architecture for extension, a
game loop, and a method for creating or binding to an exsiting
canvas context. The engine has dependencies on Underscore.js and jQuery,
although the jQuery dependency will be removed in the future.

Most of the game-specific functionality is in the 
various other modules:

* `quintus_input.js` - `Input` module, which allows for user input via keyboard and touchscreen
* `quintus_sprites.js` - `Sprites` module, which defines a basic `Q.Sprite` class along with spritesheet support in `Q.SpriteSheet`.
* `quintus_scenes.js` - `Scenes` module. It defines the `Q.Scene` class, which allows creation of reusable scenes, and the `Q.Stage` class, which handles managing a number of sprites at once.
* `quintus_anim.js` - `Anim` module, which adds in support for animations on sprites along with a `viewport` component to follow the player around and a `Q.Repeater` class that can create a repeating, scrolling background.

@module Quintus
*/

/**
 Top-level Quintus engine factory wrapper, 
 creates new instances of the engine by calling:

      var Q = Quintus({  ...  });

 Any initial setup methods also all return the `Q` object, allowing any initial 
 setup calls to be chained together.

      var Q = Quintus()
              .include("Input, Sprites, Scenes")
              .setup('quintus', { maximize: true })
              .controls();
                       
 `Q` is used internally as the object name, and is used in most of the examples, 
 but multiple instances of the engine on the same page can have different names.

     var Game1 = Quintus(), Game2 = Quintus();

@class Quintus
**/

module.exports = Quintus;

Quintus['2D'] = __webpack_require__(/*! ./quintus_2d */ "./node_modules/quintus/lib/quintus_2d.js")
Quintus.Anim = __webpack_require__(/*! ./quintus_anim */ "./node_modules/quintus/lib/quintus_anim.js")
Quintus.Audio = __webpack_require__(/*! ./quintus_audio */ "./node_modules/quintus/lib/quintus_audio.js")
Quintus.Input = __webpack_require__(/*! ./quintus_input */ "./node_modules/quintus/lib/quintus_input.js")
Quintus.Scenes = __webpack_require__(/*! ./quintus_scenes */ "./node_modules/quintus/lib/quintus_scenes.js")
Quintus.Sprites = __webpack_require__(/*! ./quintus_sprites */ "./node_modules/quintus/lib/quintus_sprites.js")
Quintus.TMX = __webpack_require__(/*! ./quintus_tmx */ "./node_modules/quintus/lib/quintus_tmx.js")
Quintus.Touch = __webpack_require__(/*! ./quintus_touch */ "./node_modules/quintus/lib/quintus_touch.js")
Quintus.UI = __webpack_require__(/*! ./quintus_ui */ "./node_modules/quintus/lib/quintus_ui.js")
Quintus.DOM = __webpack_require__(/*! ../extra/quintus_dom */ "./node_modules/quintus/extra/quintus_dom.js")
Quintus.Physics = __webpack_require__(/*! ../extra/quintus_physics */ "./node_modules/quintus/extra/quintus_physics.js")
Quintus.SVG = __webpack_require__(/*! ../extra/quintus_svg */ "./node_modules/quintus/extra/quintus_svg.js")

function Quintus(opts) {

  /**
   A la jQuery - the returned `Q` object is actually
   a method that calls `Q.select`. `Q.select` doesn't do anything
   initially, but can be overridden by a module to allow
   selection of game objects. The `Scenes` module adds in 
   the select method which selects from the default stage.
  
       var Q = Quintus().include("Sprites, Scenes");
       ... Game Code ...
       // Set the angry property on all Enemy1 class objects to true
       Q("Enemy1").p({ angry: true });
    
    @method Q
    @for Quintus
  */  
  var Q = function(selector,scope,options) {   
    return Q.select(selector,scope,options);
  };

  /**
   Default no-op select method. Replaced with the Quintus.Scene class

   @method Q.select
   @for Quintus
  */
  Q.select = function() { /* No-op */ };

  /**
   Default no-op select method. Replaced with the Quintus.Scene class


   Syntax for including other modules into quintus, can accept a comma-separated
   list of strings, an array of strings, or an array of actual objects. Example:
  
       Q.include("Input, Sprites, Scenes")

   @method Q.include
   @param {String} mod - A comma separated list of module names
   @return {Quintus} returns Quintus instance for chaining.
   @for Quintus
  */
  Q.modules = {}

  Q.include = function(mod) {
    Q._each(Q._normalizeArg(mod),function(name) {
      var m = Quintus[name] || name;
      if(!Q._isFunction(m)) { throw "Invalid Module:" + name; }
      Q.modules[name] = m;
      m(Q)
    });
    return Q;
  };

  /**
   An internal utility method (utility methods are prefixed with underscores)
   It's used to take a string of comma separated names and turn it into an `Array`
   of names. If an array of names is passed in, it's left as is. Example usage:
  
       Q._normalizeArg("Sprites, Scenes, Physics   ");
       // returns [ "Sprites", "Scenes", "Physics" ]
  
   Used by `Q.include` and `Q.Sprite.add` to add modules and components, respectively.

   Most of these utility methods are a subset of Underscore.js,
   Most are pulled directly from underscore and some are
   occasionally optimized for speed and memory usage in lieu of flexibility.

   Underscore.js is (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.

   Underscore is freely distributable under the MIT license.

   http://underscorejs.org

   @method Q._normalizeArg
   @param {String or Array} arg - Either a comma separated string or an array
   @return {Array} array of normalized names
   @for Quintus
  */
  Q._normalizeArg = function(arg) {
    if(Q._isString(arg)) {
      arg = arg.replace(/\s+/g,'').split(",");
    }
    if(!Q._isArray(arg)) {
      arg = [ arg ];
    }
    return arg;
  };


  /**
   Extends a destination object with a source object (modifies destination object)

   @method Q._extend
   @param {Object} dest - destination object
   @param {Object} source - source object
   @return {Object} returns the dest object
   @for Quintus
  */
  Q._extend = function(dest,source) {
    if(!source) { return dest; }
    for (var prop in source) {
      dest[prop] = source[prop];
    }
    return dest;
  };

  /**
   Return a shallow copy of an object. Sub-objects (and sub-arrays) are not cloned. (uses extend internally)

   @method Q._clone
   @param {Object} obj - object to clone
   @return {Object} cloned object 
   @for Quintus
  */
  Q._clone = function(obj) {
    return Q._extend({},obj);
  };

   /**
    Method that adds default properties onto an object only if the key on dest is undefined

   @method Q._defaults
   @param {Object} dest - destination object
   @param {Object} source - source object
   @return {Object} returns the dest object
   @for Quintus
  */
  Q._defaults = function(dest,source) {
    if(!source) { return dest; }
    for (var prop in source) {
      if(dest[prop] === void 0) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  };

  /**
   Shortcut for hasOwnProperty

   @method Q._defaults
   @param {Object} object - destination object
   @param {String} key - key to check for
   @return {Boolean} 
   @for Quintus
  */ 
  Q._has = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

   /**
   Check if something is a string

   NOTE: this fails for non-primitives

   @method Q._isString
   @param {Var} obj - object to check 
   @return {Boolean} 
   @for Quintus
  */
  Q._isString = function(obj) {
    return typeof obj === "string";
  };

  /**
   Check if something is a number

   @method Q._isNumber
   @param {Var} obj - object to check 
   @return {Boolean} 
   @for Quintus
  */
  Q._isNumber = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Number]';
  };

  /**
   Check if something is a function

   @method Q._isFunction
   @param {Var} obj - object to check 
   @return {Boolean} 
   @for Quintus
  */
  Q._isFunction = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  };

   /**
   Check if something is an Object

   @method Q._isObject
   @param {Var} obj - object to check 
   @return {Boolean} 
   @for Quintus
  */ 
  Q._isObject = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  };

  /**
   Check if something is an Array

   @method Q._isArray
   @param {Var} obj - object to check 
   @return {Boolean} 
   @for Quintus
  */ 
  Q._isArray = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  /**
   Check if something is undefined

   @method Q._isUndefined
   @param {Var} obj - object to check 
   @return {Boolean} 
   @for Quintus
  */ 
  Q._isUndefined = function(obj) {
    return obj === void 0;
  };

  /**
   Removes a property from an object and returns it if it exists

   @method Q._popProperty
   @param {Object} obj 
   @param {String} property - property to pop off the object
   @return {Var} popped property
   @for Quintus
  */ 
  Q._popProperty = function(obj,property) {
    var val = obj[property];
    delete obj[property];
    return val;
  };

  /**
   Basic iteration method. This can often be a performance
   handicap when the callback iterator is created inline,
   as this leads to lots of functions that need to be GC'd.
   Better is to define the iterator as a private method so.
   Uses the built in `forEach` method

   @method Q._each
   @param {Array or Object} obj 
   @param {Function iterator function, `this` is used for each object
   @for Quintus
  */ 
  Q._each = function(obj,iterator,context) {
    if (obj == null) { return; }
    if (obj.forEach) {
      obj.forEach(iterator,context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        iterator.call(context, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        iterator.call(context, obj[key], key, obj);
      }
    }
  };

  /**
   Invoke the named property on each element of the array

   @method Q._invoke
   @param {Array} arr 
   @param {String} property - property to invoke
   @param {Var} [arg1]
   @param {Var} [arg2]
   @for Quintus
  */ 
  Q._invoke = function(arr,property,arg1,arg2) {
    if (arr == null) { return; }
    for (var i = 0, l = arr.length; i < l; i++) {
      arr[i][property](arg1,arg2);
    }
  };



  /**
   Basic detection method, returns the first instance where the
   iterator returns truthy. 

   @method Q._detect
   @param {Array or Object} obj
   @param {Function} iterator 
   @param {Object} context
   @param {Var} [arg1]
   @param {Var} [arg2]
   @returns {Var} first truthy value
   @for Quintus
  */
  Q._detect = function(obj,iterator,context,arg1,arg2) {
    var result;
    if (obj == null) { return; }
    if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        result = iterator.call(context, obj[i], i, arg1,arg2);
        if(result) { return result; }
      }
      return false;
    } else {
      for (var key in obj) {
        result = iterator.call(context, obj[key], key, arg1,arg2);
        if(result) { return result; }
      }
      return false;
    }
  };

  /**
   Returns a new Array with entries set to the return value of the iterator.

   @method Q._detect
   @param {Array or Object} obj
   @param {Function} iterator 
   @param {Object} context
   @returns {Array}
   @for Quintus
  */
  Q._map = function(obj, iterator, context) {
    var results = [];
    if (obj == null) { return results; }
    if (obj.map) { return obj.map(iterator, context); }
    Q._each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) { results.length = obj.length; }
    return results;
  };

  /**
   Returns a sorted copy of unique array elements with null removed

   @method Q._uniq
   @param {Array} arr
   @returns {Array} uniq'd sorted copy of array
   @for Quintus
  */
  Q._uniq = function(arr) {
    arr = arr.slice().sort();

    var output = [];

    var last = null;
    for(var i=0;i<arr.length;i++) {
      if(arr[i] !== void 0 && last !== arr[i]) {
        output.push(arr[i]);
      }
      last = arr[i];
    }
    return output;
  };

  /**
   Returns a new array with the same entries as the source but in a random order.

   @method Q._shuffle
   @param {Array} arr
   @returns {Array} copy or arr in shuffled order
   @for Quintus
  */
  Q._shuffle = function(obj) {
    var shuffled = [], rand;
    Q._each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };


  /**
   Return an object's keys as a new Array

   @method Q._keys
   @param {Object} obj
   @returns {Array}
   @for Quintus
  */
  Q._keys = Object.keys || function(obj) {
    if(Q._isObject(obj)) { throw new TypeError('Invalid object'); }
    var keys = [];
    for (var key in obj) { if (Q._has(obj, key)) { keys[keys.length] = key; } } 
    return keys;
  };


  /**
   Return an array in the range from start to stop 

   @method Q._range
   @param {Integer} start
   @param {Integer} stop
   @param {Integer} [step]
   @returns {Array}
   @for Quintus
  */
  Q._range = function(start,stop,step) {
    step = step || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;

  };

  var idIndex = 0;
  /**
   Return a new unique identifier

   @method Q._uniqueId
   @returns {Integer}
   @for Quintus
  */
  Q._uniqueId = function() {
    return idIndex++;
  };



  /**
   Options
  
   Default engine options defining the paths 
   where images, audio and other data files should be found
   relative to the base HTML file. As well as a couple of other
   options.
  
   These can be overriden by passing in options to the `Quintus()` 
   factory method, for example:
  
       // Override the imagePath to default to /assets/images/
       var Q = Quintus({ imagePath: "/assets/images/" });
  
   If you follow the default convention from the examples, however,
   you should be able to call `Quintus()` without any options.

   Default Options

       {
        imagePath: "images/",
        audioPath: "audio/",
        dataPath:  "data/",
        audioSupported: [ 'mp3','ogg' ],
        sound: true,
        frameTimeLimit: 100
       }

   @property Q.options
   @type Object
   @for Quintus
  */
  Q.options = {
    imagePath: "images/",
    audioPath: "audio/",
    dataPath:  "data/",
    audioSupported: [ 'mp3','ogg' ],
    sound: true,
    frameTimeLimit: 100,
    autoFocus: true
  };
  if(opts) { Q._extend(Q.options,opts); }


  /**
   Game Loop support

   By default the engine doesn't start a game loop until you actually tell it to.
   Usually the loop is started the first time you call `Q.stageScene`, but if you 
   aren't using the `Scenes` module you can explicitly start the game loop yourself
   and control **exactly** what the engine does each cycle. For example:
  
       var Q = Quintus().setup();
  
       var ball = new Q.Sprite({ .. });
  
       Q.gameLoop(function(dt) {
         Q.clear(); 
         ball.step(dt);
         ball.draw(Q.ctx);
       });
  
   The callback will be called with fraction of a second that has elapsed since 
   the last call to the loop method.

   @method Q.gameLoop
   @param {Function} callback
   @for Quintus
  */
  Q.gameLoop = function(callback) {
    Q.lastGameLoopFrame = new Date().getTime();

    // Short circuit the loop check in case multiple scenes
    // are staged immediately
    Q.loop = true; 

    // Keep track of the frame we are on (so that animations can be synced
    // to the next frame)
    Q._loopFrame = 0;

    // Wrap the callback to save it and standardize the passed
    // in time. 
    Q.gameLoopCallbackWrapper = function() {
      var now = new Date().getTime();
      Q._loopFrame++;
      Q.loop = window.requestAnimationFrame(Q.gameLoopCallbackWrapper);
      var dt = now - Q.lastGameLoopFrame;
      /* Prevent fast-forwarding by limiting the length of a single frame. */
      if(dt > Q.options.frameTimeLimit) { dt = Q.options.frameTimeLimit; }
      callback.apply(Q,[dt / 1000]);  
      Q.lastGameLoopFrame = now;
    };

    window.requestAnimationFrame(Q.gameLoopCallbackWrapper);
    return Q;
  };

  /**
   Pause the entire game by canceling the requestAnimationFrame call. If you use setTimeout or
   setInterval in your game, those will, of course, keep on rolling...

    @method Q.pauseGame
    @for Quintus
  */
  Q.pauseGame = function() {
    if(Q.loop) {
      window.cancelAnimationFrame(Q.loop); 
    }
    Q.loop = null;
  };

  /**
   Unpause the game by restarting the requestAnimationFrame-based loop.
   Pause the entire game by canceling the requestAnimationFrame call. If you use setTimeout or
   setInterval in your game, those will, of course, keep on rolling...

    @method Q.pauseGame
    @for Quintus
  */
  Q.unpauseGame = function() {
    if(!Q.loop) {
      Q.lastGameLoopFrame = new Date().getTime();
      Q.loop = window.requestAnimationFrame(Q.gameLoopCallbackWrapper);
    }
  };


  /**
   The base Class object
  
   Quintus uses the Simple JavaScript inheritance Class object, created by
   John Resig and described on his blog: 
  
   [http://ejohn.org/blog/simple-javascript-inheritance/](http://ejohn.org/blog/simple-javascript-inheritance/)
  
   The class is used wholesale, with the only differences being that instead
   of appearing in a top-level namespace, the `Class` object is available as 
   `Q.Class` and a second argument on the `extend` method allows for adding
   class level methods and the class name is passed in a parameter for introspection
   purposes.
  
   Classes can be created by calling `Q.Class.extend(name,{ .. })`, although most of the time
   you'll want to use one of the derivitive classes, `Q.Evented` or `Q.GameObject` which
   have a little bit of functionality built-in. `Q.Evented` adds event binding and 
   triggering support and `Q.GameObject` adds support for components and a destroy method.
  
   The main things Q.Class get you are easy inheritance, a constructor method called `init()`,
   dynamic addition of a this._super method when a method is overloaded (be careful with 
   this as it adds some overhead to method calls.) Calls to `instanceof` also all 
   work as you'd hope.
  
   By convention, classes should be added onto to the `Q` object and capitalized, so if 
   you wanted to create a new class for your game, you'd write:
  
       Q.Class.extend("MyClass",{ ... });
  
   Examples:
  
       Q.Class.extend("Bird",{ 
         init: function(name) { this.name = name; },
         speak: function() { console.log(this.name); },
         fly: function()   { console.log("Flying"); }
       });
  
       Q.Bird.extend("Penguin",{
         speak: function() { console.log(this.name + " the penguin"); },
         fly: function()   { console.log("Can't fly, sorry..."); }
       });
  
       var randomBird = new Q.Bird("Frank"),
           pengy      = new Q.Penguin("Pengy");
  
       randomBird.fly(); // Logs "Flying"
       pengy.fly();      // Logs "Can't fly,sorry..."
  
       randomBird.speak(); // Logs "Frank"
       pengy.speak();      // Logs "Pengy the penguin"
  
       console.log(randomBird instanceof Q.Bird);    // true 
       console.log(randomBird instanceof Q.Penguin); // false
       console.log(pengy instanceof Q.Bird);         // true 
       console.log(pengy instanceof Q.Penguin);      // true 

  Simple JavaScript Inheritance
  By John Resig http://ejohn.org/
  MIT Licensed.
  
  Inspired by base2 and Prototype
  @class Q.Class
  @for Quintus
  */
  (function(){
    var initializing = false, 
        fnTest = /xyz/.test(function(){ var xyz;}) ? /\b_super\b/ : /.*/;
    /** The base Class implementation (does nothing) 
     *
     * @constructor
     * @for Q.Class
     */
    Q.Class = function(){};

    /**
     * See if a object is a specific class
     *
     * @method isA
     * @param {String} className - class to check against
     */
    Q.Class.prototype.isA = function(className) {
      return this.className === className;
    };
    
    /**
     * Create a new Class that inherits from this class 
     *
     * @method extend
     * @param {String} className
     * @param {Object} properties - hash of properties (init will be the constructor)
     * @param {Object} [classMethods] - optional class methods to add to the class
     */
    Q.Class.extend = function(className, prop, classMethods) {
      /* No name, don't add onto Q */
      if(!Q._isString(className)) {
        classMethods = prop;
        prop = className;
        className = null;
      }
      var _super = this.prototype,
          ThisClass = this;
      
      /* Instantiate a base class (but only create the instance, */
      /* don't run the init constructor) */
      initializing = true;
      var prototype = new ThisClass();
      initializing = false;

      function _superFactory(name,fn) {
        return function() {
          var tmp = this._super;

          /* Add a new ._super() method that is the same method */
          /* but on the super-class */
          this._super = _super[name];

          /* The method only need to be bound temporarily, so we */
          /* remove it when we're done executing */
          var ret = fn.apply(this, arguments);        
          this._super = tmp;

          return ret;
        };
      }

      /* Copy the properties over onto the new prototype */
      for (var name in prop) {
        /* Check if we're overwriting an existing function */
        prototype[name] = typeof prop[name] === "function" && 
          typeof _super[name] === "function" && 
            fnTest.test(prop[name]) ? 
              _superFactory(name,prop[name]) : 
              prop[name];
      }
      
      /* The dummy class constructor */
      function Class() {
        /* All construction is actually done in the init method */
        if ( !initializing && this.init ) {
          this.init.apply(this, arguments);
        }
      }
      
      /* Populate our constructed prototype object */
      Class.prototype = prototype;
      
      /* Enforce the constructor to be what we expect */
      Class.prototype.constructor = Class;
      /* And make this class extendable */
      Class.extend = Q.Class.extend;
      
      /* If there are class-level Methods, add them to the class */
      if(classMethods) {
        Q._extend(Class,classMethods);
      }

      if(className) { 
        /* Save the class onto Q */
        Q[className] = Class;

        /* Let the class know its name */
        Class.prototype.className = className;
        Class.className = className;
      }
      
      return Class;
    };
  }());
    

  // Event Handling
  // ==============

  /**
   The `Q.Evented` class adds event handling onto the base `Q.Class` 
   class. Q.Evented objects can trigger events and other objects can
   bind to those events.

   @class Q.Evented
   @extends Q.Class
   @for Quintus
  */
  Q.Class.extend("Evented",{

    /**
    Binds a callback to an event on this object. If you provide a
    `target` object, that object will add this event to it's list of
    binds, allowing it to automatically remove it when it is destroyed.

    @method on
    @for Q.Evented
    @param {String} event - name or comma separated list of events
    @param {Object} [target] - optional context for callback, defaults to the Evented
    @param {Function} [callback] - callback (optional - defaults to name of event on context
    */
    on: function(event,target,callback) {
      if(Q._isArray(event) || event.indexOf(",") !== -1) {
        event = Q._normalizeArg(event);
        for(var i=0;i<event.length;i++) {
          this.on(event[i],target,callback);
        }
        return;
      }

      // Handle the case where there is no target provided,
      // swapping the target and callback parameters.
      if(!callback) {
        callback = target;
        target = null;
      }

      // If there's still no callback, default to the event name
      if(!callback) {
        callback = event;
      }
      // Handle case for callback that is a string, this will
      // pull the callback from the target object or from this
      // object.
      if(Q._isString(callback)) {
        callback = (target || this)[callback];
      }

      // To keep `Q.Evented` objects from needing a constructor,
      // the `listeners` object is created on the fly as needed.
      // `listeners` keeps a list of callbacks indexed by event name
      // for quick lookup. 
      this.listeners = this.listeners || {};
      this.listeners[event] = this.listeners[event] || [];
      this.listeners[event].push([ target || this, callback]);

      // With a provided target, the target object keeps track of
      // the events it is bound to, which allows for automatic 
      // unbinding on destroy.
      if(target) {
        if(!target.binds) { target.binds = []; }
        target.binds.push([this,event,callback]);
      }
    },

    /**
     Triggers an event, passing in some optional additional data about
     the event. 

    @method trigger
    @for Q.Evented
    @param {String} event - name of event
    @param {Object} [data] - optional data to pass to the callback
    */
    trigger: function(event,data) {
      // First make sure there are any listeners, then check for any listeners
      // on this specific event, if not, early out.
      if(this.listeners && this.listeners[event]) {
        // Call each listener in the context of either the target passed into
        // `on` or the object itself.
        for(var i=0,len = this.listeners[event].length;i<len;i++) {
          var listener = this.listeners[event][i];
          listener[1].call(listener[0],data);
        }
      }
    },
    
    /**
      Unbinds an event. Can be called with 1, 2, or 3 parameters, each 
       of which unbinds a more specific listener.

    @method off
    @for Q.Evented
    @param {String} event - name of event
    @param {Object} [target] - optionally limit to a specific target
    @param {Function} [callback] - optionally limit to one specific callback
    */
    off: function(event,target,callback) {
      // Without a target, remove all teh listeners.
      if(!target) {
        if(this.listeners[event]) {
          delete this.listeners[event];
        }
      } else {
        // If the callback is a string, find a method of the
        // same name on the target.
        if(Q._isString(callback) && target[callback]) {
          callback = target[callback];
        }
        var l = this.listeners && this.listeners[event];
        if(l) {
          // Loop from the end to the beginning, which allows us
          // to remove elements without having to affect the loop.
          for(var i = l.length-1;i>=0;i--) {
            if(l[i][0] === target) {
              if(!callback || callback === l[i][1]) {
                this.listeners[event].splice(i,1);
              }
            }
          }
        }
      }
    },

    /** 
     `debind` is called to remove any listeners an object had
     on other objects. The most common case is when an object is
     destroyed you'll want all the event listeners to be removed
     for you.

    @method debind
    @for Q.Evented
    */
    debind: function() {
       if(this.binds) {
         for(var i=0,len=this.binds.length;i<len;i++) {
           var boundEvent = this.binds[i],
               source = boundEvent[0],
               event = boundEvent[1];
           source.off(event,this);
         }
       }
     }

   });


   


  /**
   The master list of registered components, indexed in an object by name.

   @property Q.components
   @type Object
   @for Quintus
  */
  Q.components = {};

  /**
   Components
   ==============
  
   Components are self-contained pieces of functionality that can be added onto and removed
   from objects. The allow for a more dynamic functionality tree than using inheritance (i.e.
   by favoring composition over inheritance) and are added and removed on the fly at runtime.
   (yes, I know everything in JS is at runtime, but you know what I mean, geez)
  
   Combining components with events makes it easy to create reusable pieces of
   functionality that can be decoupled from each other.

   The base class for components. These are usually not derived directly but are instead
   created by calling `Q.register` to register a new component given a set of methods the 
   component supports. Components are created automatically when they are added to a 
   `Q.GameObject` with the `add` method.
  
   Many components also define an `added` method, which is called automatically by the
   `init` constructor after a component has been added to an object. This is a good time
   to add event listeners on the object.

   @class Q.Component
   @events Q.Evented
   @for Quintus
  */
  Q.Evented.extend("Component",{

    // Components are created when they are added onto a `Q.GameObject` entity. The entity
    // is directly extended with any methods inside of an `extend` property and then the 
    // component itself is added onto the entity as well. 
    init: function(entity) {
      this.entity = entity;
      if(this.extend) { Q._extend(entity,this.extend);   }
      entity[this.name] = this;

      entity.activeComponents.push(this.componentName);

      if(entity.stage && entity.stage.addToList) {
        entity.stage.addToList(this.componentName,entity);
      }
      if(this.added) { this.added(); }    
    },

    /**
     `destroy` is called automatically when a component is removed from an entity. It is 
     not called, however, when an entity is destroyed (for performance reasons).
     
     It's job is to remove any methods that were added with `extend` and then remove and
     debind itself from the entity. It will also call `destroyed` if the component has
     a method by that name.

     @method destroy
     @for Q.Component
    */
    destroy: function() {
      if(this.extend) {
        var extensions = Q._keys(this.extend);
        for(var i=0,len=extensions.length;i<len;i++) {
          delete this.entity[extensions[i]];
        }
      }
      delete this.entity[this.name];
      var idx = this.entity.activeComponents.indexOf(this.componentName);
      if(idx !== -1) { 
        this.entity.activeComponents.splice(idx,1);

        if(this.entity.stage && this.entity.stage.addToList) {
          this.entity.stage.addToLists(this.componentName,this.entity);
        }
      }
      this.debind();
      if(this.destroyed) { this.destroyed(); }
    }
  });

  /**
   
    Game Objects
    ============

   This is the base class most Quintus objects are derived from, it extends 
   `Q.Evented` and adds component support to an object, allowing components to
   be added and removed from an object. It also defines a destroyed method
   which will debind the object, remove it from it's parent (usually a scene)
   if it has one, and trigger a destroyed event.

   @class Q.GameObject
   @extends Q.Evented
   @for Quintus
  */
  Q.Evented.extend("GameObject",{

    /**
     Simple check to see if a component already exists
     on an object by searching for a property of the same name.

     @method has
     @for Q.GameObject
     @param {String} component - name of component to test against
     @returns {Boolean}
    */
    has: function(component) {
      return this[component] ? true : false; 
    },

    /**
     Adds one or more components to an object. Accepts either 
     a comma separated string or an array of strings that map
     to component names.
    
     Instantiates a new component object of the correct type
     (if the component exists) and then triggers an addComponent
     event.

     For example:

         this.add("2d, aiBounce")
    
     Returns the object to allow chaining.

     @for Q.GameObject
     @method add
     @param {String} components - comma separated list of components to add
     @return {Object} returns this for chaining purposes
    */
    add: function(components) {
      components = Q._normalizeArg(components);
      if(!this.activeComponents) { this.activeComponents = []; }
      for(var i=0,len=components.length;i<len;i++) {
        var name = components[i],
            Comp = Q.components[name];
        if(!this.has(name) && Comp) { 
          var c = new Comp(this); 
          this.trigger('addComponent',c);
        }
      }
      return this;
    }, 

    /**
     Removes one or more components from an object. Accepts the
     same style of parameters as `add`. Triggers a delComponent event
     and and calls destroy on the component.
    
     Returns the element to allow chaining.

     @for Q.GameObject
     @method del
     @param {String} components - comma separated list of components to remove
     @return {Object} returns this for chaining purposes
    */
    del: function(components) {
      components = Q._normalizeArg(components);
      for(var i=0,len=components.length;i<len;i++) {
        var name = components[i];
        if(name && this.has(name)) { 
          this.trigger('delComponent',this[name]);
          this[name].destroy(); 
        }
      }
      return this;
    },

    /**
     Destroys the object by calling debind and removing the
     object from it's parent. Will trigger a destroyed event
     callback.

     @for Q.GameObject
     @method del
     @param {String} components - comma separated list of components to remove
     @return {Object} returns this for chaining purposes
    */
    destroy: function() {
      if(this.isDestroyed) { return; }
      this.trigger('destroyed');
      this.debind();
      if(this.stage && this.stage.remove) {
        this.stage.remove(this);
      }
      this.isDestroyed = true;
      if(this.destroyed) { this.destroyed(); }
    }
  });

  /**
   Registers a component with the engine, making it available to `Q.GameObject`'s 
   This creates a new descendent class of `Q.Component` with new methods added in.

   @for Quintus
   @method Q.component
   @param {String} name - component name
   @param {Object} metehods - hash of methods for the component
  */
  Q.component = function(name,methods) {
    if(!methods) { return Q.components[name]; }
    methods.name = name;
    methods.componentName = "." + name;
    return (Q.components[name] = Q.Component.extend(name + "Component",methods));
  };


  /**
   Generic Game State object that can be used to
   track of the current state of the Game, for example when the player starts
   a new game you might want to keep track of their score and remaining lives:
  
       Q.reset({ score: 0, lives: 2 });
  
   Then in your game might want to add to the score:
       
        Q.state.inc("score",50);
  
   In your hud, you can listen for change events on the state to update your 
   display:
  
        Q.state.on("change.score",function() { .. update the score display .. });
  
  @class Q.GameState
  @extends Q.GameObject
  */
  Q.GameObject.extend("GameState",{
    init: function(p) {
      this.p = Q._extend({},p);
      this.listeners = {};
    },


    /**
     Resets the state to value p, triggers a reset event.

     @method reset
     @param {Object} p - properties to reinitialize to
    */
    reset: function(p) { this.init(p); this.trigger("reset"); },
    
    // Internal helper method to set an individual property
    _triggerProperty: function(value,key) {
      if(this.p[key] !== value) {
        this.p[key] = value;
        this.trigger("change." + key,value);
      }
    },

    /**
     Set one or more properties, trigger events on those
     properties changing.

     @example
        Q.state.set({ lives: 5, hitPoints: 4 });
        // Triggers 3 events: change.lives, change.hitPoints, change


        Q.state.set("lives",5);
        // Triggers 2 events: change.lives, change

    @method set
    @param {Object or String} properties - hash of properties to set, or property name
    @param {Var} [value] - if setting 1 property, the value of that property
    */
    set: function(properties,value) {
      if(Q._isObject(properties)) {
        Q._each(properties,this._triggerProperty,this);
      } else {
        this._triggerProperty(value,properties);
      }
      this.trigger("change");
    },

    /**
     Increment an individual property by amount, uses set internally

     @method inc
     @param {String} property
     @param {Integer} amount - amount to increment by
    */
    inc: function(property,amount) {
      this.set(property,this.get(property) + amount);
    },

    /**

     Increment an individual property by amount, uses set internally

     @method dec
     @param {String} property
     @param {Integer} amount - amount to decrement by
    */
    dec: function(property,amount) {
      this.set(property,this.get(property) - amount);
    },

    /**

     Return an individual property

     @method get
     @param {String} property 
     @return {Var} value of the property
    */
    get: function(property) {
      return this.p[property];
    }
  });

  /**
   Top-level `Q.GameState` instance, generally used for global state in the game

   @for Quintus
   @property Q.state
   @type Q.GameState
  */
  Q.state = new Q.GameState();

  /** 
   Reset the global game state

   @for Quintus
   @method Q.reset
  */
  Q.reset = function() { Q.state.reset(); };




  Q.touchDevice = ('ontouchstart' in document);

  /**
  
   Canvas Methods
   
   The `setup` and `clear` method are the only two canvas-specific methods in 
   the core of Quintus. `imageData`  also uses canvas but it can be used in
   any type of game.

   Setup will either create a new canvas element and append it
   to the body of the document or use an existing one. It will then
   pull out the width and height of the canvas for engine use.
  
   It also adds a wrapper container around the element.
  
   If the `maximize` is set to true, the canvas element is maximized
   on the page and the scroll trick is used to try to get the address bar away.
  
   The engine will also resample the game to CSS dimensions at twice pixel
   dimensions if the `resampleWidth` or `resampleHeight` options are set.
  
   TODO: add support for auto-resize w/ engine event notifications

   Available options:

       {
        width: 320,  // width of created canvas
        height: 420, // height of created canvas
        maximize: false // set to true to maximize to screen, "touch" to maximize on touch devices
       }

   @for Quintus
   @method Q.setup
   @param {String} [id="quintus"] - id of the canvas element to trigger quintus on
   @param {Object} [options] - options hash

  */
  Q.setup = function(id, options) {
    if(Q._isObject(id)) {
      options = id;
      id = null;
    }
    options = options || {};
    id = id || "quintus";

    if(Q._isString(id)) {
      Q.el = document.getElementById(id);
    } else {
      Q.el = id;
    }

    if(!Q.el) {
      Q.el = document.createElement("canvas");
      Q.el.width = options.width || 320;
      Q.el.height = options.height || 420;
      Q.el.id = id;

      document.body.appendChild(Q.el);
    }

    var w = parseInt(Q.el.width,10),
        h = parseInt(Q.el.height,10);

    var maxWidth = options.maxWidth || 5000,
        maxHeight = options.maxHeight || 5000,
        resampleWidth = options.resampleWidth,
        resampleHeight = options.resampleHeight,
        upsampleWidth = options.upsampleWidth,
        upsampleHeight = options.upsampleHeight;

    if(options.maximize === true || (Q.touchDevice && options.maximize === 'touch'))  {
      document.body.style.padding = 0;
      document.body.style.margin = 0;

      w = options.width || Math.min(window.innerWidth,maxWidth) - ((options.pagescroll)?17:0);
      h = options.height || Math.min(window.innerHeight - 5,maxHeight);

      if(Q.touchDevice) {
        Q.el.style.height = (h*2) + "px";
        window.scrollTo(0,1);

        w = Math.min(window.innerWidth,maxWidth);
        h = Math.min(window.innerHeight,maxHeight);
      }
    } else if(Q.touchDevice) {
      window.scrollTo(0,1);
    }

    if((upsampleWidth && w <= upsampleWidth) ||
       (upsampleHeight && h <= upsampleHeight)) {
      Q.el.style.height = h + "px";
      Q.el.style.width = w + "px";
      Q.el.width = w * 2;
      Q.el.height = h * 2;
    }
    else if(((resampleWidth && w > resampleWidth) ||
        (resampleHeight && h > resampleHeight)) && 
       Q.touchDevice) { 
      Q.el.style.height = h + "px";
      Q.el.style.width = w + "px";
      Q.el.width = w / 2;
      Q.el.height = h / 2;
    } else {
      Q.el.style.height = h + "px";
      Q.el.style.width = w + "px";
      Q.el.width = w;
      Q.el.height = h;
    }

    var elParent = Q.el.parentNode;

    if(elParent) {
      Q.wrapper = document.createElement("div");
      Q.wrapper.id = Q.el.id + '_container';
      Q.wrapper.style.width = w + "px";
      Q.wrapper.style.margin = "0 auto";
      Q.wrapper.style.position = "relative";


      elParent.insertBefore(Q.wrapper,Q.el);
      Q.wrapper.appendChild(Q.el);
    }
    
    Q.el.style.position = 'relative';

    Q.ctx = Q.el.getContext && 
            Q.el.getContext("2d");


    Q.width = parseInt(Q.el.width,10);
    Q.height = parseInt(Q.el.height,10);
    Q.cssWidth = w;
    Q.cssHeight = h;

    //scale to fit
    if(options.scaleToFit) {
      var factor = 1;

      var winW = window.innerWidth*factor;
      var winH = window.innerHeight*factor;
      var winRatio = winW/winH;    
      var gameRatio = Q.el.width/Q.el.height;
      var scaleRatio = gameRatio < winRatio ? winH/Q.el.height : winW/Q.el.width;
      var scaledW = Q.el.width * scaleRatio;
      var scaledH = Q.el.height * scaleRatio;

      Q.el.style.width = scaledW + "px"; 
      Q.el.style.height = scaledH + "px"; 

      if(Q.el.parentNode) {
        Q.el.parentNode.style.width = scaledW + "px"; 
        Q.el.parentNode.style.height = scaledH + "px"; 
      }
            
      Q.cssWidth = parseInt(scaledW,10);
      Q.cssHeight = parseInt(scaledH,10);     

      //center vertically when adjusting to width
      if(gameRatio > winRatio) {
        var topPos = (winH - scaledH)/2;          
        Q.el.style.top = topPos+'px';
      }
    }   

    window.addEventListener('orientationchange',function() {
      setTimeout(function() { window.scrollTo(0,1); }, 0);
    });

    return Q;
  };


  /**
   Clear the canvas completely.

   If you want it cleared to a specific color - set `Q.clearColor` to that color

   @method Q.clear
   @for Quintus
  */
  Q.clear = function() {
    if(Q.clearColor) {
      Q.ctx.globalAlpha = 1;
      Q.ctx.fillStyle = Q.clearColor;
      Q.ctx.fillRect(0,0,Q.width,Q.height);
    } else {
      Q.ctx.clearRect(0,0,Q.width,Q.height);
    }
  };
  
  Q.setImageSmoothing = function(enabled) {
    Q.ctx.mozImageSmoothingEnabled = enabled;
    Q.ctx.webkitImageSmoothingEnabled = enabled;
    Q.ctx.msImageSmoothingEnabled = enabled;
    Q.ctx.imageSmoothingEnabled = enabled;
  };

  /**
   Return canvas image data given an Image object.

   @method Q.imageData
   @for Quintus
   @param {Image} img - image to get image datda for
  */
  Q.imageData = function(img) {
    var canvas = document.createElement("canvas");
    
    canvas.width = img.width;
    canvas.height = img.height;

    var ctx = canvas.getContext("2d");
    ctx.drawImage(img,0,0);

    return ctx.getImageData(0,0,img.width,img.height);
  };

  
  /**
   Asset Loading Support
  
   The engine supports loading assets of different types using
   `load` or `preload`. Assets are stored by their name so the 
   same asset won't be loaded twice if it already exists.

   Augmentable list of asset types, loads a specific asset 
   type if the file type matches, otherwise defaults to a Ajax
   load of the data.
  
   You can new types of assets based on file extension by
   adding to `assetTypes` and adding a method called
   loadAssetTYPENAME where TYPENAME is the name of the
   type you added in.

   Default bindings are:

     * png, jpg, gif, jpeg -> Image
     * ogg, wav, m4a, mp3 -> Audio
     * Everything else -> Data
    
   To add a new file extension in to an existing type you can just add it to asset types:

       Q.assetTypes['bmp'] = "Image";

   To add in a new loader, you'll need to define a method for that type and add to the `Q.assetTypes` object, e.g.:

       Q.loadAssetVideo = function(key,src,callback,errorCallback) {
          var vid = new Video();
          vid.addEventListener("canplaythrough",function() {  callback(key,vid); });
          vid.onerror = errorCallback;
          vid.src = Q.assetUrl(Q.options.imagePath,src);
       };

       Q.assetTypes['mp4'] = 'Video'


   @for Quintus
   @property Q.assetTypes
   @type Object
  */
  Q.assetTypes = { 
    png: 'Image', jpg: 'Image', gif: 'Image', jpeg: 'Image',
    ogg: 'Audio', wav: 'Audio', m4a: 'Audio', mp3: 'Audio'
  };


  /**
   Return the file extension of a filename

   @for Quintus
   @method Q._fileExtension
   @param {String} filename
   @return {String} lowercased extension
  */
  Q._fileExtension = function(filename) {
    var fileParts = filename.split("."),
        fileExt = fileParts[fileParts.length-1].toLowerCase();
    return fileExt;
  };

  /**
   Determine the type of asset based on the `Q.assetTypes` lookup table

   @for Quintus
   @method Q.assetType
   @param {String} asset
  */
  Q.assetType = function(asset) {
    /* Determine the lowercase extension of the file */
    var fileExt = Q._fileExtension(asset);

    // Use the web audio loader instead of the regular loader
    // if it's supported.
    var fileType =  Q.assetTypes[fileExt];
    if(fileType === 'Audio' && Q.audio && Q.audio.type === "WebAudio") {
      fileType = 'WebAudio';
    }

    /* Lookup the asset in the assetTypes hash, or return other */
    return fileType || 'Other';
  };

  /**
   Either return an absolute URL, or add a base to a relative URL

   @for Quintus
   @method Q.assetUrl
   @param {String} base - base for relative paths
   @param {String} url - url to resolve to asset url
   @return {String} resolved url
  */
  Q.assetUrl = function(base,url) {
    var timestamp = "";
    if(Q.options.development) {
      timestamp = (/\?/.test(url) ? "&" : "?") + "_t=" +new Date().getTime();
    }
    if(/^https?:\/\//.test(url) || url[0] === "/") {
      return url + timestamp;
    } else {
      return base + url + timestamp;
    }
  };

  /** 
  Loader for Images, creates a new `Image` object and uses the 
  load callback to determine the image has been loaded

  @for Quintus
  @method Q.loadAssetImage
  @param {String} key
  @param {String} src
  @param {Function} callback
  @param {Function} errorCallback
  */
  Q.loadAssetImage = function(key,src,callback,errorCallback) {
    var img = new Image();
    img.onload = function() {  callback(key,img); };
    img.onerror = errorCallback;
    img.src = Q.assetUrl(Q.options.imagePath,src);
  };


  // List of mime types given an audio file extension, used to 
  // determine what sound types the browser can play using the 
  // built-in `Sound.canPlayType`
  Q.audioMimeTypes = { mp3: 'audio/mpeg', 
                       ogg: 'audio/ogg; codecs="vorbis"',
                       m4a: 'audio/m4a',
                       wav: 'audio/wav' };


  Q._audioAssetExtension = function() {
    if(Q._audioAssetPreferredExtension) { return Q._audioAssetPreferredExtension; }

    var snd = new Audio();

    /* Find a supported type */
    return Q._audioAssetPreferredExtension = 
      Q._detect(Q.options.audioSupported,
         function(extension) {
         return snd.canPlayType(Q.audioMimeTypes[extension]) ? 
                                extension : null;
      });
  };


  /** 
   Loader for Audio assets. By default chops off the extension and 
   will automatically determine which of the supported types is 
   playable by the browser and load that type.
  
   Which types are available are determined by the file extensions
   listed in the Quintus `options.audioSupported`


  @for Quintus
  @method Q.loadAssetAudio
  @param {String} key
  @param {String} src
  @param {Function} callback
  @param {Function} errorCallback
  */
  Q.loadAssetAudio = function(key,src,callback,errorCallback) {
    if(!document.createElement("audio").play || !Q.options.sound) {
      callback(key,null);
      return;
    }

    var baseName = Q._removeExtension(src),
        extension = Q._audioAssetExtension(),
        filename = null,
        snd = new Audio();

    /* No supported audio = trigger ok callback anyway */
    if(!extension) {
      callback(key,null);
      return;
    }

    snd.addEventListener("error",errorCallback);

    // Don't wait for canplaythrough on mobile
    if(!Q.touchDevice) { 
      snd.addEventListener('canplaythrough',function() { 
        callback(key,snd); 
      });
    }
    snd.src =  Q.assetUrl(Q.options.audioPath,baseName + "." + extension);
    snd.load();

    if(Q.touchDevice) {
      callback(key,snd);
    }
  };

  /**
   Asset loader for Audio files if using the WebAudio API engine

  @for Quintus
  @method Q.loadAssetWebAudio
  @param {String} key
  @param {String} src
  @param {Function} callback
  @param {Function} errorCallback
  */
  Q.loadAssetWebAudio = function(key,src,callback,errorCallback) {
    var request = new XMLHttpRequest(),
        baseName = Q._removeExtension(src),
        extension = Q._audioAssetExtension();

    request.open("GET", Q.assetUrl(Q.options.audioPath,baseName + "." + extension), true);
    request.responseType = "arraybuffer";

    // Our asynchronous callback
    request.onload = function() {
      var audioData = request.response;

      Q.audioContext.decodeAudioData(request.response, function(buffer) {
        callback(key,buffer);
      }, errorCallback);
    };
    request.send();

  };

  /**
   Loader for other file types, just stores the data returned from an Ajax call.

   Just makes a Ajax request for all other file types

  @for Quintus
  @method Q.loadAssetOther
  @param {String} key
  @param {String} src
  @param {Function} callback
  @param {Function} errorCallback
  */
  Q.loadAssetOther = function(key,src,callback,errorCallback) {
    var request = new XMLHttpRequest();

    var fileParts = src.split("."),
        fileExt = fileParts[fileParts.length-1].toLowerCase();

    request.onreadystatechange = function() {
      if(request.readyState === 4) {
        if(request.status === 200) {
          if(fileExt === 'json') {
            callback(key,JSON.parse(request.responseText));
          } else {
            callback(key,request.responseText);
          }
        } else {
          errorCallback();
        }
      }
    };

    request.open("GET", Q.assetUrl(Q.options.dataPath,src), true);
    request.send(null);
  };

  /**
   Helper method to return a name without an extension

   @for Quintus
   @method _removeExtension
   @param {String} filename
   @return {String} filename without an extension
  */
  Q._removeExtension = function(filename) {
    return filename.replace(/\.(\w{3,4})$/,"");
  };

  // Asset hash storing any loaded assets
  Q.assets = {};

  /**
   Getter method to return an asset by its name.
  
   Asset names default to their filenames, but can be overridden
   by passing a hash to `load` to set different names.

   @for Quintus
   @method asset
   @param {String} name - name of asset to lookup
  */
  Q.asset = function(name) {
    return Q.assets[name];
  };

  /**
   Load assets, and call our callback when done.
  
   Also optionally takes a `progressCallback` which will be called 
   with the number of assets loaded and the total number of assets
   to allow showing of a progress. 
  
   Assets can be passed in as an array of file names, and Quintus
   will use the file names as the name for reference, or as a hash of 
   `{ name: filename }`. 
  
   Example usage:
       Q.load(['sprites.png','sprites.,json'],function() {
          Q.stageScene("level1"); // or something to start the game.
       });

  @for Quintus
  @method Q.load
  @param {String, Array or Array} assets - comma separated string, array or Object hash of assets to load
  @param {Function} callback - called when done loading
  @param {Object} options
  */
  Q.load = function(assets,callback,options) {
    var assetObj = {};

    /* Make sure we have an options hash to work with */
    if(!options) { options = {}; }

    /* Get our progressCallback if we have one */
    var progressCallback = options.progressCallback;

    var errors = false,
        errorCallback = function(itm) {
          errors = true;
          (options.errorCallback  ||
           function(itm) { throw("Error Loading: " + itm ); })(itm);
        };

    /* Convert to an array if it's a string */
    if(Q._isString(assets)) {
      assets = Q._normalizeArg(assets);
    }

    /* If the user passed in an array, convert it */
    /* to a hash with lookups by filename */
    if(Q._isArray(assets)) { 
      Q._each(assets,function(itm) {
        if(Q._isObject(itm)) {
          Q._extend(assetObj,itm);
        } else {
          assetObj[itm] = itm;
        }
      });
    } else {
      /* Otherwise just use the assets as is */
      assetObj = assets;
    }

    /* Find the # of assets we're loading */
    var assetsTotal = Q._keys(assetObj).length,
        assetsRemaining = assetsTotal;

    /* Closure'd per-asset callback gets called */
    /* each time an asset is successfully loadded */
    var loadedCallback = function(key,obj,force) {
      if(errors) { return; }

      // Prevent double callbacks (I'm looking at you Firefox, canplaythrough
      if(!Q.assets[key]||force) {

        /* Add the object to our asset list */
        Q.assets[key] = obj;

        /* We've got one less asset to load */
        assetsRemaining--;

        /* Update our progress if we have it */
        if(progressCallback) { 
           progressCallback(assetsTotal - assetsRemaining,assetsTotal); 
        }
      }

      /* If we're out of assets, call our full callback */
      /* if there is one */
      if(assetsRemaining === 0 && callback) {
        /* if we haven't set up our canvas element yet, */
        /* assume we're using a canvas with id 'quintus' */
        callback.apply(Q); 
      }
    };

    /* Now actually load each asset */
    Q._each(assetObj,function(itm,key) {

      /* Determine the type of the asset */
      var assetType = Q.assetType(itm);

      /* If we already have the asset loaded, */
      /* don't load it again */
      if(Q.assets[key]) {
        loadedCallback(key,Q.assets[key],true);
      } else {
        /* Call the appropriate loader function */
        /* passing in our per-asset callback */
        /* Dropping our asset by name into Q.assets */
        Q["loadAsset" + assetType](key,itm,
                                   loadedCallback,
                                   function() { errorCallback(itm); });
      }
    });

  };

  // Array to store any assets that need to be 
  // preloaded
  Q.preloads = [];
  
  /**
   Let us gather assets to load at a later time,
   and then preload them all at the same time with
   a single callback. Options are passed through to the
   Q.load method if used.
  
   Example usage:
        Q.preload("sprites.png");
        ...
        Q.preload("sprites.json");
        ...
  
        Q.preload(function() {
           Q.stageScene("level1"); // or something to start the game
        });
  @for Quintus
  @method Q.preload
  @param {String or Function} arg - comma separated string of assets to load, or callback
  @param {Object} [options] - options to pass to load
  */
  Q.preload = function(arg,options) {
    if(Q._isFunction(arg)) {
      Q.load(Q._uniq(Q.preloads),arg,options);
      Q.preloads = [];
    } else {
      Q.preloads = Q.preloads.concat(arg);
    }
  };


  // Math Methods
  // ==============
  //
  // Math methods, for rotating and scaling points

  // A list of matrices available
  Q.matrices2d = [];

  Q.matrix2d = function() {
    return Q.matrices2d.length > 0 ? Q.matrices2d.pop().identity() : new Q.Matrix2D();
  };

  /**
   A 2D matrix class, optimized for 2D points,
   where the last row of the matrix will always be 0,0,1 

   Do not call `new Q.Matrix2D` - use the provided Q.matrix2D factory function for GC happiness

        var matrix = Q.matrix2d();

   Good Docs here: https://github.com/heygrady/transform/wiki/calculating-2d-matrices

   Used internally by Quintus for all transforms / collision detection. Most of the methods modify the matrix they are called upon and are chainable.

   @class Q.Matrix2D
   @for Quintus
   @extends Q.Class
  */
  Q.Matrix2D = Q.Class.extend({
    /**
     Initialize a matrix from a source or with the identify matrix

     @constructor
     @for Q.Matrix2D
    */
    init: function(source) {
      if(source) {
        this.m = [];
        this.clone(source);
      } else {
        this.m = [1,0,0,0,1,0];
      }
    },

    /**
     Turn this matrix into the identity

     @for Q.Matrix2D
     @method identity
     @chainable
    */
    identity: function() {
      var m = this.m;
      m[0] = 1; m[1] = 0; m[2] = 0;
      m[3] = 0; m[4] = 1; m[5] = 0;
      return this;
    },

    /** 

     Clone another matrix into this one

     @for Q.Matrix2D
     @method clone
     @param {Q.Matrix2D} matrix - matrix to clone
     @chainable
    */
    clone: function(matrix) {
      var d = this.m, s = matrix.m;
      d[0]=s[0]; d[1]=s[1]; d[2] = s[2];
      d[3]=s[3]; d[4]=s[4]; d[5] = s[5];
      return this;
    },

    /**
     multiply two matrices (leaving the result in this)

        a * b = 
           [ [ a11*b11 + a12*b21 ], [ a11*b12 + a12*b22 ], [ a11*b31 + a12*b32 + a13 ] ,
           [ a21*b11 + a22*b21 ], [ a21*b12 + a22*b22 ], [ a21*b31 + a22*b32 + a23 ] ]

     @for Q.Matrix2D
     @method clone
     @param {Q.Matrix2D} matrix - matrix to multiply by
     @chainable
   */
    multiply: function(matrix) {
      var a = this.m, b = matrix.m;

      var m11 = a[0]*b[0] + a[1]*b[3];
      var m12 = a[0]*b[1] + a[1]*b[4];
      var m13 = a[0]*b[2] + a[1]*b[5] + a[2];

      var m21 = a[3]*b[0] + a[4]*b[3];
      var m22 = a[3]*b[1] + a[4]*b[4];
      var m23 = a[3]*b[2] + a[4]*b[5] + a[5];

      a[0]=m11; a[1]=m12; a[2] = m13;
      a[3]=m21; a[4]=m22; a[5] = m23;
      return this;
    },

    /** 
     
     Multiply this matrix by a rotation matrix rotated radians radians 

    @for Q.Matrix2D
    @method rotate
    @param {Float} radians - angle to rotate by
    @chainable
    */
    rotate: function(radians) {
      if(radians === 0) { return this; }
      var cos = Math.cos(radians),
          sin = Math.sin(radians),
          m = this.m;

      var m11 = m[0]*cos  + m[1]*sin;
      var m12 = m[0]*-sin + m[1]*cos;

      var m21 = m[3]*cos  + m[4]*sin;
      var m22 = m[3]*-sin + m[4]*cos;

      m[0] = m11; m[1] = m12; // m[2] == m[2]
      m[3] = m21; m[4] = m22; // m[5] == m[5]
      return this;
    },

    /**

     Helper method to rotate by a set number of degrees (calls rotate internally)

     @for Q.Matrix2D
     @method rotateDeg
     @param {Float} degrees
     @chainable
    */
    rotateDeg: function(degrees) {
      if(degrees === 0) { return this; }
      return this.rotate(Math.PI * degrees / 180);
    },

    /**

     Multiply this matrix by a scaling matrix scaling sx and sy
     @for Q.Matrix2D
     @method scale
     @param {Float} sx - scale in x dimension (scaling is uniform unless `sy` is provided)
     @param {Float} [sy] - scale in the y dimension
     @chainable
    */
    scale: function(sx,sy) {
      var m = this.m;
      if(sy === void 0) { sy = sx; }

      m[0] *= sx;
      m[1] *= sy;
      m[3] *= sx;
      m[4] *= sy;
      return this;
    },


    /** 
     Multiply this matrix by a translation matrix translate by tx and ty

     @for Q.Matrix2D
     @method translate
     @param {Float} tx
     @param {Float} ty
     @chainable
    */
    translate: function(tx,ty) {
      var m = this.m;

      m[2] += m[0]*tx + m[1]*ty;
      m[5] += m[3]*tx + m[4]*ty;
      return this;
    },


    /**
     Transform x and y coordinates by this matrix
     Memory Hoggy version, returns a new Array

     @for Q.Matrix2D
     @method transform
     @param {Float} x
     @param {Float} y

     */
    transform: function(x,y) {
      return [ x * this.m[0] + y * this.m[1] + this.m[2], 
               x * this.m[3] + y * this.m[4] + this.m[5] ];
    },

    /**
     Transform an object with an x and y property by this Matrix
     @for Q.Matrix2D
     @method transformPt
     @param {Object} obj
     @return {Object} obj
    */
    transformPt: function(obj) {
      var x = obj.x, y = obj.y;

      obj.x = x * this.m[0] + y * this.m[1] + this.m[2];
      obj.y = x * this.m[3] + y * this.m[4] + this.m[5];

      return obj;
    },

    /**
     Transform an array with an x and y elements by this Matrix and put the result in 
     the outArr

     @for Q.Matrix2D
     @method transformArr
     @param {Array} inArr - input array
     @param {Array} outArr - output array
     @return {Object} obj
    */
    transformArr: function(inArr,outArr) {
      var x = inArr[0], y = inArr[1];
      
      outArr[0] = x * this.m[0] + y * this.m[1] + this.m[2];
      outArr[1] = x * this.m[3] + y * this.m[4] + this.m[5];

      return outArr;
    },


    /**
     Return just the x coordinate transformed by this Matrix

     @for Q.Matrix2D
     @method transformX
     @param {Float} x
     @param {Float} y
     @return {Float} x transformed
    */
    transformX: function(x,y) {
      return x * this.m[0] + y * this.m[1] + this.m[2];
    },

    /**
     Return just the y coordinate transformed by this Matrix

     @for Q.Matrix2D
     @method transformY
     @param {Float} x
     @param {Float} y
     @return {Float} y transformed
    */
    transformY: function(x,y) {
      return x * this.m[3] + y * this.m[4] + this.m[5];
    },

    /**
     Release this Matrix to be reused

     @for Q.Matrix2D
     @method release
    */
    release: function() {
      Q.matrices2d.push(this);
      return null;
    },

    /**
     Set the complete transform on a Canvas 2D context

     @for Q.Matrix2D
     @method setContextTransform
     @param {Context2D} ctx - 2D canvs context
     */  
     setContextTransform: function(ctx) {
      var m = this.m;
      // source:
      //  m[0] m[1] m[2]
      //  m[3] m[4] m[5]
      //  0     0   1
      //
      // destination:
      //  m11  m21  dx
      //  m12  m22  dy
      //  0    0    1
      //  setTransform(m11, m12, m21, m22, dx, dy)
      ctx.transform(m[0],m[3],m[1],m[4],m[2],m[5]);
    }

  });

  // And that's it..
  // ===============
  //
  // Return the `Q` object from the `Quintus()` factory method. Create awesome games. Repeat.
  return Q;
};

// Lastly, add in the `requestAnimationFrame` shim, if necessary. Does nothing 
// if `requestAnimationFrame` is already on the `window` object.
(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = 
          window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
 
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }
 
    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
    }
}());




/***/ }),

/***/ "./node_modules/quintus/lib/quintus_2d.js":
/*!************************************************!*\
  !*** ./node_modules/quintus/lib/quintus_2d.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */

module.exports = function(Q) {

  Q.component('viewport',{
    added: function() {
      this.entity.on('prerender',this,'prerender');
      this.entity.on('render',this,'postrender');
      this.x = 0;
      this.y = 0;
      this.offsetX = 0;
      this.offsetY = 0;
      this.centerX = Q.width/2;
      this.centerY = Q.height/2;
      this.scale = 1;
    },

    extend: {
      follow: function(sprite,directions,boundingBox) {
        this.off('poststep',this.viewport,'follow');
        this.viewport.directions = directions || { x: true, y: true };
        this.viewport.following = sprite;
        this.viewport.boundingBox = boundingBox;
        this.on('poststep',this.viewport,'follow');
        this.viewport.follow(true);
      },

      unfollow: function() {
        this.off('poststep',this.viewport,'follow');
      },

      centerOn: function(x,y) {
        this.viewport.centerOn(x,y);
      },

      moveTo: function(x,y) {
        return this.viewport.moveTo(x,y);
      }
    },

    follow: function(first) {
      var followX = Q._isFunction(this.directions.x) ? this.directions.x(this.following) : this.directions.x;
      var followY = Q._isFunction(this.directions.y) ? this.directions.y(this.following) : this.directions.y;

      this[first === true ? 'centerOn' : 'softCenterOn'](
                    followX ? 
                      this.following.p.x + this.following.p.w/2 - this.offsetX :
                      undefined,
                    followY ?
                     this.following.p.y + this.following.p.h/2 - this.offsetY :
                     undefined
                  );
    },

    offset: function(x,y) {
      this.offsetX = x;
      this.offsetY = y;
    },

    softCenterOn: function(x,y) {
      if(x !== void 0) {        
        var dx = (x - Q.width / 2 / this.scale - this.x)/3;
        if(this.boundingBox) {
          if(this.x + dx < this.boundingBox.minX) {
            this.x = this.boundingBox.minX / this.scale;
          }
          else if(this.x + dx > (this.boundingBox.maxX - Q.width) / this.scale) {
            this.x = (this.boundingBox.maxX - Q.width) / this.scale;
          }
          else {
            this.x += dx;
          }            
        }
        else {
          this.x += dx;
        }
      }
      if(y !== void 0) { 
        var dy = (y - Q.height / 2 / this.scale - this.y)/3;
        if(this.boundingBox) {
          if(this.y + dy < this.boundingBox.minY) {
            this.y = this.boundingBox.minY / this.scale;
          }
          else if(this.y + dy > (this.boundingBox.maxY - Q.height) / this.scale) {
            this.y = (this.boundingBox.maxY - Q.height) / this.scale;
          }
          else {
            this.y += dy;
          }            
        }
        else {
          this.y += dy;
        }
      }

    },
    centerOn: function(x,y) {
      if(x !== void 0) {
        this.x = x - Q.width / 2 / this.scale;
      }
      if(y !== void 0) { 
        this.y = y - Q.height / 2 / this.scale;
      }

    },

    moveTo: function(x,y) {
      if(x !== void 0) {
        this.x = x;
      }
      if(y !== void 0) { 
        this.y = y;
      }
      return this.entity;

    },

    prerender: function() {
      this.centerX = this.x + Q.width / 2 /this.scale;
      this.centerY = this.y + Q.height / 2 /this.scale;
      Q.ctx.save();
      Q.ctx.translate(Math.floor(Q.width/2),Math.floor(Q.height/2));
      Q.ctx.scale(this.scale,this.scale);
      Q.ctx.translate(-Math.floor(this.centerX), -Math.floor(this.centerY));
    },

    postrender: function() {
      Q.ctx.restore();
    }
  });


 Q.Sprite.extend("TileLayer",{

    init: function(props) {
      this._super(props,{
        tileW: 32,
        tileH: 32,
        blockTileW: 10,
        blockTileH: 10,
        type: 1,
        renderAlways: true
      });
      if(this.p.dataAsset) {
        this.load(this.p.dataAsset);
      }

      this.setDimensions();

      this.blocks = [];
      this.p.blockW = this.p.tileW * this.p.blockTileW;
      this.p.blockH = this.p.tileH * this.p.blockTileH;
      this.colBounds = {}; 
      this.directions = [ 'top','left','right','bottom'];
      this.tileProperties = {};

      this.collisionObject = { 
        p: {
          w: this.p.tileW,
          h: this.p.tileH,
          cx: this.p.tileW/2,
          cy: this.p.tileH/2
        }
      };
      
      this.tileCollisionObjects = {};      

      this.collisionNormal = { separate: []};

      this._generateCollisionObjects();
    },

    // Generate the tileCollisionObject overrides where needed
    _generateCollisionObjects: function() {
      var self = this;

      function returnPoint(pt) {
        return [ pt[0] * self.p.tileW - self.p.tileW/2,
                 pt[1] * self.p.tileH - self.p.tileH/2
               ];
      }

      if(this.sheet() && this.sheet().frameProperties) {
        var frameProperties = this.sheet().frameProperties;
        for(var k in frameProperties) { 
          var colObj = this.tileCollisionObjects[k] = { p: Q._clone(this.collisionObject.p) };
          Q._extend(colObj.p,frameProperties[k]);

          if(colObj.p.points) {
            colObj.p.points = Q._map(colObj.p.points, returnPoint);
          }

          this.tileCollisionObjects[k] = colObj;
        }
      }

    },

    load: function(dataAsset) {
      var fileParts = dataAsset.split("."),
          fileExt = fileParts[fileParts.length-1].toLowerCase(),
          data;

      if (fileExt === "json") {  
        data = Q._isString(dataAsset) ?  Q.asset(dataAsset) : dataAsset;
      }
      else {
        throw "file type not supported";
      }
      this.p.tiles = data;
    },

    setDimensions: function() {
      var tiles = this.p.tiles;

      if(tiles) { 
        this.p.rows = tiles.length;
        this.p.cols = tiles[0].length;
        this.p.w = this.p.cols * this.p.tileW;
        this.p.h = this.p.rows * this.p.tileH;
      }
    },

    getTile: function(tileX,tileY) {
      return this.p.tiles[tileY] && this.p.tiles[tileY][tileX];
    },
    
    getTileProperty: function(tile, prop) {
      if(this.tileProperties[tile] !== undefined) {
        return this.tileProperties[tile][prop];          
      } else {
        return;
      }      
    },
    
    getTileProperties: function(tile) {
      if(this.tileProperties[tile] !== undefined) {
        return this.tileProperties[tile];          
      } else {
        return {};
      }
    },
    
    getTilePropertyAt: function(tileX, tileY, prop) {
      return this.getTileProperty(this.getTile(tileX, tileY), prop);
    },
    
    getTilePropertiesAt: function(tileX, tileY) {
      return this.getTileProperties(this.getTile(tileX, tileY));
    },
    
    tileHasProperty: function(tile, prop) {
      return(this.getTileProperty(tile, prop) !== undefined);
    },    

    setTile: function(x,y,tile) {
      var p = this.p,
          blockX = Math.floor(x/p.blockTileW),
          blockY = Math.floor(y/p.blockTileH);

      if(x >= 0 && x < this.p.cols &&
         y >= 0 && y < this.p.rows) { 

        this.p.tiles[y][x] = tile;

        if(this.blocks[blockY]) {
          this.blocks[blockY][blockX] = null;
        }
      }
    },

    tilePresent: function(tileX,tileY) {
      return this.p.tiles[tileY] && this.collidableTile(this.p.tiles[tileY][tileX]);
    },

    // Overload this method to draw tiles at frame 0 or not draw
    // tiles at higher number frames
    drawableTile: function(tileNum) {
      return tileNum > 0;
    },

    // Overload this method to control which tiles trigger a collision
    // (defaults to all tiles > number 0)
    collidableTile: function(tileNum) {
      return tileNum > 0;
    },
    
    getCollisionObject: function(tileX, tileY) {
      var p = this.p,
          tile = this.getTile(tileX, tileY),
          colObj;
      
      colObj = (this.tileCollisionObjects[tile] !== undefined) ? 
        this.tileCollisionObjects[tile] : this.collisionObject;     
      
      colObj.p.x = tileX * p.tileW + p.x + p.tileW/2;
      colObj.p.y = tileY * p.tileH + p.y + p.tileH/2;
      
      return colObj;
    },

    collide: function(obj) {
      var p = this.p,
          objP = obj.c || obj.p, 
          tileStartX = Math.floor((objP.x - objP.cx - p.x) / p.tileW),
          tileStartY = Math.floor((objP.y - objP.cy - p.y) / p.tileH),
          tileEndX =  Math.ceil((objP.x - objP.cx + objP.w - p.x) / p.tileW),
          tileEndY =  Math.ceil((objP.y - objP.cy + objP.h - p.y) / p.tileH),
          normal = this.collisionNormal,
          col, colObj;
  
      normal.collided = false;

      for(var tileY = tileStartY; tileY<=tileEndY; tileY++) {
        for(var tileX = tileStartX; tileX<=tileEndX; tileX++) {
          if(this.tilePresent(tileX,tileY)) {
            colObj = this.getCollisionObject(tileX, tileY);

            col = Q.collision(obj,colObj);
      
            if(col && col.magnitude > 0) {
              if(colObj.p.sensor) {
                colObj.tile = this.getTile(tileX,tileY);
                if(obj.trigger) { 
                  obj.trigger('sensor.tile',colObj); 
                }
              } else if(!normal.collided || normal.magnitude < col.magnitude ) {
                 normal.collided = true;
                 normal.separate[0] = col.separate[0];
                 normal.separate[1] = col.separate[1];
                 normal.magnitude = col.magnitude;
                 normal.distance = col.distance;
                 normal.normalX = col.normalX;
                 normal.normalY = col.normalY;
                 normal.tileX = tileX;
                 normal.tileY = tileY;
                 normal.tile = this.getTile(tileX,tileY);
                 if(obj.p.collisions !== undefined) {
                   obj.p.collisions.push(normal);               
                 }
              }
            }
          }
        }
      }

      return normal.collided ? normal : false;
    },

    prerenderBlock: function(blockX,blockY) {
      var p = this.p,
          tiles = p.tiles,
          sheet = this.sheet(),
          blockOffsetX = blockX*p.blockTileW,
          blockOffsetY = blockY*p.blockTileH;

      if(blockOffsetX < 0 || blockOffsetX >= this.p.cols ||
         blockOffsetY < 0 || blockOffsetY >= this.p.rows) {
           return;
      }

      var canvas = document.createElement('canvas'),
          ctx = canvas.getContext('2d');

      canvas.width = p.blockW;
      canvas.height= p.blockH;
      this.blocks[blockY] = this.blocks[blockY] || {};
      this.blocks[blockY][blockX] = canvas;

      for(var y=0;y<p.blockTileH;y++) {
        if(tiles[y+blockOffsetY]) {
          for(var x=0;x<p.blockTileW;x++) {
            if(this.drawableTile(tiles[y+blockOffsetY][x+blockOffsetX])) {
              sheet.draw(ctx,
                         x*p.tileW,
                         y*p.tileH,
                         tiles[y+blockOffsetY][x+blockOffsetX]);
            }
          }
        }
      }
    },

    drawBlock: function(ctx, blockX, blockY) {
      var p = this.p,
          startX = Math.floor(blockX * p.blockW + p.x),
          startY = Math.floor(blockY * p.blockH + p.y);

      if(!this.blocks[blockY] || !this.blocks[blockY][blockX]) {
        this.prerenderBlock(blockX,blockY);
      }

      if(this.blocks[blockY]  && this.blocks[blockY][blockX]) {
        ctx.drawImage(this.blocks[blockY][blockX],startX,startY);
      }
    },

    draw: function(ctx) {
      var p = this.p,
          viewport = this.stage.viewport,
          scale = viewport ? viewport.scale : 1,
          x = viewport ? viewport.x : 0,
          y = viewport ? viewport.y : 0,
          viewW = Q.width / scale,
          viewH = Q.height / scale,
          startBlockX = Math.floor((x - p.x) / p.blockW),
          startBlockY = Math.floor((y - p.y) / p.blockH),
          endBlockX = Math.floor((x + viewW - p.x) / p.blockW),
          endBlockY = Math.floor((y + viewH - p.y) / p.blockH);

      for(var iy=startBlockY;iy<=endBlockY;iy++) {
        for(var ix=startBlockX;ix<=endBlockX;ix++) {
          this.drawBlock(ctx,ix,iy);
        }
      }
    }
  });

  Q.gravityY = 9.8*100;
  Q.gravityX = 0;

  Q.component('2d',{
    added: function() {
      var entity = this.entity;
      Q._defaults(entity.p,{
        vx: 0,
        vy: 0,
        ax: 0,
        ay: 0,
        gravity: 1,
        collisionMask: Q.SPRITE_DEFAULT
      });
      entity.on('step',this,"step");
      entity.on('hit',this,'collision');
    },

    collision: function(col,last) {
      var entity = this.entity,
          p = entity.p,
          magnitude = 0;

      if(col.obj.p && col.obj.p.sensor) {
        col.obj.trigger("sensor",entity);
        return;
      }

      col.impact = 0;
      var impactX = Math.abs(p.vx);
      var impactY = Math.abs(p.vy);

      p.x -= col.separate[0];
      p.y -= col.separate[1];

      // Top collision
      if(col.normalY < -0.3) { 
        if(!p.skipCollide && p.vy > 0) { p.vy = 0; }
        col.impact = impactY;
        entity.trigger("bump.bottom",col);
      }
      if(col.normalY > 0.3) {
        if(!p.skipCollide && p.vy < 0) { p.vy = 0; }
        col.impact = impactY;

        entity.trigger("bump.top",col);
      }

      if(col.normalX < -0.3) { 
        if(!p.skipCollide && p.vx > 0) { p.vx = 0;  }
        col.impact = impactX;
        entity.trigger("bump.right",col);
      }
      if(col.normalX > 0.3) { 
        if(!p.skipCollide && p.vx < 0) { p.vx = 0; }
        col.impact = impactX;

        entity.trigger("bump.left",col);
      }
    },

    step: function(dt) {
      var p = this.entity.p,
          dtStep = dt;
      // TODO: check the entity's magnitude of vx and vy,
      // reduce the max dtStep if necessary to prevent 
      // skipping through objects.
      while(dtStep > 0) {
        dt = Math.min(1/30,dtStep);
        // Updated based on the velocity and acceleration
        p.vx += p.ax * dt + (p.gravityX === void 0 ? Q.gravityX : p.gravityX) * dt * p.gravity;
        p.vy += p.ay * dt + (p.gravityY === void 0 ? Q.gravityY : p.gravityY) * dt * p.gravity;
        p.x += p.vx * dt;
        p.y += p.vy * dt;

        this.entity.stage.collide(this.entity);
        dtStep -= dt;
      }
    }
  });

  Q.component('aiBounce', {
    added: function() {
      this.entity.on("bump.right",this,"goLeft");
      this.entity.on("bump.left",this,"goRight");
    },

    goLeft: function(col) {
      this.entity.p.vx = -col.impact;      
      if(this.entity.p.defaultDirection === 'right') {
          this.entity.p.flip = 'x';
      }
      else {
          this.entity.p.flip = false;
      }
    },

    goRight: function(col) {
      this.entity.p.vx = col.impact;
      if(this.entity.p.defaultDirection === 'left') {
          this.entity.p.flip = 'x';
      }
      else {
          this.entity.p.flip = false;
      }
    }
  });

};


/***/ }),

/***/ "./node_modules/quintus/lib/quintus_anim.js":
/*!**************************************************!*\
  !*** ./node_modules/quintus/lib/quintus_anim.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */

module.exports = function(Q) {

  Q._animations = {};
  Q.animations = function(sprite,animations) {
    if(!Q._animations[sprite]) { Q._animations[sprite] = {}; }
    Q._extend(Q._animations[sprite],animations);
  };

  Q.animation = function(sprite,name) {
    return Q._animations[sprite] && Q._animations[sprite][name];
  };

  Q.component('animation',{
    added: function() {
      var p = this.entity.p;
      p.animation = null;
      p.animationPriority = -1;
      p.animationFrame = 0;
      p.animationTime = 0;
      this.entity.on("step",this,"step");
    },
    extend: {
      play: function(name,priority,resetFrame) {
        this.animation.play(name,priority,resetFrame);
      }
    },
    step: function(dt) {
      var entity = this.entity,
          p = entity.p;
      if(p.animation) {
        var anim = Q.animation(p.sprite,p.animation),
            rate = anim.rate || p.rate,
            stepped = 0;
        p.animationTime += dt;
        if(p.animationChanged) {
          p.animationChanged = false;
        } else { 
          p.animationTime += dt;
          if(p.animationTime > rate) {
            stepped = Math.floor(p.animationTime / rate);
            p.animationTime -= stepped * rate;
            p.animationFrame += stepped;
          }
        }
        if(stepped > 0) {
          if(p.animationFrame >= anim.frames.length) {
            if(anim.loop === false || anim.next) {
              p.animationFrame = anim.frames.length - 1;
              entity.trigger('animEnd');
              entity.trigger('animEnd.' + p.animation);
              p.animation = null;
              p.animationPriority = -1;
              if(anim.trigger) {  
                entity.trigger(anim.trigger,anim.triggerData);
              }
              if(anim.next) { this.play(anim.next,anim.nextPriority); }
              return;
            } else {
              entity.trigger('animLoop');
              entity.trigger('animLoop.' + p.animation);
              p.animationFrame = p.animationFrame % anim.frames.length;
            }
          }
          entity.trigger("animFrame");
        }
        p.sheet = anim.sheet || p.sheet;
        p.frame = anim.frames[p.animationFrame];
        if(anim.hasOwnProperty("flip")) { p.flip  = anim.flip; }
      }
    },

    play: function(name,priority,resetFrame) {
      var entity = this.entity,
          p = entity.p;
      priority = priority || 0;
      if(name !== p.animation && priority >= p.animationPriority) {
        if(resetFrame === undefined) {
          resetFrame = true;
        }
        p.animation = name;
        if(resetFrame) {
          p.animationChanged = true;
          p.animationTime = 0;          
          p.animationFrame = 0;
        }        
        p.animationPriority = priority;
        entity.trigger('anim');
        entity.trigger('anim.' + p.animation);
      }
    }
  
  });


  Q.Sprite.extend("Repeater",{
    init: function(props) {
      this._super(Q._defaults(props,{
        speedX: 1,
        speedY: 1,
        repeatY: true,
        repeatX: true,
        renderAlways: true,
        type: 0
      }));
      this.p.repeatW = this.p.repeatW || this.p.w;
      this.p.repeatH = this.p.repeatH || this.p.h;
    },

    draw: function(ctx) {
      var p = this.p,
          asset = this.asset(),
          sheet = this.sheet(),
          scale = this.stage.viewport ? this.stage.viewport.scale : 1,
          viewX = Math.floor(this.stage.viewport ? this.stage.viewport.x : 0),
          viewY = Math.floor(this.stage.viewport ? this.stage.viewport.y : 0),
          offsetX = Math.floor(p.x + viewX * this.p.speedX),
          offsetY = Math.floor(p.y + viewY * this.p.speedY),
          curX, curY, startX;
      if(p.repeatX) {
        curX = -offsetX % p.repeatW;
        if(curX > 0) { curX -= p.repeatW; }
      } else {
        curX = p.x - viewX;
      }
      if(p.repeatY) {
        curY = -offsetY % p.repeatH;
        if(curY > 0) { curY -= p.repeatH; }
      } else {
        curY = p.y - viewY;
      }

      startX = curX;
      while(curY < Q.height / scale) {
        curX = startX;
        while(curX < Q.width / scale) {
          if(sheet) {
            sheet.draw(ctx,curX + viewX,curY + viewY,p.frame);
          } else {
            ctx.drawImage(asset,curX + viewX,curY + viewY);
          }
          curX += p.repeatW;
          if(!p.repeatX) { break; }
        }
        curY += p.repeatH;
        if(!p.repeatY) { break; }
      }
    }
  });

  Q.Tween = Q.Class.extend({
    init: function(entity,properties,duration,easing,options) {
      if(Q._isObject(easing)) { options = easing; easing = Q.Easing.Linear; }
      if(Q._isObject(duration)) { options = duration; duration = 1; }

      this.entity = entity;
      //this.p = (entity instanceof Q.Stage) ? entity.viewport : entity.p;
      this.duration = duration || 1;
      this.time = 0;
      this.options = options || {};
      this.delay = this.options.delay || 0;
      this.easing = easing || this.options.easing || Q.Easing.Linear;

      this.startFrame = Q._loopFrame + 1;
      this.properties = properties;
      this.start = {};
      this.diff = {};
    },

    step: function(dt) {
      var property;

      if(this.startFrame > Q._loopFrame) { return true; }
      if(this.delay >= dt) {
        this.delay -= dt;
        return true;
      }

      if(this.delay > 0) {
        dt -= this.delay;
        this.delay = 0;
      }

      if(this.time === 0) {
        // first time running? Initialize the properties to chaining correctly.
        var entity = this.entity, properties = this.properties;
        this.p = (entity instanceof Q.Stage) ? entity.viewport : entity.p;
        for(property in properties) {
          this.start[property] = this.p[property];
          if(!Q._isUndefined(this.start[property])) {
            this.diff[property] = properties[property] - this.start[property];
          }
        }
      }
      this.time += dt;

      var progress = Math.min(1,this.time / this.duration),
          location = this.easing(progress);

      for(property in this.start) {
        if(!Q._isUndefined(this.p[property])) {
          this.p[property] = this.start[property] + this.diff[property] * location;
        }
      }

      if(progress >= 1) {
        if(this.options.callback) { 
          this.options.callback.apply(this.entity);
        }
      }
      return progress < 1;
    }
  });

  // Code ripped directly from Tween.js
  // https://github.com/sole/tween.js/blob/master/src/Tween.js
  Q.Easing = {
    Linear: function (k) { return k; },

    Quadratic: {
      In: function ( k )  { return k * k; },
      Out: function ( k ) {return k * ( 2 - k ); },
      InOut: function ( k ) {
        if ((k *= 2 ) < 1) { return 0.5 * k * k; }
        return -0.5 * (--k * (k - 2) - 1);
      }
    }
  };

  Q.component('tween',{
    added: function() {
      this._tweens = [];
      this.entity.on("step",this,"step");
    },
    extend: {
      animate: function(properties,duration,easing,options) {
        this.tween._tweens.push(new Q.Tween(this,properties,duration,easing,options));
        return this;
      },

      chain: function(properties,duration,easing,options) {
        if(Q._isObject(easing)) { options = easing; easing = Q.Easing.Linear; }
        // Chain an animation to the end
        var tweenCnt = this.tween._tweens.length;
        if(tweenCnt > 0) {
          var lastTween = this.tween._tweens[tweenCnt - 1];
          options = options || {};
          options['delay'] = lastTween.duration - lastTween.time + lastTween.delay;
        } 

        this.animate(properties,duration,easing,options);
        return this;
      },

      stop: function() {
        this.tween._tweens.length = 0;
        return this;
      }
    },

    step: function(dt) {
      for(var i=0; i < this._tweens.length; i++) {
        if(!this._tweens[i].step(dt)) {
          this._tweens.splice(i,1);
          i--;
        }
      }
    }
  });


};



/***/ }),

/***/ "./node_modules/quintus/lib/quintus_audio.js":
/*!***************************************************!*\
  !*** ./node_modules/quintus/lib/quintus_audio.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false, AudioContext:false, window:false */

module.exports = function(Q) {

  Q.audio = {
    channels: [],
    channelMax:  Q.options.channelMax || 10,
    active: {},
    play: function() {}
  };


  Q.hasWebAudio = (typeof AudioContext !== "undefined") || (typeof webkitAudioContext !== "undefined");

  if(Q.hasWebAudio) { 
    if(typeof AudioContext !== "undefined") {
      Q.audioContext = new AudioContext();
    } else {
      Q.audioContext = new window.webkitAudioContext();
    }
  }

  Q.enableSound = function() {
    var hasTouch =  !!('ontouchstart' in window);

    if(Q.hasWebAudio) {
      Q.audio.enableWebAudioSound();
    } else {
      Q.audio.enableHTML5Sound();
    }
    return Q;
  };

  Q.audio.enableWebAudioSound = function() {
    Q.audio.type = "WebAudio";

    Q.audio.soundID = 0;

    Q.audio.playingSounds = {};

    Q.audio.removeSound = function(soundID) {
      delete Q.audio.playingSounds[soundID];
    };

    // Play a single sound, optionally debounced 
    // to prevent repeated plays in a short time
    Q.audio.play = function(s,options) {
      var now = new Date().getTime();

      // See if this audio file is currently being debounced, if 
      // it is, don't do anything and just return
      if(Q.audio.active[s] && Q.audio.active[s] > now) { return; }

      // If any options were passed in, check for a debounce,
      // which is the number of milliseconds to debounce this sound
      if(options && options['debounce']) {
        Q.audio.active[s] = now + options['debounce'];
      } else {
        delete Q.audio.active[s];
      }

      var soundID = Q.audio.soundID++;

      var source = Q.audioContext.createBufferSource();
      source.buffer = Q.asset(s);
      source.connect(Q.audioContext.destination);
      if(options && options['loop']) {
        source.loop = true;
      } else {
        setTimeout(function() {
          Q.audio.removeSound(soundID);
        },source.buffer.duration * 1000);
      }
      source.assetName = s;
      if(source.start) { source.start(0); } else { source.noteOn(0); }

      Q.audio.playingSounds[soundID] = source;


    };

    Q.audio.stop = function(s) {
      for(var key in Q.audio.playingSounds) {
        var snd = Q.audio.playingSounds[key];
        if(!s || s === snd.assetName) {
          if(snd.stop) { snd.stop(0);  } else {  snd.noteOff(0); }
        }
      }
    };

  };

  Q.audio.enableHTML5Sound = function() {
    Q.audio.type = "HTML5";

    for (var i=0;i<Q.audio.channelMax;i++) {	
      Q.audio.channels[i] = {};
      Q.audio.channels[i]['channel'] = new Audio(); 
      Q.audio.channels[i]['finished'] = -1;	
    }

    // Play a single sound, optionally debounced 
    // to prevent repeated plays in a short time
    Q.audio.play = function(s,options) {
      var now = new Date().getTime();

      // See if this audio file is currently being debounced, if 
      // it is, don't do anything and just return
      if(Q.audio.active[s] && Q.audio.active[s] > now) { return; }

      // If any options were passed in, check for a debounce,
      // which is the number of milliseconds to debounce this sound
      if(options && options['debounce']) {
        Q.audio.active[s] = now + options['debounce'];
      } else {
        delete Q.audio.active[s];
      }

      // Find a free audio channel and play the sound
      for (var i=0;i<Q.audio.channels.length;i++) {
        // Check the channel is either finished or not looping
        if (!Q.audio.channels[i]['loop'] && Q.audio.channels[i]['finished'] < now) {	

          Q.audio.channels[i]['channel'].src = Q.asset(s).src;

          // If we're looping - just set loop to true to prevent this channcel
          // from being used.
          if(options && options['loop']) { 
            Q.audio.channels[i]['loop'] = true;
            Q.audio.channels[i]['channel'].loop = true;
          } else {
            Q.audio.channels[i]['finished'] = now + Q.asset(s).duration*1000;
          }
          Q.audio.channels[i]['channel'].load();
          Q.audio.channels[i]['channel'].play();
          break;
        }
      }
    };

    // Stop a single sound asset or stop all sounds currently playing
    Q.audio.stop = function(s) {
      var src = s ? Q.asset(s).src : null;
      var tm = new Date().getTime();
      for (var i=0;i<Q.audio.channels.length;i++) {
        if ((!src || Q.audio.channels[i]['channel'].src === src) && 
            (Q.audio.channels[i]['loop'] || Q.audio.channels[i]['finished'] >= tm)) {
          Q.audio.channels[i]['channel'].pause();
          Q.audio.channels[i]['loop'] = false;
        }
      }
    };

  };

};
  


/***/ }),

/***/ "./node_modules/quintus/lib/quintus_input.js":
/*!***************************************************!*\
  !*** ./node_modules/quintus/lib/quintus_input.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */
/**
Quintus HTML5 Game Engine - Input Module

The code in `quintus_input.js` defines the `Quintus.Input` module, which
concerns itself with game-type (pretty anything besides touchscreen input)

@module Quintus.Input
*/

/**
 * Quintus Input Module
 *
 * @class Quintus.Input
 */
module.exports = function(Q) {
  /**
   * Provided key names mapped to key codes - add more names and key codes as necessary
   *
   * @for Quintus.Input
   * @property KEY_NAMES
   * @type Object
   * @static
   */
  var KEY_NAMES = Q.KEY_NAMES = {
    LEFT: 37, RIGHT: 39,
    UP: 38, DOWN: 40,
    SPACE: 32,
    Z: 90,
    X: 88,
    ENTER: 13,
    ESC: 27,
    P: 80,
    S: 83
  };

  var DEFAULT_KEYS = {
    LEFT: 'left', RIGHT: 'right',
    UP: 'up',     DOWN: 'down',
    SPACE: 'fire',
    Z: 'fire',
    X: 'action',
    ENTER: 'confirm',
    ESC: 'esc',
    P: 'P',
    S: 'S'
  };

  var DEFAULT_TOUCH_CONTROLS  = [ ['left','<' ],
                            ['right','>' ],
                            [],
                            ['action','b'],
                            ['fire', 'a' ]];

  // Clockwise from midnight (a la CSS)
  var DEFAULT_JOYPAD_INPUTS =  [ 'up','right','down','left'];

  /**
   * Current state of bound inputs
   *
   * @for Quintus.Input
   * @property Q.inputs
   * @type Object
   */
  Q.inputs = {};
  Q.joypad = {};

  var hasTouch =  !!('ontouchstart' in window);


  /**
   *
   * Convert a canvas point to a stage point, x dimension
   *
   * @method Q.canvasToStageX
   * @for Quintus.Input
   * @param {Float} x
   * @param {Q.Stage} stage
   * @returns {Integer} x
   */
  Q.canvasToStageX = function(x,stage) {
    x = x / Q.cssWidth * Q.width;
    if(stage.viewport) {
      x /= stage.viewport.scale;
      x += stage.viewport.x;
    }

    return x;
  };

  /**
   *
   * Convert a canvas point to a stage point, y dimension
   *
   * @method Q.canvasToStageY
   * @param {Float} y
   * @param {Q.Stage} stage
   * @returns {Integer} y
   */
  Q.canvasToStageY = function(y,stage) {
      y = y / Q.cssWidth * Q.width;
      if(stage.viewport) {
        y /= stage.viewport.scale;
        y += stage.viewport.y;
      }

      return y;
  };



  /**
   *
   * Button and mouse input subsystem for Quintus.
   * An instance of this class is auto-created as {{#crossLink "Q.input"}}{{/crossLink}}
   *
   * @class Q.InputSystem
   * @extends Q.Evented
   * @for Quintus.Input
   */
  Q.InputSystem = Q.Evented.extend({
    keys: {},
    keypad: {},
    keyboardEnabled: false,
    touchEnabled: false,
    joypadEnabled: false,

    /**
     * Bind a key name or keycode to an action name (used by `keyboardControls`)
     *
     * @method bindKey
     * @for Q.InputSystem
     * @param {String or Integer} key - name or integer keycode for to bind
     * @param {String} name - name of action to bind to
     */
    bindKey: function(key,name) {
      Q.input.keys[KEY_NAMES[key] || key] = name;
    },

    /**
     * Enable keyboard controls by binding to events
     *
     * @for Q.InputSystem
     * @method enableKeyboard
     */
    enableKeyboard: function() {
      if(this.keyboardEnabled) { return false; }

      // Make selectable and remove an :focus outline
      Q.el.tabIndex = 0;
      Q.el.style.outline = 0;

      Q.el.addEventListener("keydown",function(e) {
        if(Q.input.keys[e.keyCode]) {
          var actionName = Q.input.keys[e.keyCode];
          Q.inputs[actionName] = true;
          Q.input.trigger(actionName);
          Q.input.trigger('keydown',e.keyCode);
        }
        e.preventDefault();
      },false);

      Q.el.addEventListener("keyup",function(e) {
        if(Q.input.keys[e.keyCode]) {
          var actionName = Q.input.keys[e.keyCode];
          Q.inputs[actionName] = false;
          Q.input.trigger(actionName + "Up");
          Q.input.trigger('keyup',e.keyCode);
        }
        e.preventDefault();
      },false);

      if(Q.options.autoFocus) {  Q.el.focus(); }
      this.keyboardEnabled = true;
    },


    /**
     * Convenience method to activate keyboard controls (call `bindKey` and `enableKeyboard` internally)
      *
     * @method keyboardControls
     * @for Q.InputSystem
     * @param {Object} [keys] - hash of key names or codes to actions
     */
    keyboardControls: function(keys) {
      keys = keys || DEFAULT_KEYS;
      Q._each(keys,function(name,key) {
       this.bindKey(key,name);
      },Q.input);
      this.enableKeyboard();
    },

    _containerOffset: function() {
      Q.input.offsetX = 0;
      Q.input.offsetY = 0;
      var el = Q.el;
      do {
        Q.input.offsetX += el.offsetLeft;
        Q.input.offsetY += el.offsetTop;
      } while(el = el.offsetParent);
    },

    touchLocation: function(touch) {
      var el = Q.el, 
        posX = touch.offsetX,
        posY = touch.offsetY,
        touchX, touchY;

      if(Q._isUndefined(posX) || Q._isUndefined(posY)) {
        posX = touch.layerX;
        posY = touch.layerY;
      }

      if(Q._isUndefined(posX) || Q._isUndefined(posY)) {
        if(Q.input.offsetX === void 0) { Q.input._containerOffset(); }
        posX = touch.pageX - Q.input.offsetX;
        posY = touch.pageY - Q.input.offsetY;
      }

      touchX = Q.width * posX / Q.cssWidth;
      touchY = Q.height * posY / Q.cssHeight;


      return { x: touchX, y: touchY };
    },

    /**
     * Activate touch button controls - pass in an options hash to override
     *
     * Default Options:
     *
     *     {
     *        left: 0,
     *        gutter:10,
     *        controls: DEFAULT_TOUCH_CONTROLS,
     *        width: Q.width,
     *        bottom: Q.height
     *      }
     *
     * Default controls are left and right buttons, a space, and 'a' and 'b' buttons, as defined as an Array of Arrays below:
     *
     *      [ ['left','<' ],
     *        ['right','>' ],
     *        [],  // use an empty array as a spacer
     *        ['action','b'],
     *        ['fire', 'a' ]]
     *
     * @method touchControls
     * @for Q.InputSystem
     * @param {Object} [opts] - Options hash
     */
    touchControls: function(opts) {
      if(this.touchEnabled) { return false; }
      if(!hasTouch) { return false; }

      Q.input.keypad = opts = Q._extend({
        left: 0,
        gutter:10,
        controls: DEFAULT_TOUCH_CONTROLS,
        width: Q.width,
        bottom: Q.height,
        fullHeight: false
      },opts);

      opts.unit = (opts.width / opts.controls.length);
      opts.size = opts.unit - 2 * opts.gutter;

      function getKey(touch) {
        var pos = Q.input.touchLocation(touch),
            minY = opts.bottom - opts.unit;
        for(var i=0,len=opts.controls.length;i<len;i++) {
          var minX = opts.left + i * opts.unit + i * opts.gutter;
          if(pos.x >=  minX && pos.x <= (minX+opts.unit) && (opts.fullHeight || (pos.y >= minY && pos.y <= (minY+opts.unit)))) {
            return opts.controls[i][0];
          }
        }
      }

      function touchDispatch(event) {
        var wasOn = {},
            i, len, tch, key, actionName;

        // Reset all the actions bound to controls
        // but keep track of all the actions that were on
        for(i=0,len = opts.controls.length;i<len;i++) {
          actionName = opts.controls[i][0];
          if(Q.inputs[actionName]) { wasOn[actionName] = true; }
          Q.inputs[actionName] = false;
        }

        var touches = event.touches ? event.touches : [ event ];

        for(i=0,len=touches.length;i<len;i++) {
          tch = touches[i];
          key = getKey(tch);

          if(key) {
            // Mark this input as on
            Q.inputs[key] = true;

            // Either trigger a new action
            // or remove from wasOn list
            if(!wasOn[key]) {
              Q.input.trigger(key);
            } else {
              delete wasOn[key];
            }
          }
        }

        // Any remaining were on the last frame
        // and need to trigger an up action
        for(actionName in wasOn) {
          Q.input.trigger(actionName + "Up");
        }

        return null;
      }

      this.touchDispatchHandler = function(e) {
        touchDispatch(e);
        e.preventDefault();
      };


      Q._each(["touchstart","touchend","touchmove","touchcancel"],function(evt) {
        Q.el.addEventListener(evt,this.touchDispatchHandler);
      },this);

      this.touchEnabled = true;
    },

    /**
     * Turn off touch (buytton and joypad) controls and remove event listeners
     *
     * @method disableTouchControls
     * @for Q.InputSystem
     */
    disableTouchControls: function() {
      Q._each(["touchstart","touchend","touchmove","touchcancel"],function(evt) {
        Q.el.removeEventListener(evt,this.touchDispatchHandler);
      },this);

      Q.el.removeEventListener('touchstart',this.joypadStart);
      Q.el.removeEventListener('touchmove',this.joypadMove);
      Q.el.removeEventListener('touchend',this.joypadEnd);
      Q.el.removeEventListener('touchcancel',this.joypadEnd);
      this.touchEnabled = false;

      // clear existing inputs
      for(var input in Q.inputs) {
        Q.inputs[input] = false;
      }
    },

    /** 
     * Activate joypad controls (i.e. 4-way touch controls)
     *
     * Lots of options, defaults are:
     * 
     *     {
     *      size: 50,
     *      trigger: 20,
     *      center: 25,
     *      color: "#CCC",
     *      background: "#000",
     *      alpha: 0.5,
     *      zone: Q.width / 2,
     *      inputs: DEFAULT_JOYPAD_INPUTS
     *    }
     *
     *  Default joypad controls is an array that defines the inputs to bind to:
     *
     *       // Clockwise from midnight (a la CSS)
     *       var DEFAULT_JOYPAD_INPUTS =  [ 'up','right','down','left'];
     *
     * @method joypadControls
     * @for Q.InputSystem
     * @param {Object} [opts] -  joypad options
     */
   joypadControls: function(opts) {
      if(this.joypadEnabled) { return false; }
      if(!hasTouch) { return false; }

      var joypad = Q.joypad = Q._defaults(opts || {},{
        size: 50,
        trigger: 20,
        center: 25,
        color: "#CCC",
        background: "#000",
        alpha: 0.5,
        zone: Q.width / 2,
        joypadTouch: null,
        inputs: DEFAULT_JOYPAD_INPUTS,
        triggers: []
      });

      this.joypadStart = function(evt) {
        if(joypad.joypadTouch === null) {
          var touch = evt.changedTouches[0],
              loc = Q.input.touchLocation(touch);

          if(loc.x < joypad.zone) {
            joypad.joypadTouch = touch.identifier;
            joypad.centerX = loc.x;
            joypad.centerY = loc.y; 
            joypad.x = null;
            joypad.y = null;
          }
        }
      };

      
      this.joypadMove = function(e) {
        if(joypad.joypadTouch !== null) {
          var evt = e;

          for(var i=0,len=evt.changedTouches.length;i<len;i++) {
            var touch = evt.changedTouches[i];

            if(touch.identifier === joypad.joypadTouch) {
              var loc = Q.input.touchLocation(touch),
                  dx = loc.x - joypad.centerX,
                  dy = loc.y - joypad.centerY,
                  dist = Math.sqrt(dx * dx + dy * dy),
                  overage = Math.max(1,dist / joypad.size),
                  ang =  Math.atan2(dx,dy);

              if(overage > 1) {
                dx /= overage;
                dy /= overage;
                dist /= overage;
              }

              var triggers = [
                dy < -joypad.trigger,
                dx > joypad.trigger,
                dy > joypad.trigger,
                dx < -joypad.trigger
              ];

              for(var k=0;k<triggers.length;k++) {
                var actionName = joypad.inputs[k];
                if(triggers[k]) {
                  Q.inputs[actionName] = true;

                  if(!joypad.triggers[k]) { 
                    Q.input.trigger(actionName);
                  }
                } else {
                  Q.inputs[actionName] = false;
                  if(joypad.triggers[k]) { 
                    Q.input.trigger(actionName + "Up");
                  }
                }
              }

              Q._extend(joypad, {
                dx: dx, dy: dy,
                x: joypad.centerX + dx,
                y: joypad.centerY + dy,
                dist: dist,
                ang: ang,
                triggers: triggers
              });

              break;
            }
          }
        }
        e.preventDefault();
      };

      this.joypadEnd = function(e) { 
          var evt = e;

          if(joypad.joypadTouch !== null) {
            for(var i=0,len=evt.changedTouches.length;i<len;i++) { 
            var touch = evt.changedTouches[i];
              if(touch.identifier === joypad.joypadTouch) {
                for(var k=0;k<joypad.triggers.length;k++) {
                  var actionName = joypad.inputs[k];
                  Q.inputs[actionName] = false;
                    if(joypad.triggers[k]) {
                        Q.input.trigger(actionName + "Up");
                    }
                }
                joypad.joypadTouch = null;
                break;
              }
            }
          }
          e.preventDefault();
      };

      Q.el.addEventListener("touchstart",this.joypadStart);
      Q.el.addEventListener("touchmove",this.joypadMove);
      Q.el.addEventListener("touchend",this.joypadEnd);
      Q.el.addEventListener("touchcancel",this.joypadEnd);

      this.joypadEnabled = true;
    },

    /**
     * Activate mouse controls - mouse controls don't trigger events, but just set `Q.inputs['mouseX']` & `Q.inputs['mouseY']` on each frame.
     *
     * Default options:
     *
     *     {
     *       stageNum: 0,
     *       mouseX: "mouseX",
     *       mouseY: "mouseY",
     *       cursor: "off"
     *     }
     *
     * @method mouseControls
     * @for Q.InputSystem
     * @param {Object} [options] - override default options
     */
    mouseControls: function(options) {
      options = options || {};

      var stageNum = options.stageNum || 0;
      var mouseInputX = options.mouseX || "mouseX";
      var mouseInputY = options.mouseY || "mouseY";
      var cursor = options.cursor || "off";

      var mouseMoveObj = {};

      if(cursor !== "on") {
          if(cursor === "off") {
              Q.el.style.cursor = 'none';
          }
          else {
              Q.el.style.cursor = cursor;
          }
      }

      Q.inputs[mouseInputX] = 0;
      Q.inputs[mouseInputY] = 0;

      Q._mouseMove = function(e) {
        e.preventDefault();
        var touch = e.touches ? e.touches[0] : e;
        var el = Q.el, 
            posX = touch.offsetX,
            posY = touch.offsetY,
            eX, eY,
            stage = Q.stage(stageNum);

        if(Q._isUndefined(posX) || Q._isUndefined(posY)) {
          posX = touch.layerX;
          posY = touch.layerY;
        }

        if(Q._isUndefined(posX) || Q._isUndefined(posY)) {
          if(Q.input.offsetX === void 0) { Q.input._containerOffset(); }
          posX = touch.pageX - Q.input.offsetX;
          posY = touch.pageY - Q.input.offsetY;
        }

        if(stage) {
          mouseMoveObj.x= Q.canvasToStageX(posX,stage);
          mouseMoveObj.y= Q.canvasToStageY(posY,stage);

          Q.inputs[mouseInputX] = mouseMoveObj.x;
          Q.inputs[mouseInputY] = mouseMoveObj.y;

          Q.input.trigger('mouseMove',mouseMoveObj);
        }
      };

      Q.el.addEventListener('mousemove',Q._mouseMove,true);
      Q.el.addEventListener('touchstart',Q._mouseMove,true);
      Q.el.addEventListener('touchmove',Q._mouseMove,true);
    },

    /**
     * Turn off mouse controls
     *
     * @method disableMouseControls
     * @for Q.InputSystem
     */
    disableMouseControls: function() {
      if(Q._mouseMove) {
        Q.el.removeEventListener("mousemove",Q._mouseMove, true);
        Q.el.style.cursor = 'inherit';
        Q._mouseMove = null;
      }
    },

    /** 
     * Draw the touch buttons on the screen
     *
     * overload this to change how buttons are drawn
     *
     * @method drawButtons
     * @for Q.InputSystem
     */
    drawButtons: function() {
      var keypad = Q.input.keypad,
          ctx = Q.ctx;

      ctx.save();
      ctx.textAlign = "center"; 
      ctx.textBaseline = "middle";

      for(var i=0;i<keypad.controls.length;i++) {
        var control = keypad.controls[i];

        if(control[0]) {
          ctx.font = "bold " + (keypad.size/2) + "px arial";
          var x = keypad.left + i * keypad.unit + keypad.gutter,
              y = keypad.bottom - keypad.unit,
              key = Q.inputs[control[0]];

          ctx.fillStyle = keypad.color || "#FFFFFF";
          ctx.globalAlpha = key ? 1.0 : 0.5;
          ctx.fillRect(x,y,keypad.size,keypad.size);

          ctx.fillStyle = keypad.text || "#000000";
          ctx.fillText(control[1],
                       x+keypad.size/2,
                       y+keypad.size/2);
        }
      }

      ctx.restore();
    },

    drawCircle: function(x,y,color,size) {
      var ctx = Q.ctx,
          joypad = Q.joypad;

      ctx.save();
      ctx.beginPath();
      ctx.globalAlpha=joypad.alpha;
      ctx.fillStyle = color;
      ctx.arc(x, y, size, 0, Math.PI*2, true); 
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    },



    /** 
     * Draw the joypad on the screen
     *
     * overload this to change how joypad is drawn
     *
     * @method drawJoypad
     * @for Q.InputSystem
     */
    drawJoypad: function() {
      var joypad = Q.joypad;
      if(joypad.joypadTouch !== null) {
        Q.input.drawCircle(joypad.centerX,
                           joypad.centerY,
                           joypad.background,
                           joypad.size);

        if(joypad.x !== null) {
          Q.input.drawCircle(joypad.x,
                           joypad.y,
                           joypad.color,
                           joypad.center);
        }
      }

    },

    /** 
     * Called each frame by the stage game loop to render any onscreen UI
     *
     * calls `drawJoypad` and `drawButtons` if enabled
     *
     * @method drawCanvas
     * @for Q.InputSystem
     */
    drawCanvas: function() {
      if(this.touchEnabled) {
        this.drawButtons();
      }

      if(this.joypadEnabled) {
        this.drawJoypad();
      }
    }


  });
  
  /**
   * Instance of the input subsytem that is actually used during gameplay
   *
   * @property Q.input
   * @for Quintus.Input
   * @type Q.InputSystem
   */
  Q.input = new Q.InputSystem();

  /**
   * Helper method to activate controls with default options
   *
   * @for Quintus.Input
   * @method Q.controls
   * @param {Boolean} joypad - enable 4-way joypad (true) or just left, right controls (false, undefined)
   */
  Q.controls = function(joypad) {
    Q.input.keyboardControls();

    if(joypad) {
      Q.input.touchControls({
        controls: [ [],[],[],['action','b'],['fire','a']]
      });
      Q.input.joypadControls();
    } else {
      Q.input.touchControls();
    }

    return Q;
  };
  

  /**
   * Platformer Control Component
   *
   * Adds 2D platformer controls onto a Sprite
   *
   * Platformer controls bind to left, and right and allow the player to jump. 
   *
   * Adds the following properties to the entity to control speed and jumping:
   *
   *      { 
   *        speed: 200,
   *        jumpSpeed: -300
   *      }
   *
   *
   * @class platformerControls
   * @for Quintus.Input
   */
  Q.component("platformerControls", {
    defaults: {
      speed: 200,
      jumpSpeed: -300,
      collisions: []
    },

    added: function() {
      var p = this.entity.p;

      Q._defaults(p,this.defaults);

      this.entity.on("step",this,"step");
      this.entity.on("bump.bottom",this,"landed");

      p.landed = 0;
      p.direction ='right';
    },

    landed: function(col) {
      var p = this.entity.p;
      p.landed = 1/5;
    },

    step: function(dt) {
      var p = this.entity.p;
      
      if(p.ignoreControls === undefined || !p.ignoreControls) {
        var collision = null;
        
        // Follow along the current slope, if possible.
        if(p.collisions !== undefined && p.collisions.length > 0 && (Q.inputs['left'] || Q.inputs['right'] || p.landed > 0)) {
          if(p.collisions.length === 1) {
            collision = p.collisions[0];
          } else {
            // If there's more than one possible slope, follow slope with negative Y normal
            collision = null;

            for(var i = 0; i < p.collisions.length; i++) {
              if(p.collisions[i].normalY < 0) {
                collision = p.collisions[i];
              }
            }          
          }
          
          // Don't climb up walls.      
          if(collision !== null && collision.normalY > -0.3 && collision.normalY < 0.3) {        
            collision = null;
          }        
        }      

        if(Q.inputs['left']) {
          p.direction = 'left';
          if(collision && p.landed > 0) {
            p.vx = p.speed * collision.normalY;
            p.vy = -p.speed * collision.normalX;
          } else {
            p.vx = -p.speed;
          }        
        } else if(Q.inputs['right']) {
          p.direction = 'right';
          if(collision && p.landed > 0) {
            p.vx = -p.speed * collision.normalY;
            p.vy = p.speed * collision.normalX;          
          } else {
            p.vx = p.speed;
          }
        } else {
          p.vx = 0;
          if(collision && p.landed > 0) {
            p.vy = 0;
          }
        }
        
        if(p.landed > 0 && (Q.inputs['up'] || Q.inputs['action']) && !p.jumping) {
          p.vy = p.jumpSpeed;
          p.landed = -dt;
          p.jumping = true;
        } else if(Q.inputs['up'] || Q.inputs['action']) {
          this.entity.trigger('jump', this.entity);
          p.jumping = true;
        }
        
        if(p.jumping && !(Q.inputs['up'] || Q.inputs['action'])) {
          p.jumping = false;
          this.entity.trigger('jumped', this.entity);
          if(p.vy < p.jumpSpeed / 3) {
            p.vy = p.jumpSpeed / 3;
          }
        }
      }
      p.landed -= dt;
    }
  });


  /**
   * Step Controls component
   *
   * Adds Step (square grid based) 4-ways controls onto a Sprite
   *
   * Adds the following properties to the entity:
   *
   *      { 
   *        stepDistance: 32, // should be tile size
   *        stepDelay: 0.2  // seconds to delay before next step
   *      }
   *
   *
   * @class stepControls
   * @for Quintus.Input
   */
  Q.component("stepControls", {

    added: function() {
      var p = this.entity.p;

      if(!p.stepDistance) { p.stepDistance = 32; }
      if(!p.stepDelay) { p.stepDelay = 0.2; }

      p.stepWait = 0;
      this.entity.on("step",this,"step");
      this.entity.on("hit", this,"collision");
    },

    collision: function(col) {
      var p = this.entity.p;

      if(p.stepping) {
        p.stepping = false;
        p.x = p.origX;
        p.y = p.origY;
      }

    },

    step: function(dt) {
      var p = this.entity.p,
          moved = false;
      p.stepWait -= dt;

      if(p.stepping) {
        p.x += p.diffX * dt / p.stepDelay;
        p.y += p.diffY * dt / p.stepDelay;
      }

      if(p.stepWait > 0) { return; }
      if(p.stepping) {
        p.x = p.destX;
        p.y = p.destY;
      }
      p.stepping = false;

      p.diffX = 0;
      p.diffY = 0;

      if(Q.inputs['left']) {
        p.diffX = -p.stepDistance;
      } else if(Q.inputs['right']) {
        p.diffX = p.stepDistance;
      }

      if(Q.inputs['up']) {
        p.diffY = -p.stepDistance;
      } else if(Q.inputs['down']) {
        p.diffY = p.stepDistance;
      }

      if(p.diffY || p.diffX ) { 
        p.stepping = true;
        p.origX = p.x;
        p.origY = p.y;
        p.destX = p.x + p.diffX;
        p.destY = p.y + p.diffY;
        p.stepWait = p.stepDelay; 
      }

    }

  });
};



/***/ }),

/***/ "./node_modules/quintus/lib/quintus_scenes.js":
/*!****************************************************!*\
  !*** ./node_modules/quintus/lib/quintus_scenes.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */

/**
Quintus HTML5 Game Engine - Scenes Module

The code in `quintus_scenes.js` defines the `Quintus.Scenes` module, which
adds in support for Scenes and Stages into Quintus. 

Depends on the `Quintus.Sprite` module.

Scenes let you create reusable definitions for setting up levels and screens.

Stages are the primary container object in Quintus, handling Sprite management,
stepping, rendering and collision detection.

@module Quintus.Scenes
*/

/** 
 * Quintus Scenes Module Class
 *
 * @class Quintus.Scenes
 */
module.exports = function(Q) {

  Q.scenes = {};
  Q.stages = [];


  /** 
   Basic scene class, consisting primarily of a scene function 
   and some options that are passed to the stage.

   Should be instantiated by calling `Q.scene` not new

   @class Q.Scene
   @for Quintus.Scenes
  */
  Q.Class.extend('Scene',{
    init: function(sceneFunc,opts) {
      this.opts = opts || {};
      this.sceneFunc = sceneFunc;
    }
  });

  /**
   Set up a new scene or return an existing scene. If you don't pass in `sceneFunc`, 
   it'll return a scene otherwise it'll create a new one.

   @method Q.scene
   @for Quintus.Scenes
   @param {String} name - name of scene to create or return
   @param {Function} [sceneFunc] - scene function: `function(stage) { .. }` that sets up the stage
  */
  Q.scene = function(name,sceneFunc,opts) {
    if(sceneFunc === void 0) {
      return Q.scenes[name];
    } else {
      if(Q._isFunction(sceneFunc)) {
        sceneFunc = new Q.Scene(sceneFunc,opts);
        sceneFunc.name = name;
      }
      Q.scenes[name] = sceneFunc;
      return sceneFunc;
    }
  };

  Q._nullContainer = {
    c: {
      x: 0,
      y: 0,
      angle: 0,
      scale: 1
    },
    matrix: Q.matrix2d()
  };

 
  /**
   SAT collision detection between two objects
   Thanks to doc's at: http://www.sevenson.com.au/actionscript/sat/

   This is sort of a black box - use the methods on stage like `search` and `collide` to
   run the collision system.

   @property Q.collision
   @for Quintus.Scenes
  */
  Q.collision = (function() { 
    var normalX, normalY,
        offset = [ 0,0 ],
        result1 = { separate: [] },
        result2 = { separate: [] };

    function calculateNormal(points,idx) {
      var pt1 = points[idx],
          pt2 = points[idx+1] || points[0];

      normalX = -(pt2[1] - pt1[1]);
      normalY = pt2[0] - pt1[0];

      var dist = Math.sqrt(normalX*normalX + normalY*normalY);
      if(dist > 0) {
        normalX /= dist;
        normalY /= dist;
      }
    }

    function dotProductAgainstNormal(point) {
      return (normalX * point[0]) + (normalY * point[1]);

    }

    function collide(o1,o2,flip) {
      var min1,max1,
          min2,max2,
          d1, d2,
          offsetLength,
          tmp, i, j,
          minDist, minDistAbs,
          shortestDist = Number.POSITIVE_INFINITY,
          collided = false,
          p1, p2;

      var result = flip ? result2 : result1;

      offset[0] = 0; //o1.x + o1.cx - o2.x - o2.cx;
      offset[1] = 0; //o1.y + o1.cy - o2.y - o2.cy;

      // If we have a position matrix, just use those points,
      if(o1.c) {
        p1 = o1.c.points;
      } else {
        p1 = o1.p.points;
        offset[0] += o1.p.x;
        offset[1] += o1.p.y;
      }

      if(o2.c) {
        p2 = o2.c.points;
      } else {
        p2 = o2.p.points;
        offset[0] += -o2.p.x;
        offset[1] += -o2.p.y; 
      }

      o1 = o1.p;
      o2 = o2.p;


      for(i = 0;i<p1.length;i++) {
        calculateNormal(p1,i);

        min1 = dotProductAgainstNormal(p1[0]);
        max1 = min1;

        for(j = 1; j<p1.length;j++) {
          tmp = dotProductAgainstNormal(p1[j]);
          if(tmp < min1) { min1 = tmp; }
          if(tmp > max1) { max1 = tmp; }
        }

        min2 = dotProductAgainstNormal(p2[0]);
        max2 = min2;

        for(j = 1;j<p2.length;j++) {
          tmp = dotProductAgainstNormal(p2[j]);
          if(tmp < min2) { min2 = tmp; }
          if(tmp > max2) { max2 = tmp; }
        }

        offsetLength = dotProductAgainstNormal(offset);
        min1 += offsetLength;
        max1 += offsetLength;

        d1 = min1 - max2;
        d2 = min2 - max1;

        if(d1 > 0 || d2 > 0) { return null; }

        minDist = (max2 - min1) * -1;
        if(flip) { minDist *= -1; }

        minDistAbs = Math.abs(minDist);

        if(minDistAbs < shortestDist) {
          result.distance = minDist;
          result.magnitude = minDistAbs;
          result.normalX = normalX;
          result.normalY = normalY;

          if(result.distance > 0) {
            result.distance *= -1;
            result.normalX *= -1;
            result.normalY *= -1;
          }

          collided = true;
          shortestDist = minDistAbs;
        }
      }

      // Do return the actual collision
      return collided ? result : null;
    }

    function satCollision(o1,o2) {
      var result1, result2, result;

      if(!o1.p.points) { Q._generatePoints(o1); }
      if(!o2.p.points) { Q._generatePoints(o2); }

      result1 = collide(o1,o2);
      if(!result1) { return false; }

      result2 = collide(o2,o1,true);
      if(!result2) { return false; }

      result = (result2.magnitude < result1.magnitude) ? result2 : result1;

      if(result.magnitude === 0) { return false; }
      result.separate[0] = result.distance * result.normalX;
      result.separate[1] = result.distance * result.normalY;

      return result;
    }

    return satCollision;
  }());


  /**
   Check for the overlap of the boudning boxes of two Sprites

   @method Q.overlap
   @for Quintus.Scenes
   @param {Q.Sprite} o1
   @param {Q.Sprite} o2
   @returns {Boolean}
  */
  Q.overlap = function(o1,o2) {
    var c1 = o1.c || o1.p || o1;
    var c2 = o2.c || o2.p || o2;

    var o1x = c1.x - (c1.cx || 0),
        o1y = c1.y - (c1.cy || 0);
    var o2x = c2.x - (c2.cx || 0),
        o2y = c2.y - (c2.cy || 0);

    return !((o1y+c1.h<o2y) || (o1y>o2y+c2.h) ||
             (o1x+c1.w<o2x) || (o1x>o2x+c2.w));
  };

  /**
   Base stage class, responsible for managing sets of sprites.

   `Q.Stage`'s aren't generally instantiated directly, but rather are created
   automatically when you call `Q.stageScene('sceneName')`

   @class Q.Stage
   @extends Q.GameObject
   @for Quintus.Scenes
  */
  Q.Stage = Q.GameObject.extend({
    // Should know whether or not the stage is paused
    defaults: {
      sort: false,
      gridW: 400,
      gridH: 400,
      x: 0,
      y: 0
    },

    init: function(scene,opts) {
      this.scene = scene;
      this.items = [];
      this.lists = {};
      this.index = {};
      this.removeList = [];
      this.grid = {};
      this._collisionLayers = [];

      this.time = 0;

      this.defaults['w'] = Q.width;
      this.defaults['h'] = Q.height;

      this.options = Q._extend({},this.defaults);
      if(this.scene)  { 
        Q._extend(this.options,scene.opts);
      }
      if(opts) { Q._extend(this.options,opts); }


      if(this.options.sort && !Q._isFunction(this.options.sort)) {
          this.options.sort = function(a,b) { return ((a.p && a.p.z) || -1) - ((b.p && b.p.z) || -1); };
      }
    },

    destroyed: function() {
      this.invoke("debind");
      this.trigger("destroyed");
    },

    // Needs to be separated out so the current stage can be set
    loadScene: function() {
      if(this.scene)  { 
        this.scene.sceneFunc(this);
      }
    },

    /**
      Load an array of assets of the form:

          [ [ "Player", { x: 15, y: 54 } ],
            [ "Enemy",  { x: 54, y: 42 } ] ]

      Either pass in the array or a string of asset name

     @method loadAssets
     @param {Array or String} asset - Array of assets or a string of asset name
     @for Q.Stage
    */
    // Load an array of assets of the form:
    // [ [ "Player", { x: 15, y: 54 } ],
    //   [ "Enemy",  { x: 54, y: 42 } ] ]
    // Either pass in the array or a string of asset name
    loadAssets: function(asset) {
      var assetArray = Q._isArray(asset) ? asset : Q.asset(asset);
      for(var i=0;i<assetArray.length;i++) {
        var spriteClass = assetArray[i][0];
        var spriteProps = assetArray[i][1];
        this.insert(new Q[spriteClass](spriteProps));
      }
    },

    /**
     executes the callback for each item in the scene

     @method each
     @param {function} callback
     @for Q.Stage
    */
    each: function(callback) {
      for(var i=0,len=this.items.length;i<len;i++) {
        callback.call(this.items[i],arguments[1],arguments[2]);
      }
    },

    /**
     invokes a functioncall for each item in the scene

     @method invoke
     @param {function} funcName
     @for Q.Stage
    */
    invoke: function(funcName) {
      for(var i=0,len=this.items.length;i<len;i++) {              
        this.items[i][funcName].call(
          this.items[i],arguments[1],arguments[2]
        );
      }
    },

    /**

     @method detect
     @param {function} func
     @for Q.Stage
    */
    detect: function(func) {
      for(var i = this.items.length-1;i >= 0; i--) {
        if(func.call(this.items[i],arguments[1],arguments[2],arguments[3])) {
          return this.items[i];
        }
      }
      return false;
    },


    /**

     @method identify
     @param {function} func
     @for Q.Stage
    */
    identify: function(func) {
      var result;
      for(var i = this.items.length-1;i >= 0; i--) {
        if(result = func.call(this.items[i],arguments[1],arguments[2],arguments[3])) {
          return result;
        }
      }
      return false;
    },

    /**

     @method find
     @param {Number or String} id
     @for Q.Stage
    */
    find: function(id) {
      return this.index[id];
    },

    addToLists: function(lists,object) {
      for(var i=0;i<lists.length;i++) {
        this.addToList(lists[i],object);
      }
    },

    addToList: function(list, itm) {
      if(!this.lists[list]) { this.lists[list] = []; }
      this.lists[list].push(itm);
    },


    removeFromLists: function(lists, itm) {
      for(var i=0;i<lists.length;i++) {
        this.removeFromList(lists[i],itm);
      }
    },

    removeFromList: function(list, itm) {
      var listIndex = this.lists[list].indexOf(itm);
      if(listIndex !== -1) { 
        this.lists[list].splice(listIndex,1);
      }
    },

    /**
     Inserts an item directly into the scene, or inside a container.
     The object can later accessed via `children` property of the scene or the container.

     @method insert
     @for Q.Stage
     @param {Q.GameObject} itm - the Item to insert
     @param [container] - `container` to add the item to
     @return the inserted object for chaining
    */
    insert: function(itm,container) {
      this.items.push(itm);
      itm.stage = this;
      itm.container = container;
      if(container) {
        container.children.push(itm);
      }

      itm.grid = {};


      // Make sure we have a square of collision points
      Q._generatePoints(itm);
      Q._generateCollisionPoints(itm);

      
      if(itm.className) { this.addToList(itm.className, itm); }
      if(itm.activeComponents) { this.addToLists(itm.activeComponents, itm); }

      if(itm.p) {
        this.index[itm.p.id] = itm;
      }
      this.trigger('inserted',itm);
      itm.trigger('inserted',this);

      this.regrid(itm);
      return itm;
    },

    /**
     Removes an item from the scene.

     @method remove
     @param {Q.GameObject} itm - the Item to remove
     @for Q.Stage
    */
    remove: function(itm) {
      this.delGrid(itm);
      this.removeList.push(itm);
    },

    forceRemove: function(itm) {
      var idx =  this.items.indexOf(itm);
      if(idx !== -1) { 
        this.items.splice(idx,1);

        if(itm.className) { this.removeFromList(itm.className,itm); }
        if(itm.activeComponents) { this.removeFromLists(itm.activeComponents,itm); }
        if(itm.container) {
          var containerIdx = itm.container.children.indexOf(itm);
          if(containerIdx !== -1) {
            itm.container.children.splice(containerIdx,1);
          }
        }

        if(itm.destroy) { itm.destroy(); }
        if(itm.p.id) {
          delete this.index[itm.p.id];
        }
        this.trigger('removed',itm);
      }
    },

    /**
     Pauses the scene, sprites will no longer be stepped but still rendered.

     @method pause
     @for Q.Stage
    */
    pause: function() {
      this.paused = true;
    },

    /**
     Unpauses the scene.

     @method unpause
     @for Q.Stage
    */
    unpause: function() {
      this.paused = false;
    },

    _gridCellCheck: function(type,id,obj,collisionMask) {
      if(Q._isUndefined(collisionMask) || collisionMask & type) {
        var obj2 = this.index[id];
        if(obj2 && obj2 !== obj && Q.overlap(obj,obj2)) {
          var col= Q.collision(obj,obj2);
          if(col) {
            col.obj = obj2;
            return col;
          } else {
            return false;
          }
        }
      }
    },

    gridTest: function(obj,collisionMask) {
      var grid = obj.grid, gridCell, col;

      for(var y = grid.Y1;y <= grid.Y2;y++) {
        if(this.grid[y]) {
          for(var x = grid.X1;x <= grid.X2;x++) {
            gridCell = this.grid[y][x];
            if(gridCell) { 
              col = Q._detect(gridCell,this._gridCellCheck,this,obj,collisionMask);
              if(col) { return col; }
            }
          }
        }
      }
      return false;
    },

    collisionLayer: function(layer) {
      this._collisionLayers.push(layer);
      layer.collisionLayer = true;
      return this.insert(layer);
    },
    
    _collideCollisionLayer: function(obj,collisionMask) {
      var col;

      for(var i = 0,max = this._collisionLayers.length;i < max;i++) {
        var layer = this._collisionLayers[i];
        if(layer.p.type & collisionMask) {
          col = layer.collide(obj);
          if(col) { col.obj = layer;  return col; }
        }
      }
      return false;
    },

    /**
     Searches the scene for an object.

     @method search
     @param obj
     @param [collisionMask] -
     @for Q.Stage
    */
    search: function(obj,collisionMask) {
      var col;

      // If the object doesn't have a grid, regrid it
      // so we know where to search
      // and skip adding it to the grid only if it's not on this stage
      if(!obj.grid) { this.regrid(obj,obj.stage !== this); }

      collisionMask = Q._isUndefined(collisionMask) ? (obj.p && obj.p.collisionMask) : collisionMask;

      col = this._collideCollisionLayer(obj,collisionMask);
      col =  col || this.gridTest(obj,collisionMask);
      return col;
    },

    _locateObj: {
      p: { 
        x: 0,
        y: 0,
        cx: 0,
        cy: 0,
        w: 1,
        h: 1
      }, grid: {}
    },

    /**
     Finds any object that collides with the point x,y on the stage (not on the canvas).
     If `collisionMask` is used, only checks for collisions with sprites of that type.

     @method locate
     @param {number} x
     @param {number} y
     @param [collisionMask] - type of the sprite
     @return the object if one is found or false
     @for Q.Stage
    */
    locate: function(x,y,collisionMask) {
      var col = null;

      this._locateObj.p.x = x;
      this._locateObj.p.y = y;

      this.regrid(this._locateObj,true);

      col = this._collideCollisionLayer(this._locateObj,collisionMask);
      col =  col || this.gridTest(this._locateObj,collisionMask);

      if(col && col.obj) {
        return col.obj;
      } else {
        return false;
      }

    },

    /**
     calculates if the given object collides with anything in the scene

     @method collide
     @param {Object} obj - the object on that the collisions should be checked
     @param {Object} [options] - collisionsMask, maxCol, skipEvents to overwrite from obj
     @return col2 || col
     @for Q.Stage
    */
    collide: function(obj,options) {
      var col, col2, collisionMask, 
          maxCol, curCol, skipEvents;
      if(Q._isObject(options)) {
        collisionMask = options.collisionMask;
        maxCol = options.maxCol;
        skipEvents = options.skipEvents;
      } else {
        collisionMask = options;
      }
      collisionMask = Q._isUndefined(collisionMask) ? (obj.p && obj.p.collisionMask) : collisionMask;
      maxCol = maxCol || 3;


      Q._generateCollisionPoints(obj);
      this.regrid(obj);

      curCol = maxCol;
      while(curCol > 0 && (col = this._collideCollisionLayer(obj,collisionMask))) {
        if(!skipEvents) { 
          obj.trigger('hit',col);
          obj.trigger('hit.collision',col);
        }
        Q._generateCollisionPoints(obj);
        this.regrid(obj);
        curCol--;
      }

      curCol = maxCol;
      while(curCol > 0 && (col2 = this.gridTest(obj,collisionMask))) {
        obj.trigger('hit',col2);
        obj.trigger('hit.sprite',col2);

        // Do the recipricol collision
        // TODO: extract
        if(!skipEvents) { 
          var obj2 = col2.obj;
          col2.obj = obj;
          col2.normalX *= -1;
          col2.normalY *= -1;
          col2.distance = 0;
          col2.magnitude = 0;
          col2.separate[0] = 0;
          col2.separate[1] = 0;

          
          obj2.trigger('hit',col2);
          obj2.trigger('hit.sprite',col2);
        }

        Q._generateCollisionPoints(obj);
        this.regrid(obj);
        curCol--;
      }

      return col2 || col;
    },

    delGrid: function(item) {
      var grid = item.grid;

      for(var y = grid.Y1;y <= grid.Y2;y++) {
        if(this.grid[y]) {
          for(var x = grid.X1;x <= grid.X2;x++) {
            if(this.grid[y][x]) {
            delete this.grid[y][x][item.p.id];
            }
          }
        }
      }
    },

    addGrid: function(item) {
      var grid = item.grid;

      for(var y = grid.Y1;y <= grid.Y2;y++) {
        if(!this.grid[y]) { this.grid[y] = {}; }
        for(var x = grid.X1;x <= grid.X2;x++) {
          if(!this.grid[y][x]) { this.grid[y][x] = {}; }
          this.grid[y][x][item.p.id] = item.p.type;
        }
      }

    },

    // Add an item into the collision detection grid,
    // Ignore collision layers
    regrid: function(item,skipAdd) {
      if(item.collisionLayer) { return; }
      item.grid = item.grid || {};

      var c = item.c || item.p;

      var gridX1 = Math.floor((c.x - c.cx) / this.options.gridW),
          gridY1 = Math.floor((c.y - c.cy) / this.options.gridH),
          gridX2 = Math.floor((c.x - c.cx + c.w) / this.options.gridW),
          gridY2 = Math.floor((c.y - c.cy + c.h) / this.options.gridH),
          grid = item.grid;

      if(grid.X1 !== gridX1 || grid.X2 !== gridX2 || 
         grid.Y1 !== gridY1 || grid.Y2 !== gridY2) {

         if(grid.X1 !== void 0) { this.delGrid(item); }
         grid.X1 = gridX1;
         grid.X2 = gridX2;
         grid.Y1 = gridY1;
         grid.Y2 = gridY2;

         if(!skipAdd) { this.addGrid(item); }
      }
    },
    
    markSprites: function(items,time) {
      var viewport = this.viewport,
          scale = viewport ? viewport.scale : 1,
          x = viewport ? viewport.x : 0,
          y = viewport ? viewport.y : 0,
          viewW = Q.width / scale,
          viewH = Q.height / scale,
          gridX1 = Math.floor(x / this.options.gridW),
          gridY1 = Math.floor(y / this.options.gridH),
          gridX2 = Math.floor((x + viewW) / this.options.gridW),
          gridY2 = Math.floor((y + viewH) / this.options.gridH),
          gridRow, gridBlock;

      for(var iy=gridY1; iy<=gridY2; iy++) {
        if((gridRow = this.grid[iy])) { 
          for(var ix=gridX1; ix<=gridX2; ix++) {
            if((gridBlock = gridRow[ix])) {
              for(var id in gridBlock) {
                if(this.index[id]) {
                  this.index[id].mark = time;
                  if(this.index[id].container) { this.index[id].container.mark = time; }
                }
              }
            }
          }
        }
      }
    },

    updateSprites: function(items,dt,isContainer) {
      var item;

      for(var i=0,len=items.length;i<len;i++) {              
        item = items[i];
        // If set to visible only, don't step if set to visibleOnly
        if(!isContainer && (item.p.visibleOnly && (!item.mark || item.mark < this.time))) { continue; }

        if(isContainer || !item.container) { 
          item.update(dt);
          Q._generateCollisionPoints(item);
          this.regrid(item);
        }
      }
    },



    step:function(dt) {
      if(this.paused) { return false; }

      this.time += dt;
      this.markSprites(this.items,this.time);

      this.trigger("prestep",dt);
      this.updateSprites(this.items,dt);
      this.trigger("step",dt);

      if(this.removeList.length > 0) {
        for(var i=0,len=this.removeList.length;i<len;i++) {
          this.forceRemove(this.removeList[i]);
        }
        this.removeList.length = 0;
      }

      this.trigger('poststep',dt);
    },

    /**
     Hides the scene.

     @method hide
     @for Q.Stage
    */
    hide: function() {
      this.hidden = true;
    },

    /**
     Unhides the scene.

     @method show
     @for Q.Stage
    */
    show: function() {
      this.hidden = false;
    },

    /**
     Stops the scene (hides and pauses).

     @method stop
     @for Q.Stage
    */
    stop: function() {
      this.hide();
      this.pause();
    },

    /**
     Starts the scene (shows and unpauses).

     @method start
     @for Q.Stage
    */
    start: function() {
      this.show();
      this.unpause();
    },

    render: function(ctx) {
      if(this.hidden) { return false; }
      if(this.options.sort) {
        this.items.sort(this.options.sort);
      }
      this.trigger("prerender",ctx);
      this.trigger("beforerender",ctx);

      for(var i=0,len=this.items.length;i<len;i++) {              
        var item = this.items[i];
        // Don't render sprites with containers (sprites do that themselves)
        // Also don't render if not onscreen
        if(!item.container && (item.p.renderAlways || item.mark >= this.time)) {
          item.render(ctx);
        }
      }
      this.trigger("render",ctx);
      this.trigger("postrender",ctx);
    }
  });

  Q.activeStage = 0;

  Q.StageSelector = Q.Class.extend({
    emptyList: [],

    init: function(stage,selector) {
      this.stage = stage;
      this.selector = selector;

      // Generate an object list from the selector
      // TODO: handle array selectors
      this.items = this.stage.lists[this.selector] || this.emptyList;
      this.length = this.items.length;
    },

    each: function(callback) {
      for(var i=0,len=this.items.length;i<len;i++) {
        callback.call(this.items[i],arguments[1],arguments[2]);
      }
      return this;
    },

    invoke: function(funcName) {
      for(var i=0,len=this.items.length;i<len;i++) {              
        this.items[i][funcName].call(
          this.items[i],arguments[1],arguments[2]
        );
      }
      return this;
    },

    trigger: function(name,params) {
      this.invoke("trigger",name,params);
    },

    destroy: function() {
      this.invoke("destroy");
    },

    detect: function(func) {
      for(var i = 0,val=null, len=this.items.length; i < len; i++) {
        if(func.call(this.items[i],arguments[1],arguments[2])) {
          return this.items[i];
        }
      }
      return false;
    },

    identify: function(func) {
      var result = null;
      for(var i = 0,val=null, len=this.items.length; i < len; i++) {
        if(result = func.call(this.items[i],arguments[1],arguments[2])) {
          return result;
        }
      }
      return false;

    },

    // This hidden utility method extends
    // and object's properties with a source object.
    // Used by the p method to set properties.
    _pObject: function(source) {
      Q._extend(this.p,source);
    },

    _pSingle: function(property,value) {
      this.p[property] = value;
    },

    set: function(property, value) {
      // Is value undefined
      if(value === void 0) {
        this.each(this._pObject,property);
      } else {
        this.each(this._pSingle,property,value);
      }

      return this;
    },

    at: function(idx) {
      return this.items[idx];
    },

    first: function() {
      return this.items[0];
    },

    last: function() {
      return this.items[this.items.length-1];
    }

  });

  // Maybe add support for different types
  // entity - active collision detection
  //  particle - no collision detection, no adding components to lists / etc
  //

  // Q("Player").invoke("shimmer); - needs to return a selector
  // Q(".happy").invoke("sasdfa",'fdsafas',"fasdfas");
  // Q("Enemy").p({ a: "asdfasf"  });

  Q.select = function(selector,scope) {
    scope = (scope === void 0) ? Q.activeStage : scope;
    scope = Q.stage(scope);
    if(Q._isNumber(selector)) {
      return scope.index[selector];
    } else {
      return new Q.StageSelector(scope,selector);
      // check if is array
      // check is has any commas
         // split into arrays
      // find each of the classes
      // find all the instances of a specific class
    }
  };

  /**
   Returns the default or currently active stage.
   If called from a sprites step() returns the stage that the sprite is member of
   If a number is passed in, this stages is returned
   *Warning* might return `undefined` if that stage doesnt exist!

   @method Q.stage
   @for Q
   @param {Number} num - number of the stage
   @return {Q.Stage} current, active, or numbered stage
  */
  Q.stage = function(num) {
    // Use activeStage is num is undefined
    num = (num === void 0) ? Q.activeStage : num;
    return Q.stages[num];
  };

  /**
   Stages a scene. `num` is like a z-index. Higher numbered stages render on top
   of lower numbered stages!

   @method Q.stageScene
   @param {Q.Scene or String} scene - a Q.Scene or the string for name of a scene
   @param {number} [num] - index
   @param {Object} options - some options
   @for Quintus
   */
  Q.stageScene = function(scene,num,options) {
    // If it's a string, find a registered scene by that name
    if(Q._isString(scene)) {
      scene = Q.scene(scene);
    }

    // If the user skipped the num arg and went straight to options,
    // swap the two and grab a default for num
    if(Q._isObject(num)) {
      options = num;
      num = Q._popProperty(options,"stage") || (scene && scene.opts.stage) || 0;
    }

    // Clone the options arg to prevent modification
    options = Q._clone(options);

    // Grab the stage class, pulling from options, the scene default, or use
    // the default stage
    var StageClass = (Q._popProperty(options,"stageClass")) || 
                     (scene && scene.opts.stageClass) || Q.Stage;

    // Figure out which stage to use
    num = Q._isUndefined(num) ? ((scene && scene.opts.stage) || 0) : num;

    // Clean up an existing stage if necessary
    if(Q.stages[num]) {
      Q.stages[num].destroy();
    }

    // Make this this the active stage and initialize the stage,
    // calling loadScene to popuplate the stage if we have a scene.
    Q.activeStage = num;
    var stage = Q.stages[num] = new StageClass(scene,options);

    // Load an assets object array
    if(stage.options.asset) {
      stage.loadAssets(stage.options.asset);
    }

    if(scene) {
      stage.loadScene();
    }
    Q.activeStage = 0;

    // If there's no loop active, run the default stageGameLoop
    if(!Q.loop) {
      Q.gameLoop(Q.stageGameLoop);
    }

    // Finally return the stage to the user for use if needed
    return stage;
  };

  Q.stageGameLoop = function(dt) {
    var i,len,stage;


    if(dt < 0) { dt = 1.0/60; }
    if(dt > 1/15) { dt  = 1.0/15; }

    for(i =0,len=Q.stages.length;i<len;i++) {
      Q.activeStage = i;
      stage = Q.stage();
      if(stage) {
        stage.step(dt);
      }
    }

    if(Q.ctx) { Q.clear(); }

    for(i =0,len=Q.stages.length;i<len;i++) {
      Q.activeStage = i;
      stage = Q.stage();
      if(stage) {
        stage.render(Q.ctx);
      }
    }

    Q.activeStage = 0;

    if(Q.input && Q.ctx) { Q.input.drawCanvas(Q.ctx); }
  };

  /**
   Destroys the stage with index `num`.

   @method clearStage
   @param {Number} num
   @for Q
  */
  Q.clearStage = function(num) {
    if(Q.stages[num]) { 
      Q.stages[num].destroy(); 
      Q.stages[num] = null;
    }
  };

  /**
   Destroys all stages.

   @method clearStages
   @for Q
  */
  Q.clearStages = function() {
    for(var i=0,len=Q.stages.length;i<len;i++) {
      if(Q.stages[i]) { Q.stages[i].destroy(); }
    }
    Q.stages.length = 0;
  };


};



/***/ }),

/***/ "./node_modules/quintus/lib/quintus_sprites.js":
/*!*****************************************************!*\
  !*** ./node_modules/quintus/lib/quintus_sprites.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */
/**
Quintus HTML5 Game Engine - Sprites Module

The code in `quintus_sprites.js` defines the `Quintus.Sprites` module, which
add support for sprite sheets and the base sprite class.

Most games will include at a minimum `Quintus.Sprites` and `Quintus.Scenes`

@module Quintus.Sprites
*/


/**
 * Quintus Sprites Module Class
 *
 * @class Quintus.Sprites
 */
module.exports = function(Q) {
 
  /**

  Sprite sheet class - generally instantiated with `Q.sheet` new `new`


  @class Q.SpriteSheet
  @extends Q.Class
  @for Quintus.Sprites
  */
  Q.Class.extend("SpriteSheet",{

    /**
    constructor

    Options:

      * tileW - tile width
      * tileH - tile height
      * w     - width of the sprite block
      * h     - height of the sprite block
      * sx    - start x
      * sy    - start y
      * spacingX - spacing between each tile x (after 1st)
      * spacingY - spacing between each tile y
      * marginX - margin around each tile x 
      * marginY - margin around each tile y
      * cols  - number of columns per row
    
    @constructor
    @for Q.SpriteSheet
    @method init
    @param {String} name
    @param {String} asset 
    @param {Object} options
    */
    init: function(name, asset,options) {
      if(!Q.asset(asset)) { throw "Invalid Asset:" + asset; }
      Q._extend(this,{
        name: name,
        asset: asset,
        w: Q.asset(asset).width,
        h: Q.asset(asset).height,
        tileW: 64,
        tileH: 64,
        sx: 0,
        sy: 0,
        spacingX: 0,
        spacingY: 0,
        frameProperties: {}
        });
      if(options) { Q._extend(this,options); }
      // fix for old tilew instead of tileW
      if(this.tilew) { 
        this.tileW = this.tilew; 
        delete this['tilew']; 
      }
      if(this.tileh) { 
        this.tileH = this.tileh; 
        delete this['tileh']; 
      }

      this.cols = this.cols || 
                  Math.floor(this.w / (this.tileW + this.spacingX));

      this.frames = this.cols * (Math.floor(this.h/(this.tileH + this.spacingY)));
    },

    /**
     Returns the starting x position of a single frame

     @method fx
     @for Q.SpriteSheet
     @param {Integer} frame
    */
    fx: function(frame) {
      return Math.floor((frame % this.cols) * (this.tileW + this.spacingX) + this.sx);
    },

    /**
     Returns the starting y position of a single frame

     @method fy
     @for Q.SpriteSheet
     @param {Integer} frame
    */
    fy: function(frame) {
      return Math.floor(Math.floor(frame / this.cols) * (this.tileH + this.spacingY) + this.sy);
    },

    /** 
     Draw a single frame at x,y on the provided context

     @method draw
     @for Q.SpriteSheet
     @param {Context2D} ctx
     @param {Float} x
     @param {Float} y
     @param {Integer} frame
    */
    draw: function(ctx, x, y, frame) {
      if(!ctx) { ctx = Q.ctx; }
      ctx.drawImage(Q.asset(this.asset),
                    this.fx(frame),this.fy(frame),
                    this.tileW, this.tileH,
                    Math.floor(x),Math.floor(y),
                    this.tileW, this.tileH);

    }

  });


  Q.sheets = {};

  /**
   Return a `Q.SpriteSheet` or  create a new sprite sheet

   @method Q.sheet
   @for Quintus.Sprites
   @param {String} name - name of sheet to return or create
   @param {String} [asset] - if provided, will create a sprite sheet using this asset
   @param {Object} [options] - if provided, will be passed as options to `Q.SpriteSheet`
  */
  Q.sheet = function(name,asset,options) {
    if(asset) {
      Q.sheets[name] = new Q.SpriteSheet(name,asset,options);
    } else {
      return Q.sheets[name];
    }
  };

  /**
   Create a number of `Q.SpriteSheet` objects from an image asset and a sprite data JSON asset

   @method Q.compileSheets
   @for Quintus.Sprites
   @param {String} imageAsset 
   @param {String spriteDataAsset
  */
  Q.compileSheets = function(imageAsset,spriteDataAsset) {
    var data = Q.asset(spriteDataAsset);
    Q._each(data,function(spriteData,name) {
      Q.sheet(name,imageAsset,spriteData);
    });
  };


  /**
   Bitmask 0 to indicate no sprites

   @property Q.SPRITE_NONE
   @for Quintus.Sprites
   @final
  */
  Q.SPRITE_NONE     = 0;

  /**
   default sprite type 1

   @property Q.SPRITE_DEFAULT
   @for Quintus.Sprites
   @final
  */
  Q.SPRITE_DEFAULT  = 1;

  /**
   particle sprite type 2

   @property Q.SPRITE_PARTICLE
   @for Quintus.Sprites
   @final
  */
  Q.SPRITE_PARTICLE = 2;

  /**
   active sprite type 4

   @property Q.SPRITE_ACTIVE
   @for Quintus.Sprites
   @final
  */
  Q.SPRITE_ACTIVE   = 4;

  /**
   friendly sprite type 8

   @property Q.SPRITE_FRIENDLY
   @for Quintus.Sprites
   @final
  */
  Q.SPRITE_FRIENDLY = 8;

  /**
   enemy sprite type 16

   @property Q.SPRITE_ENEMY
   @for Quintus.Sprites
   @final
  */
  Q.SPRITE_ENEMY    = 16;


  /**
   powerup sprite type 32

   @property Q.SPRITE_POWERUP
   @for Quintus.Sprites
   @final
  */
  Q.SPRITE_POWERUP  = 32;


  /**
   UI sprite type 64

   @property Q.SPRITE_UI
   @for Quintus.Sprites
   @final
  */
  Q.SPRITE_UI       = 64;

  /** 
   all sprite type - 0xFFFF

   @property Q.SPRITE_ALL
   @for Quintus.Sprites
   @final
  */
  Q.SPRITE_ALL   = 0xFFFF;


  /**
   generate a square set of  `p.points` on an object from `p.w` and `p.h`

   `p.points` represent the collision points for an object in object coordinates.


    @method q._generatePoints
    @for Quintus.Sprites
    @param {Q.Sprite} obj - object to add points to
    @param {Boolean} force - if set to true, will regenerate `p.points` even if it already exists, otherwise  if p.points exist it'll be left alone
  */
  Q._generatePoints = function(obj,force) {
    if(obj.p.points && !force) { return; }
    var p = obj.p,
        halfW = p.w/2,
        halfH = p.h/2;

    p.points = [ 
      [ -halfW, -halfH ],
      [  halfW, -halfH ],
      [  halfW,  halfH ],
      [ -halfW,  halfH ]
      ];
  };


  /**
   Generate a square set of  `c.points` on an object from the object transform matrix and `p.points`

   `c.points` represents the collision points of an sprite in world coordinates, scaled, rotate and taking into account any parent transforms.


    @method Q._generateCollisionPoints
    @for Quintus.Sprites
    @param {q.sprite} obj - object to add collision points to
  */
 Q._generateCollisionPoints = function(obj) {
    if(!obj.matrix && !obj.refreshMatrix) { return; }
    if(!obj.c) { obj.c = { points: [] }; }
    var p = obj.p, c = obj.c;

    if(!p.moved && 
       c.origX === p.x &&
       c.origY === p.y &&
       c.origScale === p.scale &&
       c.origAngle === p.angle) { 
        return;
    }

    c.origX = p.x;
    c.origY = p.y;
    c.origScale = p.scale;
    c.origAngle = p.angle;

    obj.refreshMatrix();

    var i;

    // Early out if we don't need to rotate / scale / deal with a container
    if(!obj.container && (!p.scale || p.scale === 1) && p.angle === 0) {
      for(i=0;i<obj.p.points.length;i++) {
        obj.c.points[i] = obj.c.points[i] || [];
        obj.c.points[i][0] = p.x + obj.p.points[i][0];
        obj.c.points[i][1] = p.y + obj.p.points[i][1];
      }
      c.x = p.x; c.y = p.y;
      c.cx = p.cx; c.cy = p.cy;
      c.w = p.w; c.h = p.h;
      return;
    }
    var container = obj.container || Q._nullContainer;

    c.x = container.matrix.transformX(p.x,p.y);
    c.y = container.matrix.transformY(p.x,p.y);
    c.angle = p.angle + container.c.angle;
    c.scale = (container.c.scale || 1) * (p.scale || 1);

    var minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    for(i=0;i<obj.p.points.length;i++) {
      if(!obj.c.points[i]) {
        obj.c.points[i] = [];
      }
      obj.matrix.transformArr(obj.p.points[i],obj.c.points[i]);
      var x = obj.c.points[i][0],
          y = obj.c.points[i][1];

          if(x < minX) { minX = x; }
          if(x > maxX) { maxX = x; }
          if(y < minY) { minY = y; }
          if(y > maxY) { maxY = y; }
    }

    if(minX === maxX) { maxX+=1; }
    if(minY === maxY) { maxY+=1; }

    c.cx = c.x - minX;
    c.cy = c.y - minY;

    c.w = maxX - minX;
    c.h = maxY - minY;

    // TODO: Invoke moved on children
  };
  
  
  /**
   
   Basic sprite class - will render either and asset or a frame from a sprite sheet.

   Auto sets the width and height (`p.w` and `p.h`) from the provided image asset and
   centers the sprite so 0,0 is the center of the provide image.

   Most of the times you'll sub-class `Q.Sprite` 

   @extends Q.GameObject
   @class Q.Sprite
   @for Quintus.Sprites
  */
  Q.GameObject.extend("Sprite",{

    /**
     
      Default sprite constructor, takes in a set of properties and a set of default properties (useful when you create a subclass of sprite)
     
      Default properties:

           {
            asset: null,  // asset to use
            sheet: null,  // sprite sheet to use (overrides asset)
            x: 0,
            y: 0,
            z: 0,
            w: 0,         // width, set from p.asset or p.sheet
            h: 0,         // height, set from p.asset or p.sheet
            cx: w/2,      // center x, defaults to center of the asset or sheet
            cy: h/2,      // center y, default same as cx
            // points defines the collision shape, override to customer the collision shape,
            // must be a convex polygon in clockwise order
            points: [  [ -w/2, -h/2 ], [  w/2, -h/2 ], [  w/2,  h/2 ], [ -w/2,  h/2 ] ],
            opacity: 1,
            angle: 0,
            frame: 0
            type:  Q.SPRITE_DEFAULT | Q.SPRITE_ACTIVE,
            name: '',
            sort: false,   // set to true to force children to be sorted by theier p.z,
            hidden: false,  // set to true to hide the sprite
            flip: ""       // set to "x", "y", or "xy" to flip sprite over that dimension
           }

      @method init
      @for Q.Sprite
      @param {Object} props - property has that will be turned into `p`
      @param {Object} [defaultProps] - default properties that are assigned only if there's not a corresponding value in `props`
    */
    init: function(props,defaultProps) {
      this.p = Q._extend({ 
        x: 0,
        y: 0,
        z: 0,
        opacity: 1,
        angle: 0,
        frame: 0,
        type: Q.SPRITE_DEFAULT | Q.SPRITE_ACTIVE,
        name: '',
        spriteProperties: {}
      },defaultProps);

      this.matrix = new Q.Matrix2D();
      this.children = [];

      Q._extend(this.p,props); 

      this.size();
      this.p.id = this.p.id || Q._uniqueId();

      this.refreshMatrix();
    },

    /**
    Resets the width, height and center based on the
     asset or sprite sheet

    @method size
    @for Q.Sprite
    @param {Boolean} force - force a reset (call if w or h changes)
    */
    size: function(force) {
      if(force || (!this.p.w || !this.p.h)) { 
        if(this.asset()) {
          this.p.w = this.asset().width;
          this.p.h = this.asset().height;
        } else if(this.sheet()) {
          this.p.w = this.sheet().tileW;
          this.p.h = this.sheet().tileH;
        }
      } 

      this.p.cx = (force || this.p.cx === void 0) ? (this.p.w / 2) : this.p.cx;
      this.p.cy = (force || this.p.cy === void 0) ? (this.p.h / 2) : this.p.cy;
    },

    /**
    Get or set the asset associate with this sprite

    @method asset
    @for Q.Sprite
    @param {String} [name] - leave empty to return the asset, add to set the asset
    @param {Boolean} [resize] - force a call to `size()` and `_generatePoints`
    */
    asset: function(name,resize) {
      if(!name) { return Q.asset(this.p.asset); }

      this.p.asset = name;
      if(resize) {
        this.size(true);
        Q._generatePoints(this,true);
      }
    },

    /**

     Get or set the sheet associate with this sprite

     @method sheet
     @for Q.Sprite
     @param {String} [name] - leave empty to return the sprite sheet, add to resize
     @param {Boolean} [resize] - force a resize
    */
    sheet: function(name,resize) {
      if(!name) { return Q.sheet(this.p.sheet); }

      this.p.sheet = name;
      if(resize) { 
        this.size(true);
        Q._generatePoints(this,true);
      }
    },

    /**
     Hide the sprite (render returns without rendering)

     @method hide
     @for Q.Sprite
    */
    hide: function() {
      this.p.hidden = true;
    },

    /**
     Show the sprite 

     @method show
     @for Q.Sprite
    */
    show: function() {
      this.p.hidden = false;
    },

    /**
     Set a set of `p` properties on a Sprite

     @method set
     @for Q.Sprite
     @param {Object} properties - hash of properties to set
    */
    set: function(properties) {
      Q._extend(this.p,properties);
      return this;
    },

    _sortChild: function(a,b) {
      return ((a.p && a.p.z) || -1) - ((b.p && b.p.z) || -1);
    },

    _flipArgs: {
      "x":  [ -1,  1],
      "y":  [  1, -1],
      "xy": [ -1, -1]
    },

    /** 
     Default render method for the sprite. Don't overload this unless you want to
     handle all the transform and scale stuff yourself. Rather overload the `draw` method.

     @method render
     @for Q.Sprite
     @param {Context2D} ctx - context to render to
    */
    render: function(ctx) {
      var p = this.p;

      if(p.hidden) { return; }
      if(!ctx) { ctx = Q.ctx; }

      this.trigger('predraw',ctx);

      ctx.save();

        if(this.p.opacity !== void 0 && this.p.opacity !== 1) {
          ctx.globalAlpha = this.p.opacity;
        }

        this.matrix.setContextTransform(ctx);

        if(this.p.flip) { ctx.scale.apply(ctx,this._flipArgs[this.p.flip]); }

        this.trigger('beforedraw',ctx);
        this.draw(ctx);
        this.trigger('draw',ctx);

      ctx.restore();
      
      // Children set up their own complete matrix
      // from the base stage matrix
      if(this.p.sort) { this.children.sort(this._sortChild); }
      Q._invoke(this.children,"render",ctx);
      
      this.trigger('postdraw',ctx);

      if(Q.debug) { this.debugRender(ctx); }

    },

    /**
     Center sprite inside of it's container (or the stage)

     @method center
     @for Q.Sprite
    */
    center: function() {
      if(this.container) {
        this.p.x = this.container.p.w / 2;
        this.p.y = this.container.p.h / 2;
      } else {
        this.p.x = Q.width / 2;
        this.p.y = Q.height / 2;
      }

    },

    /**
     Draw the asset on the stage. the context passed in is alreay transformed.

     All you need to do is a draw the sprite centered at 0,0

     @method draw
     @for Q.Sprite
     @param {Context2D} ctx
    */
    draw: function(ctx) {
      var p = this.p;
      if(p.sheet) {
        this.sheet().draw(ctx,-p.cx,-p.cy,p.frame);
      } else if(p.asset) {
        ctx.drawImage(Q.asset(p.asset),-p.cx,-p.cy);
      } else if(p.color) {
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.cx,-p.cy,p.w,p.h);
      }
    },

    debugRender: function(ctx) {
      if(!this.p.points) {
        Q._generatePoints(this);
      }
      ctx.save();
      this.matrix.setContextTransform(ctx);
      ctx.beginPath();
      ctx.fillStyle = this.p.hit ? "blue" : "red";
      ctx.strokeStyle = "#FF0000";
      ctx.fillStyle = "rgba(0,0,0,0.5)";

      ctx.moveTo(this.p.points[0][0],this.p.points[0][1]);
      for(var i=0;i<this.p.points.length;i++) {
        ctx.lineTo(this.p.points[i][0],this.p.points[i][1]);
      }
      ctx.lineTo(this.p.points[0][0],this.p.points[0][1]);
      ctx.stroke();
      if(Q.debugFill) { ctx.fill(); }

      ctx.restore();

      if(this.c) { 
        var c = this.c;
        ctx.save();
          ctx.globalAlpha = 1;
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#FF00FF";
          ctx.beginPath();
          ctx.moveTo(c.x - c.cx,       c.y - c.cy);
          ctx.lineTo(c.x - c.cx + c.w, c.y - c.cy);
          ctx.lineTo(c.x - c.cx + c.w, c.y - c.cy + c.h);
          ctx.lineTo(c.x - c.cx      , c.y - c.cy + c.h);
          ctx.lineTo(c.x - c.cx,       c.y - c.cy);
          ctx.stroke();
        ctx.restore();
      }
    },

    /** 
     Update method is called each step with the time elapsed since the last step.

     Doesn't do anything other than trigger events, call a `step` method if defined
     and run update on all its children.

     Generally leave this method alone and define a `step` method that will be called

     @method update
     @for Q.Sprite
     @param {Float} dt - time elapsed since last call
    */
    update: function(dt) {
      this.trigger('prestep',dt);
      if(this.step) { this.step(dt); }
      this.trigger('step',dt);
      this.refreshMatrix();

      // Ugly coupling to stage - workaround?
      if(this.stage && this.children.length > 0) {
        this.stage.updateSprites(this.children,dt,true);
      }
      
      // Reset collisions if we're tracking them
      if(this.p.collisions) { this.p.collisions = []; }
    },

    /* 
     Regenerates this sprite's transformation matrix

     @method refreshMatrix
     @for Q.Sprite
    */
    refreshMatrix: function() {
      var p = this.p;
      this.matrix.identity();

      if(this.container) { this.matrix.multiply(this.container.matrix); }
      
      this.matrix.translate(p.x,p.y);

      if(p.scale) { this.matrix.scale(p.scale,p.scale); }

      this.matrix.rotateDeg(p.angle);
    }
  });

  /**
   Simple sprite that adds in basic newtonian physics on each step:

       p.vx += p.ax * dt;
       p.vy += p.ay * dt;

       p.x += p.vx * dt;
       p.y += p.vy * dt;

   @class Q.MovingSprite
   @extends Q.Sprite
   @for Quintus.Sprites
  */
  Q.Sprite.extend("MovingSprite",{
    init: function(props,defaultProps) {
      this._super(Q._extend({
        vx: 0,
        vy: 0,
        ax: 0,
        ay: 0
      },props),defaultProps);
   },

   step: function(dt) {
     var p = this.p;

     p.vx += p.ax * dt;
     p.vy += p.ay * dt;

     p.x += p.vx * dt;
     p.y += p.vy * dt;
   }
 });




  return Q;
};



/***/ }),

/***/ "./node_modules/quintus/lib/quintus_tmx.js":
/*!*************************************************!*\
  !*** ./node_modules/quintus/lib/quintus_tmx.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */

/*global Quintus:false */
/**
Quintus HTML5 Game Engine - TMX Loader module

Module responsible for loading Tiled TMX files

@module Quintus.Input
*/

/**
 * Quintus TMX Loading module
 *
 * @class Quintus.TMX
 */
module.exports = function(Q) {


 // Add TMX file loading support to Quintus
 Q.assetTypes['tmx'] = 'TMX';

 // Load a TMX file as a parsed XML DOM
 Q.loadAssetTMX =  function(key,src,callback,errorCallback) {

   // Piggyback on loadAssetOther's AJAX call
   Q.loadAssetOther(key,src,function(key,responseText) {
     var parser = new DOMParser();
     var doc = parser.parseFromString(responseText, "application/xml");
     // save the asset as the parsed doc
     callback(key,doc);
   }, errorCallback);

 };

 Q._tmxExtractAssetName = function(result) {
   var source = result.getAttribute("source"),
   sourceParts = source.split("/");
   // only return the last part of the asset string
   return sourceParts[sourceParts.length - 1];
 };


 Q._tmxExtractSources = function(asset) {
   var results = asset.querySelectorAll("[source]");
   return Q._map(results,Q._tmxExtractAssetName);

 };
 

 Q.loadTMX = function(files,callback,options) {
   if(Q._isString(files)) {
     files = Q._normalizeArg(files);
   }

   var tmxFiles = [];
   Q._each(files,function(file) {
     if(Q._fileExtension(file) === 'tmx') {
        tmxFiles.push(file);
     }
   });

   var additionalAssets = [];

   Q.load(files,function() {
     Q._each(tmxFiles,function(tmxFile) {
       var sources = Q._tmxExtractSources(Q.asset(tmxFile));
       additionalAssets = additionalAssets.concat(sources);
     });

     if(additionalAssets.length > 0) {
       Q.load(additionalAssets,callback,options);
     } else {
       callback();
     }
   });

 };



 function attr(elem,atr) {
   var value = elem.getAttribute(atr);
   return isNaN(value) ? value : +value;
 }

 function parseProperties(elem) {
   var propElems = elem.querySelectorAll("property"),
       props = {};

   for(var i = 0; i < propElems.length; i++) {
     var propElem = propElems[i];
     props[attr(propElem,'name')] = attr(propElem,'value');
   }
   return props;
 }

 Q._tmxLoadTilesets = function(tilesets, tileProperties) {
   var gidMap = [];

   function parsePoint(pt) {
     var pts = pt.split(",");
     return [ parseFloat(pts[0]), parseFloat(pts[1]) ];
   }

   for(var t = 0; t < tilesets.length;t++) {
     var tileset = tilesets[t],
         sheetName = attr(tileset,"name"),
         gid = attr(tileset,"firstgid"),
         assetName = Q._tmxExtractAssetName(tileset.querySelector("image")),
         tilesetTileProps = {},
         tilesetProps = { tileW: attr(tileset,"tilewidth"),
                          tileH: attr(tileset,"tileheight"),
                          spacingX: attr(tileset,"spacing"),
                          spacingY: attr(tileset,"spacing")
                        };

     var tiles = tileset.querySelectorAll("tile");
     for(var i = 0;i < tiles.length;i++) {
       var tile = tiles[i];
       var tileId = attr(tile,"id");
       var tileGid = gid + tileId;

       var properties = parseProperties(tile);

       if(properties.points) {
         properties.points = Q._map(properties.points.split(" "),parsePoint);
       }

       // save the properties indexed by GID for creating objects
       tileProperties[tileGid] = properties;

       // save the properties indexed by tile number for the frame properties
       tilesetTileProps[tileId] = properties;
     }
     tilesetProps.frameProperties = tilesetTileProps;
     gidMap.push([ gid, sheetName ]);
     Q.sheet(sheetName, assetName,  tilesetProps);

   }
   return gidMap;
 };

 Q._tmxProcessImageLayer = function(stage,gidMap,tileProperties,layer) {
   var assetName = Q._tmxExtractAssetName(layer.querySelector("image"));
   var properties = parseProperties(layer);
   properties.asset = assetName;

   stage.insert(new Q.Repeater(properties));
 };

 // get the first entry in the gid map that gives
 // a gid offset
 Q._lookupGid = function(gid,gidMap) {
   var idx = 0;

   while(gidMap[idx+1] && gid >= gidMap[idx+1][0]) {
     idx++;
   }
   return gidMap[idx];
 };

 Q._tmxProcessTileLayer = function(stage,gidMap,tileProperties,layer) {
   var tiles = layer.querySelectorAll("tile"),
       width = attr(layer,'width'),
       height = attr(layer,'height');

       
   var gidDetails,gidOffset, sheetName;

   var data = [], idx=0;
   for(var y=0;y<height;y++) {
     data[y] = [];
     for(var x=0;x<width;x++) {
       var gid = attr(tiles[idx],"gid");
       if(gid === 0) {
         data[y].push(null);
       } else {
         // If we don't know what tileset this map is associated with
         // figure it out by looking up the gid of the tile w/
         // and match to the tilesef
         if(!gidOffset) {
           gidDetails = Q._lookupGid(attr(tiles[idx],"gid"),gidMap);
           gidOffset = gidDetails[0];
           sheetName = gidDetails[1];
         }
         data[y].push(gid - gidOffset);
       }
       idx++;
     }
   }

   var tileLayerProperties = Q._extend({   
     tileW: Q.sheet(sheetName).tileW,
     tileH: Q.sheet(sheetName).tileH,
     sheet: sheetName,
     tiles: data
     },parseProperties(layer));

   var TileLayerClass = tileLayerProperties.Class || 'TileLayer';

   if(tileLayerProperties['collision']) {
     stage.collisionLayer(new Q[TileLayerClass](tileLayerProperties));
   } else {
     stage.insert(new Q[TileLayerClass](tileLayerProperties));
   }
 };

 Q._tmxProcessObjectLayer = function(stage,gidMap,tileProperties,layer) {
   var objects = layer.querySelectorAll("object");
   for(var i=0;i < objects.length;i++) {
     var obj = objects[i],
         gid = attr(obj,"gid"),
         x = attr(obj,'x'),
         y = attr(obj,'y'),
         properties = tileProperties[gid],
         overrideProperties = parseProperties(obj);

     if(!properties) { throw "Invalid TMX Object: missing properties for GID:" + gid; }
     if(!properties['Class']) { throw "Invalid TMX Object: missing Class for GID:" + gid; }

     var className = properties['Class'];
     if(!className) { throw "Invalid TMX Object Class: " + className + " GID:" + gid; }

     var p = Q._extend(Q._extend({ x: x, y: y }, properties), overrideProperties);

     // Offset the sprite
     var sprite = new Q[className](p);
     sprite.p.x += sprite.p.w/2;
     sprite.p.y -= sprite.p.h/2;

     stage.insert(sprite);
   }

 };

 Q._tmxProcessors = { 'objectgroup': Q._tmxProcessObjectLayer,
                      'layer': Q._tmxProcessTileLayer,
                      'imagelayer': Q._tmxProcessImageLayer };

 Q.stageTMX = function(dataAsset,stage) {
    var data = Q._isString(dataAsset) ?  Q.asset(dataAsset) : dataAsset;

    var tileProperties = {};

    // Load Tilesets
    var tilesets = data.getElementsByTagName("tileset");
    var gidMap = Q._tmxLoadTilesets(tilesets,tileProperties);

    // Go through each of the layers
    Q._each(data.documentElement.childNodes,function(layer) {
      var layerType = layer.tagName;
      if(Q._tmxProcessors[layerType]) {
        Q._tmxProcessors[layerType](stage, gidMap, tileProperties, layer);
      }
    });
  };

};



/***/ }),

/***/ "./node_modules/quintus/lib/quintus_touch.js":
/*!***************************************************!*\
  !*** ./node_modules/quintus/lib/quintus_touch.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */

module.exports = function(Q) {
  if(Q._isUndefined(Q.modules.Sprites)) {
    throw "Quintus.Touch requires Quintus.Sprites Module";
  }

  var hasTouch =  !!('ontouchstart' in window);

  var touchStage = [0];
  var touchType = 0;

  Q.Evented.extend("TouchSystem",{

    init: function() {
      var touchSystem = this;

      this.boundTouch = function(e) { touchSystem.touch(e); };
      this.boundDrag = function(e) { touchSystem.drag(e); };
      this.boundEnd = function(e) { touchSystem.touchEnd(e); };

      Q.el.addEventListener('touchstart',this.boundTouch);
      Q.el.addEventListener('mousedown',this.boundTouch);

      Q.el.addEventListener('touchmove',this.boundDrag);
      Q.el.addEventListener('mousemove',this.boundDrag);

      Q.el.addEventListener('touchend',this.boundEnd);
      Q.el.addEventListener('mouseup',this.boundEnd);
      Q.el.addEventListener('touchcancel',this.boundEnd);

      this.touchPos = new Q.Evented();
      this.touchPos.grid = {};
      this.touchPos.p = { w:1, h:1, cx: 0, cy: 0 };
      this.activeTouches = {};
      this.touchedObjects = {};
    },

    destroy: function() {
      Q.el.removeEventListener('touchstart',this.boundTouch);
      Q.el.removeEventListener('mousedown',this.boundTouch);

      Q.el.removeEventListener('touchmove',this.boundDrag);
      Q.el.removeEventListener('mousemove',this.boundDrag);

      Q.el.removeEventListener('touchend',this.boundEnd);
      Q.el.removeEventListener('mouseup',this.boundEnd);
      Q.el.removeEventListener('touchcancel',this.boundEnd);
    },

    normalizeTouch: function(touch,stage) {
      var canvasPosX = touch.offsetX,
          canvasPosY = touch.offsetY;
         

      if(Q._isUndefined(canvasPosX) || Q._isUndefined(canvasPosY)) {
        canvasPosX = touch.layerX;
        canvasPosY = touch.layerY;
      }

      if(Q._isUndefined(canvasPosX) || Q._isUndefined(canvasPosY)) {
        if(Q.touch.offsetX === void 0) {
          Q.touch.offsetX = 0;
          Q.touch.offsetY = 0;
          var el = Q.el;
          do {
            Q.touch.offsetX += el.offsetLeft;
            Q.touch.offsetY += el.offsetTop;
          } while(el = el.offsetParent);
        }
        canvasPosX = touch.pageX - Q.touch.offsetX;
        canvasPosY = touch.pageY - Q.touch.offsetY;
      }


      this.touchPos.p.ox = this.touchPos.p.px = canvasPosX / Q.cssWidth * Q.width;
      this.touchPos.p.oy = this.touchPos.p.py = canvasPosY / Q.cssHeight * Q.height;
      
      if(stage.viewport) {
        this.touchPos.p.px /= stage.viewport.scale;
        this.touchPos.p.py /= stage.viewport.scale;
        this.touchPos.p.px += stage.viewport.x;
        this.touchPos.p.py += stage.viewport.y;
      }

      this.touchPos.p.x = this.touchPos.p.px;
      this.touchPos.p.y = this.touchPos.p.py;

      this.touchPos.obj = null;
      return this.touchPos;
    },

    touch: function(e) {
      var touches = e.changedTouches || [ e ];

      for(var i=0;i<touches.length;i++) {

        for(var stageIdx=0;stageIdx < touchStage.length;stageIdx++) {
          var touch = touches[i],
              stage = Q.stage(touchStage[stageIdx]);

          if(!stage) { continue; }

          touch.identifier = touch.identifier || 0;
          var pos = this.normalizeTouch(touch,stage);

          stage.regrid(pos,true);
          var col = stage.search(pos,touchType), obj;

          if(col || stageIdx === touchStage.length - 1) {
            obj = col && col.obj;
            pos.obj = obj;
            this.trigger("touch",pos);
          }

          if(obj && !this.touchedObjects[obj]) {
            this.activeTouches[touch.identifier] = {
              x: pos.p.px,
              y: pos.p.py,
              origX: obj.p.x,
              origY: obj.p.y,
              sx: pos.p.ox,
              sy: pos.p.oy,
              identifier: touch.identifier,
              obj: obj,
              stage: stage
            };
            this.touchedObjects[obj.p.id] = true;
            obj.trigger('touch', this.activeTouches[touch.identifier]);
            break;
          }

        }

      }
      //e.preventDefault();
    },

    drag: function(e) {
      var touches = e.changedTouches || [ e ];

      for(var i=0;i<touches.length;i++) {
        var touch = touches[i];
        touch.identifier = touch.identifier || 0;

        var active = this.activeTouches[touch.identifier],
            stage = active && active.stage;

        if(active) {
          var pos = this.normalizeTouch(touch,stage);
          active.x = pos.p.px;
          active.y = pos.p.py;
          active.dx = pos.p.ox - active.sx;
          active.dy = pos.p.oy - active.sy;

          active.obj.trigger('drag', active);
        }
      }
      e.preventDefault();
    },

    touchEnd: function(e) {
      var touches = e.changedTouches || [ e ];

      for(var i=0;i<touches.length;i++) {
        var touch = touches[i];

        touch.identifier = touch.identifier || 0;

        var active = this.activeTouches[touch.identifier];

        if(active) {
          active.obj.trigger('touchEnd', active);
          delete this.touchedObjects[active.obj.p.id];
          this.activeTouches[touch.identifier] = null;
        }
      }
      e.preventDefault();
    }

  });

  Q.touch = function(type,stage) {
    Q.untouch();
    touchType = type || Q.SPRITE_UI;
    touchStage = stage || [2,1,0];
    if(!Q._isArray(touchStage)) {
      touchStage = [touchStage];
    }

    if(!Q._touch) {
      Q.touchInput = new Q.TouchSystem();
    }
    return Q;
  };

  Q.untouch = function() {
    if(Q.touchInput) {
      Q.touchInput.destroy();
      delete Q['touchInput'];
    }
    return Q;
  };

};


/***/ }),

/***/ "./node_modules/quintus/lib/quintus_ui.js":
/*!************************************************!*\
  !*** ./node_modules/quintus/lib/quintus_ui.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*global Quintus:false */


/**
Quintus HTML5 Game Engine - UI Module

The code in `quintus_ui.js` defines the `Quintus.UI` module, which
adds in some easily accessible UI elements into Quintus.

Depends on the `Quintus.Sprite` module.

UI lets you create UI elements like containers, buttons and text elements.

@module Quintus.UI
*/

/**
 * Quintus UI Module Class
 *
 * @class Quintus.UI
 */
module.exports = function(Q) {
  if(Q._isUndefined(Q.modules.Touch)) {
    throw "Quintus.UI requires Quintus.Touch Module";
  }

  Q.UI = {};

  /**
   Draws a rounded rectangle centered on 0,0

   Options for `rect`

     * radius - radius of the rounded corners
     * w      - width of the rect
     * h      - height of the rect
     * cx     - X coordinate of top left corner
     * cy     - Y coordinate of top left corner

   @method roundRect
   @for Q.UI
   @param {canvas context} ctx
   @param {Object} rect -
   */
  Q.UI.roundRect = function(ctx, rect) {
    ctx.beginPath();
    ctx.moveTo(-rect.cx + rect.radius, -rect.cy);
    ctx.lineTo(-rect.cx + rect.w - rect.radius, -rect.cy);
    ctx.quadraticCurveTo(-rect.cx + rect.w, -rect.cy, -rect.cx + rect.w, -rect.cy + rect.radius);
    ctx.lineTo(-rect.cx + rect.w, -rect.cy + rect.h - rect.radius);
    ctx.quadraticCurveTo(-rect.cx + rect.w,
                         -rect.cy + rect.h,
                         -rect.cx + rect.w - rect.radius,
                         -rect.cy + rect.h);
    ctx.lineTo(-rect.cx + rect.radius, -rect.cy + rect.h);
    ctx.quadraticCurveTo(-rect.cx, -rect.cy + rect.h, -rect.cx, -rect.cy + rect.h - rect.radius);
    ctx.lineTo(-rect.cx, -rect.cy + rect.radius);
    ctx.quadraticCurveTo(-rect.cx, -rect.cy, -rect.cx + rect.radius, -rect.cy);
    ctx.closePath();
  };

  /**
   Creates a container for UI elements.

   Options for `p` are very similar to the ones for Q.Sprite.

     * border - width of the border [0] (no border)
     * radius - radius of the rounded border [5]
     * stroke - color of the border [#000]
     * w      - width of the container
     * h      - height of the container
     * x      - X coordinate of top left corner
     * y      - Y coordinate of top left corner
     * fill   - background color [null]
     * shadow - if the container should have a shadow[false]
     * shadowColor - `rgb` value of the shadow [false]

   @class Q.UI.Container
   @extends Q.Sprite
   @for Q.UI
   @param {Object} p - as described above
   */
  Q.UI.Container = Q.Sprite.extend("UI.Container", {
    init: function(p,defaults) {
      var adjustedP = Q._clone(p||{}),
          match;

      if(p && Q._isString(p.w) && (match = p.w.match(/^[0-9]+%$/))) {
        adjustedP.w = parseInt(p.w,10) * Q.width / 100;
        adjustedP.x = Q.width/2 - adjustedP.w/2;
      }

      if(p && Q._isString(p.h) && (match = p.h.match(/^[0-9]+%$/))) {
        adjustedP.h = parseInt(p.h,10) * Q.height / 100;
        adjustedP.y = Q.height /2 - adjustedP.h/2;
      }

      this._super(Q._defaults(adjustedP,defaults),{
        opacity: 1,
        hidden: false, // Set to true to not show the container
        fill:   null, // Set to color to add background
        highlight:   null, // Set to color to for button
        radius: 5, // Border radius
        stroke: "#000",
        border: false, // Set to a width to show a border
        shadow: false, // Set to true or a shadow offest
        shadowColor: false, // Set to a rgba value for the shadow
        outlineWidth: false, // Set to a width to outline text
        outlineColor: "#000",
        type: Q.SPRITE_NONE
      });

    },

    /**
     Inserts an object into the container.
     The object can later accessed via `children` property of the container.

     @method insert
     @for Q.UI.Container
     @param {Q.GameObject} obj - the Item to insert
     @return the inserted object for chaining
    */
    insert: function(obj) {
      this.stage.insert(obj,this);
      return obj;
    },

    /**
     Fits the containers size depending on its children.

     @method fit
     @for Q.UI.Container
     @param {Number} paddingY - vertical padding
     @param {Number} paddingX - horizontal padding
     @return the inserted object for chaining
    */
    fit: function(paddingY,paddingX) {
      if(this.children.length === 0) { return; }

      if(paddingY === void 0) { paddingY = 0; }
      if(paddingX === void 0) { paddingX = paddingY; }

      var minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;

      for(var i =0;i < this.children.length;i++) {
        var obj = this.children[i];
        var minObjX = obj.p.x - obj.p.cx,
            minObjY = obj.p.y - obj.p.cy,
            maxObjX = obj.p.x - obj.p.cx + obj.p.w,
            maxObjY = obj.p.y - obj.p.cy + obj.p.h;

        if(minObjX < minX) { minX = minObjX; }
        if(minObjY < minY) { minY = minObjY; }

        if(maxObjX > maxX) { maxX = maxObjX; }
        if(maxObjY > maxY) { maxY = maxObjY; }

      }

      this.p.cx = -minX + paddingX;
      this.p.cy = -minY + paddingY;
      this.p.w = maxX - minX + paddingX * 2;
      this.p.h = maxY - minY + paddingY * 2;
    },

    /**
     Adds the shadow specified in `p` to the container.

     @method addShadow
     @param {canvas context} ctx - the canvas context
     @for Q.UI.Container
    */
    addShadow: function(ctx) {
      if(this.p.shadow) {
        var shadowAmount = Q._isNumber(this.p.shadow) ? this.p.shadow : 5;
        ctx.shadowOffsetX=shadowAmount;
        ctx.shadowOffsetY=shadowAmount;
        ctx.shadowColor = this.p.shadowColor || "rgba(0,0,50,0.1)";
      }
    },

    /**
     Sets the shadows color to `transparent`.

     @method clearShadow
     @param {canvas context} ctx - the canvas context
     @for Q.UI.Container
    */
    clearShadow: function(ctx) {
      ctx.shadowColor = "transparent";
    },

    /**
     (re)Draws the roundedRect with shadow and border of the container.

     @method drawRadius
     @param {canvas context} ctx - the canvas context
     @for Q.UI.Container
    */
    drawRadius: function(ctx) {
      Q.UI.roundRect(ctx,this.p);
      this.addShadow(ctx);
      ctx.fill();
      if(this.p.border) {
        this.clearShadow(ctx);
        ctx.lineWidth = this.p.border;
        ctx.stroke();
      }
    },

    drawSquare: function(ctx) {
      this.addShadow(ctx);
      if(this.p.fill) {
        ctx.fillRect(-this.p.cx,-this.p.cy,
                      this.p.w,this.p.h);
      }

      if(this.p.border) {
        this.clearShadow(ctx);
        ctx.lineWidth = this.p.border;
        ctx.strokeRect(-this.p.cx,-this.p.cy,
                        this.p.w,this.p.h);
      }
    },

    draw: function(ctx) {
      if(this.p.hidden) { return false; }
      if(!this.p.border && !this.p.fill) { return; }

      ctx.globalAlpha = this.p.opacity;
      if(this.p.frame === 1 && this.p.highlight) {
        ctx.fillStyle = this.p.highlight;
      } else {
        ctx.fillStyle = this.p.fill;
      }
      ctx.strokeStyle = this.p.stroke;

      if(this.p.radius > 0) {
        this.drawRadius(ctx);
      } else {
        this.drawSquare(ctx);
      }

    }
  });


  /**
   Creates a Text-UI element.

   Options for `p` are very similar to the ones for Q.Sprite.

     * label        - text to display
     * weight       - weight of the text [800]
     * size         - size of the text in px [24]
     * align        - horizontal alignment of the text [left]
     * family       - font family [Arial]
     * color        - color of the text [black]
     * outline      - outline color of the text [black]
     * outlineWidth - thickness of the outline [0]

   @class Q.UI.Text
   @extends Q.Sprite
   @for Q.UI
   @param {Object} p - as described above
   */
  Q.UI.Text = Q.Sprite.extend("UI.Text", {
    init: function(p,defaultProps) {
      this._super(Q._defaults(p||{},defaultProps),{
        type: Q.SPRITE_UI,
        size: 24
      });

      //this.el = document.createElement("canvas");
      //this.ctx = this.el.getContext("2d");

      if(this.p.label) {
        this.calcSize();
      }

      //this.prerender();
    },

    calcSize: function() {
      this.setFont(Q.ctx);
      this.splitLabel = this.p.label.split("\n");
      var maxLabel = "";
      for(var i = 0;i < this.splitLabel.length;i++) {
        if(this.splitLabel[i].length > maxLabel.length) {
          maxLabel = this.splitLabel[i];
        }
      }

      var metrics = Q.ctx.measureText(maxLabel);
      this.p.h = (this.p.size || 24) * this.splitLabel.length * 1.2;
      this.p.w = metrics.width;
      this.p.cx = this.p.w / 2;
      this.p.cy = this.p.h / 2;
    },

    prerender: function() {
      if(this.p.oldLabel === this.p.label) { return; }
      this.p.oldLabel = this.p.label;
      this.calcSize();
      this.el.width = this.p.w;
      this.el.height = this.p.h * 4;
      this.ctx.clearRect(0,0,this.p.w,this.p.h);

      this.ctx.fillStyle = "#FF0";
      this.ctx.fillRect(0,0,this.p.w,this.p.h/2);
      this.setFont(this.ctx);

      this.ctx.fillText(this.p.label,0,0);
    },

    draw: function(ctx) {
       //this.prerender();
      if(this.p.opacity === 0) { return; }

      if(this.p.oldLabel !== this.p.label) { this.calcSize(); }

      this.setFont(ctx);
      if(this.p.opacity !== void 0) { ctx.globalAlpha = this.p.opacity; }
      for(var i =0;i<this.splitLabel.length;i++) {
        if(this.p.align === 'center') {
          if(this.p.outlineWidth) {
            ctx.strokeText(this.splitLabel[i],0,-this.p.cy + i * this.p.size * 1.2);
          }
          ctx.fillText(this.splitLabel[i],0,-this.p.cy + i * this.p.size * 1.2);
        } else if(this.p.align === 'right') {
          if(this.p.outlineWidth) {
            ctx.strokeText(this.splitLabel[i],this.p.cx,-this.p.cy + i * this.p.size * 1.2);
          }
          ctx.fillText(this.splitLabel[i],this.p.cx,-this.p.cy + i * this.p.size * 1.2);
        } else {
          if(this.p.outlineWidth) {
            ctx.strokeText(this.splitLabel[i],-this.p.cx,-this.p.cy +i * this.p.size * 1.2);
          }
          ctx.fillText(this.splitLabel[i],-this.p.cx,-this.p.cy +i * this.p.size * 1.2);
        }
      }
    },

    /**
     Returns the asset of the element

     @method asset
     @for Q.UI.Text
    */
    asset: function() {
      return this.el;
    },

    /**
     Sets the textfont using parameters of `p`.
     Defaults: see Class description!

     @method setFont
     @for Q.UI.Text
    */
    setFont: function(ctx) {
      ctx.textBaseline = "top";
      ctx.font= this.font();
      ctx.fillStyle = this.p.color || "black";
      ctx.textAlign = this.p.align || "left";
      ctx.strokeStyle = this.p.outlineColor || "black";
      ctx.lineWidth = this.p.outlineWidth || 0;
    },

    font: function() {
      if(this.fontString) { return this.fontString; }

      this.fontString = (this.p.weight || "800") + " " +
                        (this.p.size || 24) + "px " +
                        (this.p.family || "Arial");

      return this.fontString;
    }

  });


  /**
   Creates a Button-UI element that can be pressed/touched.
   When `touch` starts, it is highlighted.
   When `touchEnd` is triggered, the button calls the `callback` function and triggers a `click` event.
   Can be given a `keyActionName`. If so, the button listens for `keydown`-triggers of this key.

   Options for `p` are very similar to the ones for Q.UI.Container and Q.UI.Text.

     * label         - text to display
     * keyActionName - _see above_
     * font          - font for text [weigth: 400, size: 24px, family: arial]

   @class Q.UI.Button
   @extends Q.Container
   @for Q.UI
   @param {Object} p - as described above
   @param {function} callback - function to be called on `push` or `touch`
   @param {Object} defaultProps - could be used to overwrite default properties, otherwise uses the ones of Q.Sprite
   */
  Q.UI.Button = Q.UI.Container.extend("UI.Button", {
    init: function(p, callback, defaultProps) {
      this._super(Q._defaults(p||{},defaultProps),{
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        keyActionName: null
      });
      if(this.p.label && (!this.p.w || !this.p.h)) {
        Q.ctx.save();
        this.setFont(Q.ctx);
        var metrics = Q.ctx.measureText(this.p.label);
        Q.ctx.restore();
        if(!this.p.h) {  this.p.h = 24 + 20; }
        if(!this.p.w) { this.p.w = metrics.width + 20; }
      }

      if(isNaN(this.p.cx)) { this.p.cx = this.p.w / 2; }
      if(isNaN(this.p.cy)) { this.p.cy = this.p.h / 2; }
      this.callback = callback;
      this.on('touch',this,"highlight");
      this.on('touchEnd',this,"push");
      if(this.p.keyActionName) {
        Q.input.on(this.p.keyActionName,this,"push");
      }
    },

    highlight: function() {
      if(typeof this.sheet() !== 'undefined' && this.sheet().frames > 1) {
        this.p.frame = 1;
      }
    },

    push: function() {
      this.p.frame = 0;
      if(this.callback) { this.callback(); }
      this.trigger('click');
    },

    draw: function(ctx) {
      this._super(ctx);

      if(this.p.asset || this.p.sheet) {
        Q.Sprite.prototype.draw.call(this,ctx);
      }

      if(this.p.label) {
        ctx.save();
        this.setFont(ctx);
        ctx.fillText(this.p.label,0,0);
        ctx.restore();
      }
    },

    /**
     Sets the textfont using parameters of `p`.
     Defaults: see Class description!

     @method setFont
     @for Q.UI.Button
    */
    setFont: function(ctx) {
      ctx.textBaseline = "middle";
      ctx.font = this.p.font || "400 24px arial";
      ctx.fillStyle = this.p.fontColor || "black";
      ctx.textAlign = "center";
    }

  });

  /**
   Creates a html-iframe in the html-document.
   It has all other capabilities of Q.Sprite.
   (default) Properties of the html-element:

     * style.position: aboslute
     * style.zIndex: 500
     * Attribute frameborder: 0

   Options via `p`:

     * url - src for iframe
     * w   - width of the iframe
     * h   - height of the iframe

   @class Q.UI.IFrame
   @extends Q.Sprite
   @for Q.UI
   */
  Q.UI.IFrame = Q.Sprite.extend("UI.IFrame", {
    init: function(p) {
      this._super(p, { opacity: 1, type: Q.SPRITE_UI | Q.SPRITE_DEFAULT });

      Q.wrapper.style.overflow = "hidden";

      this.iframe = document.createElement("IFRAME");
      this.iframe.setAttribute("src",this.p.url);
      this.iframe.style.position = "absolute";
      this.iframe.style.zIndex = 500;
      this.iframe.setAttribute("width",this.p.w);
      this.iframe.setAttribute("height",this.p.h);
      this.iframe.setAttribute("frameborder",0);

      if(this.p.background) {
        this.iframe.style.backgroundColor = this.p.background;
      }

      Q.wrapper.appendChild(this.iframe);
      this.on("inserted",function(parent) {
        this.positionIFrame();
        parent.on("destroyed",this,"remove");
      });
    },

    positionIFrame: function() {
      var x = this.p.x;
      var y = this.p.y;
      if(this.stage.viewport) {
        x -= this.stage.viewport.x;
        y -= this.stage.viewport.y;
      }

      if(this.oldX !== x || this.oldY !== y || this.oldOpacity !== this.p.opacity) {

        this.iframe.style.top = (y - this.p.cy) + "px";
        this.iframe.style.left = (x - this.p.cx) + "px";
        this.iframe.style.opacity = this.p.opacity;

        this.oldX = x;
        this.oldY = y;
        this.oldOpacity = this.p.opacity;
      }
    },

    step: function(dt) {
      this._super(dt);
      this.positionIFrame();
    },

    remove: function() {
      if(this.iframe) {
        Q.wrapper.removeChild(this.iframe);
        this.iframe = null;
      }
    }
  });

  /**
   Creates a div-Helement in the html-document with given innerHTML.
   It has all other capabilities of Q.Sprite.

   Option via `p`:

     * html - innerHTML of the div

   @class Q.UI.HTMLElement
   @extends Q.Sprite
   @for Q.UI
   */
  Q.UI.HTMLElement = Q.Sprite.extend("UI.HTMLElement", {
    init: function(p) {
      this._super(p, { opacity: 1, type: Q.SPRITE_UI  });

      Q.wrapper.style.overflow = "hidden";

      this.el = document.createElement("div");
      this.el.innerHTML = this.p.html;

      Q.wrapper.appendChild(this.el);
      this.on("inserted",function(parent) {
        this.position();
        parent.on("destroyed",this,"remove");
        parent.on("clear",this,"remove");
      });
    },

    position: function() {
    },

    step: function(dt) {
      this._super(dt);
      this.position();
    },

    remove: function() {
      if(this.el) {
        Q.wrapper.removeChild(this.el);
        this.el= null;
      }
    }
  });

  Q.UI.VerticalLayout = Q.Sprite.extend("UI.VerticalLayout",{


    init: function(p) {
      this.children = [];
      this._super(p, { type: 0 });
    },

    insert: function(sprite) {
      this.stage.insert(sprite,this);
      this.relayout();
      // Bind to destroy
      return sprite;
    },

    relayout: function() {
      var totalHeight = 0;
      for(var i=0;i<this.children.length;i++) {
        totalHeight += this.children[i].p.h || 0;
      }

      // Center?
      var totalSepartion = this.p.h - totalHeight;

      // Make sure all elements have the same space between them
    }
  });



};


/***/ }),

/***/ "./node_modules/sockjs-client/dist/sockjs.js":
/*!***************************************************!*\
  !*** ./node_modules/sockjs-client/dist/sockjs.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.3.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.3.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/strip-ansi/index.js":
/*!******************************************!*\
  !*** ./node_modules/strip-ansi/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/ansi-regex/index.js")();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/BaseClient.js":
/*!*********************************************************!*\
  !*** (webpack)-dev-server/client/clients/BaseClient.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js":
/*!***********************************************************!*\
  !*** (webpack)-dev-server/client/clients/SockJSClient.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(/*! sockjs-client/dist/sockjs */ "./node_modules/sockjs-client/dist/sockjs.js");

var BaseClient = __webpack_require__(/*! ./BaseClient */ "./node_modules/webpack-dev-server/client/clients/BaseClient.js");

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);
    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(/*! ./SockJSClient */ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js");
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/index.js?http://nw191779:4200":
/*!********************************************************!*\
  !*** (webpack)-dev-server/client?http://nw191779:4200 ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(/*! strip-ansi */ "./node_modules/strip-ansi/index.js");

var socket = __webpack_require__(/*! ./socket */ "./node_modules/webpack-dev-server/client/socket.js");

var overlay = __webpack_require__(/*! ./overlay */ "./node_modules/webpack-dev-server/client/overlay.js");

var _require = __webpack_require__(/*! ./utils/log */ "./node_modules/webpack-dev-server/client/utils/log.js"),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(/*! ./utils/sendMessage */ "./node_modules/webpack-dev-server/client/utils/sendMessage.js");

var reloadApp = __webpack_require__(/*! ./utils/reloadApp */ "./node_modules/webpack-dev-server/client/utils/reloadApp.js");

var createSocketUrl = __webpack_require__(/*! ./utils/createSocketUrl */ "./node_modules/webpack-dev-server/client/utils/createSocketUrl.js");

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__("./node_modules/webpack/hot sync ^\\.\\/log$");

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://nw191779:4200"))

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay.js":
/*!**********************************************!*\
  !*** (webpack)-dev-server/client/overlay.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(/*! ansi-html */ "./node_modules/ansi-html/index.js");

var _require = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/index.js"),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/*!*********************************************!*\
  !*** (webpack)-dev-server/client/socket.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(/*! ./clients/SockJSClient */ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js");
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! (webpack)-dev-server/client/clients/SockJSClient.js */ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js")))

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/createSocketUrl.js":
/*!************************************************************!*\
  !*** (webpack)-dev-server/client/utils/createSocketUrl.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

var getCurrentScriptSource = __webpack_require__(/*! ./getCurrentScriptSource */ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js");

function createSocketUrl(resourceQuery) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    urlParts = url.parse(resourceQuery.substr(1));
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource(); // eslint-disable-next-line no-useless-escape

    scriptHost = scriptHost.replace(/\/[^\/]+$/, '');
    urlParts = url.parse(scriptHost || '/', false, true);
  }

  if (!urlParts.port || urlParts.port === '0') {
    urlParts.port = self.location.port;
  }

  var _urlParts = urlParts,
      auth = _urlParts.auth,
      path = _urlParts.path;
  var _urlParts2 = urlParts,
      hostname = _urlParts2.hostname,
      protocol = _urlParts2.protocol; // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384

  if ((hostname === '0.0.0.0' || hostname === '::') && self.location.hostname && // eslint-disable-next-line no-bitwise
  !!~self.location.protocol.indexOf('http')) {
    hostname = self.location.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = self.location.protocol;
  } // default values of the sock url if they are not provided


  var sockHost = hostname;
  var sockPath = '/sockjs-node';
  var sockPort = urlParts.port; // eslint-disable-next-line no-undefined

  if (path !== null && path !== undefined && path !== '/') {
    var parsedQuery = querystring.parse(path); // all of these sock url params are optionally passed in through
    // resourceQuery, so we need to fall back to the default if
    // they are not provided

    sockHost = parsedQuery.sockHost || sockHost;
    sockPath = parsedQuery.sockPath || sockPath;
    sockPort = parsedQuery.sockPort || sockPort;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!*******************************************************************!*\
  !*** (webpack)-dev-server/client/utils/getCurrentScriptSource.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/log.js":
/*!************************************************!*\
  !*** (webpack)-dev-server/client/utils/log.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js").getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/reloadApp.js":
/*!******************************************************!*\
  !*** (webpack)-dev-server/client/utils/reloadApp.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(/*! ./log */ "./node_modules/webpack-dev-server/client/utils/log.js"),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...'); // eslint-disable-next-line global-require

    var hotEmitter = __webpack_require__(/*! webpack/hot/emitter */ "./node_modules/webpack/hot/emitter.js");

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/sendMessage.js":
/*!********************************************************!*\
  !*** (webpack)-dev-server/client/utils/sendMessage.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/hot sync ^\\.\\/log$":
/*!*************************************************!*\
  !*** (webpack)/hot sync nonrecursive ^\.\/log$ ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": "./node_modules/webpack/hot/log.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/webpack/hot sync ^\\.\\/log$";

/***/ }),

/***/ "./node_modules/webpack/hot/emitter.js":
/*!********************************!*\
  !*** (webpack)/hot/emitter.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
module.exports = new EventEmitter();


/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!****************************!*\
  !*** (webpack)/hot/log.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),

/***/ "./src/game-object/box-thrower.js":
/*!****************************************!*\
  !*** ./src/game-object/box-thrower.js ***!
  \****************************************/
/*! exports provided: BoxThrower */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxThrower", function() { return BoxThrower; });
const BoxThrower = {
  init: function () {
    this.p = {
      launchDelay: 1.75,
      launchRandom: 1,
      launch: 2
    }
  },

  update: function (dt) {
    this.p.launch -= dt;

    if (this.p.launch < 0) {
      let key = Math.random().toString(36).substring(2, 15);
      let house = new Q.Box(key);
      Q.houses[key] = house;
      this.stage.insert(house);
      this.p.launch = this.p.launchDelay + this.p.launchRandom * Math.random();
    }
  }
};

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var quintus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quintus */ "./node_modules/quintus/index.js");
/* harmony import */ var quintus__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(quintus__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _game_object_box_thrower__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game-object/box-thrower */ "./src/game-object/box-thrower.js");
/* harmony import */ var _scene_level1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scene/level1 */ "./src/scene/level1.js");
/* harmony import */ var _sprite_box__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sprite/box */ "./src/sprite/box.js");
/* harmony import */ var _sprite_driver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sprite/driver */ "./src/sprite/driver.js");
/* harmony import */ var _sprite_house__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sprite/house */ "./src/sprite/house.js");
/* harmony import */ var _sprite_money__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sprite/money */ "./src/sprite/money.js");
/* harmony import */ var _sprite_player__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sprite/player */ "./src/sprite/player.js");
/* harmony import */ var _sprite_wheel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sprite/wheel */ "./src/sprite/wheel.js");










window.loadGame = () => {
  var playButton = window.document.getElementById('playButton');
  playButton.parentNode.removeChild(playButton);

  var Q = window.Q = quintus__WEBPACK_IMPORTED_MODULE_0__({ audioSupported: ['mp3', 'ogg'] })
    .include("Sprites, Scenes, Input, 2D, Anim, Touch, UI")
    .setup({ width: 1920, height: 1080, scaleToFit: true })
    .controls().touch();

  Q.gravityY = 2000;

  Q.boxes = 0;
  Q.score = 0;
  Q.houses = {};

  Q.include("Audio").enableSound();

  Q.Sprite.extend("Driver", _sprite_driver__WEBPACK_IMPORTED_MODULE_4__["Driver"]);

  Q.Sprite.extend("Player", _sprite_player__WEBPACK_IMPORTED_MODULE_7__["Player"]);
  
  Q.Sprite.extend("Box", _sprite_box__WEBPACK_IMPORTED_MODULE_3__["Box"]);

  Q.Sprite.extend("Money", _sprite_money__WEBPACK_IMPORTED_MODULE_6__["Money"]);

  Q.Sprite.extend("Wheel", _sprite_wheel__WEBPACK_IMPORTED_MODULE_8__["Wheel"]);
  
  Q.GameObject.extend("BoxThrower", _game_object_box_thrower__WEBPACK_IMPORTED_MODULE_1__["BoxThrower"]);

  Q.Sprite.extend("House", _sprite_house__WEBPACK_IMPORTED_MODULE_5__["House"]);

  Q.scene("level1", _scene_level1__WEBPACK_IMPORTED_MODULE_2__["Level1"]);

  Q.load(["driver.png",
    'player.png',
    'wheel-source.png',
    'sky.png',
    'road.png',
    'crates.png',
    'crates.json',
    'grass.png',
    'vehicle.png',
    'money.png',
    'house1.png',
    'house1-destroyed.png',
    'house2.png',
    'house2-destroyed.png',
    'jingle.mp3'], function () {
      Q.compileSheets("crates.png", "crates.json");
      Q.stageScene("level1");

      function playThemeSong() {
        Q.audio.stop('jingle.mp3');
        Q.audio.play('jingle.mp3', {
          loop: true,
          loopStart: 0,
          loopEnd: 51
        });
      }
      playThemeSong();
    });
  };




/***/ }),

/***/ "./src/scene/level1.js":
/*!*****************************!*\
  !*** ./src/scene/level1.js ***!
  \*****************************/
/*! exports provided: Level1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Level1", function() { return Level1; });
const Level1 = function (stage) {
  stage.insert(new Q.Repeater({
    asset: "sky.png",
    repeatY: false,
    speedX: 0.5,
    y: -75
  }));
  1
  stage.insert(new Q.Repeater({
    asset: "road.png",
    repeatY: false,
    speedX: 1.0,
    y: 300
  }));

  stage.insert(new Q.Repeater({
    asset: "grass.png",
    repeatY: false,
    speedX: 1.0,
    y: 150
  }));
  stage.insert(new Q.BoxThrower());
  stage.insert(new Q.Driver({z:1,scale:.5}));
  stage.insert(new Q.Player({z:100}));
  stage.insert(new Q.Wheel({x:20}));
  stage.insert(new Q.Wheel({x:590}));

  stage.add("viewport");
};


/***/ }),

/***/ "./src/sprite/box.js":
/*!***************************!*\
  !*** ./src/sprite/box.js ***!
  \***************************/
/*! exports provided: Box */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return Box; });
const Box = {
  init: function (key) {

    var levels = [565, 540, 500, 450];

    var player = Q("Player").first();
    this._super({
      id: key,
      x: player.p.x + Q.width + 50,
      y: 265,
      collisionMask: 1,
      scale: .7,
      asset: (Math.random() < 0.5 ? 'house1-destroyed.png' :'house2-destroyed.png'),
      vx: 0,
      vy: 0,
      sx: 600,
      sy: 600,
      ay: 0
    });

    this.on("hit");
  },

  step: function (dt) {
    var player = Q("Player").first();
    this.p.x += this.p.vx * dt;


    this.p.vy += this.p.ay * dt;
    this.p.y += this.p.vy * dt;

    if (this.p.x < player.p.x - 1100) {
      delete Q.houses[this.p.id];
      this.destroy();
    }
  },

  fix: function () {
    this.p.asset = 'house1.png';
    delete Q.houses[this.p.id];
    Q.score++;
  }
}; 

/***/ }),

/***/ "./src/sprite/driver.js":
/*!******************************!*\
  !*** ./src/sprite/driver.js ***!
  \******************************/
/*! exports provided: Driver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Driver", function() { return Driver; });
const Driver =
{
  init: function (p) {

    this._super(p, {
      asset: "driver.png",
      collisionMask: 0,
      x: 330,
      y: 500,
      speed: 500,
      jump: -750
    });

    this.add("2d, animation");
  },

  step: function (dt) {
    this.p.vx += (this.p.speed - this.p.vx) / 4;

    if (this.p.y > 500) {
      this.p.y = 500;
      this.p.landed = 1;
      this.p.vy = 0;
    } else {
      this.p.landed = 0;
    }

    if (Q.inputs['action'] && this.p.landed > 0) {
      this.p.vy = this.p.jump;
      this.p.scale *= 1.1;
    }
  }
};

/***/ }),

/***/ "./src/sprite/house.js":
/*!*****************************!*\
  !*** ./src/sprite/house.js ***!
  \*****************************/
/*! exports provided: House */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "House", function() { return House; });
const House = {
  init: function () {

    var levels = [565, 540, 500, 450];

    var player = Q("Player").first();
    this._super({

      x: player.p.x,
      y: player.p.y,
    //  frame: Math.random() < 0.5 ? 1 : 0,
      asset: 'House1.png',
      vx: -600 + 200 * Math.random(),
      vy: 0,
      ay: 0,
      theta: (300 * Math.random() + 200) * (Math.random() < 0.5 ? 1 : -1)
    });


    // this.on("hit");
  },

  step: function (dt) {
    this.p.x += this.p.vx * dt;


    this.p.vy += this.p.ay * dt;
    this.p.y += this.p.vy * dt;
    if (this.p.y != 565) {
      this.p.angle += this.p.theta * dt;
    }

    if (this.p.y > 800) { this.destroy(); }

  },

  // hit: function () {
  //   this.p.type = 0;
  //   this.p.collisionMask = Q.SPRITE_NONE;
  //   this.p.vx = 200;
  //   this.p.ay = 400;
  //   this.p.vy = -300;
  //   this.p.opacity = 0.5;
  // }
}; 

/***/ }),

/***/ "./src/sprite/money.js":
/*!*****************************!*\
  !*** ./src/sprite/money.js ***!
  \*****************************/
/*! exports provided: Money */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Money", function() { return Money; });
const Money = {
  init: function (player) {
    this._super({
      asset:'money.png',
      x: player.x + 50,
      y: player.y - 20,
      scale: .05,
      speed: 500,
      player: player,
      collisionMask: 1
    });

    this.on('hit');
  },

  step: function (dt) {
    this.p.y -= 5;
    this.p.x = this.p.player.x + 50;
    this.p.angle += 10;
    this.p.scale *= .985;

    if (this.p.y < 350) {
      this.p.scale *= .9;

      for (const key in Q.houses) {
        if (Q.houses.hasOwnProperty(key)) {
          if (this.p.x >= Q.houses[key].p.x - 150 && this.p.x <= Q.houses[key].p.x + 150) {
            Q.houses[key].fix();
          }
        }
      }
    }

    if (this.p.y < 300) { 
      this.destroy(); 
      Q.boxes--;
    }
  },

  hit: function() {
    console.log('Hello');
    this.p.scale = 5;
  }
};

/***/ }),

/***/ "./src/sprite/player.js":
/*!******************************!*\
  !*** ./src/sprite/player.js ***!
  \******************************/
/*! exports provided: Player */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Player", function() { return Player; });
const Player =
{
  init: function (p) {

    this._super(p, {
      asset: "vehicle.png",
      collisionMask: 0,
      x: 300,
      y: 550,
      speed: 500,
      jump: -750
    });

    this.p.points = this.p.standingPoints;

    this.add("2d, animation");
  },

  step: function (dt) {
    this.p.vx += (this.p.speed - this.p.vx) / 4;

    if (this.p.y > 550) {
      this.p.y = 550;
      this.p.landed = 1;
      this.p.vy = 0;
    } else {
      this.p.landed = 0;
    }

    if (Q.inputs['action'] && this.p.landed > 0) {
      this.p.vy = this.p.jump;
    }

    if (Q.inputs['fire']) {
      if (Q.boxes < 1) {
        this.stage.insert(new Q.Money(this.p));
        Q.boxes++;
      }
    }

    this.stage.viewport.centerOn(this.p.x + 300, 400);
  }
};

/***/ }),

/***/ "./src/sprite/wheel.js":
/*!*****************************!*\
  !*** ./src/sprite/wheel.js ***!
  \*****************************/
/*! exports provided: Wheel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Wheel", function() { return Wheel; });
const Wheel =
{
  init: function (p) {

    this._super(p, {
      asset: "wheel-source.png",
      collisionMask: 0,
      y: 660,
      speed: 500,
      jump: -750
    });

    this.add("2d, animation");
  },

  step: function (dt) {
    this.p.vx += (this.p.speed - this.p.vx) / 4;

    if (this.p.y > 660) {
      this.p.y = 660;
      this.p.landed = 1;
      this.p.vy = 0;
    } else {
      this.p.landed = 0;
    }
    this.p.angle += 10;

  }
};

/***/ }),

/***/ 0:
/*!****************************************************************************!*\
  !*** multi (webpack)-dev-server/client?http://nw191779:4200 ./src/main.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! C:\Projects\onyourside-man\node_modules\webpack-dev-server\client\index.js?http://nw191779:4200 */"./node_modules/webpack-dev-server/client/index.js?http://nw191779:4200");
module.exports = __webpack_require__(/*! C:\Projects\onyourside-man\src\main.js */"./src/main.js");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fuc2ktaHRtbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm94MmR3ZWIvYm94MmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNS1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIveG1sLWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWludHVzL2V4dHJhL3F1aW50dXNfZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWludHVzL2V4dHJhL3F1aW50dXNfcGh5c2ljcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpbnR1cy9leHRyYS9xdWludHVzX3N2Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpbnR1cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpbnR1cy9saWIvcXVpbnR1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpbnR1cy9saWIvcXVpbnR1c18yZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpbnR1cy9saWIvcXVpbnR1c19hbmltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWludHVzL2xpYi9xdWludHVzX2F1ZGlvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWludHVzL2xpYi9xdWludHVzX2lucHV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWludHVzL2xpYi9xdWludHVzX3NjZW5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpbnR1cy9saWIvcXVpbnR1c19zcHJpdGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWludHVzL2xpYi9xdWludHVzX3RteC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpbnR1cy9saWIvcXVpbnR1c190b3VjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpbnR1cy9saWIvcXVpbnR1c191aS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL0Jhc2VDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1NvY2tKU0NsaWVudC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2NyZWF0ZVNvY2tldFVybC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9sb2cuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3Qgc3luYyBub25yZWN1cnNpdmUgXlxcLlxcL2xvZyQiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUtb2JqZWN0L2JveC10aHJvd2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9zY2VuZS9sZXZlbDEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Nwcml0ZS9ib3guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Nwcml0ZS9kcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Nwcml0ZS9ob3VzZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3ByaXRlL21vbmV5LmpzIiwid2VicGFjazovLy8uL3NyYy9zcHJpdGUvcGxheWVyLmpzIiwid2VicGFjazovLy8uL3NyYy9zcHJpdGUvd2hlZWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGWTs7QUFFWjs7QUFFQTtBQUNBLG1EQUFtRCxJQUFJLFNBQVMsTUFBTSxJQUFJOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsR0FBRztBQUNIO0FBQ0Esc0JBQXNCO0FBQ3RCLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVSwrQkFBK0I7QUFDaEY7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDL0thO0FBQ2I7QUFDQSw2QkFBNkIsWUFBWSxJQUFJLElBQUksTUFBTSxJQUFJO0FBQzNEOzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7O0FBRVo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUNBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUNBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHO0FBQ3RDLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxHQUFHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBLG9DQUFvQyxHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQ0FBcUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsV0FBVywyQkFBMkI7O0FBRXRDLHNCOzs7Ozs7Ozs7Ozs7QUN2bVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSx5QkFBeUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvYkE7QUFDQSxlQUFlLG1CQUFPLENBQUMsK0VBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLG1GQUF5QjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBeUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsbUZBQXlCO0FBQ3BEOzs7Ozs7Ozs7Ozs7QUNMQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVCxvQ0FBb0M7QUFDcEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNsSkE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsV0FBVztBQUNYLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsb0NBQU8sVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzFCLEtBQUssTUFBTSxFQUlOO0FBQ0wsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUN6UEQ7QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUJBQW1CLEtBQTBCO0FBQzdDO0FBQ0Esa0JBQWtCLEtBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qix5Q0FBeUMscUJBQXFCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFFVTtBQUNaO0FBQ0EsRUFBRSxtQ0FBbUI7QUFDckI7QUFDQSxHQUFHO0FBQUEsb0dBQUM7QUFDSixFQUFFLE1BQU0sRUFhTjs7QUFFRixDQUFDOzs7Ozs7Ozs7Ozs7OztBQ3BoQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BGYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQywwREFBVTtBQUNuRCxxQ0FBcUMsbUJBQU8sQ0FBQywwREFBVTs7Ozs7Ozs7Ozs7O0FDSHZEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsMENBQTBDO0FBQzFDLGNBQWMsMENBQTBDO0FBQ3hEO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCLEVBQUU7QUFDbkQ7QUFDQSw2QkFBNkIsc0JBQXNCLEVBQUU7QUFDckQsS0FBSztBQUNMO0FBQ0E7O0FBRUEsYTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSx1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUwsMEJBQTBCLEVBQUU7O0FBRTVCO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHdCQUF3QjtBQUN4Qix3REFBd0QsRUFBRTs7QUFFMUQsMkJBQTJCO0FBQzNCLDhEQUE4RCxFQUFFO0FBQ2hFO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEMsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFOzs7OztBQUtIOzs7Ozs7Ozs7Ozs7O0FDNVRBO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLGtEQUFVOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsK0JBQStCLEVBQUU7QUFDM0Usd0NBQXdDLDZCQUE2QixFQUFFO0FBQ3ZFLHNEQUFzRCxvQ0FBb0M7O0FBRTFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7Ozs7Ozs7Ozs7OztBQ2xNQTtBQUNBOztBQUVBO0FBQ0EsMkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsc0JBQXNCLEVBQUU7QUFDbkQ7QUFDQSw2QkFBNkIsc0JBQXNCLEVBQUU7QUFDckQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QyxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLG9CQUFvQixjQUFjO0FBQ2xDOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLCtCQUErQjtBQUNsRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7QUNuTUEsaUJBQWlCLG1CQUFPLENBQUMsNERBQWUsQzs7Ozs7Ozs7Ozs7QUNBeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsUUFBUTs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsOERBQWM7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLGtFQUFnQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBaUI7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFrQjtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBbUI7QUFDN0MsY0FBYyxtQkFBTyxDQUFDLGdFQUFlO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFpQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsOERBQWM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLHlFQUFzQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLHlFQUFzQjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjOztBQUVwQztBQUNBO0FBQ0E7QUFDQSw0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVksUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVksUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVksUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVksUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVksUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVksUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLElBQUk7QUFDZixXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDLGtCQUFrQixtQ0FBbUM7QUFDckQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsNkJBQTZCO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQSwwQkFBMEIsd0JBQXdCLHlCQUF5QixFQUFFLEU7QUFDN0U7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsK0JBQStCOztBQUV2RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjs7O0FBR3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDLEtBQUs7O0FBRXJDO0FBQ0EsbUI7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0I7QUFDeEUsb0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDLE1BQU07O0FBRXZDOztBQUVBLDhCO0FBQ0EsK0JBQStCLGtCQUFrQixFQUFFO0FBQ25ELDRCQUE0Qix3QkFBd0IsRUFBRTtBQUN0RCw0QkFBNEIsdUJBQXVCO0FBQ25ELFFBQVE7O0FBRVI7QUFDQSw0QkFBNEIseUNBQXlDLEVBQUU7QUFDdkUsNEJBQTRCLG9DQUFvQztBQUNoRSxRQUFROztBQUVSO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLG1CQUFtQjs7QUFFbkIsMEJBQTBCO0FBQzFCLHFCQUFxQjs7QUFFckIsaURBQWlEO0FBQ2pELG9EQUFvRDtBQUNwRCw0Q0FBNEM7QUFDNUMsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7Ozs7OztBQU1KO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYyxFO0FBQ3BDLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQSw0QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0QkFBNEI7QUFDOUQsd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBLHFDO0FBQ0EsaUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQSxvQztBQUNBO0FBQ0EsK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixxQkFBcUI7O0FBRXJDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLGlDQUFpQzs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSx3QkFBd0IsY0FBYyx1QkFBdUIsRUFBRTs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7Ozs7O0FBS3pDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QztBQUNBLHlDOztBQUVBO0FBQ0EscUQ7QUFDQSxzRDtBQUNBOztBQUVBO0FBQ0EseUM7O0FBRUE7QUFDQTtBQUNBLHdDO0FBQ0E7QUFDQTtBQUNBLEs7O0FBRUE7QUFDQSw2QkFBNkIsc0JBQXNCLEVBQUU7QUFDckQsS0FBSzs7QUFFTDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQsb0JBQW9CLEVBQUU7QUFDbEY7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHVDQUF1QztBQUN2QztBQUNBOzs7QUFHQTtBQUNBLHlDQUF5Qyx3Q0FBd0M7O0FBRWpGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCO0FBQ0Esd0Q7QUFDQSwwQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxTQUFTO0FBQ25CLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssaUJBQWlCOztBQUV0QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLFFBQVE7O0FBRVI7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDLFVBQVUsU0FBUztBQUNuQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDLEVBQUU7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEI7QUFDQSx1RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0IsRUFBRTtBQUNyRTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsTUFBTTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE1BQU07QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsTUFBTTtBQUNuQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFxRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQ0FBaUMsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQzl0RUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esd0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEI7QUFDQTtBQUNBOztBQUVBLDhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxpQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwrQztBQUNBLE9BQU87QUFDUDtBQUNBLE87QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQyxpQkFBaUI7QUFDbEQsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDO0FBQ0Esb0Q7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGNBQWM7QUFDM0MsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QjtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQSw4QjtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDZCO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOzs7Ozs7Ozs7Ozs7QUM5Z0JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0NBQXdDO0FBQ3JFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QjtBQUNBO0FBQ0EsUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QyxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCLDBCQUEwQjtBQUMzRSxpQ0FBaUMsb0JBQW9CLGNBQWM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVLEVBQUU7O0FBRXRDO0FBQ0EsMkJBQTJCLGNBQWMsRUFBRTtBQUMzQywyQkFBMkIscUJBQXFCLEVBQUU7QUFDbEQ7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLGlDQUFpQyxrQkFBa0IsMEJBQTBCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFM7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7Ozs7Ozs7Ozs7OztBQ2hSQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7O0FBRUEscUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCxRQUFROztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQixFQUFFLE9BQU8sa0JBQWtCOztBQUVwRTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYSxHQUFHLE9BQU8saUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixxQkFBcUIsTTtBQUN0QztBQUNBLG1EO0FBQ0EsMkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0Esb0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCwrQkFBK0IsZUFBZTtBQUM5QztBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsY0FBYztBQUNkLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0MscUJBQXFCLGNBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQSxvQ0FBb0MsMEJBQTBCO0FBQzlEO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLE1BQU07QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxxQkFBcUIsY0FBYzs7QUFFbkMsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsTUFBTTtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQSwyQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0M7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxNQUFNLE07QUFDNUQ7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0I7QUFDQTs7QUFFQSxrQkFBa0IseUJBQXlCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7O0FBSUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTs7QUFFQTtBQUNBLHlGO0FBQ0E7QUFDQSxXO0FBQ0EsUzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLHFCQUFxQjtBQUNoRCx3QkFBd0IsbUJBQW1COztBQUUzQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLCtCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7O0FDMzVCQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTLGlEQUFpRCxLQUFLO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDZCO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLDBCQUEwQixZQUFZO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QywwQkFBMEIsWUFBWTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsYUFBYTs7QUFFM0M7QUFDQSxrQkFBa0IsZUFBZTs7QUFFakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0Msd0JBQXdCLHVCQUF1Qjs7QUFFL0M7QUFDQSxvQkFBb0IsY0FBYzs7QUFFbEM7QUFDQSxvQkFBb0IsY0FBYzs7QUFFbEM7O0FBRUEsa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsdUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4Qjs7O0FBRzlDO0FBQ0EsNkNBQTZDLHdEQUF3RDtBQUNyRztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLHlCQUF5QixlQUFlO0FBQ3hDLHlCQUF5QixlQUFlOztBQUV4Qzs7QUFFQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTSxNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBLEtBQUs7OztBQUdMO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDRCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0EseUJBQXlCLG9DQUFvQztBQUM3RCxnQ0FBZ0MsNENBQTRDOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHNCO0FBQ0E7O0FBRUEsMkJBQTJCLHdDQUF3QztBQUNuRSxrQ0FBa0MsZ0RBQWdEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0EsMEI7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUIsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQzs7QUFFMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLDBCQUEwQixhQUFhO0FBQ3ZDLDJCQUEyQixtQkFBbUI7QUFDOUMsNEJBQTRCLGFBQWE7QUFDekMsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFlBQVk7QUFDcEMsdUM7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzQ0FBc0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLG1DQUFtQyxNQUFNLE07QUFDekM7QUFDQTtBQUNBLDJGQUEyRixVQUFVOztBQUVyRyw0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7O0FBSUw7QUFDQSx1QkFBdUIsY0FBYzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxNQUFNLE07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx3Q0FBd0MsTUFBTSxNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQSxtQkFBbUIsZ0JBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxnQkFBZ0IsYUFBYTtBQUM3QixtQkFBbUIsY0FBYzs7QUFFakMsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsV0FBVzs7QUFFMUIsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQiwyQkFBMkI7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSx1QjtBQUNBLDhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7QUMzbkNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQSxzQjtBQUNBLGdDO0FBQ0EsNkI7QUFDQTtBQUNBLHNCO0FBQ0EsZ0M7QUFDQSw2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRCxnQkFBZ0IsVUFBVSxjQUFjO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFVBQVU7QUFDbEMsd0JBQXdCLFVBQVU7QUFDbEMsd0JBQXdCLFVBQVU7QUFDbEMsd0JBQXdCLFVBQVU7QUFDbEM7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEMsdUJBQXVCLFNBQVM7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLDBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBLDhCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSw2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCOztBQUUvQztBQUNBLGtCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCLGdCQUFnQixhQUFhOztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCLGtEQUFrRDs7QUFFM0U7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUNBQXFDO0FBQzVEOztBQUVBOztBQUVBLG1CQUFtQix1QkFBdUI7O0FBRTFDLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZOztBQUVuQzs7QUFFQSxrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JELEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLDZDQUE2Qzs7QUFFdkU7O0FBRUEsbUJBQW1CLG9DQUFvQzs7QUFFdkQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNudUJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLCtEQUErRDtBQUNyRiwrQkFBK0IsMERBQTBEOztBQUV6RjtBQUNBLHFCQUFxQixnRUFBZ0U7O0FBRXJGLGtDQUFrQyxhQUFhOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2xRQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLHNCQUFzQjtBQUMzRCxvQ0FBb0MscUJBQXFCO0FBQ3pELG1DQUFtQyx5QkFBeUI7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7O0FBRW5DLDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDNU1BOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7O0FBRTlDLCtCQUErQixjQUFjO0FBQzdDLCtCQUErQixxQkFBcUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsZ0JBQWdCO0FBQzVDLDRCQUE0QixnQkFBZ0I7O0FBRTVDLDRCQUE0QixnQkFBZ0I7QUFDNUMsNEJBQTRCLGdCQUFnQjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkMsMENBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7O0FBRXhDLDRDQUE0QyxpQkFBaUI7O0FBRTdEO0FBQ0EscUNBQXFDLGtDQUFrQztBQUN2RSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwyQkFBMkIsd0JBQXdCOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1Qyx1QkFBdUIsK0JBQStCO0FBQ3REOztBQUVBLDRCQUE0QiwwQkFBMEI7QUFDdEQsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQW1EOztBQUV6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQzs7QUFFdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7O0FBR0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7O0FBSUg7Ozs7Ozs7Ozs7OztBQ2puQkE7QUFDQSxhQUFhLEdBQUcsSUFBc0QsRUFBRSxtQkFBbUIsS0FBSyxVQUErTixDQUFDLGFBQWEsMEJBQTBCLG1CQUFtQixrQkFBa0IsZ0JBQWdCLFVBQVUsVUFBVSwwQ0FBMEMsZ0JBQWdCLE9BQUMsT0FBTyxvQkFBb0IsOENBQThDLGtDQUFrQyxZQUFZLFlBQVksbUNBQW1DLGlCQUFpQixlQUFlLHNCQUFzQixvQkFBb0Isa0RBQWtELFdBQVcsWUFBWSxTQUFTLFNBQVMsS0FBSztBQUMzekI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLGtDQUFrQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLDBCQUEwQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxnQ0FBZ0M7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSwwQkFBMEI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLCtCQUErQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx1SUFBdUk7QUFDMUk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG1FQUFtRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxzRkFBc0Y7QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHNIQUFzSDtBQUN6SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLHdOQUF3TjtBQUMzTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLDhYQUE4WDtBQUNqWTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQSxLQUFLLFlBQVk7QUFDakI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixzQ0FBc0MsRUFBRTs7QUFFOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjs7O0FBRzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdDQUFnQztBQUM5RSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLDBRQUEwUTtBQUM3UTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsZ0ZBQWdGO0FBQ25GO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0dBQXdHO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxxRkFBcUY7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLCtJQUErSTtBQUNsSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxtRkFBbUY7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxRUFBcUU7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlGQUF5Rjs7QUFFekY7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLHFEQUFxRDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG9GQUFvRjtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxREFBcUQ7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHlHQUF5RztBQUM1RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFxRCxtQkFBbUIsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsa0lBQWtJO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsd0RBQXdEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsaUNBQWlDO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEMsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUseUJBQXlCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGlDQUFpQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsa0dBQWtHO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUEsQ0FBQyxFQUFFLCtGQUErRjtBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQzs7QUFFQSxDQUFDLEVBQUUsMEVBQTBFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUEsQ0FBQyxFQUFFLHVHQUF1RztBQUMxRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSw2SEFBNkg7QUFDaEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUMsRUFBRSxXQUFXO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLGNBQWM7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGtEQUFrRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsb0NBQW9DO0FBQ3ZDLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLFlBQVk7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLFdBQVc7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsMEJBQTBCO0FBQzdCOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUEsdUJBQXVCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFN1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLGlCQUFpQjtBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsY0FBYztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsQ0FBQyxFQUFFLFFBQVE7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtDQUFrQyxpREFBaUQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFvRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDZCQUE2QjtBQUM3Rix1RUFBdUUsaUNBQWlDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHdEQUF3RCwwRUFBMEUsT0FBTywwQkFBMEIsU0FBUztBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnRUFBZ0UsZ0JBQWdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDJCQUEyQjtBQUM1RjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2RkFBNkY7QUFDckgsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1HQUFtRztBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1HQUFtRztBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELEdBQUc7QUFDSCxzQ0FBc0M7QUFDdEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEseUJBQXlCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUsdUNBQXVDLEVBQUUsR0FBRztBQUMvQyxDQUFDOzs7QUFHRDs7Ozs7Ozs7Ozs7Ozs7QUN4ckxhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsc0RBQVk7O0FBRXBDO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9GQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQywwQ0FBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUFLOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hELDBDQUEwQyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsbUJBQU8sQ0FBQyw0REFBYTs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM3RCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZmE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxHOzs7Ozs7Ozs7Ozs7QUMxQlk7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFN1YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4saURBQWlELDBFQUEwRSxhQUFhLEVBQUUscUNBQXFDOztBQUUvSyx1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXBLLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTSwwQ0FBMEMsK0RBQStELDJFQUEyRSxFQUFFLHlFQUF5RSxlQUFlLHNEQUFzRCxFQUFFLEVBQUUsdURBQXVEOztBQUUvWCxnQ0FBZ0MsNEVBQTRFLGlCQUFpQixVQUFVLEdBQUcsOEJBQThCOztBQUV4SyxhQUFhLG1CQUFPLENBQUMsOEVBQTJCOztBQUVoRCxpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBYzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxtQkFBZSxDQUFDLHdGQUFnQjtBQUM3QztBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDLGE7Ozs7Ozs7Ozs7OztBQ3BFRCx1REFBYTtBQUNiOztBQUVBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFZOztBQUVwQyxhQUFhLG1CQUFPLENBQUMsb0VBQVU7O0FBRS9CLGNBQWMsbUJBQU8sQ0FBQyxzRUFBVzs7QUFFakMsZUFBZSxtQkFBTyxDQUFDLDBFQUFhO0FBQ3BDO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsMEZBQXFCOztBQUUvQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBbUI7O0FBRTNDLHNCQUFzQixtQkFBTyxDQUFDLGtHQUF5Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsa0VBQWtEOztBQUVuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOzs7Ozs7Ozs7Ozs7O0FDL0thO0FBQ2I7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLG9EQUFXOztBQUVsQyxlQUFlLG1CQUFPLENBQUMsNERBQWU7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQSxHQUFHLEVBQUU7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7OztBQ3ZIQSxxRUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFPLENBQUMsZ0dBQXdCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHdCOzs7Ozs7Ozs7Ozs7O0FDbkRhO0FBQ2I7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLHNDQUFLOztBQUV2QixrQkFBa0IsbUJBQU8sQ0FBQyw0REFBYTs7QUFFdkMsNkJBQTZCLG1CQUFPLENBQUMsMEdBQTBCOztBQUUvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUM7Ozs7Ozs7Ozs7OztBQzdFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQSx3Qzs7Ozs7Ozs7Ozs7O0FDckJhOztBQUViLFVBQVUsbUJBQU8sQ0FBQyx5REFBVTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7OztBQ2hEYTtBQUNiOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxvRUFBTztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QyxxQkFBcUIsbUJBQU8sQ0FBQyxrRUFBcUI7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7Ozs7Ozs7O0FDdERhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEseUI7Ozs7Ozs7Ozs7O0FDYkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0U7Ozs7Ozs7Ozs7O0FDdEJBLG1CQUFtQixtQkFBTyxDQUFDLCtDQUFRO0FBQ25DOzs7Ozs7Ozs7Ozs7QUNEQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW1DO0FBQ29CO0FBQ2Y7QUFDTDtBQUNNO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsb0NBQU8sRUFBRSxpQ0FBaUM7QUFDL0Q7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLHFEQUFNOztBQUVsQyw0QkFBNEIscURBQU07O0FBRWxDLHlCQUF5QiwrQ0FBRzs7QUFFNUIsMkJBQTJCLG1EQUFLOztBQUVoQywyQkFBMkIsbURBQUs7O0FBRWhDLG9DQUFvQyxtRUFBVTs7QUFFOUMsMkJBQTJCLG1EQUFLOztBQUVoQyxvQkFBb0Isb0RBQU07O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZCQUE2QixhQUFhO0FBQzFDLDZCQUE2QixNQUFNO0FBQ25DLDRCQUE0QixLQUFLO0FBQ2pDLDRCQUE0QixNQUFNOztBQUVsQztBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQUE7QUFBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQUE7QUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUFBO0FBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsZ0JBQWdCOztBQUV6QyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7QUM1Q0E7QUFBQTtBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUI7QUFDQSxxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQUE7QUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQUE7QUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL29ueW91cnNpZGUtbWFuL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBhbnNpSFRNTFxuXG4vLyBSZWZlcmVuY2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hbnNpLXJlZ2V4XG52YXIgX3JlZ0FOU0kgPSAvKD86KD86XFx1MDAxYlxcWyl8XFx1MDA5YikoPzooPzpbMC05XXsxLDN9KT8oPzooPzo7WzAtOV17MCwzfSkqKT9bQS1NfGYtbV0pfFxcdTAwMWJbQS1NXS9cblxudmFyIF9kZWZDb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ2ZmZicsICcwMDAnXSwgLy8gW0ZPUkVHUk9VRF9DT0xPUiwgQkFDS0dST1VORF9DT0xPUl1cbiAgYmxhY2s6ICcwMDAnLFxuICByZWQ6ICdmZjAwMDAnLFxuICBncmVlbjogJzIwOTgwNScsXG4gIHllbGxvdzogJ2U4YmYwMycsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgY3lhbjogJzAwZmZlZScsXG4gIGxpZ2h0Z3JleTogJ2YwZjBmMCcsXG4gIGRhcmtncmV5OiAnODg4J1xufVxudmFyIF9zdHlsZXMgPSB7XG4gIDMwOiAnYmxhY2snLFxuICAzMTogJ3JlZCcsXG4gIDMyOiAnZ3JlZW4nLFxuICAzMzogJ3llbGxvdycsXG4gIDM0OiAnYmx1ZScsXG4gIDM1OiAnbWFnZW50YScsXG4gIDM2OiAnY3lhbicsXG4gIDM3OiAnbGlnaHRncmV5J1xufVxudmFyIF9vcGVuVGFncyA9IHtcbiAgJzEnOiAnZm9udC13ZWlnaHQ6Ym9sZCcsIC8vIGJvbGRcbiAgJzInOiAnb3BhY2l0eTowLjUnLCAvLyBkaW1cbiAgJzMnOiAnPGk+JywgLy8gaXRhbGljXG4gICc0JzogJzx1PicsIC8vIHVuZGVyc2NvcmVcbiAgJzgnOiAnZGlzcGxheTpub25lJywgLy8gaGlkZGVuXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcbn1cbnZhciBfY2xvc2VUYWdzID0ge1xuICAnMjMnOiAnPC9pPicsIC8vIHJlc2V0IGl0YWxpY1xuICAnMjQnOiAnPC91PicsIC8vIHJlc2V0IHVuZGVyc2NvcmVcbiAgJzI5JzogJzwvZGVsPicgLy8gcmVzZXQgZGVsZXRlXG59XG5cbjtbMCwgMjEsIDIyLCAyNywgMjgsIDM5LCA0OV0uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nXG59KVxuXG4vKipcbiAqIENvbnZlcnRzIHRleHQgd2l0aCBBTlNJIGNvbG9yIGNvZGVzIHRvIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBhbnNpSFRNTCAodGV4dCkge1xuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGlmIHRoZSBzdHJpbmcgaGFzIG5vIEFOU0kgZXNjYXBlIGNvZGUuXG4gIGlmICghX3JlZ0FOU0kudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvLyBDYWNoZSBvcGVuZWQgc2VxdWVuY2UuXG4gIHZhciBhbnNpQ29kZXMgPSBbXVxuICAvLyBSZXBsYWNlIHdpdGggbWFya3VwLlxuICB2YXIgcmV0ID0gdGV4dC5yZXBsYWNlKC9cXDAzM1xcWyhcXGQrKSptL2csIGZ1bmN0aW9uIChtYXRjaCwgc2VxKSB7XG4gICAgdmFyIG90ID0gX29wZW5UYWdzW3NlcV1cbiAgICBpZiAob3QpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgc2VxdWVuY2UgaGFzIGJlZW4gb3BlbmVkLCBjbG9zZSBpdC5cbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgICByZXR1cm4gJzwvc3Bhbj4nXG4gICAgICB9XG4gICAgICAvLyBPcGVuIHRhZy5cbiAgICAgIGFuc2lDb2Rlcy5wdXNoKHNlcSlcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPidcbiAgICB9XG5cbiAgICB2YXIgY3QgPSBfY2xvc2VUYWdzW3NlcV1cbiAgICBpZiAoY3QpIHtcbiAgICAgIC8vIFBvcCBzZXF1ZW5jZVxuICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICByZXR1cm4gY3RcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH0pXG5cbiAgLy8gTWFrZSBzdXJlIHRhZ3MgYXJlIGNsb3NlZC5cbiAgdmFyIGwgPSBhbnNpQ29kZXMubGVuZ3RoXG4gIDsobCA+IDApICYmIChyZXQgKz0gQXJyYXkobCArIDEpLmpvaW4oJzwvc3Bhbj4nKSlcblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogQ3VzdG9taXplIGNvbG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgcmVmZXJlbmNlIHRvIF9kZWZDb2xvcnNcbiAqL1xuYW5zaUhUTUwuc2V0Q29sb3JzID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICBpZiAodHlwZW9mIGNvbG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bjb2xvcnNgIHBhcmFtZXRlciBtdXN0IGJlIGFuIE9iamVjdC4nKVxuICB9XG5cbiAgdmFyIF9maW5hbENvbG9ycyA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBfZGVmQ29sb3JzKSB7XG4gICAgdmFyIGhleCA9IGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29sb3JzW2tleV0gOiBudWxsXG4gICAgaWYgKCFoZXgpIHtcbiAgICAgIF9maW5hbENvbG9yc1trZXldID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoJ3Jlc2V0JyA9PT0ga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gW2hleF1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBoICE9PSAnc3RyaW5nJ1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIEFycmF5IGFuZCBlYWNoIGl0ZW0gY291bGQgb25seSBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgICB9XG4gICAgICB2YXIgZGVmSGV4Q29sb3IgPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGlmICghaGV4WzBdKSB7XG4gICAgICAgIGhleFswXSA9IGRlZkhleENvbG9yWzBdXG4gICAgICB9XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSB8fCAhaGV4WzFdKSB7XG4gICAgICAgIGhleCA9IFtoZXhbMF1dXG4gICAgICAgIGhleC5wdXNoKGRlZkhleENvbG9yWzFdKVxuICAgICAgfVxuXG4gICAgICBoZXggPSBoZXguc2xpY2UoMCwgMilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgIH1cbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleFxuICB9XG4gIF9zZXRUYWdzKF9maW5hbENvbG9ycylcbn1cblxuLyoqXG4gKiBSZXNldCBjb2xvcnMuXG4gKi9cbmFuc2lIVE1MLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBfc2V0VGFncyhfZGVmQ29sb3JzKVxufVxuXG4vKipcbiAqIEV4cG9zZSB0YWdzLCBpbmNsdWRpbmcgb3BlbiBhbmQgY2xvc2UuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5hbnNpSFRNTC50YWdzID0ge31cblxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ29wZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfb3BlblRhZ3MgfVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ2Nsb3NlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Nsb3NlVGFncyB9XG4gIH0pXG59IGVsc2Uge1xuICBhbnNpSFRNTC50YWdzLm9wZW4gPSBfb3BlblRhZ3NcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3Ncbn1cblxuZnVuY3Rpb24gX3NldFRhZ3MgKGNvbG9ycykge1xuICAvLyByZXNldCBhbGxcbiAgX29wZW5UYWdzWycwJ10gPSAnZm9udC13ZWlnaHQ6bm9ybWFsO29wYWNpdHk6MTtjb2xvcjojJyArIGNvbG9ycy5yZXNldFswXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFsxXVxuICAvLyBpbnZlcnNlXG4gIF9vcGVuVGFnc1snNyddID0gJ2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzFdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzBdXG4gIC8vIGRhcmsgZ3JleVxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXlcblxuICBmb3IgKHZhciBjb2RlIGluIF9zdHlsZXMpIHtcbiAgICB2YXIgY29sb3IgPSBfc3R5bGVzW2NvZGVdXG4gICAgdmFyIG9yaUNvbG9yID0gY29sb3JzW2NvbG9yXSB8fCAnMDAwJ1xuICAgIF9vcGVuVGFnc1tjb2RlXSA9ICdjb2xvcjojJyArIG9yaUNvbG9yXG4gICAgY29kZSA9IHBhcnNlSW50KGNvZGUpXG4gICAgX29wZW5UYWdzWyhjb2RlICsgMTApLnRvU3RyaW5nKCldID0gJ2JhY2tncm91bmQ6IycgKyBvcmlDb2xvclxuICB9XG59XG5cbmFuc2lIVE1MLnJlc2V0KClcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG4iLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwNyBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tXG4qXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuKi9cblwidXNlIHN0cmljdFwiXG5cbnZhciBCb3gyRCA9IHt9O1xuXG4oZnVuY3Rpb24gKGEyaiwgdW5kZWZpbmVkKSB7XG4gICBcbiAgIGZ1bmN0aW9uIGVtcHR5Rm4oKSB7fTtcbiAgIGEyai5pbmhlcml0ID0gZnVuY3Rpb24oY2xzLCBiYXNlKSB7XG4gICAgICB2YXIgdG1wQ3RyID0gY2xzO1xuICAgICAgZW1wdHlGbi5wcm90b3R5cGUgPSBiYXNlLnByb3RvdHlwZTtcbiAgICAgIGNscy5wcm90b3R5cGUgPSBuZXcgZW1wdHlGbjtcbiAgICAgIGNscy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSB0bXBDdHI7XG4gICB9O1xuICAgXG4gICBhMmouZ2VuZXJhdGVDYWxsYmFjayA9IGZ1bmN0aW9uIGdlbmVyYXRlQ2FsbGJhY2soY29udGV4dCwgY2IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICBjYi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgIH07XG4gICBcbiAgIGEyai5OVmVjdG9yID0gZnVuY3Rpb24gTlZlY3RvcihsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgbGVuZ3RoID0gMDtcbiAgICAgIHZhciB0bXAgPSBuZXcgQXJyYXkobGVuZ3RoIHx8IDApO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSlcbiAgICAgIHRtcFtpXSA9IDA7XG4gICAgICByZXR1cm4gdG1wO1xuICAgfTtcbiAgIFxuICAgYTJqLmlzID0gZnVuY3Rpb24gaXMobzEsIG8yKSB7XG4gICAgICBpZiAobzEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICgobzIgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgKG8xIGluc3RhbmNlb2YgbzIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICgobzEuY29uc3RydWN0b3IuX19pbXBsZW1lbnRzICE9IHVuZGVmaW5lZCkgJiYgKG8xLmNvbnN0cnVjdG9yLl9faW1wbGVtZW50c1tvMl0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH07XG4gICBcbiAgIGEyai5wYXJzZVVJbnQgPSBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMocGFyc2VJbnQodikpO1xuICAgfVxuICAgXG59KShCb3gyRCk7XG5cbi8vI1RPRE8gcmVtb3ZlIGFzc2lnbm1lbnRzIGZyb20gZ2xvYmFsIG5hbWVzcGFjZVxudmFyIFZlY3RvciA9IEFycmF5O1xudmFyIFZlY3Rvcl9hMmpfTnVtYmVyID0gQm94MkQuTlZlY3Rvcjtcbi8vcGFja2FnZSBzdHJ1Y3R1cmVcbmlmICh0eXBlb2YoQm94MkQpID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRCA9IHt9O1xuaWYgKHR5cGVvZihCb3gyRC5Db2xsaXNpb24pID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRC5Db2xsaXNpb24gPSB7fTtcbmlmICh0eXBlb2YoQm94MkQuQ29sbGlzaW9uLlNoYXBlcykgPT09IFwidW5kZWZpbmVkXCIpIEJveDJELkNvbGxpc2lvbi5TaGFwZXMgPSB7fTtcbmlmICh0eXBlb2YoQm94MkQuQ29tbW9uKSA9PT0gXCJ1bmRlZmluZWRcIikgQm94MkQuQ29tbW9uID0ge307XG5pZiAodHlwZW9mKEJveDJELkNvbW1vbi5NYXRoKSA9PT0gXCJ1bmRlZmluZWRcIikgQm94MkQuQ29tbW9uLk1hdGggPSB7fTtcbmlmICh0eXBlb2YoQm94MkQuRHluYW1pY3MpID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRC5EeW5hbWljcyA9IHt9O1xuaWYgKHR5cGVvZihCb3gyRC5EeW5hbWljcy5Db250YWN0cykgPT09IFwidW5kZWZpbmVkXCIpIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzID0ge307XG5pZiAodHlwZW9mKEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzKSA9PT0gXCJ1bmRlZmluZWRcIikgQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMgPSB7fTtcbmlmICh0eXBlb2YoQm94MkQuRHluYW1pY3MuSm9pbnRzKSA9PT0gXCJ1bmRlZmluZWRcIikgQm94MkQuRHluYW1pY3MuSm9pbnRzID0ge307XG4vL3ByZS1kZWZpbml0aW9uc1xuKGZ1bmN0aW9uICgpIHtcbiAgIEJveDJELkNvbGxpc2lvbi5JQnJvYWRQaGFzZSA9ICdCb3gyRC5Db2xsaXNpb24uSUJyb2FkUGhhc2UnO1xuXG4gICBmdW5jdGlvbiBiMkFBQkIoKSB7XG4gICAgICBiMkFBQkIuYjJBQUJCLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyQUFCQiA9IGIyQUFCQjtcblxuICAgZnVuY3Rpb24gYjJCb3VuZCgpIHtcbiAgICAgIGIyQm91bmQuYjJCb3VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkJvdW5kID0gYjJCb3VuZDtcblxuICAgZnVuY3Rpb24gYjJCb3VuZFZhbHVlcygpIHtcbiAgICAgIGIyQm91bmRWYWx1ZXMuYjJCb3VuZFZhbHVlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQm91bmRWYWx1ZXMpIHRoaXMuYjJCb3VuZFZhbHVlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkJvdW5kVmFsdWVzID0gYjJCb3VuZFZhbHVlcztcblxuICAgZnVuY3Rpb24gYjJDb2xsaXNpb24oKSB7XG4gICAgICBiMkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbiA9IGIyQ29sbGlzaW9uO1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RJRCgpIHtcbiAgICAgIGIyQ29udGFjdElELmIyQ29udGFjdElELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJDb250YWN0SUQpIHRoaXMuYjJDb250YWN0SUQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJDb250YWN0SUQgPSBiMkNvbnRhY3RJRDtcblxuICAgZnVuY3Rpb24gYjJDb250YWN0UG9pbnQoKSB7XG4gICAgICBiMkNvbnRhY3RQb2ludC5iMkNvbnRhY3RQb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkNvbnRhY3RQb2ludCA9IGIyQ29udGFjdFBvaW50O1xuXG4gICBmdW5jdGlvbiBiMkRpc3RhbmNlKCkge1xuICAgICAgYjJEaXN0YW5jZS5iMkRpc3RhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2UgPSBiMkRpc3RhbmNlO1xuXG4gICBmdW5jdGlvbiBiMkRpc3RhbmNlSW5wdXQoKSB7XG4gICAgICBiMkRpc3RhbmNlSW5wdXQuYjJEaXN0YW5jZUlucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VJbnB1dCA9IGIyRGlzdGFuY2VJbnB1dDtcblxuICAgZnVuY3Rpb24gYjJEaXN0YW5jZU91dHB1dCgpIHtcbiAgICAgIGIyRGlzdGFuY2VPdXRwdXQuYjJEaXN0YW5jZU91dHB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlT3V0cHV0ID0gYjJEaXN0YW5jZU91dHB1dDtcblxuICAgZnVuY3Rpb24gYjJEaXN0YW5jZVByb3h5KCkge1xuICAgICAgYjJEaXN0YW5jZVByb3h5LmIyRGlzdGFuY2VQcm94eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlUHJveHkgPSBiMkRpc3RhbmNlUHJveHk7XG5cbiAgIGZ1bmN0aW9uIGIyRHluYW1pY1RyZWUoKSB7XG4gICAgICBiMkR5bmFtaWNUcmVlLmIyRHluYW1pY1RyZWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkR5bmFtaWNUcmVlKSB0aGlzLmIyRHluYW1pY1RyZWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZSA9IGIyRHluYW1pY1RyZWU7XG5cbiAgIGZ1bmN0aW9uIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlKCkge1xuICAgICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UuYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UgPSBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZTtcblxuICAgZnVuY3Rpb24gYjJEeW5hbWljVHJlZU5vZGUoKSB7XG4gICAgICBiMkR5bmFtaWNUcmVlTm9kZS5iMkR5bmFtaWNUcmVlTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlTm9kZSA9IGIyRHluYW1pY1RyZWVOb2RlO1xuXG4gICBmdW5jdGlvbiBiMkR5bmFtaWNUcmVlUGFpcigpIHtcbiAgICAgIGIyRHluYW1pY1RyZWVQYWlyLmIyRHluYW1pY1RyZWVQYWlyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVQYWlyID0gYjJEeW5hbWljVHJlZVBhaXI7XG5cbiAgIGZ1bmN0aW9uIGIyTWFuaWZvbGQoKSB7XG4gICAgICBiMk1hbmlmb2xkLmIyTWFuaWZvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMk1hbmlmb2xkKSB0aGlzLmIyTWFuaWZvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZCA9IGIyTWFuaWZvbGQ7XG5cbiAgIGZ1bmN0aW9uIGIyTWFuaWZvbGRQb2ludCgpIHtcbiAgICAgIGIyTWFuaWZvbGRQb2ludC5iMk1hbmlmb2xkUG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMk1hbmlmb2xkUG9pbnQpIHRoaXMuYjJNYW5pZm9sZFBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyTWFuaWZvbGRQb2ludCA9IGIyTWFuaWZvbGRQb2ludDtcblxuICAgZnVuY3Rpb24gYjJQb2ludCgpIHtcbiAgICAgIGIyUG9pbnQuYjJQb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMlBvaW50ID0gYjJQb2ludDtcblxuICAgZnVuY3Rpb24gYjJSYXlDYXN0SW5wdXQoKSB7XG4gICAgICBiMlJheUNhc3RJbnB1dC5iMlJheUNhc3RJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUmF5Q2FzdElucHV0KSB0aGlzLmIyUmF5Q2FzdElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyUmF5Q2FzdElucHV0ID0gYjJSYXlDYXN0SW5wdXQ7XG5cbiAgIGZ1bmN0aW9uIGIyUmF5Q2FzdE91dHB1dCgpIHtcbiAgICAgIGIyUmF5Q2FzdE91dHB1dC5iMlJheUNhc3RPdXRwdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0T3V0cHV0ID0gYjJSYXlDYXN0T3V0cHV0O1xuXG4gICBmdW5jdGlvbiBiMlNlZ21lbnQoKSB7XG4gICAgICBiMlNlZ21lbnQuYjJTZWdtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLmIyU2VnbWVudCA9IGIyU2VnbWVudDtcblxuICAgZnVuY3Rpb24gYjJTZXBhcmF0aW9uRnVuY3Rpb24oKSB7XG4gICAgICBiMlNlcGFyYXRpb25GdW5jdGlvbi5iMlNlcGFyYXRpb25GdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbiA9IGIyU2VwYXJhdGlvbkZ1bmN0aW9uO1xuXG4gICBmdW5jdGlvbiBiMlNpbXBsZXgoKSB7XG4gICAgICBiMlNpbXBsZXguYjJTaW1wbGV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJTaW1wbGV4KSB0aGlzLmIyU2ltcGxleC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXggPSBiMlNpbXBsZXg7XG5cbiAgIGZ1bmN0aW9uIGIyU2ltcGxleENhY2hlKCkge1xuICAgICAgYjJTaW1wbGV4Q2FjaGUuYjJTaW1wbGV4Q2FjaGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4Q2FjaGUgPSBiMlNpbXBsZXhDYWNoZTtcblxuICAgZnVuY3Rpb24gYjJTaW1wbGV4VmVydGV4KCkge1xuICAgICAgYjJTaW1wbGV4VmVydGV4LmIyU2ltcGxleFZlcnRleC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhWZXJ0ZXggPSBiMlNpbXBsZXhWZXJ0ZXg7XG5cbiAgIGZ1bmN0aW9uIGIyVGltZU9mSW1wYWN0KCkge1xuICAgICAgYjJUaW1lT2ZJbXBhY3QuYjJUaW1lT2ZJbXBhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QgPSBiMlRpbWVPZkltcGFjdDtcblxuICAgZnVuY3Rpb24gYjJUT0lJbnB1dCgpIHtcbiAgICAgIGIyVE9JSW5wdXQuYjJUT0lJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5iMlRPSUlucHV0ID0gYjJUT0lJbnB1dDtcblxuICAgZnVuY3Rpb24gYjJXb3JsZE1hbmlmb2xkKCkge1xuICAgICAgYjJXb3JsZE1hbmlmb2xkLmIyV29ybGRNYW5pZm9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyV29ybGRNYW5pZm9sZCkgdGhpcy5iMldvcmxkTWFuaWZvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uYjJXb3JsZE1hbmlmb2xkID0gYjJXb3JsZE1hbmlmb2xkO1xuXG4gICBmdW5jdGlvbiBDbGlwVmVydGV4KCkge1xuICAgICAgQ2xpcFZlcnRleC5DbGlwVmVydGV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLkNsaXBWZXJ0ZXggPSBDbGlwVmVydGV4O1xuXG4gICBmdW5jdGlvbiBGZWF0dXJlcygpIHtcbiAgICAgIEZlYXR1cmVzLkZlYXR1cmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29sbGlzaW9uLkZlYXR1cmVzID0gRmVhdHVyZXM7XG5cbiAgIGZ1bmN0aW9uIGIyQ2lyY2xlU2hhcGUoKSB7XG4gICAgICBiMkNpcmNsZVNoYXBlLmIyQ2lyY2xlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkNpcmNsZVNoYXBlKSB0aGlzLmIyQ2lyY2xlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyQ2lyY2xlU2hhcGUgPSBiMkNpcmNsZVNoYXBlO1xuXG4gICBmdW5jdGlvbiBiMkVkZ2VDaGFpbkRlZigpIHtcbiAgICAgIGIyRWRnZUNoYWluRGVmLmIyRWRnZUNoYWluRGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJFZGdlQ2hhaW5EZWYpIHRoaXMuYjJFZGdlQ2hhaW5EZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZUNoYWluRGVmID0gYjJFZGdlQ2hhaW5EZWY7XG5cbiAgIGZ1bmN0aW9uIGIyRWRnZVNoYXBlKCkge1xuICAgICAgYjJFZGdlU2hhcGUuYjJFZGdlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkVkZ2VTaGFwZSkgdGhpcy5iMkVkZ2VTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlU2hhcGUgPSBiMkVkZ2VTaGFwZTtcblxuICAgZnVuY3Rpb24gYjJNYXNzRGF0YSgpIHtcbiAgICAgIGIyTWFzc0RhdGEuYjJNYXNzRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJNYXNzRGF0YSA9IGIyTWFzc0RhdGE7XG5cbiAgIGZ1bmN0aW9uIGIyUG9seWdvblNoYXBlKCkge1xuICAgICAgYjJQb2x5Z29uU2hhcGUuYjJQb2x5Z29uU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlBvbHlnb25TaGFwZSkgdGhpcy5iMlBvbHlnb25TaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJQb2x5Z29uU2hhcGUgPSBiMlBvbHlnb25TaGFwZTtcblxuICAgZnVuY3Rpb24gYjJTaGFwZSgpIHtcbiAgICAgIGIyU2hhcGUuYjJTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyU2hhcGUpIHRoaXMuYjJTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZSA9IGIyU2hhcGU7XG4gICBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCA9ICdCb3gyRC5Db21tb24uYjJpbnRlcm5hbCc7XG5cbiAgIGZ1bmN0aW9uIGIyQ29sb3IoKSB7XG4gICAgICBiMkNvbG9yLmIyQ29sb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkNvbG9yKSB0aGlzLmIyQ29sb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db21tb24uYjJDb2xvciA9IGIyQ29sb3I7XG5cbiAgIGZ1bmN0aW9uIGIyU2V0dGluZ3MoKSB7XG4gICAgICBiMlNldHRpbmdzLmIyU2V0dGluZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncyA9IGIyU2V0dGluZ3M7XG5cbiAgIGZ1bmN0aW9uIGIyTWF0MjIoKSB7XG4gICAgICBiMk1hdDIyLmIyTWF0MjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMk1hdDIyKSB0aGlzLmIyTWF0MjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDIyID0gYjJNYXQyMjtcblxuICAgZnVuY3Rpb24gYjJNYXQzMygpIHtcbiAgICAgIGIyTWF0MzMuYjJNYXQzMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTWF0MzMpIHRoaXMuYjJNYXQzMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MzMgPSBiMk1hdDMzO1xuXG4gICBmdW5jdGlvbiBiMk1hdGgoKSB7XG4gICAgICBiMk1hdGguYjJNYXRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoID0gYjJNYXRoO1xuXG4gICBmdW5jdGlvbiBiMlN3ZWVwKCkge1xuICAgICAgYjJTd2VlcC5iMlN3ZWVwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29tbW9uLk1hdGguYjJTd2VlcCA9IGIyU3dlZXA7XG5cbiAgIGZ1bmN0aW9uIGIyVHJhbnNmb3JtKCkge1xuICAgICAgYjJUcmFuc2Zvcm0uYjJUcmFuc2Zvcm0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlRyYW5zZm9ybSkgdGhpcy5iMlRyYW5zZm9ybS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbW1vbi5NYXRoLmIyVHJhbnNmb3JtID0gYjJUcmFuc2Zvcm07XG5cbiAgIGZ1bmN0aW9uIGIyVmVjMigpIHtcbiAgICAgIGIyVmVjMi5iMlZlYzIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlZlYzIpIHRoaXMuYjJWZWMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyID0gYjJWZWMyO1xuXG4gICBmdW5jdGlvbiBiMlZlYzMoKSB7XG4gICAgICBiMlZlYzMuYjJWZWMzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJWZWMzKSB0aGlzLmIyVmVjMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMyA9IGIyVmVjMztcblxuICAgZnVuY3Rpb24gYjJCb2R5KCkge1xuICAgICAgYjJCb2R5LmIyQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQm9keSkgdGhpcy5iMkJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMkJvZHkgPSBiMkJvZHk7XG5cbiAgIGZ1bmN0aW9uIGIyQm9keURlZigpIHtcbiAgICAgIGIyQm9keURlZi5iMkJvZHlEZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkJvZHlEZWYpIHRoaXMuYjJCb2R5RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmID0gYjJCb2R5RGVmO1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RGaWx0ZXIoKSB7XG4gICAgICBiMkNvbnRhY3RGaWx0ZXIuYjJDb250YWN0RmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyID0gYjJDb250YWN0RmlsdGVyO1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RJbXB1bHNlKCkge1xuICAgICAgYjJDb250YWN0SW1wdWxzZS5iMkNvbnRhY3RJbXB1bHNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJDb250YWN0SW1wdWxzZSA9IGIyQ29udGFjdEltcHVsc2U7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdExpc3RlbmVyKCkge1xuICAgICAgYjJDb250YWN0TGlzdGVuZXIuYjJDb250YWN0TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lciA9IGIyQ29udGFjdExpc3RlbmVyO1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RNYW5hZ2VyKCkge1xuICAgICAgYjJDb250YWN0TWFuYWdlci5iMkNvbnRhY3RNYW5hZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJDb250YWN0TWFuYWdlcikgdGhpcy5iMkNvbnRhY3RNYW5hZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJDb250YWN0TWFuYWdlciA9IGIyQ29udGFjdE1hbmFnZXI7XG5cbiAgIGZ1bmN0aW9uIGIyRGVidWdEcmF3KCkge1xuICAgICAgYjJEZWJ1Z0RyYXcuYjJEZWJ1Z0RyYXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkRlYnVnRHJhdykgdGhpcy5iMkRlYnVnRHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3ID0gYjJEZWJ1Z0RyYXc7XG5cbiAgIGZ1bmN0aW9uIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcigpIHtcbiAgICAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lci5iMkRlc3RydWN0aW9uTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMkRlc3RydWN0aW9uTGlzdGVuZXIgPSBiMkRlc3RydWN0aW9uTGlzdGVuZXI7XG5cbiAgIGZ1bmN0aW9uIGIyRmlsdGVyRGF0YSgpIHtcbiAgICAgIGIyRmlsdGVyRGF0YS5iMkZpbHRlckRhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5iMkZpbHRlckRhdGEgPSBiMkZpbHRlckRhdGE7XG5cbiAgIGZ1bmN0aW9uIGIyRml4dHVyZSgpIHtcbiAgICAgIGIyRml4dHVyZS5iMkZpeHR1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkZpeHR1cmUpIHRoaXMuYjJGaXh0dXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlID0gYjJGaXh0dXJlO1xuXG4gICBmdW5jdGlvbiBiMkZpeHR1cmVEZWYoKSB7XG4gICAgICBiMkZpeHR1cmVEZWYuYjJGaXh0dXJlRGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJGaXh0dXJlRGVmKSB0aGlzLmIyRml4dHVyZURlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZiA9IGIyRml4dHVyZURlZjtcblxuICAgZnVuY3Rpb24gYjJJc2xhbmQoKSB7XG4gICAgICBiMklzbGFuZC5iMklzbGFuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIySXNsYW5kKSB0aGlzLmIySXNsYW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJJc2xhbmQgPSBiMklzbGFuZDtcblxuICAgZnVuY3Rpb24gYjJUaW1lU3RlcCgpIHtcbiAgICAgIGIyVGltZVN0ZXAuYjJUaW1lU3RlcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLmIyVGltZVN0ZXAgPSBiMlRpbWVTdGVwO1xuXG4gICBmdW5jdGlvbiBiMldvcmxkKCkge1xuICAgICAgYjJXb3JsZC5iMldvcmxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJXb3JsZCkgdGhpcy5iMldvcmxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZCA9IGIyV29ybGQ7XG5cbiAgIGZ1bmN0aW9uIGIyQ2lyY2xlQ29udGFjdCgpIHtcbiAgICAgIGIyQ2lyY2xlQ29udGFjdC5iMkNpcmNsZUNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNpcmNsZUNvbnRhY3QgPSBiMkNpcmNsZUNvbnRhY3Q7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdCgpIHtcbiAgICAgIGIyQ29udGFjdC5iMkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkNvbnRhY3QpIHRoaXMuYjJDb250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0ID0gYjJDb250YWN0O1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RDb25zdHJhaW50KCkge1xuICAgICAgYjJDb250YWN0Q29uc3RyYWludC5iMkNvbnRhY3RDb25zdHJhaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJDb250YWN0Q29uc3RyYWludCkgdGhpcy5iMkNvbnRhY3RDb25zdHJhaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0Q29uc3RyYWludCA9IGIyQ29udGFjdENvbnN0cmFpbnQ7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdENvbnN0cmFpbnRQb2ludCgpIHtcbiAgICAgIGIyQ29udGFjdENvbnN0cmFpbnRQb2ludC5iMkNvbnRhY3RDb25zdHJhaW50UG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RDb25zdHJhaW50UG9pbnQgPSBiMkNvbnRhY3RDb25zdHJhaW50UG9pbnQ7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udGFjdEVkZ2UoKSB7XG4gICAgICBiMkNvbnRhY3RFZGdlLmIyQ29udGFjdEVkZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RFZGdlID0gYjJDb250YWN0RWRnZTtcblxuICAgZnVuY3Rpb24gYjJDb250YWN0RmFjdG9yeSgpIHtcbiAgICAgIGIyQ29udGFjdEZhY3RvcnkuYjJDb250YWN0RmFjdG9yeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQ29udGFjdEZhY3RvcnkpIHRoaXMuYjJDb250YWN0RmFjdG9yeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdEZhY3RvcnkgPSBiMkNvbnRhY3RGYWN0b3J5O1xuXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RSZWdpc3RlcigpIHtcbiAgICAgIGIyQ29udGFjdFJlZ2lzdGVyLmIyQ29udGFjdFJlZ2lzdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0UmVnaXN0ZXIgPSBiMkNvbnRhY3RSZWdpc3RlcjtcblxuICAgZnVuY3Rpb24gYjJDb250YWN0UmVzdWx0KCkge1xuICAgICAgYjJDb250YWN0UmVzdWx0LmIyQ29udGFjdFJlc3VsdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFJlc3VsdCA9IGIyQ29udGFjdFJlc3VsdDtcblxuICAgZnVuY3Rpb24gYjJDb250YWN0U29sdmVyKCkge1xuICAgICAgYjJDb250YWN0U29sdmVyLmIyQ29udGFjdFNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQ29udGFjdFNvbHZlcikgdGhpcy5iMkNvbnRhY3RTb2x2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RTb2x2ZXIgPSBiMkNvbnRhY3RTb2x2ZXI7XG5cbiAgIGZ1bmN0aW9uIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QoKSB7XG4gICAgICBiMkVkZ2VBbmRDaXJjbGVDb250YWN0LmIyRWRnZUFuZENpcmNsZUNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkVkZ2VBbmRDaXJjbGVDb250YWN0ID0gYjJFZGdlQW5kQ2lyY2xlQ29udGFjdDtcblxuICAgZnVuY3Rpb24gYjJOdWxsQ29udGFjdCgpIHtcbiAgICAgIGIyTnVsbENvbnRhY3QuYjJOdWxsQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTnVsbENvbnRhY3QpIHRoaXMuYjJOdWxsQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyTnVsbENvbnRhY3QgPSBiMk51bGxDb250YWN0O1xuXG4gICBmdW5jdGlvbiBiMlBvbHlBbmRDaXJjbGVDb250YWN0KCkge1xuICAgICAgYjJQb2x5QW5kQ2lyY2xlQ29udGFjdC5iMlBvbHlBbmRDaXJjbGVDb250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCA9IGIyUG9seUFuZENpcmNsZUNvbnRhY3Q7XG5cbiAgIGZ1bmN0aW9uIGIyUG9seUFuZEVkZ2VDb250YWN0KCkge1xuICAgICAgYjJQb2x5QW5kRWRnZUNvbnRhY3QuYjJQb2x5QW5kRWRnZUNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvbHlBbmRFZGdlQ29udGFjdCA9IGIyUG9seUFuZEVkZ2VDb250YWN0O1xuXG4gICBmdW5jdGlvbiBiMlBvbHlnb25Db250YWN0KCkge1xuICAgICAgYjJQb2x5Z29uQ29udGFjdC5iMlBvbHlnb25Db250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5Z29uQ29udGFjdCA9IGIyUG9seWdvbkNvbnRhY3Q7XG5cbiAgIGZ1bmN0aW9uIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCgpIHtcbiAgICAgIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZC5iMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQpIHRoaXMuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkID0gYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkO1xuXG4gICBmdW5jdGlvbiBiMkJ1b3lhbmN5Q29udHJvbGxlcigpIHtcbiAgICAgIGIyQnVveWFuY3lDb250cm9sbGVyLmIyQnVveWFuY3lDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJCdW95YW5jeUNvbnRyb2xsZXIgPSBiMkJ1b3lhbmN5Q29udHJvbGxlcjtcblxuICAgZnVuY3Rpb24gYjJDb25zdGFudEFjY2VsQ29udHJvbGxlcigpIHtcbiAgICAgIGIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIuYjJDb25zdGFudEFjY2VsQ29udHJvbGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIgPSBiMkNvbnN0YW50QWNjZWxDb250cm9sbGVyO1xuXG4gICBmdW5jdGlvbiBiMkNvbnN0YW50Rm9yY2VDb250cm9sbGVyKCkge1xuICAgICAgYjJDb25zdGFudEZvcmNlQ29udHJvbGxlci5iMkNvbnN0YW50Rm9yY2VDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb25zdGFudEZvcmNlQ29udHJvbGxlciA9IGIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXI7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udHJvbGxlcigpIHtcbiAgICAgIGIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXIgPSBiMkNvbnRyb2xsZXI7XG5cbiAgIGZ1bmN0aW9uIGIyQ29udHJvbGxlckVkZ2UoKSB7XG4gICAgICBiMkNvbnRyb2xsZXJFZGdlLmIyQ29udHJvbGxlckVkZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXJFZGdlID0gYjJDb250cm9sbGVyRWRnZTtcblxuICAgZnVuY3Rpb24gYjJHcmF2aXR5Q29udHJvbGxlcigpIHtcbiAgICAgIGIyR3Jhdml0eUNvbnRyb2xsZXIuYjJHcmF2aXR5Q29udHJvbGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyR3Jhdml0eUNvbnRyb2xsZXIgPSBiMkdyYXZpdHlDb250cm9sbGVyO1xuXG4gICBmdW5jdGlvbiBiMlRlbnNvckRhbXBpbmdDb250cm9sbGVyKCkge1xuICAgICAgYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlci5iMlRlbnNvckRhbXBpbmdDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlciA9IGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXI7XG5cbiAgIGZ1bmN0aW9uIGIyRGlzdGFuY2VKb2ludCgpIHtcbiAgICAgIGIyRGlzdGFuY2VKb2ludC5iMkRpc3RhbmNlSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkRpc3RhbmNlSm9pbnQpIHRoaXMuYjJEaXN0YW5jZUpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyRGlzdGFuY2VKb2ludCA9IGIyRGlzdGFuY2VKb2ludDtcblxuICAgZnVuY3Rpb24gYjJEaXN0YW5jZUpvaW50RGVmKCkge1xuICAgICAgYjJEaXN0YW5jZUpvaW50RGVmLmIyRGlzdGFuY2VKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRGlzdGFuY2VKb2ludERlZikgdGhpcy5iMkRpc3RhbmNlSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJEaXN0YW5jZUpvaW50RGVmID0gYjJEaXN0YW5jZUpvaW50RGVmO1xuXG4gICBmdW5jdGlvbiBiMkZyaWN0aW9uSm9pbnQoKSB7XG4gICAgICBiMkZyaWN0aW9uSm9pbnQuYjJGcmljdGlvbkpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJGcmljdGlvbkpvaW50KSB0aGlzLmIyRnJpY3Rpb25Kb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkZyaWN0aW9uSm9pbnQgPSBiMkZyaWN0aW9uSm9pbnQ7XG5cbiAgIGZ1bmN0aW9uIGIyRnJpY3Rpb25Kb2ludERlZigpIHtcbiAgICAgIGIyRnJpY3Rpb25Kb2ludERlZi5iMkZyaWN0aW9uSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkZyaWN0aW9uSm9pbnREZWYpIHRoaXMuYjJGcmljdGlvbkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyRnJpY3Rpb25Kb2ludERlZiA9IGIyRnJpY3Rpb25Kb2ludERlZjtcblxuICAgZnVuY3Rpb24gYjJHZWFySm9pbnQoKSB7XG4gICAgICBiMkdlYXJKb2ludC5iMkdlYXJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyR2VhckpvaW50KSB0aGlzLmIyR2VhckpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyR2VhckpvaW50ID0gYjJHZWFySm9pbnQ7XG5cbiAgIGZ1bmN0aW9uIGIyR2VhckpvaW50RGVmKCkge1xuICAgICAgYjJHZWFySm9pbnREZWYuYjJHZWFySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkdlYXJKb2ludERlZikgdGhpcy5iMkdlYXJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkdlYXJKb2ludERlZiA9IGIyR2VhckpvaW50RGVmO1xuXG4gICBmdW5jdGlvbiBiMkphY29iaWFuKCkge1xuICAgICAgYjJKYWNvYmlhbi5iMkphY29iaWFuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySmFjb2JpYW4gPSBiMkphY29iaWFuO1xuXG4gICBmdW5jdGlvbiBiMkpvaW50KCkge1xuICAgICAgYjJKb2ludC5iMkpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJKb2ludCkgdGhpcy5iMkpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQgPSBiMkpvaW50O1xuXG4gICBmdW5jdGlvbiBiMkpvaW50RGVmKCkge1xuICAgICAgYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJKb2ludERlZikgdGhpcy5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYgPSBiMkpvaW50RGVmO1xuXG4gICBmdW5jdGlvbiBiMkpvaW50RWRnZSgpIHtcbiAgICAgIGIySm9pbnRFZGdlLmIySm9pbnRFZGdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnRFZGdlID0gYjJKb2ludEVkZ2U7XG5cbiAgIGZ1bmN0aW9uIGIyTGluZUpvaW50KCkge1xuICAgICAgYjJMaW5lSm9pbnQuYjJMaW5lSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkxpbmVKb2ludCkgdGhpcy5iMkxpbmVKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkxpbmVKb2ludCA9IGIyTGluZUpvaW50O1xuXG4gICBmdW5jdGlvbiBiMkxpbmVKb2ludERlZigpIHtcbiAgICAgIGIyTGluZUpvaW50RGVmLmIyTGluZUpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJMaW5lSm9pbnREZWYpIHRoaXMuYjJMaW5lSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJMaW5lSm9pbnREZWYgPSBiMkxpbmVKb2ludERlZjtcblxuICAgZnVuY3Rpb24gYjJNb3VzZUpvaW50KCkge1xuICAgICAgYjJNb3VzZUpvaW50LmIyTW91c2VKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTW91c2VKb2ludCkgdGhpcy5iMk1vdXNlSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJNb3VzZUpvaW50ID0gYjJNb3VzZUpvaW50O1xuXG4gICBmdW5jdGlvbiBiMk1vdXNlSm9pbnREZWYoKSB7XG4gICAgICBiMk1vdXNlSm9pbnREZWYuYjJNb3VzZUpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJNb3VzZUpvaW50RGVmKSB0aGlzLmIyTW91c2VKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMk1vdXNlSm9pbnREZWYgPSBiMk1vdXNlSm9pbnREZWY7XG5cbiAgIGZ1bmN0aW9uIGIyUHJpc21hdGljSm9pbnQoKSB7XG4gICAgICBiMlByaXNtYXRpY0pvaW50LmIyUHJpc21hdGljSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlByaXNtYXRpY0pvaW50KSB0aGlzLmIyUHJpc21hdGljSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJQcmlzbWF0aWNKb2ludCA9IGIyUHJpc21hdGljSm9pbnQ7XG5cbiAgIGZ1bmN0aW9uIGIyUHJpc21hdGljSm9pbnREZWYoKSB7XG4gICAgICBiMlByaXNtYXRpY0pvaW50RGVmLmIyUHJpc21hdGljSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlByaXNtYXRpY0pvaW50RGVmKSB0aGlzLmIyUHJpc21hdGljSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJQcmlzbWF0aWNKb2ludERlZiA9IGIyUHJpc21hdGljSm9pbnREZWY7XG5cbiAgIGZ1bmN0aW9uIGIyUHVsbGV5Sm9pbnQoKSB7XG4gICAgICBiMlB1bGxleUpvaW50LmIyUHVsbGV5Sm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlB1bGxleUpvaW50KSB0aGlzLmIyUHVsbGV5Sm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJQdWxsZXlKb2ludCA9IGIyUHVsbGV5Sm9pbnQ7XG5cbiAgIGZ1bmN0aW9uIGIyUHVsbGV5Sm9pbnREZWYoKSB7XG4gICAgICBiMlB1bGxleUpvaW50RGVmLmIyUHVsbGV5Sm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlB1bGxleUpvaW50RGVmKSB0aGlzLmIyUHVsbGV5Sm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJQdWxsZXlKb2ludERlZiA9IGIyUHVsbGV5Sm9pbnREZWY7XG5cbiAgIGZ1bmN0aW9uIGIyUmV2b2x1dGVKb2ludCgpIHtcbiAgICAgIGIyUmV2b2x1dGVKb2ludC5iMlJldm9sdXRlSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlJldm9sdXRlSm9pbnQpIHRoaXMuYjJSZXZvbHV0ZUpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludCA9IGIyUmV2b2x1dGVKb2ludDtcblxuICAgZnVuY3Rpb24gYjJSZXZvbHV0ZUpvaW50RGVmKCkge1xuICAgICAgYjJSZXZvbHV0ZUpvaW50RGVmLmIyUmV2b2x1dGVKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUmV2b2x1dGVKb2ludERlZikgdGhpcy5iMlJldm9sdXRlSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJSZXZvbHV0ZUpvaW50RGVmID0gYjJSZXZvbHV0ZUpvaW50RGVmO1xuXG4gICBmdW5jdGlvbiBiMldlbGRKb2ludCgpIHtcbiAgICAgIGIyV2VsZEpvaW50LmIyV2VsZEpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJXZWxkSm9pbnQpIHRoaXMuYjJXZWxkSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJXZWxkSm9pbnQgPSBiMldlbGRKb2ludDtcblxuICAgZnVuY3Rpb24gYjJXZWxkSm9pbnREZWYoKSB7XG4gICAgICBiMldlbGRKb2ludERlZi5iMldlbGRKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyV2VsZEpvaW50RGVmKSB0aGlzLmIyV2VsZEpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyV2VsZEpvaW50RGVmID0gYjJXZWxkSm9pbnREZWY7XG59KSgpOyAvL2RlZmluaXRpb25zXG5Cb3gyRC5wb3N0RGVmcyA9IFtdO1xuKGZ1bmN0aW9uICgpIHtcbiAgIHZhciBiMkNpcmNsZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkNpcmNsZVNoYXBlLFxuICAgICAgYjJFZGdlQ2hhaW5EZWYgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZUNoYWluRGVmLFxuICAgICAgYjJFZGdlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZVNoYXBlLFxuICAgICAgYjJNYXNzRGF0YSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJNYXNzRGF0YSxcbiAgICAgIGIyUG9seWdvblNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlBvbHlnb25TaGFwZSxcbiAgICAgIGIyU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUsXG4gICAgICBiMkNvbG9yID0gQm94MkQuQ29tbW9uLmIyQ29sb3IsXG4gICAgICBiMmludGVybmFsID0gQm94MkQuQ29tbW9uLmIyaW50ZXJuYWwsXG4gICAgICBiMlNldHRpbmdzID0gQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MsXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcbiAgICAgIGIyTWF0MzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDMzLFxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXG4gICAgICBiMlRyYW5zZm9ybSA9IEJveDJELkNvbW1vbi5NYXRoLmIyVHJhbnNmb3JtLFxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzLFxuICAgICAgYjJBQUJCID0gQm94MkQuQ29sbGlzaW9uLmIyQUFCQixcbiAgICAgIGIyQm91bmQgPSBCb3gyRC5Db2xsaXNpb24uYjJCb3VuZCxcbiAgICAgIGIyQm91bmRWYWx1ZXMgPSBCb3gyRC5Db2xsaXNpb24uYjJCb3VuZFZhbHVlcyxcbiAgICAgIGIyQ29sbGlzaW9uID0gQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLFxuICAgICAgYjJDb250YWN0SUQgPSBCb3gyRC5Db2xsaXNpb24uYjJDb250YWN0SUQsXG4gICAgICBiMkNvbnRhY3RQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMkNvbnRhY3RQb2ludCxcbiAgICAgIGIyRGlzdGFuY2UgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZSxcbiAgICAgIGIyRGlzdGFuY2VJbnB1dCA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlSW5wdXQsXG4gICAgICBiMkRpc3RhbmNlT3V0cHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VPdXRwdXQsXG4gICAgICBiMkRpc3RhbmNlUHJveHkgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZVByb3h5LFxuICAgICAgYjJEeW5hbWljVHJlZSA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlLFxuICAgICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UsXG4gICAgICBiMkR5bmFtaWNUcmVlTm9kZSA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlTm9kZSxcbiAgICAgIGIyRHluYW1pY1RyZWVQYWlyID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVQYWlyLFxuICAgICAgYjJNYW5pZm9sZCA9IEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkLFxuICAgICAgYjJNYW5pZm9sZFBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyTWFuaWZvbGRQb2ludCxcbiAgICAgIGIyUG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJQb2ludCxcbiAgICAgIGIyUmF5Q2FzdElucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyUmF5Q2FzdElucHV0LFxuICAgICAgYjJSYXlDYXN0T3V0cHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyUmF5Q2FzdE91dHB1dCxcbiAgICAgIGIyU2VnbWVudCA9IEJveDJELkNvbGxpc2lvbi5iMlNlZ21lbnQsXG4gICAgICBiMlNlcGFyYXRpb25GdW5jdGlvbiA9IEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbixcbiAgICAgIGIyU2ltcGxleCA9IEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXgsXG4gICAgICBiMlNpbXBsZXhDYWNoZSA9IEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhDYWNoZSxcbiAgICAgIGIyU2ltcGxleFZlcnRleCA9IEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhWZXJ0ZXgsXG4gICAgICBiMlRpbWVPZkltcGFjdCA9IEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdCxcbiAgICAgIGIyVE9JSW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJUT0lJbnB1dCxcbiAgICAgIGIyV29ybGRNYW5pZm9sZCA9IEJveDJELkNvbGxpc2lvbi5iMldvcmxkTWFuaWZvbGQsXG4gICAgICBDbGlwVmVydGV4ID0gQm94MkQuQ29sbGlzaW9uLkNsaXBWZXJ0ZXgsXG4gICAgICBGZWF0dXJlcyA9IEJveDJELkNvbGxpc2lvbi5GZWF0dXJlcyxcbiAgICAgIElCcm9hZFBoYXNlID0gQm94MkQuQ29sbGlzaW9uLklCcm9hZFBoYXNlO1xuXG4gICBiMkFBQkIuYjJBQUJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sb3dlckJvdW5kID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy51cHBlckJvdW5kID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyQUFCQi5wcm90b3R5cGUuSXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkWCA9IHRoaXMudXBwZXJCb3VuZC54IC0gdGhpcy5sb3dlckJvdW5kLng7XG4gICAgICB2YXIgZFkgPSB0aGlzLnVwcGVyQm91bmQueSAtIHRoaXMubG93ZXJCb3VuZC55O1xuICAgICAgdmFyIHZhbGlkID0gZFggPj0gMC4wICYmIGRZID49IDAuMDtcbiAgICAgIHZhbGlkID0gdmFsaWQgJiYgdGhpcy5sb3dlckJvdW5kLklzVmFsaWQoKSAmJiB0aGlzLnVwcGVyQm91bmQuSXNWYWxpZCgpO1xuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgfVxuICAgYjJBQUJCLnByb3RvdHlwZS5HZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMigodGhpcy5sb3dlckJvdW5kLnggKyB0aGlzLnVwcGVyQm91bmQueCkgLyAyLCAodGhpcy5sb3dlckJvdW5kLnkgKyB0aGlzLnVwcGVyQm91bmQueSkgLyAyKTtcbiAgIH1cbiAgIGIyQUFCQi5wcm90b3R5cGUuR2V0RXh0ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgYjJWZWMyKCh0aGlzLnVwcGVyQm91bmQueCAtIHRoaXMubG93ZXJCb3VuZC54KSAvIDIsICh0aGlzLnVwcGVyQm91bmQueSAtIHRoaXMubG93ZXJCb3VuZC55KSAvIDIpO1xuICAgfVxuICAgYjJBQUJCLnByb3RvdHlwZS5Db250YWlucyA9IGZ1bmN0aW9uIChhYWJiKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiB0aGlzLmxvd2VyQm91bmQueCA8PSBhYWJiLmxvd2VyQm91bmQueDtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiB0aGlzLmxvd2VyQm91bmQueSA8PSBhYWJiLmxvd2VyQm91bmQueTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBhYWJiLnVwcGVyQm91bmQueCA8PSB0aGlzLnVwcGVyQm91bmQueDtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBhYWJiLnVwcGVyQm91bmQueSA8PSB0aGlzLnVwcGVyQm91bmQueTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICB9XG4gICBiMkFBQkIucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCkge1xuICAgICAgdmFyIHRtaW4gPSAoLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgdmFyIHRtYXggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIHBYID0gaW5wdXQucDEueDtcbiAgICAgIHZhciBwWSA9IGlucHV0LnAxLnk7XG4gICAgICB2YXIgZFggPSBpbnB1dC5wMi54IC0gaW5wdXQucDEueDtcbiAgICAgIHZhciBkWSA9IGlucHV0LnAyLnkgLSBpbnB1dC5wMS55O1xuICAgICAgdmFyIGFic0RYID0gTWF0aC5hYnMoZFgpO1xuICAgICAgdmFyIGFic0RZID0gTWF0aC5hYnMoZFkpO1xuICAgICAgdmFyIG5vcm1hbCA9IG91dHB1dC5ub3JtYWw7XG4gICAgICB2YXIgaW52X2QgPSAwO1xuICAgICAgdmFyIHQxID0gMDtcbiAgICAgIHZhciB0MiA9IDA7XG4gICAgICB2YXIgdDMgPSAwO1xuICAgICAgdmFyIHMgPSAwOyB7XG4gICAgICAgICBpZiAoYWJzRFggPCBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICAgICBpZiAocFggPCB0aGlzLmxvd2VyQm91bmQueCB8fCB0aGlzLnVwcGVyQm91bmQueCA8IHBYKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGludl9kID0gMS4wIC8gZFg7XG4gICAgICAgICAgICB0MSA9ICh0aGlzLmxvd2VyQm91bmQueCAtIHBYKSAqIGludl9kO1xuICAgICAgICAgICAgdDIgPSAodGhpcy51cHBlckJvdW5kLnggLSBwWCkgKiBpbnZfZDtcbiAgICAgICAgICAgIHMgPSAoLTEuMCk7XG4gICAgICAgICAgICBpZiAodDEgPiB0Mikge1xuICAgICAgICAgICAgICAgdDMgPSB0MTtcbiAgICAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgICAgICAgICB0MiA9IHQzO1xuICAgICAgICAgICAgICAgcyA9IDEuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0MSA+IHRtaW4pIHtcbiAgICAgICAgICAgICAgIG5vcm1hbC54ID0gcztcbiAgICAgICAgICAgICAgIG5vcm1hbC55ID0gMDtcbiAgICAgICAgICAgICAgIHRtaW4gPSB0MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCB0Mik7XG4gICAgICAgICAgICBpZiAodG1pbiA+IHRtYXgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgIH1cbiAgICAgIH0ge1xuICAgICAgICAgaWYgKGFic0RZIDwgTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgICAgaWYgKHBZIDwgdGhpcy5sb3dlckJvdW5kLnkgfHwgdGhpcy51cHBlckJvdW5kLnkgPCBwWSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnZfZCA9IDEuMCAvIGRZO1xuICAgICAgICAgICAgdDEgPSAodGhpcy5sb3dlckJvdW5kLnkgLSBwWSkgKiBpbnZfZDtcbiAgICAgICAgICAgIHQyID0gKHRoaXMudXBwZXJCb3VuZC55IC0gcFkpICogaW52X2Q7XG4gICAgICAgICAgICBzID0gKC0xLjApO1xuICAgICAgICAgICAgaWYgKHQxID4gdDIpIHtcbiAgICAgICAgICAgICAgIHQzID0gdDE7XG4gICAgICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICAgICAgICAgdDIgPSB0MztcbiAgICAgICAgICAgICAgIHMgPSAxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodDEgPiB0bWluKSB7XG4gICAgICAgICAgICAgICBub3JtYWwueSA9IHM7XG4gICAgICAgICAgICAgICBub3JtYWwueCA9IDA7XG4gICAgICAgICAgICAgICB0bWluID0gdDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgdDIpO1xuICAgICAgICAgICAgaWYgKHRtaW4gPiB0bWF4KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXRwdXQuZnJhY3Rpb24gPSB0bWluO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICB9XG4gICBiMkFBQkIucHJvdG90eXBlLlRlc3RPdmVybGFwID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICB2YXIgZDFYID0gb3RoZXIubG93ZXJCb3VuZC54IC0gdGhpcy51cHBlckJvdW5kLng7XG4gICAgICB2YXIgZDFZID0gb3RoZXIubG93ZXJCb3VuZC55IC0gdGhpcy51cHBlckJvdW5kLnk7XG4gICAgICB2YXIgZDJYID0gdGhpcy5sb3dlckJvdW5kLnggLSBvdGhlci51cHBlckJvdW5kLng7XG4gICAgICB2YXIgZDJZID0gdGhpcy5sb3dlckJvdW5kLnkgLSBvdGhlci51cHBlckJvdW5kLnk7XG4gICAgICBpZiAoZDFYID4gMC4wIHx8IGQxWSA+IDAuMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGQyWCA+IDAuMCB8fCBkMlkgPiAwLjApIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgYjJBQUJCLkNvbWJpbmUgPSBmdW5jdGlvbiAoYWFiYjEsIGFhYmIyKSB7XG4gICAgICB2YXIgYWFiYiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIGFhYmIuQ29tYmluZShhYWJiMSwgYWFiYjIpO1xuICAgICAgcmV0dXJuIGFhYmI7XG4gICB9XG4gICBiMkFBQkIucHJvdG90eXBlLkNvbWJpbmUgPSBmdW5jdGlvbiAoYWFiYjEsIGFhYmIyKSB7XG4gICAgICB0aGlzLmxvd2VyQm91bmQueCA9IE1hdGgubWluKGFhYmIxLmxvd2VyQm91bmQueCwgYWFiYjIubG93ZXJCb3VuZC54KTtcbiAgICAgIHRoaXMubG93ZXJCb3VuZC55ID0gTWF0aC5taW4oYWFiYjEubG93ZXJCb3VuZC55LCBhYWJiMi5sb3dlckJvdW5kLnkpO1xuICAgICAgdGhpcy51cHBlckJvdW5kLnggPSBNYXRoLm1heChhYWJiMS51cHBlckJvdW5kLngsIGFhYmIyLnVwcGVyQm91bmQueCk7XG4gICAgICB0aGlzLnVwcGVyQm91bmQueSA9IE1hdGgubWF4KGFhYmIxLnVwcGVyQm91bmQueSwgYWFiYjIudXBwZXJCb3VuZC55KTtcbiAgIH1cbiAgIGIyQm91bmQuYjJCb3VuZCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJCb3VuZC5wcm90b3R5cGUuSXNMb3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09IDA7XG4gICB9XG4gICBiMkJvdW5kLnByb3RvdHlwZS5Jc1VwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT0gMTtcbiAgIH1cbiAgIGIyQm91bmQucHJvdG90eXBlLlN3YXAgPSBmdW5jdGlvbiAoYikge1xuICAgICAgdmFyIHRlbXBWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB2YXIgdGVtcFByb3h5ID0gdGhpcy5wcm94eTtcbiAgICAgIHZhciB0ZW1wU3RhYmJpbmdDb3VudCA9IHRoaXMuc3RhYmJpbmdDb3VudDtcbiAgICAgIHRoaXMudmFsdWUgPSBiLnZhbHVlO1xuICAgICAgdGhpcy5wcm94eSA9IGIucHJveHk7XG4gICAgICB0aGlzLnN0YWJiaW5nQ291bnQgPSBiLnN0YWJiaW5nQ291bnQ7XG4gICAgICBiLnZhbHVlID0gdGVtcFZhbHVlO1xuICAgICAgYi5wcm94eSA9IHRlbXBQcm94eTtcbiAgICAgIGIuc3RhYmJpbmdDb3VudCA9IHRlbXBTdGFiYmluZ0NvdW50O1xuICAgfVxuICAgYjJCb3VuZFZhbHVlcy5iMkJvdW5kVmFsdWVzID0gZnVuY3Rpb24gKCkge307XG4gICBiMkJvdW5kVmFsdWVzLnByb3RvdHlwZS5iMkJvdW5kVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sb3dlclZhbHVlcyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigpO1xuICAgICAgdGhpcy5sb3dlclZhbHVlc1swXSA9IDAuMDtcbiAgICAgIHRoaXMubG93ZXJWYWx1ZXNbMV0gPSAwLjA7XG4gICAgICB0aGlzLnVwcGVyVmFsdWVzID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKCk7XG4gICAgICB0aGlzLnVwcGVyVmFsdWVzWzBdID0gMC4wO1xuICAgICAgdGhpcy51cHBlclZhbHVlc1sxXSA9IDAuMDtcbiAgIH1cbiAgIGIyQ29sbGlzaW9uLmIyQ29sbGlzaW9uID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbGxpc2lvbi5DbGlwU2VnbWVudFRvTGluZSA9IGZ1bmN0aW9uICh2T3V0LCB2SW4sIG5vcm1hbCwgb2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIG9mZnNldCA9IDA7XG4gICAgICB2YXIgY3Y7XG4gICAgICB2YXIgbnVtT3V0ID0gMDtcbiAgICAgIGN2ID0gdkluWzBdO1xuICAgICAgdmFyIHZJbjAgPSBjdi52O1xuICAgICAgY3YgPSB2SW5bMV07XG4gICAgICB2YXIgdkluMSA9IGN2LnY7XG4gICAgICB2YXIgZGlzdGFuY2UwID0gbm9ybWFsLnggKiB2SW4wLnggKyBub3JtYWwueSAqIHZJbjAueSAtIG9mZnNldDtcbiAgICAgIHZhciBkaXN0YW5jZTEgPSBub3JtYWwueCAqIHZJbjEueCArIG5vcm1hbC55ICogdkluMS55IC0gb2Zmc2V0O1xuICAgICAgaWYgKGRpc3RhbmNlMCA8PSAwLjApIHZPdXRbbnVtT3V0KytdLlNldCh2SW5bMF0pO1xuICAgICAgaWYgKGRpc3RhbmNlMSA8PSAwLjApIHZPdXRbbnVtT3V0KytdLlNldCh2SW5bMV0pO1xuICAgICAgaWYgKGRpc3RhbmNlMCAqIGRpc3RhbmNlMSA8IDAuMCkge1xuICAgICAgICAgdmFyIGludGVycCA9IGRpc3RhbmNlMCAvIChkaXN0YW5jZTAgLSBkaXN0YW5jZTEpO1xuICAgICAgICAgY3YgPSB2T3V0W251bU91dF07XG4gICAgICAgICB2YXIgdFZlYyA9IGN2LnY7XG4gICAgICAgICB0VmVjLnggPSB2SW4wLnggKyBpbnRlcnAgKiAodkluMS54IC0gdkluMC54KTtcbiAgICAgICAgIHRWZWMueSA9IHZJbjAueSArIGludGVycCAqICh2SW4xLnkgLSB2SW4wLnkpO1xuICAgICAgICAgY3YgPSB2T3V0W251bU91dF07XG4gICAgICAgICB2YXIgY3YyO1xuICAgICAgICAgaWYgKGRpc3RhbmNlMCA+IDAuMCkge1xuICAgICAgICAgICAgY3YyID0gdkluWzBdO1xuICAgICAgICAgICAgY3YuaWQgPSBjdjIuaWQ7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN2MiA9IHZJblsxXTtcbiAgICAgICAgICAgIGN2LmlkID0gY3YyLmlkO1xuICAgICAgICAgfSsrbnVtT3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bU91dDtcbiAgIH1cbiAgIGIyQ29sbGlzaW9uLkVkZ2VTZXBhcmF0aW9uID0gZnVuY3Rpb24gKHBvbHkxLCB4ZjEsIGVkZ2UxLCBwb2x5MiwgeGYyKSB7XG4gICAgICBpZiAoZWRnZTEgPT09IHVuZGVmaW5lZCkgZWRnZTEgPSAwO1xuICAgICAgdmFyIGNvdW50MSA9IHBhcnNlSW50KHBvbHkxLm1fdmVydGV4Q291bnQpO1xuICAgICAgdmFyIHZlcnRpY2VzMSA9IHBvbHkxLm1fdmVydGljZXM7XG4gICAgICB2YXIgbm9ybWFsczEgPSBwb2x5MS5tX25vcm1hbHM7XG4gICAgICB2YXIgY291bnQyID0gcGFyc2VJbnQocG9seTIubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgdmVydGljZXMyID0gcG9seTIubV92ZXJ0aWNlcztcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRWZWM7XG4gICAgICB0TWF0ID0geGYxLlI7XG4gICAgICB0VmVjID0gbm9ybWFsczFbZWRnZTFdO1xuICAgICAgdmFyIG5vcm1hbDFXb3JsZFggPSAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB2YXIgbm9ybWFsMVdvcmxkWSA9ICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHRNYXQgPSB4ZjIuUjtcbiAgICAgIHZhciBub3JtYWwxWCA9ICh0TWF0LmNvbDEueCAqIG5vcm1hbDFXb3JsZFggKyB0TWF0LmNvbDEueSAqIG5vcm1hbDFXb3JsZFkpO1xuICAgICAgdmFyIG5vcm1hbDFZID0gKHRNYXQuY29sMi54ICogbm9ybWFsMVdvcmxkWCArIHRNYXQuY29sMi55ICogbm9ybWFsMVdvcmxkWSk7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIG1pbkRvdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50MjsgKytpKSB7XG4gICAgICAgICB0VmVjID0gdmVydGljZXMyW2ldO1xuICAgICAgICAgdmFyIGRvdCA9IHRWZWMueCAqIG5vcm1hbDFYICsgdFZlYy55ICogbm9ybWFsMVk7XG4gICAgICAgICBpZiAoZG90IDwgbWluRG90KSB7XG4gICAgICAgICAgICBtaW5Eb3QgPSBkb3Q7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICB0VmVjID0gdmVydGljZXMxW2VkZ2UxXTtcbiAgICAgIHRNYXQgPSB4ZjEuUjtcbiAgICAgIHZhciB2MVggPSB4ZjEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHZhciB2MVkgPSB4ZjEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHRWZWMgPSB2ZXJ0aWNlczJbaW5kZXhdO1xuICAgICAgdE1hdCA9IHhmMi5SO1xuICAgICAgdmFyIHYyWCA9IHhmMi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgdmFyIHYyWSA9IHhmMi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdjJYIC09IHYxWDtcbiAgICAgIHYyWSAtPSB2MVk7XG4gICAgICB2YXIgc2VwYXJhdGlvbiA9IHYyWCAqIG5vcm1hbDFXb3JsZFggKyB2MlkgKiBub3JtYWwxV29ybGRZO1xuICAgICAgcmV0dXJuIHNlcGFyYXRpb247XG4gICB9XG4gICBiMkNvbGxpc2lvbi5GaW5kTWF4U2VwYXJhdGlvbiA9IGZ1bmN0aW9uIChlZGdlSW5kZXgsIHBvbHkxLCB4ZjEsIHBvbHkyLCB4ZjIpIHtcbiAgICAgIHZhciBjb3VudDEgPSBwYXJzZUludChwb2x5MS5tX3ZlcnRleENvdW50KTtcbiAgICAgIHZhciBub3JtYWxzMSA9IHBvbHkxLm1fbm9ybWFscztcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB0TWF0ID0geGYyLlI7XG4gICAgICB0VmVjID0gcG9seTIubV9jZW50cm9pZDtcbiAgICAgIHZhciBkWCA9IHhmMi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgdmFyIGRZID0geGYyLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICB0TWF0ID0geGYxLlI7XG4gICAgICB0VmVjID0gcG9seTEubV9jZW50cm9pZDtcbiAgICAgIGRYIC09IHhmMS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgZFkgLT0geGYxLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICB2YXIgZExvY2FsMVggPSAoZFggKiB4ZjEuUi5jb2wxLnggKyBkWSAqIHhmMS5SLmNvbDEueSk7XG4gICAgICB2YXIgZExvY2FsMVkgPSAoZFggKiB4ZjEuUi5jb2wyLnggKyBkWSAqIHhmMS5SLmNvbDIueSk7XG4gICAgICB2YXIgZWRnZSA9IDA7XG4gICAgICB2YXIgbWF4RG90ID0gKC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQxOyArK2kpIHtcbiAgICAgICAgIHRWZWMgPSBub3JtYWxzMVtpXTtcbiAgICAgICAgIHZhciBkb3QgPSAodFZlYy54ICogZExvY2FsMVggKyB0VmVjLnkgKiBkTG9jYWwxWSk7XG4gICAgICAgICBpZiAoZG90ID4gbWF4RG90KSB7XG4gICAgICAgICAgICBtYXhEb3QgPSBkb3Q7XG4gICAgICAgICAgICBlZGdlID0gaTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzID0gYjJDb2xsaXNpb24uRWRnZVNlcGFyYXRpb24ocG9seTEsIHhmMSwgZWRnZSwgcG9seTIsIHhmMik7XG4gICAgICB2YXIgcHJldkVkZ2UgPSBwYXJzZUludChlZGdlIC0gMSA+PSAwID8gZWRnZSAtIDEgOiBjb3VudDEgLSAxKTtcbiAgICAgIHZhciBzUHJldiA9IGIyQ29sbGlzaW9uLkVkZ2VTZXBhcmF0aW9uKHBvbHkxLCB4ZjEsIHByZXZFZGdlLCBwb2x5MiwgeGYyKTtcbiAgICAgIHZhciBuZXh0RWRnZSA9IHBhcnNlSW50KGVkZ2UgKyAxIDwgY291bnQxID8gZWRnZSArIDEgOiAwKTtcbiAgICAgIHZhciBzTmV4dCA9IGIyQ29sbGlzaW9uLkVkZ2VTZXBhcmF0aW9uKHBvbHkxLCB4ZjEsIG5leHRFZGdlLCBwb2x5MiwgeGYyKTtcbiAgICAgIHZhciBiZXN0RWRnZSA9IDA7XG4gICAgICB2YXIgYmVzdFNlcGFyYXRpb24gPSAwO1xuICAgICAgdmFyIGluY3JlbWVudCA9IDA7XG4gICAgICBpZiAoc1ByZXYgPiBzICYmIHNQcmV2ID4gc05leHQpIHtcbiAgICAgICAgIGluY3JlbWVudCA9ICgtMSk7XG4gICAgICAgICBiZXN0RWRnZSA9IHByZXZFZGdlO1xuICAgICAgICAgYmVzdFNlcGFyYXRpb24gPSBzUHJldjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNOZXh0ID4gcykge1xuICAgICAgICAgaW5jcmVtZW50ID0gMTtcbiAgICAgICAgIGJlc3RFZGdlID0gbmV4dEVkZ2U7XG4gICAgICAgICBiZXN0U2VwYXJhdGlvbiA9IHNOZXh0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBlZGdlSW5kZXhbMF0gPSBlZGdlO1xuICAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgaWYgKGluY3JlbWVudCA9PSAoLTEpKSBlZGdlID0gYmVzdEVkZ2UgLSAxID49IDAgPyBiZXN0RWRnZSAtIDEgOiBjb3VudDEgLSAxO1xuICAgICAgICAgZWxzZSBlZGdlID0gYmVzdEVkZ2UgKyAxIDwgY291bnQxID8gYmVzdEVkZ2UgKyAxIDogMDtzID0gYjJDb2xsaXNpb24uRWRnZVNlcGFyYXRpb24ocG9seTEsIHhmMSwgZWRnZSwgcG9seTIsIHhmMik7XG4gICAgICAgICBpZiAocyA+IGJlc3RTZXBhcmF0aW9uKSB7XG4gICAgICAgICAgICBiZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgICAgICBiZXN0U2VwYXJhdGlvbiA9IHM7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWRnZUluZGV4WzBdID0gYmVzdEVkZ2U7XG4gICAgICByZXR1cm4gYmVzdFNlcGFyYXRpb247XG4gICB9XG4gICBiMkNvbGxpc2lvbi5GaW5kSW5jaWRlbnRFZGdlID0gZnVuY3Rpb24gKGMsIHBvbHkxLCB4ZjEsIGVkZ2UxLCBwb2x5MiwgeGYyKSB7XG4gICAgICBpZiAoZWRnZTEgPT09IHVuZGVmaW5lZCkgZWRnZTEgPSAwO1xuICAgICAgdmFyIGNvdW50MSA9IHBhcnNlSW50KHBvbHkxLm1fdmVydGV4Q291bnQpO1xuICAgICAgdmFyIG5vcm1hbHMxID0gcG9seTEubV9ub3JtYWxzO1xuICAgICAgdmFyIGNvdW50MiA9IHBhcnNlSW50KHBvbHkyLm1fdmVydGV4Q291bnQpO1xuICAgICAgdmFyIHZlcnRpY2VzMiA9IHBvbHkyLm1fdmVydGljZXM7XG4gICAgICB2YXIgbm9ybWFsczIgPSBwb2x5Mi5tX25vcm1hbHM7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdE1hdCA9IHhmMS5SO1xuICAgICAgdFZlYyA9IG5vcm1hbHMxW2VkZ2UxXTtcbiAgICAgIHZhciBub3JtYWwxWCA9ICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHZhciBub3JtYWwxWSA9ICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHRNYXQgPSB4ZjIuUjtcbiAgICAgIHZhciB0WCA9ICh0TWF0LmNvbDEueCAqIG5vcm1hbDFYICsgdE1hdC5jb2wxLnkgKiBub3JtYWwxWSk7XG4gICAgICBub3JtYWwxWSA9ICh0TWF0LmNvbDIueCAqIG5vcm1hbDFYICsgdE1hdC5jb2wyLnkgKiBub3JtYWwxWSk7XG4gICAgICBub3JtYWwxWCA9IHRYO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBtaW5Eb3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDI7ICsraSkge1xuICAgICAgICAgdFZlYyA9IG5vcm1hbHMyW2ldO1xuICAgICAgICAgdmFyIGRvdCA9IChub3JtYWwxWCAqIHRWZWMueCArIG5vcm1hbDFZICogdFZlYy55KTtcbiAgICAgICAgIGlmIChkb3QgPCBtaW5Eb3QpIHtcbiAgICAgICAgICAgIG1pbkRvdCA9IGRvdDtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0Q2xpcDtcbiAgICAgIHZhciBpMSA9IHBhcnNlSW50KGluZGV4KTtcbiAgICAgIHZhciBpMiA9IHBhcnNlSW50KGkxICsgMSA8IGNvdW50MiA/IGkxICsgMSA6IDApO1xuICAgICAgdENsaXAgPSBjWzBdO1xuICAgICAgdFZlYyA9IHZlcnRpY2VzMltpMV07XG4gICAgICB0TWF0ID0geGYyLlI7XG4gICAgICB0Q2xpcC52LnggPSB4ZjIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHRDbGlwLnYueSA9IHhmMi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdENsaXAuaWQuZmVhdHVyZXMucmVmZXJlbmNlRWRnZSA9IGVkZ2UxO1xuICAgICAgdENsaXAuaWQuZmVhdHVyZXMuaW5jaWRlbnRFZGdlID0gaTE7XG4gICAgICB0Q2xpcC5pZC5mZWF0dXJlcy5pbmNpZGVudFZlcnRleCA9IDA7XG4gICAgICB0Q2xpcCA9IGNbMV07XG4gICAgICB0VmVjID0gdmVydGljZXMyW2kyXTtcbiAgICAgIHRNYXQgPSB4ZjIuUjtcbiAgICAgIHRDbGlwLnYueCA9IHhmMi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgdENsaXAudi55ID0geGYyLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICB0Q2xpcC5pZC5mZWF0dXJlcy5yZWZlcmVuY2VFZGdlID0gZWRnZTE7XG4gICAgICB0Q2xpcC5pZC5mZWF0dXJlcy5pbmNpZGVudEVkZ2UgPSBpMjtcbiAgICAgIHRDbGlwLmlkLmZlYXR1cmVzLmluY2lkZW50VmVydGV4ID0gMTtcbiAgIH1cbiAgIGIyQ29sbGlzaW9uLk1ha2VDbGlwUG9pbnRWZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgciA9IG5ldyBWZWN0b3IoMik7XG4gICAgICByWzBdID0gbmV3IENsaXBWZXJ0ZXgoKTtcbiAgICAgIHJbMV0gPSBuZXcgQ2xpcFZlcnRleCgpO1xuICAgICAgcmV0dXJuIHI7XG4gICB9XG4gICBiMkNvbGxpc2lvbi5Db2xsaWRlUG9seWdvbnMgPSBmdW5jdGlvbiAobWFuaWZvbGQsIHBvbHlBLCB4ZkEsIHBvbHlCLCB4ZkIpIHtcbiAgICAgIHZhciBjdjtcbiAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDA7XG4gICAgICB2YXIgdG90YWxSYWRpdXMgPSBwb2x5QS5tX3JhZGl1cyArIHBvbHlCLm1fcmFkaXVzO1xuICAgICAgdmFyIGVkZ2VBID0gMDtcbiAgICAgIGIyQ29sbGlzaW9uLnNfZWRnZUFPWzBdID0gZWRnZUE7XG4gICAgICB2YXIgc2VwYXJhdGlvbkEgPSBiMkNvbGxpc2lvbi5GaW5kTWF4U2VwYXJhdGlvbihiMkNvbGxpc2lvbi5zX2VkZ2VBTywgcG9seUEsIHhmQSwgcG9seUIsIHhmQik7XG4gICAgICBlZGdlQSA9IGIyQ29sbGlzaW9uLnNfZWRnZUFPWzBdO1xuICAgICAgaWYgKHNlcGFyYXRpb25BID4gdG90YWxSYWRpdXMpIHJldHVybjtcbiAgICAgIHZhciBlZGdlQiA9IDA7XG4gICAgICBiMkNvbGxpc2lvbi5zX2VkZ2VCT1swXSA9IGVkZ2VCO1xuICAgICAgdmFyIHNlcGFyYXRpb25CID0gYjJDb2xsaXNpb24uRmluZE1heFNlcGFyYXRpb24oYjJDb2xsaXNpb24uc19lZGdlQk8sIHBvbHlCLCB4ZkIsIHBvbHlBLCB4ZkEpO1xuICAgICAgZWRnZUIgPSBiMkNvbGxpc2lvbi5zX2VkZ2VCT1swXTtcbiAgICAgIGlmIChzZXBhcmF0aW9uQiA+IHRvdGFsUmFkaXVzKSByZXR1cm47XG4gICAgICB2YXIgcG9seTE7XG4gICAgICB2YXIgcG9seTI7XG4gICAgICB2YXIgeGYxO1xuICAgICAgdmFyIHhmMjtcbiAgICAgIHZhciBlZGdlMSA9IDA7XG4gICAgICB2YXIgZmxpcCA9IDA7XG4gICAgICB2YXIga19yZWxhdGl2ZVRvbCA9IDAuOTg7XG4gICAgICB2YXIga19hYnNvbHV0ZVRvbCA9IDAuMDAxO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICBpZiAoc2VwYXJhdGlvbkIgPiBrX3JlbGF0aXZlVG9sICogc2VwYXJhdGlvbkEgKyBrX2Fic29sdXRlVG9sKSB7XG4gICAgICAgICBwb2x5MSA9IHBvbHlCO1xuICAgICAgICAgcG9seTIgPSBwb2x5QTtcbiAgICAgICAgIHhmMSA9IHhmQjtcbiAgICAgICAgIHhmMiA9IHhmQTtcbiAgICAgICAgIGVkZ2UxID0gZWRnZUI7XG4gICAgICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfZmFjZUI7XG4gICAgICAgICBmbGlwID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgcG9seTEgPSBwb2x5QTtcbiAgICAgICAgIHBvbHkyID0gcG9seUI7XG4gICAgICAgICB4ZjEgPSB4ZkE7XG4gICAgICAgICB4ZjIgPSB4ZkI7XG4gICAgICAgICBlZGdlMSA9IGVkZ2VBO1xuICAgICAgICAgbWFuaWZvbGQubV90eXBlID0gYjJNYW5pZm9sZC5lX2ZhY2VBO1xuICAgICAgICAgZmxpcCA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgaW5jaWRlbnRFZGdlID0gYjJDb2xsaXNpb24uc19pbmNpZGVudEVkZ2U7XG4gICAgICBiMkNvbGxpc2lvbi5GaW5kSW5jaWRlbnRFZGdlKGluY2lkZW50RWRnZSwgcG9seTEsIHhmMSwgZWRnZTEsIHBvbHkyLCB4ZjIpO1xuICAgICAgdmFyIGNvdW50MSA9IHBhcnNlSW50KHBvbHkxLm1fdmVydGV4Q291bnQpO1xuICAgICAgdmFyIHZlcnRpY2VzMSA9IHBvbHkxLm1fdmVydGljZXM7XG4gICAgICB2YXIgbG9jYWxfdjExID0gdmVydGljZXMxW2VkZ2UxXTtcbiAgICAgIHZhciBsb2NhbF92MTI7XG4gICAgICBpZiAoZWRnZTEgKyAxIDwgY291bnQxKSB7XG4gICAgICAgICBsb2NhbF92MTIgPSB2ZXJ0aWNlczFbcGFyc2VJbnQoZWRnZTEgKyAxKV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIGxvY2FsX3YxMiA9IHZlcnRpY2VzMVswXTtcbiAgICAgIH1cbiAgICAgIHZhciBsb2NhbFRhbmdlbnQgPSBiMkNvbGxpc2lvbi5zX2xvY2FsVGFuZ2VudDtcbiAgICAgIGxvY2FsVGFuZ2VudC5TZXQobG9jYWxfdjEyLnggLSBsb2NhbF92MTEueCwgbG9jYWxfdjEyLnkgLSBsb2NhbF92MTEueSk7XG4gICAgICBsb2NhbFRhbmdlbnQuTm9ybWFsaXplKCk7XG4gICAgICB2YXIgbG9jYWxOb3JtYWwgPSBiMkNvbGxpc2lvbi5zX2xvY2FsTm9ybWFsO1xuICAgICAgbG9jYWxOb3JtYWwueCA9IGxvY2FsVGFuZ2VudC55O1xuICAgICAgbG9jYWxOb3JtYWwueSA9ICgtbG9jYWxUYW5nZW50LngpO1xuICAgICAgdmFyIHBsYW5lUG9pbnQgPSBiMkNvbGxpc2lvbi5zX3BsYW5lUG9pbnQ7XG4gICAgICBwbGFuZVBvaW50LlNldCgwLjUgKiAobG9jYWxfdjExLnggKyBsb2NhbF92MTIueCksIDAuNSAqIChsb2NhbF92MTEueSArIGxvY2FsX3YxMi55KSk7XG4gICAgICB2YXIgdGFuZ2VudCA9IGIyQ29sbGlzaW9uLnNfdGFuZ2VudDtcbiAgICAgIHRNYXQgPSB4ZjEuUjtcbiAgICAgIHRhbmdlbnQueCA9ICh0TWF0LmNvbDEueCAqIGxvY2FsVGFuZ2VudC54ICsgdE1hdC5jb2wyLnggKiBsb2NhbFRhbmdlbnQueSk7XG4gICAgICB0YW5nZW50LnkgPSAodE1hdC5jb2wxLnkgKiBsb2NhbFRhbmdlbnQueCArIHRNYXQuY29sMi55ICogbG9jYWxUYW5nZW50LnkpO1xuICAgICAgdmFyIHRhbmdlbnQyID0gYjJDb2xsaXNpb24uc190YW5nZW50MjtcbiAgICAgIHRhbmdlbnQyLnggPSAoLXRhbmdlbnQueCk7XG4gICAgICB0YW5nZW50Mi55ID0gKC10YW5nZW50LnkpO1xuICAgICAgdmFyIG5vcm1hbCA9IGIyQ29sbGlzaW9uLnNfbm9ybWFsO1xuICAgICAgbm9ybWFsLnggPSB0YW5nZW50Lnk7XG4gICAgICBub3JtYWwueSA9ICgtdGFuZ2VudC54KTtcbiAgICAgIHZhciB2MTEgPSBiMkNvbGxpc2lvbi5zX3YxMTtcbiAgICAgIHZhciB2MTIgPSBiMkNvbGxpc2lvbi5zX3YxMjtcbiAgICAgIHYxMS54ID0geGYxLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiBsb2NhbF92MTEueCArIHRNYXQuY29sMi54ICogbG9jYWxfdjExLnkpO1xuICAgICAgdjExLnkgPSB4ZjEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIGxvY2FsX3YxMS54ICsgdE1hdC5jb2wyLnkgKiBsb2NhbF92MTEueSk7XG4gICAgICB2MTIueCA9IHhmMS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogbG9jYWxfdjEyLnggKyB0TWF0LmNvbDIueCAqIGxvY2FsX3YxMi55KTtcbiAgICAgIHYxMi55ID0geGYxLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiBsb2NhbF92MTIueCArIHRNYXQuY29sMi55ICogbG9jYWxfdjEyLnkpO1xuICAgICAgdmFyIGZyb250T2Zmc2V0ID0gbm9ybWFsLnggKiB2MTEueCArIG5vcm1hbC55ICogdjExLnk7XG4gICAgICB2YXIgc2lkZU9mZnNldDEgPSAoLXRhbmdlbnQueCAqIHYxMS54KSAtIHRhbmdlbnQueSAqIHYxMS55ICsgdG90YWxSYWRpdXM7XG4gICAgICB2YXIgc2lkZU9mZnNldDIgPSB0YW5nZW50LnggKiB2MTIueCArIHRhbmdlbnQueSAqIHYxMi55ICsgdG90YWxSYWRpdXM7XG4gICAgICB2YXIgY2xpcFBvaW50czEgPSBiMkNvbGxpc2lvbi5zX2NsaXBQb2ludHMxO1xuICAgICAgdmFyIGNsaXBQb2ludHMyID0gYjJDb2xsaXNpb24uc19jbGlwUG9pbnRzMjtcbiAgICAgIHZhciBucCA9IDA7XG4gICAgICBucCA9IGIyQ29sbGlzaW9uLkNsaXBTZWdtZW50VG9MaW5lKGNsaXBQb2ludHMxLCBpbmNpZGVudEVkZ2UsIHRhbmdlbnQyLCBzaWRlT2Zmc2V0MSk7XG4gICAgICBpZiAobnAgPCAyKSByZXR1cm47XG4gICAgICBucCA9IGIyQ29sbGlzaW9uLkNsaXBTZWdtZW50VG9MaW5lKGNsaXBQb2ludHMyLCBjbGlwUG9pbnRzMSwgdGFuZ2VudCwgc2lkZU9mZnNldDIpO1xuICAgICAgaWYgKG5wIDwgMikgcmV0dXJuO1xuICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLlNldFYobG9jYWxOb3JtYWwpO1xuICAgICAgbWFuaWZvbGQubV9sb2NhbFBvaW50LlNldFYocGxhbmVQb2ludCk7XG4gICAgICB2YXIgcG9pbnRDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7ICsraSkge1xuICAgICAgICAgY3YgPSBjbGlwUG9pbnRzMltpXTtcbiAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gbm9ybWFsLnggKiBjdi52LnggKyBub3JtYWwueSAqIGN2LnYueSAtIGZyb250T2Zmc2V0O1xuICAgICAgICAgaWYgKHNlcGFyYXRpb24gPD0gdG90YWxSYWRpdXMpIHtcbiAgICAgICAgICAgIHZhciBjcCA9IG1hbmlmb2xkLm1fcG9pbnRzW3BvaW50Q291bnRdO1xuICAgICAgICAgICAgdE1hdCA9IHhmMi5SO1xuICAgICAgICAgICAgdmFyIHRYID0gY3Yudi54IC0geGYyLnBvc2l0aW9uLng7XG4gICAgICAgICAgICB2YXIgdFkgPSBjdi52LnkgLSB4ZjIucG9zaXRpb24ueTtcbiAgICAgICAgICAgIGNwLm1fbG9jYWxQb2ludC54ID0gKHRYICogdE1hdC5jb2wxLnggKyB0WSAqIHRNYXQuY29sMS55KTtcbiAgICAgICAgICAgIGNwLm1fbG9jYWxQb2ludC55ID0gKHRYICogdE1hdC5jb2wyLnggKyB0WSAqIHRNYXQuY29sMi55KTtcbiAgICAgICAgICAgIGNwLm1faWQuU2V0KGN2LmlkKTtcbiAgICAgICAgICAgIGNwLm1faWQuZmVhdHVyZXMuZmxpcCA9IGZsaXA7XG4gICAgICAgICAgICArK3BvaW50Q291bnQ7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYW5pZm9sZC5tX3BvaW50Q291bnQgPSBwb2ludENvdW50O1xuICAgfVxuICAgYjJDb2xsaXNpb24uQ29sbGlkZUNpcmNsZXMgPSBmdW5jdGlvbiAobWFuaWZvbGQsIGNpcmNsZTEsIHhmMSwgY2lyY2xlMiwgeGYyKSB7XG4gICAgICBtYW5pZm9sZC5tX3BvaW50Q291bnQgPSAwO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFZlYztcbiAgICAgIHRNYXQgPSB4ZjEuUjtcbiAgICAgIHRWZWMgPSBjaXJjbGUxLm1fcDtcbiAgICAgIHZhciBwMVggPSB4ZjEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHZhciBwMVkgPSB4ZjEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHRNYXQgPSB4ZjIuUjtcbiAgICAgIHRWZWMgPSBjaXJjbGUyLm1fcDtcbiAgICAgIHZhciBwMlggPSB4ZjIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHZhciBwMlkgPSB4ZjIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHZhciBkWCA9IHAyWCAtIHAxWDtcbiAgICAgIHZhciBkWSA9IHAyWSAtIHAxWTtcbiAgICAgIHZhciBkaXN0U3FyID0gZFggKiBkWCArIGRZICogZFk7XG4gICAgICB2YXIgcmFkaXVzID0gY2lyY2xlMS5tX3JhZGl1cyArIGNpcmNsZTIubV9yYWRpdXM7XG4gICAgICBpZiAoZGlzdFNxciA+IHJhZGl1cyAqIHJhZGl1cykge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFuaWZvbGQubV90eXBlID0gYjJNYW5pZm9sZC5lX2NpcmNsZXM7XG4gICAgICBtYW5pZm9sZC5tX2xvY2FsUG9pbnQuU2V0VihjaXJjbGUxLm1fcCk7XG4gICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwuU2V0WmVybygpO1xuICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gMTtcbiAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1fbG9jYWxQb2ludC5TZXRWKGNpcmNsZTIubV9wKTtcbiAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1faWQua2V5ID0gMDtcbiAgIH1cbiAgIGIyQ29sbGlzaW9uLkNvbGxpZGVQb2x5Z29uQW5kQ2lyY2xlID0gZnVuY3Rpb24gKG1hbmlmb2xkLCBwb2x5Z29uLCB4ZjEsIGNpcmNsZSwgeGYyKSB7XG4gICAgICBtYW5pZm9sZC5tX3BvaW50Q291bnQgPSAwO1xuICAgICAgdmFyIHRQb2ludDtcbiAgICAgIHZhciBkWCA9IDA7XG4gICAgICB2YXIgZFkgPSAwO1xuICAgICAgdmFyIHBvc2l0aW9uWCA9IDA7XG4gICAgICB2YXIgcG9zaXRpb25ZID0gMDtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB0TWF0ID0geGYyLlI7XG4gICAgICB0VmVjID0gY2lyY2xlLm1fcDtcbiAgICAgIHZhciBjWCA9IHhmMi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgdmFyIGNZID0geGYyLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICBkWCA9IGNYIC0geGYxLnBvc2l0aW9uLng7XG4gICAgICBkWSA9IGNZIC0geGYxLnBvc2l0aW9uLnk7XG4gICAgICB0TWF0ID0geGYxLlI7XG4gICAgICB2YXIgY0xvY2FsWCA9IChkWCAqIHRNYXQuY29sMS54ICsgZFkgKiB0TWF0LmNvbDEueSk7XG4gICAgICB2YXIgY0xvY2FsWSA9IChkWCAqIHRNYXQuY29sMi54ICsgZFkgKiB0TWF0LmNvbDIueSk7XG4gICAgICB2YXIgZGlzdCA9IDA7XG4gICAgICB2YXIgbm9ybWFsSW5kZXggPSAwO1xuICAgICAgdmFyIHNlcGFyYXRpb24gPSAoLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgdmFyIHJhZGl1cyA9IHBvbHlnb24ubV9yYWRpdXMgKyBjaXJjbGUubV9yYWRpdXM7XG4gICAgICB2YXIgdmVydGV4Q291bnQgPSBwYXJzZUludChwb2x5Z29uLm1fdmVydGV4Q291bnQpO1xuICAgICAgdmFyIHZlcnRpY2VzID0gcG9seWdvbi5tX3ZlcnRpY2VzO1xuICAgICAgdmFyIG5vcm1hbHMgPSBwb2x5Z29uLm1fbm9ybWFscztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgdFZlYyA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgZFggPSBjTG9jYWxYIC0gdFZlYy54O1xuICAgICAgICAgZFkgPSBjTG9jYWxZIC0gdFZlYy55O1xuICAgICAgICAgdFZlYyA9IG5vcm1hbHNbaV07XG4gICAgICAgICB2YXIgcyA9IHRWZWMueCAqIGRYICsgdFZlYy55ICogZFk7XG4gICAgICAgICBpZiAocyA+IHJhZGl1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKHMgPiBzZXBhcmF0aW9uKSB7XG4gICAgICAgICAgICBzZXBhcmF0aW9uID0gcztcbiAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gaTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2ZXJ0SW5kZXgxID0gcGFyc2VJbnQobm9ybWFsSW5kZXgpO1xuICAgICAgdmFyIHZlcnRJbmRleDIgPSBwYXJzZUludCh2ZXJ0SW5kZXgxICsgMSA8IHZlcnRleENvdW50ID8gdmVydEluZGV4MSArIDEgOiAwKTtcbiAgICAgIHZhciB2MSA9IHZlcnRpY2VzW3ZlcnRJbmRleDFdO1xuICAgICAgdmFyIHYyID0gdmVydGljZXNbdmVydEluZGV4Ml07XG4gICAgICBpZiAoc2VwYXJhdGlvbiA8IE51bWJlci5NSU5fVkFMVUUpIHtcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDE7XG4gICAgICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfZmFjZUE7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwuU2V0Vihub3JtYWxzW25vcm1hbEluZGV4XSk7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUG9pbnQueCA9IDAuNSAqICh2MS54ICsgdjIueCk7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUG9pbnQueSA9IDAuNSAqICh2MS55ICsgdjIueSk7XG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50c1swXS5tX2xvY2FsUG9pbnQuU2V0VihjaXJjbGUubV9wKTtcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1faWQua2V5ID0gMDtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB1MSA9IChjTG9jYWxYIC0gdjEueCkgKiAodjIueCAtIHYxLngpICsgKGNMb2NhbFkgLSB2MS55KSAqICh2Mi55IC0gdjEueSk7XG4gICAgICB2YXIgdTIgPSAoY0xvY2FsWCAtIHYyLngpICogKHYxLnggLSB2Mi54KSArIChjTG9jYWxZIC0gdjIueSkgKiAodjEueSAtIHYyLnkpO1xuICAgICAgaWYgKHUxIDw9IDAuMCkge1xuICAgICAgICAgaWYgKChjTG9jYWxYIC0gdjEueCkgKiAoY0xvY2FsWCAtIHYxLngpICsgKGNMb2NhbFkgLSB2MS55KSAqIChjTG9jYWxZIC0gdjEueSkgPiByYWRpdXMgKiByYWRpdXMpIHJldHVybjtcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDE7XG4gICAgICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfZmFjZUE7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwueCA9IGNMb2NhbFggLSB2MS54O1xuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLnkgPSBjTG9jYWxZIC0gdjEueTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC5Ob3JtYWxpemUoKTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQb2ludC5TZXRWKHYxKTtcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1fbG9jYWxQb2ludC5TZXRWKGNpcmNsZS5tX3ApO1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9pZC5rZXkgPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodTIgPD0gMCkge1xuICAgICAgICAgaWYgKChjTG9jYWxYIC0gdjIueCkgKiAoY0xvY2FsWCAtIHYyLngpICsgKGNMb2NhbFkgLSB2Mi55KSAqIChjTG9jYWxZIC0gdjIueSkgPiByYWRpdXMgKiByYWRpdXMpIHJldHVybjtcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDE7XG4gICAgICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfZmFjZUE7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwueCA9IGNMb2NhbFggLSB2Mi54O1xuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLnkgPSBjTG9jYWxZIC0gdjIueTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC5Ob3JtYWxpemUoKTtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQb2ludC5TZXRWKHYyKTtcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1fbG9jYWxQb2ludC5TZXRWKGNpcmNsZS5tX3ApO1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9pZC5rZXkgPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB2YXIgZmFjZUNlbnRlclggPSAwLjUgKiAodjEueCArIHYyLngpO1xuICAgICAgICAgdmFyIGZhY2VDZW50ZXJZID0gMC41ICogKHYxLnkgKyB2Mi55KTtcbiAgICAgICAgIHNlcGFyYXRpb24gPSAoY0xvY2FsWCAtIGZhY2VDZW50ZXJYKSAqIG5vcm1hbHNbdmVydEluZGV4MV0ueCArIChjTG9jYWxZIC0gZmFjZUNlbnRlclkpICogbm9ybWFsc1t2ZXJ0SW5kZXgxXS55O1xuICAgICAgICAgaWYgKHNlcGFyYXRpb24gPiByYWRpdXMpIHJldHVybjtcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDE7XG4gICAgICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfZmFjZUE7XG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwueCA9IG5vcm1hbHNbdmVydEluZGV4MV0ueDtcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC55ID0gbm9ybWFsc1t2ZXJ0SW5kZXgxXS55O1xuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLk5vcm1hbGl6ZSgpO1xuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBvaW50LlNldChmYWNlQ2VudGVyWCwgZmFjZUNlbnRlclkpO1xuICAgICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9sb2NhbFBvaW50LlNldFYoY2lyY2xlLm1fcCk7XG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50c1swXS5tX2lkLmtleSA9IDA7XG4gICAgICB9XG4gICB9XG4gICBiMkNvbGxpc2lvbi5UZXN0T3ZlcmxhcCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgdDEgPSBiLmxvd2VyQm91bmQ7XG4gICAgICB2YXIgdDIgPSBhLnVwcGVyQm91bmQ7XG4gICAgICB2YXIgZDFYID0gdDEueCAtIHQyLng7XG4gICAgICB2YXIgZDFZID0gdDEueSAtIHQyLnk7XG4gICAgICB0MSA9IGEubG93ZXJCb3VuZDtcbiAgICAgIHQyID0gYi51cHBlckJvdW5kO1xuICAgICAgdmFyIGQyWCA9IHQxLnggLSB0Mi54O1xuICAgICAgdmFyIGQyWSA9IHQxLnkgLSB0Mi55O1xuICAgICAgaWYgKGQxWCA+IDAuMCB8fCBkMVkgPiAwLjApIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChkMlggPiAwLjAgfHwgZDJZID4gMC4wKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfaW5jaWRlbnRFZGdlID0gYjJDb2xsaXNpb24uTWFrZUNsaXBQb2ludFZlY3RvcigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfY2xpcFBvaW50czEgPSBiMkNvbGxpc2lvbi5NYWtlQ2xpcFBvaW50VmVjdG9yKCk7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24uc19jbGlwUG9pbnRzMiA9IGIyQ29sbGlzaW9uLk1ha2VDbGlwUG9pbnRWZWN0b3IoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX2VkZ2VBTyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigxKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX2VkZ2VCTyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigxKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX2xvY2FsVGFuZ2VudCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX2xvY2FsTm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfcGxhbmVQb2ludCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX25vcm1hbCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX3RhbmdlbnQgPSBuZXcgYjJWZWMyKCk7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24uc190YW5nZW50MiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX3YxMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX3YxMiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5iMkNvbGxpZGVQb2x5VGVtcFZlYyA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5iMl9udWxsRmVhdHVyZSA9IDB4MDAwMDAwZmY7XG4gICB9KTtcbiAgIGIyQ29udGFjdElELmIyQ29udGFjdElEID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5mZWF0dXJlcyA9IG5ldyBGZWF0dXJlcygpO1xuICAgfTtcbiAgIGIyQ29udGFjdElELnByb3RvdHlwZS5iMkNvbnRhY3RJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZmVhdHVyZXMuX21faWQgPSB0aGlzO1xuICAgfVxuICAgYjJDb250YWN0SUQucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgdGhpcy5rZXkgPSBpZC5fa2V5O1xuICAgfVxuICAgYjJDb250YWN0SUQucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWQgPSBuZXcgYjJDb250YWN0SUQoKTtcbiAgICAgIGlkLmtleSA9IHRoaXMua2V5O1xuICAgICAgcmV0dXJuIGlkO1xuICAgfVxuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGIyQ29udGFjdElELnByb3RvdHlwZSwgJ2tleScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xuICAgICAgfVxuICAgfSk7XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYjJDb250YWN0SUQucHJvdG90eXBlLCAna2V5Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gMDtcbiAgICAgICAgIHRoaXMuX2tleSA9IHZhbHVlO1xuICAgICAgICAgdGhpcy5mZWF0dXJlcy5fcmVmZXJlbmNlRWRnZSA9IHRoaXMuX2tleSAmIDB4MDAwMDAwZmY7XG4gICAgICAgICB0aGlzLmZlYXR1cmVzLl9pbmNpZGVudEVkZ2UgPSAoKHRoaXMuX2tleSAmIDB4MDAwMGZmMDApID4+IDgpICYgMHgwMDAwMDBmZjtcbiAgICAgICAgIHRoaXMuZmVhdHVyZXMuX2luY2lkZW50VmVydGV4ID0gKCh0aGlzLl9rZXkgJiAweDAwZmYwMDAwKSA+PiAxNikgJiAweDAwMDAwMGZmO1xuICAgICAgICAgdGhpcy5mZWF0dXJlcy5fZmxpcCA9ICgodGhpcy5fa2V5ICYgMHhmZjAwMDAwMCkgPj4gMjQpICYgMHgwMDAwMDBmZjtcbiAgICAgIH1cbiAgIH0pO1xuICAgYjJDb250YWN0UG9pbnQuYjJDb250YWN0UG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5pZCA9IG5ldyBiMkNvbnRhY3RJRCgpO1xuICAgfTtcbiAgIGIyRGlzdGFuY2UuYjJEaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJEaXN0YW5jZS5EaXN0YW5jZSA9IGZ1bmN0aW9uIChvdXRwdXQsIGNhY2hlLCBpbnB1dCkge1xuICAgICAgKytiMkRpc3RhbmNlLmIyX2dqa0NhbGxzO1xuICAgICAgdmFyIHByb3h5QSA9IGlucHV0LnByb3h5QTtcbiAgICAgIHZhciBwcm94eUIgPSBpbnB1dC5wcm94eUI7XG4gICAgICB2YXIgdHJhbnNmb3JtQSA9IGlucHV0LnRyYW5zZm9ybUE7XG4gICAgICB2YXIgdHJhbnNmb3JtQiA9IGlucHV0LnRyYW5zZm9ybUI7XG4gICAgICB2YXIgc2ltcGxleCA9IGIyRGlzdGFuY2Uuc19zaW1wbGV4O1xuICAgICAgc2ltcGxleC5SZWFkQ2FjaGUoY2FjaGUsIHByb3h5QSwgdHJhbnNmb3JtQSwgcHJveHlCLCB0cmFuc2Zvcm1CKTtcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IHNpbXBsZXgubV92ZXJ0aWNlcztcbiAgICAgIHZhciBrX21heEl0ZXJzID0gMjA7XG4gICAgICB2YXIgc2F2ZUEgPSBiMkRpc3RhbmNlLnNfc2F2ZUE7XG4gICAgICB2YXIgc2F2ZUIgPSBiMkRpc3RhbmNlLnNfc2F2ZUI7XG4gICAgICB2YXIgc2F2ZUNvdW50ID0gMDtcbiAgICAgIHZhciBjbG9zZXN0UG9pbnQgPSBzaW1wbGV4LkdldENsb3Nlc3RQb2ludCgpO1xuICAgICAgdmFyIGRpc3RhbmNlU3FyMSA9IGNsb3Nlc3RQb2ludC5MZW5ndGhTcXVhcmVkKCk7XG4gICAgICB2YXIgZGlzdGFuY2VTcXIyID0gZGlzdGFuY2VTcXIxO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHA7XG4gICAgICB2YXIgaXRlciA9IDA7XG4gICAgICB3aGlsZSAoaXRlciA8IGtfbWF4SXRlcnMpIHtcbiAgICAgICAgIHNhdmVDb3VudCA9IHNpbXBsZXgubV9jb3VudDtcbiAgICAgICAgIGZvciAoaSA9IDA7XG4gICAgICAgICBpIDwgc2F2ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHNhdmVBW2ldID0gdmVydGljZXNbaV0uaW5kZXhBO1xuICAgICAgICAgICAgc2F2ZUJbaV0gPSB2ZXJ0aWNlc1tpXS5pbmRleEI7XG4gICAgICAgICB9XG4gICAgICAgICBzd2l0Y2ggKHNpbXBsZXgubV9jb3VudCkge1xuICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBzaW1wbGV4LlNvbHZlMigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzaW1wbGV4LlNvbHZlMygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAoc2ltcGxleC5tX2NvdW50ID09IDMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgICAgcCA9IHNpbXBsZXguR2V0Q2xvc2VzdFBvaW50KCk7XG4gICAgICAgICBkaXN0YW5jZVNxcjIgPSBwLkxlbmd0aFNxdWFyZWQoKTtcbiAgICAgICAgIGlmIChkaXN0YW5jZVNxcjIgPiBkaXN0YW5jZVNxcjEpIHt9XG4gICAgICAgICBkaXN0YW5jZVNxcjEgPSBkaXN0YW5jZVNxcjI7XG4gICAgICAgICB2YXIgZCA9IHNpbXBsZXguR2V0U2VhcmNoRGlyZWN0aW9uKCk7XG4gICAgICAgICBpZiAoZC5MZW5ndGhTcXVhcmVkKCkgPCBOdW1iZXIuTUlOX1ZBTFVFICogTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbc2ltcGxleC5tX2NvdW50XTtcbiAgICAgICAgIHZlcnRleC5pbmRleEEgPSBwcm94eUEuR2V0U3VwcG9ydChiMk1hdGguTXVsVE1WKHRyYW5zZm9ybUEuUiwgZC5HZXROZWdhdGl2ZSgpKSk7XG4gICAgICAgICB2ZXJ0ZXgud0EgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCBwcm94eUEuR2V0VmVydGV4KHZlcnRleC5pbmRleEEpKTtcbiAgICAgICAgIHZlcnRleC5pbmRleEIgPSBwcm94eUIuR2V0U3VwcG9ydChiMk1hdGguTXVsVE1WKHRyYW5zZm9ybUIuUiwgZCkpO1xuICAgICAgICAgdmVydGV4LndCID0gYjJNYXRoLk11bFgodHJhbnNmb3JtQiwgcHJveHlCLkdldFZlcnRleCh2ZXJ0ZXguaW5kZXhCKSk7XG4gICAgICAgICB2ZXJ0ZXgudyA9IGIyTWF0aC5TdWJ0cmFjdFZWKHZlcnRleC53QiwgdmVydGV4LndBKTtcbiAgICAgICAgICsraXRlcjtcbiAgICAgICAgICsrYjJEaXN0YW5jZS5iMl9namtJdGVycztcbiAgICAgICAgIHZhciBkdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgIGZvciAoaSA9IDA7XG4gICAgICAgICBpIDwgc2F2ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXguaW5kZXhBID09IHNhdmVBW2ldICYmIHZlcnRleC5pbmRleEIgPT0gc2F2ZUJbaV0pIHtcbiAgICAgICAgICAgICAgIGR1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfSsrc2ltcGxleC5tX2NvdW50O1xuICAgICAgfVxuICAgICAgYjJEaXN0YW5jZS5iMl9namtNYXhJdGVycyA9IGIyTWF0aC5NYXgoYjJEaXN0YW5jZS5iMl9namtNYXhJdGVycywgaXRlcik7XG4gICAgICBzaW1wbGV4LkdldFdpdG5lc3NQb2ludHMob3V0cHV0LnBvaW50QSwgb3V0cHV0LnBvaW50Qik7XG4gICAgICBvdXRwdXQuZGlzdGFuY2UgPSBiMk1hdGguU3VidHJhY3RWVihvdXRwdXQucG9pbnRBLCBvdXRwdXQucG9pbnRCKS5MZW5ndGgoKTtcbiAgICAgIG91dHB1dC5pdGVyYXRpb25zID0gaXRlcjtcbiAgICAgIHNpbXBsZXguV3JpdGVDYWNoZShjYWNoZSk7XG4gICAgICBpZiAoaW5wdXQudXNlUmFkaWkpIHtcbiAgICAgICAgIHZhciByQSA9IHByb3h5QS5tX3JhZGl1cztcbiAgICAgICAgIHZhciByQiA9IHByb3h5Qi5tX3JhZGl1cztcbiAgICAgICAgIGlmIChvdXRwdXQuZGlzdGFuY2UgPiByQSArIHJCICYmIG91dHB1dC5kaXN0YW5jZSA+IE51bWJlci5NSU5fVkFMVUUpIHtcbiAgICAgICAgICAgIG91dHB1dC5kaXN0YW5jZSAtPSByQSArIHJCO1xuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGIyTWF0aC5TdWJ0cmFjdFZWKG91dHB1dC5wb2ludEIsIG91dHB1dC5wb2ludEEpO1xuICAgICAgICAgICAgbm9ybWFsLk5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50QS54ICs9IHJBICogbm9ybWFsLng7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnRBLnkgKz0gckEgKiBub3JtYWwueTtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludEIueCAtPSByQiAqIG5vcm1hbC54O1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50Qi55IC09IHJCICogbm9ybWFsLnk7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBuZXcgYjJWZWMyKCk7XG4gICAgICAgICAgICBwLnggPSAuNSAqIChvdXRwdXQucG9pbnRBLnggKyBvdXRwdXQucG9pbnRCLngpO1xuICAgICAgICAgICAgcC55ID0gLjUgKiAob3V0cHV0LnBvaW50QS55ICsgb3V0cHV0LnBvaW50Qi55KTtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludEEueCA9IG91dHB1dC5wb2ludEIueCA9IHAueDtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludEEueSA9IG91dHB1dC5wb2ludEIueSA9IHAueTtcbiAgICAgICAgICAgIG91dHB1dC5kaXN0YW5jZSA9IDAuMDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2Uuc19zaW1wbGV4ID0gbmV3IGIyU2ltcGxleCgpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2Uuc19zYXZlQSA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigzKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlLnNfc2F2ZUIgPSBuZXcgVmVjdG9yX2Eyal9OdW1iZXIoMyk7XG4gICB9KTtcbiAgIGIyRGlzdGFuY2VJbnB1dC5iMkRpc3RhbmNlSW5wdXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgIGIyRGlzdGFuY2VPdXRwdXQuYjJEaXN0YW5jZU91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucG9pbnRBID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5wb2ludEIgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJEaXN0YW5jZVByb3h5LmIyRGlzdGFuY2VQcm94eSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJEaXN0YW5jZVByb3h5LnByb3RvdHlwZS5TZXQgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHN3aXRjaCAoc2hhcGUuR2V0VHlwZSgpKSB7XG4gICAgICBjYXNlIGIyU2hhcGUuZV9jaXJjbGVTaGFwZTpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjaXJjbGUgPSAoc2hhcGUgaW5zdGFuY2VvZiBiMkNpcmNsZVNoYXBlID8gc2hhcGUgOiBudWxsKTtcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlcyA9IG5ldyBWZWN0b3IoMSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLm1fdmVydGljZXNbMF0gPSBjaXJjbGUubV9wO1xuICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgICAgIHRoaXMubV9yYWRpdXMgPSBjaXJjbGUubV9yYWRpdXM7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJTaGFwZS5lX3BvbHlnb25TaGFwZTpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gKHNoYXBlIGluc3RhbmNlb2YgYjJQb2x5Z29uU2hhcGUgPyBzaGFwZSA6IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzID0gcG9seWdvbi5tX3ZlcnRpY2VzO1xuICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gcG9seWdvbi5tX3ZlcnRleENvdW50O1xuICAgICAgICAgICAgdGhpcy5tX3JhZGl1cyA9IHBvbHlnb24ubV9yYWRpdXM7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KGZhbHNlKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuR2V0U3VwcG9ydCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgYmVzdEluZGV4ID0gMDtcbiAgICAgIHZhciBiZXN0VmFsdWUgPSB0aGlzLm1fdmVydGljZXNbMF0ueCAqIGQueCArIHRoaXMubV92ZXJ0aWNlc1swXS55ICogZC55O1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tX3ZlcnRpY2VzW2ldLnggKiBkLnggKyB0aGlzLm1fdmVydGljZXNbaV0ueSAqIGQueTtcbiAgICAgICAgIGlmICh2YWx1ZSA+IGJlc3RWYWx1ZSkge1xuICAgICAgICAgICAgYmVzdEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJlc3RJbmRleDtcbiAgIH1cbiAgIGIyRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuR2V0U3VwcG9ydFZlcnRleCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgYmVzdEluZGV4ID0gMDtcbiAgICAgIHZhciBiZXN0VmFsdWUgPSB0aGlzLm1fdmVydGljZXNbMF0ueCAqIGQueCArIHRoaXMubV92ZXJ0aWNlc1swXS55ICogZC55O1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm1fY291bnQ7ICsraSkge1xuICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tX3ZlcnRpY2VzW2ldLnggKiBkLnggKyB0aGlzLm1fdmVydGljZXNbaV0ueSAqIGQueTtcbiAgICAgICAgIGlmICh2YWx1ZSA+IGJlc3RWYWx1ZSkge1xuICAgICAgICAgICAgYmVzdEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubV92ZXJ0aWNlc1tiZXN0SW5kZXhdO1xuICAgfVxuICAgYjJEaXN0YW5jZVByb3h5LnByb3RvdHlwZS5HZXRWZXJ0ZXhDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY291bnQ7XG4gICB9XG4gICBiMkRpc3RhbmNlUHJveHkucHJvdG90eXBlLkdldFZlcnRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIGluZGV4ID0gMDtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMCA8PSBpbmRleCAmJiBpbmRleCA8IHRoaXMubV9jb3VudCk7XG4gICAgICByZXR1cm4gdGhpcy5tX3ZlcnRpY2VzW2luZGV4XTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWUuYjJEeW5hbWljVHJlZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuYjJEeW5hbWljVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9yb290ID0gbnVsbDtcbiAgICAgIHRoaXMubV9mcmVlTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLm1fcGF0aCA9IDA7XG4gICAgICB0aGlzLm1faW5zZXJ0aW9uQ291bnQgPSAwO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuQ3JlYXRlUHJveHkgPSBmdW5jdGlvbiAoYWFiYiwgdXNlckRhdGEpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5BbGxvY2F0ZU5vZGUoKTtcbiAgICAgIHZhciBleHRlbmRYID0gYjJTZXR0aW5ncy5iMl9hYWJiRXh0ZW5zaW9uO1xuICAgICAgdmFyIGV4dGVuZFkgPSBiMlNldHRpbmdzLmIyX2FhYmJFeHRlbnNpb247XG4gICAgICBub2RlLmFhYmIubG93ZXJCb3VuZC54ID0gYWFiYi5sb3dlckJvdW5kLnggLSBleHRlbmRYO1xuICAgICAgbm9kZS5hYWJiLmxvd2VyQm91bmQueSA9IGFhYmIubG93ZXJCb3VuZC55IC0gZXh0ZW5kWTtcbiAgICAgIG5vZGUuYWFiYi51cHBlckJvdW5kLnggPSBhYWJiLnVwcGVyQm91bmQueCArIGV4dGVuZFg7XG4gICAgICBub2RlLmFhYmIudXBwZXJCb3VuZC55ID0gYWFiYi51cHBlckJvdW5kLnkgKyBleHRlbmRZO1xuICAgICAgbm9kZS51c2VyRGF0YSA9IHVzZXJEYXRhO1xuICAgICAgdGhpcy5JbnNlcnRMZWFmKG5vZGUpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5EZXN0cm95UHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgIHRoaXMuUmVtb3ZlTGVhZihwcm94eSk7XG4gICAgICB0aGlzLkZyZWVOb2RlKHByb3h5KTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLk1vdmVQcm94eSA9IGZ1bmN0aW9uIChwcm94eSwgYWFiYiwgZGlzcGxhY2VtZW50KSB7XG4gICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KHByb3h5LklzTGVhZigpKTtcbiAgICAgIGlmIChwcm94eS5hYWJiLkNvbnRhaW5zKGFhYmIpKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLlJlbW92ZUxlYWYocHJveHkpO1xuICAgICAgdmFyIGV4dGVuZFggPSBiMlNldHRpbmdzLmIyX2FhYmJFeHRlbnNpb24gKyBiMlNldHRpbmdzLmIyX2FhYmJNdWx0aXBsaWVyICogKGRpc3BsYWNlbWVudC54ID4gMCA/IGRpc3BsYWNlbWVudC54IDogKC1kaXNwbGFjZW1lbnQueCkpO1xuICAgICAgdmFyIGV4dGVuZFkgPSBiMlNldHRpbmdzLmIyX2FhYmJFeHRlbnNpb24gKyBiMlNldHRpbmdzLmIyX2FhYmJNdWx0aXBsaWVyICogKGRpc3BsYWNlbWVudC55ID4gMCA/IGRpc3BsYWNlbWVudC55IDogKC1kaXNwbGFjZW1lbnQueSkpO1xuICAgICAgcHJveHkuYWFiYi5sb3dlckJvdW5kLnggPSBhYWJiLmxvd2VyQm91bmQueCAtIGV4dGVuZFg7XG4gICAgICBwcm94eS5hYWJiLmxvd2VyQm91bmQueSA9IGFhYmIubG93ZXJCb3VuZC55IC0gZXh0ZW5kWTtcbiAgICAgIHByb3h5LmFhYmIudXBwZXJCb3VuZC54ID0gYWFiYi51cHBlckJvdW5kLnggKyBleHRlbmRYO1xuICAgICAgcHJveHkuYWFiYi51cHBlckJvdW5kLnkgPSBhYWJiLnVwcGVyQm91bmQueSArIGV4dGVuZFk7XG4gICAgICB0aGlzLkluc2VydExlYWYocHJveHkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5SZWJhbGFuY2UgPSBmdW5jdGlvbiAoaXRlcmF0aW9ucykge1xuICAgICAgaWYgKGl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpZiAodGhpcy5tX3Jvb3QgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgIHZhciBub2RlID0gdGhpcy5tX3Jvb3Q7XG4gICAgICAgICB2YXIgYml0ID0gMDtcbiAgICAgICAgIHdoaWxlIChub2RlLklzTGVhZigpID09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlID0gKHRoaXMubV9wYXRoID4+IGJpdCkgJiAxID8gbm9kZS5jaGlsZDIgOiBub2RlLmNoaWxkMTtcbiAgICAgICAgICAgIGJpdCA9IChiaXQgKyAxKSAmIDMxO1xuICAgICAgICAgfSsrdGhpcy5tX3BhdGg7XG4gICAgICAgICB0aGlzLlJlbW92ZUxlYWYobm9kZSk7XG4gICAgICAgICB0aGlzLkluc2VydExlYWYobm9kZSk7XG4gICAgICB9XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5HZXRGYXRBQUJCID0gZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgICByZXR1cm4gcHJveHkuYWFiYjtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLkdldFVzZXJEYXRhID0gZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgICByZXR1cm4gcHJveHkudXNlckRhdGE7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5RdWVyeSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYWFiYikge1xuICAgICAgaWYgKHRoaXMubV9yb290ID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICBzdGFja1tjb3VudCsrXSA9IHRoaXMubV9yb290O1xuICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICAgdmFyIG5vZGUgPSBzdGFja1stLWNvdW50XTtcbiAgICAgICAgIGlmIChub2RlLmFhYmIuVGVzdE92ZXJsYXAoYWFiYikpIHtcbiAgICAgICAgICAgIGlmIChub2RlLklzTGVhZigpKSB7XG4gICAgICAgICAgICAgICB2YXIgcHJvY2VlZCA9IGNhbGxiYWNrKG5vZGUpO1xuICAgICAgICAgICAgICAgaWYgKCFwcm9jZWVkKSByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIHN0YWNrW2NvdW50KytdID0gbm9kZS5jaGlsZDE7XG4gICAgICAgICAgICAgICBzdGFja1tjb3VudCsrXSA9IG5vZGUuY2hpbGQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuUmF5Q2FzdCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLm1fcm9vdCA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgcDEgPSBpbnB1dC5wMTtcbiAgICAgIHZhciBwMiA9IGlucHV0LnAyO1xuICAgICAgdmFyIHIgPSBiMk1hdGguU3VidHJhY3RWVihwMSwgcDIpO1xuICAgICAgci5Ob3JtYWxpemUoKTtcbiAgICAgIHZhciB2ID0gYjJNYXRoLkNyb3NzRlYoMS4wLCByKTtcbiAgICAgIHZhciBhYnNfdiA9IGIyTWF0aC5BYnNWKHYpO1xuICAgICAgdmFyIG1heEZyYWN0aW9uID0gaW5wdXQubWF4RnJhY3Rpb247XG4gICAgICB2YXIgc2VnbWVudEFBQkIgPSBuZXcgYjJBQUJCKCk7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIHRZID0gMDsge1xuICAgICAgICAgdFggPSBwMS54ICsgbWF4RnJhY3Rpb24gKiAocDIueCAtIHAxLngpO1xuICAgICAgICAgdFkgPSBwMS55ICsgbWF4RnJhY3Rpb24gKiAocDIueSAtIHAxLnkpO1xuICAgICAgICAgc2VnbWVudEFBQkIubG93ZXJCb3VuZC54ID0gTWF0aC5taW4ocDEueCwgdFgpO1xuICAgICAgICAgc2VnbWVudEFBQkIubG93ZXJCb3VuZC55ID0gTWF0aC5taW4ocDEueSwgdFkpO1xuICAgICAgICAgc2VnbWVudEFBQkIudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgocDEueCwgdFgpO1xuICAgICAgICAgc2VnbWVudEFBQkIudXBwZXJCb3VuZC55ID0gTWF0aC5tYXgocDEueSwgdFkpO1xuICAgICAgfVxuICAgICAgdmFyIHN0YWNrID0gbmV3IFZlY3RvcigpO1xuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIHN0YWNrW2NvdW50KytdID0gdGhpcy5tX3Jvb3Q7XG4gICAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgICB2YXIgbm9kZSA9IHN0YWNrWy0tY291bnRdO1xuICAgICAgICAgaWYgKG5vZGUuYWFiYi5UZXN0T3ZlcmxhcChzZWdtZW50QUFCQikgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIGMgPSBub2RlLmFhYmIuR2V0Q2VudGVyKCk7XG4gICAgICAgICB2YXIgaCA9IG5vZGUuYWFiYi5HZXRFeHRlbnRzKCk7XG4gICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IE1hdGguYWJzKHYueCAqIChwMS54IC0gYy54KSArIHYueSAqIChwMS55IC0gYy55KSkgLSBhYnNfdi54ICogaC54IC0gYWJzX3YueSAqIGgueTtcbiAgICAgICAgIGlmIChzZXBhcmF0aW9uID4gMC4wKSBjb250aW51ZTtcbiAgICAgICAgIGlmIChub2RlLklzTGVhZigpKSB7XG4gICAgICAgICAgICB2YXIgc3ViSW5wdXQgPSBuZXcgYjJSYXlDYXN0SW5wdXQoKTtcbiAgICAgICAgICAgIHN1YklucHV0LnAxID0gaW5wdXQucDE7XG4gICAgICAgICAgICBzdWJJbnB1dC5wMiA9IGlucHV0LnAyO1xuICAgICAgICAgICAgc3ViSW5wdXQubWF4RnJhY3Rpb24gPSBpbnB1dC5tYXhGcmFjdGlvbjtcbiAgICAgICAgICAgIG1heEZyYWN0aW9uID0gY2FsbGJhY2soc3ViSW5wdXQsIG5vZGUpO1xuICAgICAgICAgICAgaWYgKG1heEZyYWN0aW9uID09IDAuMCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG1heEZyYWN0aW9uID4gMC4wKSB7XG4gICAgICAgICAgICAgICB0WCA9IHAxLnggKyBtYXhGcmFjdGlvbiAqIChwMi54IC0gcDEueCk7XG4gICAgICAgICAgICAgICB0WSA9IHAxLnkgKyBtYXhGcmFjdGlvbiAqIChwMi55IC0gcDEueSk7XG4gICAgICAgICAgICAgICBzZWdtZW50QUFCQi5sb3dlckJvdW5kLnggPSBNYXRoLm1pbihwMS54LCB0WCk7XG4gICAgICAgICAgICAgICBzZWdtZW50QUFCQi5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbihwMS55LCB0WSk7XG4gICAgICAgICAgICAgICBzZWdtZW50QUFCQi51cHBlckJvdW5kLnggPSBNYXRoLm1heChwMS54LCB0WCk7XG4gICAgICAgICAgICAgICBzZWdtZW50QUFCQi51cHBlckJvdW5kLnkgPSBNYXRoLm1heChwMS55LCB0WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrW2NvdW50KytdID0gbm9kZS5jaGlsZDE7XG4gICAgICAgICAgICBzdGFja1tjb3VudCsrXSA9IG5vZGUuY2hpbGQyO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuQWxsb2NhdGVOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMubV9mcmVlTGlzdCkge1xuICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fZnJlZUxpc3Q7XG4gICAgICAgICB0aGlzLm1fZnJlZUxpc3QgPSBub2RlLnBhcmVudDtcbiAgICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgIG5vZGUuY2hpbGQxID0gbnVsbDtcbiAgICAgICAgIG5vZGUuY2hpbGQyID0gbnVsbDtcbiAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBiMkR5bmFtaWNUcmVlTm9kZSgpO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuRnJlZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzLm1fZnJlZUxpc3Q7XG4gICAgICB0aGlzLm1fZnJlZUxpc3QgPSBub2RlO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuSW5zZXJ0TGVhZiA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICArK3RoaXMubV9pbnNlcnRpb25Db3VudDtcbiAgICAgIGlmICh0aGlzLm1fcm9vdCA9PSBudWxsKSB7XG4gICAgICAgICB0aGlzLm1fcm9vdCA9IGxlYWY7XG4gICAgICAgICB0aGlzLm1fcm9vdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNlbnRlciA9IGxlYWYuYWFiYi5HZXRDZW50ZXIoKTtcbiAgICAgIHZhciBzaWJsaW5nID0gdGhpcy5tX3Jvb3Q7XG4gICAgICBpZiAoc2libGluZy5Jc0xlYWYoKSA9PSBmYWxzZSkge1xuICAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGNoaWxkMSA9IHNpYmxpbmcuY2hpbGQxO1xuICAgICAgICAgICAgdmFyIGNoaWxkMiA9IHNpYmxpbmcuY2hpbGQyO1xuICAgICAgICAgICAgdmFyIG5vcm0xID0gTWF0aC5hYnMoKGNoaWxkMS5hYWJiLmxvd2VyQm91bmQueCArIGNoaWxkMS5hYWJiLnVwcGVyQm91bmQueCkgLyAyIC0gY2VudGVyLngpICsgTWF0aC5hYnMoKGNoaWxkMS5hYWJiLmxvd2VyQm91bmQueSArIGNoaWxkMS5hYWJiLnVwcGVyQm91bmQueSkgLyAyIC0gY2VudGVyLnkpO1xuICAgICAgICAgICAgdmFyIG5vcm0yID0gTWF0aC5hYnMoKGNoaWxkMi5hYWJiLmxvd2VyQm91bmQueCArIGNoaWxkMi5hYWJiLnVwcGVyQm91bmQueCkgLyAyIC0gY2VudGVyLngpICsgTWF0aC5hYnMoKGNoaWxkMi5hYWJiLmxvd2VyQm91bmQueSArIGNoaWxkMi5hYWJiLnVwcGVyQm91bmQueSkgLyAyIC0gY2VudGVyLnkpO1xuICAgICAgICAgICAgaWYgKG5vcm0xIDwgbm9ybTIpIHtcbiAgICAgICAgICAgICAgIHNpYmxpbmcgPSBjaGlsZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIHNpYmxpbmcgPSBjaGlsZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICB3aGlsZSAoc2libGluZy5Jc0xlYWYoKSA9PSBmYWxzZSlcbiAgICAgIH1cbiAgICAgIHZhciBub2RlMSA9IHNpYmxpbmcucGFyZW50O1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5BbGxvY2F0ZU5vZGUoKTtcbiAgICAgIG5vZGUyLnBhcmVudCA9IG5vZGUxO1xuICAgICAgbm9kZTIudXNlckRhdGEgPSBudWxsO1xuICAgICAgbm9kZTIuYWFiYi5Db21iaW5lKGxlYWYuYWFiYiwgc2libGluZy5hYWJiKTtcbiAgICAgIGlmIChub2RlMSkge1xuICAgICAgICAgaWYgKHNpYmxpbmcucGFyZW50LmNoaWxkMSA9PSBzaWJsaW5nKSB7XG4gICAgICAgICAgICBub2RlMS5jaGlsZDEgPSBub2RlMjtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZTEuY2hpbGQyID0gbm9kZTI7XG4gICAgICAgICB9XG4gICAgICAgICBub2RlMi5jaGlsZDEgPSBzaWJsaW5nO1xuICAgICAgICAgbm9kZTIuY2hpbGQyID0gbGVhZjtcbiAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gbm9kZTI7XG4gICAgICAgICBsZWFmLnBhcmVudCA9IG5vZGUyO1xuICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKG5vZGUxLmFhYmIuQ29udGFpbnMobm9kZTIuYWFiYikpIGJyZWFrO1xuICAgICAgICAgICAgbm9kZTEuYWFiYi5Db21iaW5lKG5vZGUxLmNoaWxkMS5hYWJiLCBub2RlMS5jaGlsZDIuYWFiYik7XG4gICAgICAgICAgICBub2RlMiA9IG5vZGUxO1xuICAgICAgICAgICAgbm9kZTEgPSBub2RlMS5wYXJlbnQ7XG4gICAgICAgICB9XG4gICAgICAgICB3aGlsZSAobm9kZTEpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIG5vZGUyLmNoaWxkMSA9IHNpYmxpbmc7XG4gICAgICAgICBub2RlMi5jaGlsZDIgPSBsZWFmO1xuICAgICAgICAgc2libGluZy5wYXJlbnQgPSBub2RlMjtcbiAgICAgICAgIGxlYWYucGFyZW50ID0gbm9kZTI7XG4gICAgICAgICB0aGlzLm1fcm9vdCA9IG5vZGUyO1xuICAgICAgfVxuICAgfVxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuUmVtb3ZlTGVhZiA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICBpZiAobGVhZiA9PSB0aGlzLm1fcm9vdCkge1xuICAgICAgICAgdGhpcy5tX3Jvb3QgPSBudWxsO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUyID0gbGVhZi5wYXJlbnQ7XG4gICAgICB2YXIgbm9kZTEgPSBub2RlMi5wYXJlbnQ7XG4gICAgICB2YXIgc2libGluZztcbiAgICAgIGlmIChub2RlMi5jaGlsZDEgPT0gbGVhZikge1xuICAgICAgICAgc2libGluZyA9IG5vZGUyLmNoaWxkMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgc2libGluZyA9IG5vZGUyLmNoaWxkMTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlMSkge1xuICAgICAgICAgaWYgKG5vZGUxLmNoaWxkMSA9PSBub2RlMikge1xuICAgICAgICAgICAgbm9kZTEuY2hpbGQxID0gc2libGluZztcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZTEuY2hpbGQyID0gc2libGluZztcbiAgICAgICAgIH1cbiAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gbm9kZTE7XG4gICAgICAgICB0aGlzLkZyZWVOb2RlKG5vZGUyKTtcbiAgICAgICAgIHdoaWxlIChub2RlMSkge1xuICAgICAgICAgICAgdmFyIG9sZEFBQkIgPSBub2RlMS5hYWJiO1xuICAgICAgICAgICAgbm9kZTEuYWFiYiA9IGIyQUFCQi5Db21iaW5lKG5vZGUxLmNoaWxkMS5hYWJiLCBub2RlMS5jaGlsZDIuYWFiYik7XG4gICAgICAgICAgICBpZiAob2xkQUFCQi5Db250YWlucyhub2RlMS5hYWJiKSkgYnJlYWs7XG4gICAgICAgICAgICBub2RlMSA9IG5vZGUxLnBhcmVudDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX3Jvb3QgPSBzaWJsaW5nO1xuICAgICAgICAgc2libGluZy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgdGhpcy5GcmVlTm9kZShub2RlMik7XG4gICAgICB9XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5iMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV90cmVlID0gbmV3IGIyRHluYW1pY1RyZWUoKTtcbiAgICAgIHRoaXMubV9tb3ZlQnVmZmVyID0gbmV3IFZlY3RvcigpO1xuICAgICAgdGhpcy5tX3BhaXJCdWZmZXIgPSBuZXcgVmVjdG9yKCk7XG4gICAgICB0aGlzLm1fcGFpckNvdW50ID0gMDtcbiAgIH07XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuQ3JlYXRlUHJveHkgPSBmdW5jdGlvbiAoYWFiYiwgdXNlckRhdGEpIHtcbiAgICAgIHZhciBwcm94eSA9IHRoaXMubV90cmVlLkNyZWF0ZVByb3h5KGFhYmIsIHVzZXJEYXRhKTtcbiAgICAgICsrdGhpcy5tX3Byb3h5Q291bnQ7XG4gICAgICB0aGlzLkJ1ZmZlck1vdmUocHJveHkpO1xuICAgICAgcmV0dXJuIHByb3h5O1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkRlc3Ryb3lQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xuICAgICAgdGhpcy5VbkJ1ZmZlck1vdmUocHJveHkpO1xuICAgICAgLS10aGlzLm1fcHJveHlDb3VudDtcbiAgICAgIHRoaXMubV90cmVlLkRlc3Ryb3lQcm94eShwcm94eSk7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuTW92ZVByb3h5ID0gZnVuY3Rpb24gKHByb3h5LCBhYWJiLCBkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBidWZmZXIgPSB0aGlzLm1fdHJlZS5Nb3ZlUHJveHkocHJveHksIGFhYmIsIGRpc3BsYWNlbWVudCk7XG4gICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICB0aGlzLkJ1ZmZlck1vdmUocHJveHkpO1xuICAgICAgfVxuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLlRlc3RPdmVybGFwID0gZnVuY3Rpb24gKHByb3h5QSwgcHJveHlCKSB7XG4gICAgICB2YXIgYWFiYkEgPSB0aGlzLm1fdHJlZS5HZXRGYXRBQUJCKHByb3h5QSk7XG4gICAgICB2YXIgYWFiYkIgPSB0aGlzLm1fdHJlZS5HZXRGYXRBQUJCKHByb3h5Qik7XG4gICAgICByZXR1cm4gYWFiYkEuVGVzdE92ZXJsYXAoYWFiYkIpO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkdldFVzZXJEYXRhID0gZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3RyZWUuR2V0VXNlckRhdGEocHJveHkpO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkdldEZhdEFBQkIgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdHJlZS5HZXRGYXRBQUJCKHByb3h5KTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5HZXRQcm94eUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9wcm94eUNvdW50O1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLlVwZGF0ZVBhaXJzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX190aGlzID0gdGhpcztcbiAgICAgIF9fdGhpcy5tX3BhaXJDb3VudCA9IDA7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICBxdWVyeVByb3h5O1xuICAgICAgIGZ1bmN0aW9uIFF1ZXJ5Q2FsbGJhY2socHJveHkpIHtcbiAgICAgICAgICBpZiAocHJveHkgPT0gcXVlcnlQcm94eSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKF9fdGhpcy5tX3BhaXJDb3VudCA9PSBfX3RoaXMubV9wYWlyQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgIF9fdGhpcy5tX3BhaXJCdWZmZXJbX190aGlzLm1fcGFpckNvdW50XSA9IG5ldyBiMkR5bmFtaWNUcmVlUGFpcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGFpciA9IF9fdGhpcy5tX3BhaXJCdWZmZXJbX190aGlzLm1fcGFpckNvdW50XTtcbiAgICAgICAgICBwYWlyLnByb3h5QSA9IHByb3h5IDwgcXVlcnlQcm94eSA/IHByb3h5IDogcXVlcnlQcm94eTtcbiAgICAgICAgICBwYWlyLnByb3h5QiA9IHByb3h5ID49IHF1ZXJ5UHJveHkgPyBwcm94eSA6IHF1ZXJ5UHJveHk7KytfX3RoaXMubV9wYWlyQ291bnQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgfTtcbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgX190aGlzLm1fbW92ZUJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgcXVlcnlQcm94eSA9IF9fdGhpcy5tX21vdmVCdWZmZXJbaV07XG4gICAgICAgICB2YXIgZmF0QUFCQiA9IF9fdGhpcy5tX3RyZWUuR2V0RmF0QUFCQihxdWVyeVByb3h5KTtcbiAgICAgICAgIF9fdGhpcy5tX3RyZWUuUXVlcnkoUXVlcnlDYWxsYmFjaywgZmF0QUFCQik7XG4gICAgICB9XG4gICAgICBfX3RoaXMubV9tb3ZlQnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9fdGhpcy5tX3BhaXJDb3VudDspIHtcbiAgICAgICAgIHZhciBwcmltYXJ5UGFpciA9IF9fdGhpcy5tX3BhaXJCdWZmZXJbaV07XG4gICAgICAgICB2YXIgdXNlckRhdGFBID0gX190aGlzLm1fdHJlZS5HZXRVc2VyRGF0YShwcmltYXJ5UGFpci5wcm94eUEpO1xuICAgICAgICAgdmFyIHVzZXJEYXRhQiA9IF9fdGhpcy5tX3RyZWUuR2V0VXNlckRhdGEocHJpbWFyeVBhaXIucHJveHlCKTtcbiAgICAgICAgIGNhbGxiYWNrKHVzZXJEYXRhQSwgdXNlckRhdGFCKTtcbiAgICAgICAgICsraTtcbiAgICAgICAgIHdoaWxlIChpIDwgX190aGlzLm1fcGFpckNvdW50KSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IF9fdGhpcy5tX3BhaXJCdWZmZXJbaV07XG4gICAgICAgICAgICBpZiAocGFpci5wcm94eUEgIT0gcHJpbWFyeVBhaXIucHJveHlBIHx8IHBhaXIucHJveHlCICE9IHByaW1hcnlQYWlyLnByb3h5Qikge1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9KytpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLlF1ZXJ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhYWJiKSB7XG4gICAgICB0aGlzLm1fdHJlZS5RdWVyeShjYWxsYmFjaywgYWFiYik7XG4gICB9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuUmF5Q2FzdCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgaW5wdXQpIHtcbiAgICAgIHRoaXMubV90cmVlLlJheUNhc3QoY2FsbGJhY2ssIGlucHV0KTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5WYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHt9XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuUmViYWxhbmNlID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMpIHtcbiAgICAgIGlmIChpdGVyYXRpb25zID09PSB1bmRlZmluZWQpIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdGhpcy5tX3RyZWUuUmViYWxhbmNlKGl0ZXJhdGlvbnMpO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkJ1ZmZlck1vdmUgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgIHRoaXMubV9tb3ZlQnVmZmVyW3RoaXMubV9tb3ZlQnVmZmVyLmxlbmd0aF0gPSBwcm94eTtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5VbkJ1ZmZlck1vdmUgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgIHZhciBpID0gcGFyc2VJbnQodGhpcy5tX21vdmVCdWZmZXIuaW5kZXhPZihwcm94eSkpO1xuICAgICAgdGhpcy5tX21vdmVCdWZmZXIuc3BsaWNlKGksIDEpO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkNvbXBhcmVQYWlycyA9IGZ1bmN0aW9uIChwYWlyMSwgcGFpcjIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgfVxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UuX19pbXBsZW1lbnRzID0ge307XG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5fX2ltcGxlbWVudHNbSUJyb2FkUGhhc2VdID0gdHJ1ZTtcbiAgIGIyRHluYW1pY1RyZWVOb2RlLmIyRHluYW1pY1RyZWVOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5hYWJiID0gbmV3IGIyQUFCQigpO1xuICAgfTtcbiAgIGIyRHluYW1pY1RyZWVOb2RlLnByb3RvdHlwZS5Jc0xlYWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZDEgPT0gbnVsbDtcbiAgIH1cbiAgIGIyRHluYW1pY1RyZWVQYWlyLmIyRHluYW1pY1RyZWVQYWlyID0gZnVuY3Rpb24gKCkge307XG4gICBiMk1hbmlmb2xkLmIyTWFuaWZvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fcG9pbnRDb3VudCA9IDA7XG4gICB9O1xuICAgYjJNYW5pZm9sZC5wcm90b3R5cGUuYjJNYW5pZm9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9wb2ludHMgPSBuZXcgVmVjdG9yKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzOyBpKyspIHtcbiAgICAgICAgIHRoaXMubV9wb2ludHNbaV0gPSBuZXcgYjJNYW5pZm9sZFBvaW50KCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fbG9jYWxQbGFuZU5vcm1hbCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gbmV3IGIyVmVjMigpO1xuICAgfVxuICAgYjJNYW5pZm9sZC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xuICAgICAgICAgKCh0aGlzLm1fcG9pbnRzW2ldIGluc3RhbmNlb2YgYjJNYW5pZm9sZFBvaW50ID8gdGhpcy5tX3BvaW50c1tpXSA6IG51bGwpKS5SZXNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2xvY2FsUGxhbmVOb3JtYWwuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX2xvY2FsUG9pbnQuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX3R5cGUgPSAwO1xuICAgICAgdGhpcy5tX3BvaW50Q291bnQgPSAwO1xuICAgfVxuICAgYjJNYW5pZm9sZC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgIHRoaXMubV9wb2ludENvdW50ID0gbS5tX3BvaW50Q291bnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xuICAgICAgICAgKCh0aGlzLm1fcG9pbnRzW2ldIGluc3RhbmNlb2YgYjJNYW5pZm9sZFBvaW50ID8gdGhpcy5tX3BvaW50c1tpXSA6IG51bGwpKS5TZXQobS5tX3BvaW50c1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fbG9jYWxQbGFuZU5vcm1hbC5TZXRWKG0ubV9sb2NhbFBsYW5lTm9ybWFsKTtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50LlNldFYobS5tX2xvY2FsUG9pbnQpO1xuICAgICAgdGhpcy5tX3R5cGUgPSBtLm1fdHlwZTtcbiAgIH1cbiAgIGIyTWFuaWZvbGQucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29weSA9IG5ldyBiMk1hbmlmb2xkKCk7XG4gICAgICBjb3B5LlNldCh0aGlzKTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZC5lX2NpcmNsZXMgPSAweDAwMDE7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZC5lX2ZhY2VBID0gMHgwMDAyO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyTWFuaWZvbGQuZV9mYWNlQiA9IDB4MDAwNDtcbiAgIH0pO1xuICAgYjJNYW5pZm9sZFBvaW50LmIyTWFuaWZvbGRQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2lkID0gbmV3IGIyQ29udGFjdElEKCk7XG4gICB9O1xuICAgYjJNYW5pZm9sZFBvaW50LnByb3RvdHlwZS5iMk1hbmlmb2xkUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLlJlc2V0KCk7XG4gICB9XG4gICBiMk1hbmlmb2xkUG9pbnQucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX2xvY2FsUG9pbnQuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX25vcm1hbEltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1fdGFuZ2VudEltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1faWQua2V5ID0gMDtcbiAgIH1cbiAgIGIyTWFuaWZvbGRQb2ludC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50LlNldFYobS5tX2xvY2FsUG9pbnQpO1xuICAgICAgdGhpcy5tX25vcm1hbEltcHVsc2UgPSBtLm1fbm9ybWFsSW1wdWxzZTtcbiAgICAgIHRoaXMubV90YW5nZW50SW1wdWxzZSA9IG0ubV90YW5nZW50SW1wdWxzZTtcbiAgICAgIHRoaXMubV9pZC5TZXQobS5tX2lkKTtcbiAgIH1cbiAgIGIyUG9pbnQuYjJQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucCA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMlBvaW50LnByb3RvdHlwZS5TdXBwb3J0ID0gZnVuY3Rpb24gKHhmLCB2WCwgdlkpIHtcbiAgICAgIGlmICh2WCA9PT0gdW5kZWZpbmVkKSB2WCA9IDA7XG4gICAgICBpZiAodlkgPT09IHVuZGVmaW5lZCkgdlkgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMucDtcbiAgIH1cbiAgIGIyUG9pbnQucHJvdG90eXBlLkdldEZpcnN0VmVydGV4ID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICByZXR1cm4gdGhpcy5wO1xuICAgfVxuICAgYjJSYXlDYXN0SW5wdXQuYjJSYXlDYXN0SW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnAxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5wMiA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMlJheUNhc3RJbnB1dC5wcm90b3R5cGUuYjJSYXlDYXN0SW5wdXQgPSBmdW5jdGlvbiAocDEsIHAyLCBtYXhGcmFjdGlvbikge1xuICAgICAgaWYgKHAxID09PSB1bmRlZmluZWQpIHAxID0gbnVsbDtcbiAgICAgIGlmIChwMiA9PT0gdW5kZWZpbmVkKSBwMiA9IG51bGw7XG4gICAgICBpZiAobWF4RnJhY3Rpb24gPT09IHVuZGVmaW5lZCkgbWF4RnJhY3Rpb24gPSAxO1xuICAgICAgaWYgKHAxKSB0aGlzLnAxLlNldFYocDEpO1xuICAgICAgaWYgKHAyKSB0aGlzLnAyLlNldFYocDIpO1xuICAgICAgdGhpcy5tYXhGcmFjdGlvbiA9IG1heEZyYWN0aW9uO1xuICAgfVxuICAgYjJSYXlDYXN0T3V0cHV0LmIyUmF5Q2FzdE91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyU2VnbWVudC5iMlNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnAxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5wMiA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMlNlZ21lbnQucHJvdG90eXBlLlRlc3RTZWdtZW50ID0gZnVuY3Rpb24gKGxhbWJkYSwgbm9ybWFsLCBzZWdtZW50LCBtYXhMYW1iZGEpIHtcbiAgICAgIGlmIChtYXhMYW1iZGEgPT09IHVuZGVmaW5lZCkgbWF4TGFtYmRhID0gMDtcbiAgICAgIHZhciBzID0gc2VnbWVudC5wMTtcbiAgICAgIHZhciByWCA9IHNlZ21lbnQucDIueCAtIHMueDtcbiAgICAgIHZhciByWSA9IHNlZ21lbnQucDIueSAtIHMueTtcbiAgICAgIHZhciBkWCA9IHRoaXMucDIueCAtIHRoaXMucDEueDtcbiAgICAgIHZhciBkWSA9IHRoaXMucDIueSAtIHRoaXMucDEueTtcbiAgICAgIHZhciBuWCA9IGRZO1xuICAgICAgdmFyIG5ZID0gKC1kWCk7XG4gICAgICB2YXIga19zbG9wID0gMTAwLjAgKiBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgdmFyIGRlbm9tID0gKC0oclggKiBuWCArIHJZICogblkpKTtcbiAgICAgIGlmIChkZW5vbSA+IGtfc2xvcCkge1xuICAgICAgICAgdmFyIGJYID0gcy54IC0gdGhpcy5wMS54O1xuICAgICAgICAgdmFyIGJZID0gcy55IC0gdGhpcy5wMS55O1xuICAgICAgICAgdmFyIGEgPSAoYlggKiBuWCArIGJZICogblkpO1xuICAgICAgICAgaWYgKDAuMCA8PSBhICYmIGEgPD0gbWF4TGFtYmRhICogZGVub20pIHtcbiAgICAgICAgICAgIHZhciBtdTIgPSAoLXJYICogYlkpICsgclkgKiBiWDtcbiAgICAgICAgICAgIGlmICgoLWtfc2xvcCAqIGRlbm9tKSA8PSBtdTIgJiYgbXUyIDw9IGRlbm9tICogKDEuMCArIGtfc2xvcCkpIHtcbiAgICAgICAgICAgICAgIGEgLz0gZGVub207XG4gICAgICAgICAgICAgICB2YXIgbkxlbiA9IE1hdGguc3FydChuWCAqIG5YICsgblkgKiBuWSk7XG4gICAgICAgICAgICAgICBuWCAvPSBuTGVuO1xuICAgICAgICAgICAgICAgblkgLz0gbkxlbjtcbiAgICAgICAgICAgICAgIGxhbWJkYVswXSA9IGE7XG4gICAgICAgICAgICAgICBub3JtYWwuU2V0KG5YLCBuWSk7XG4gICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyU2VnbWVudC5wcm90b3R5cGUuRXh0ZW5kID0gZnVuY3Rpb24gKGFhYmIpIHtcbiAgICAgIHRoaXMuRXh0ZW5kRm9yd2FyZChhYWJiKTtcbiAgICAgIHRoaXMuRXh0ZW5kQmFja3dhcmQoYWFiYik7XG4gICB9XG4gICBiMlNlZ21lbnQucHJvdG90eXBlLkV4dGVuZEZvcndhcmQgPSBmdW5jdGlvbiAoYWFiYikge1xuICAgICAgdmFyIGRYID0gdGhpcy5wMi54IC0gdGhpcy5wMS54O1xuICAgICAgdmFyIGRZID0gdGhpcy5wMi55IC0gdGhpcy5wMS55O1xuICAgICAgdmFyIGxhbWJkYSA9IE1hdGgubWluKGRYID4gMCA/IChhYWJiLnVwcGVyQm91bmQueCAtIHRoaXMucDEueCkgLyBkWCA6IGRYIDwgMCA/IChhYWJiLmxvd2VyQm91bmQueCAtIHRoaXMucDEueCkgLyBkWCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgIGRZID4gMCA/IChhYWJiLnVwcGVyQm91bmQueSAtIHRoaXMucDEueSkgLyBkWSA6IGRZIDwgMCA/IChhYWJiLmxvd2VyQm91bmQueSAtIHRoaXMucDEueSkgLyBkWSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICB0aGlzLnAyLnggPSB0aGlzLnAxLnggKyBkWCAqIGxhbWJkYTtcbiAgICAgIHRoaXMucDIueSA9IHRoaXMucDEueSArIGRZICogbGFtYmRhO1xuICAgfVxuICAgYjJTZWdtZW50LnByb3RvdHlwZS5FeHRlbmRCYWNrd2FyZCA9IGZ1bmN0aW9uIChhYWJiKSB7XG4gICAgICB2YXIgZFggPSAoLXRoaXMucDIueCkgKyB0aGlzLnAxLng7XG4gICAgICB2YXIgZFkgPSAoLXRoaXMucDIueSkgKyB0aGlzLnAxLnk7XG4gICAgICB2YXIgbGFtYmRhID0gTWF0aC5taW4oZFggPiAwID8gKGFhYmIudXBwZXJCb3VuZC54IC0gdGhpcy5wMi54KSAvIGRYIDogZFggPCAwID8gKGFhYmIubG93ZXJCb3VuZC54IC0gdGhpcy5wMi54KSAvIGRYIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgZFkgPiAwID8gKGFhYmIudXBwZXJCb3VuZC55IC0gdGhpcy5wMi55KSAvIGRZIDogZFkgPCAwID8gKGFhYmIubG93ZXJCb3VuZC55IC0gdGhpcy5wMi55KSAvIGRZIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgIHRoaXMucDEueCA9IHRoaXMucDIueCArIGRYICogbGFtYmRhO1xuICAgICAgdGhpcy5wMS55ID0gdGhpcy5wMi55ICsgZFkgKiBsYW1iZGE7XG4gICB9XG4gICBiMlNlcGFyYXRpb25GdW5jdGlvbi5iMlNlcGFyYXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2F4aXMgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJTZXBhcmF0aW9uRnVuY3Rpb24ucHJvdG90eXBlLkluaXRpYWxpemUgPSBmdW5jdGlvbiAoY2FjaGUsIHByb3h5QSwgdHJhbnNmb3JtQSwgcHJveHlCLCB0cmFuc2Zvcm1CKSB7XG4gICAgICB0aGlzLm1fcHJveHlBID0gcHJveHlBO1xuICAgICAgdGhpcy5tX3Byb3h5QiA9IHByb3h5QjtcbiAgICAgIHZhciBjb3VudCA9IHBhcnNlSW50KGNhY2hlLmNvdW50KTtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMCA8IGNvdW50ICYmIGNvdW50IDwgMyk7XG4gICAgICB2YXIgbG9jYWxQb2ludEE7XG4gICAgICB2YXIgbG9jYWxQb2ludEExO1xuICAgICAgdmFyIGxvY2FsUG9pbnRBMjtcbiAgICAgIHZhciBsb2NhbFBvaW50QjtcbiAgICAgIHZhciBsb2NhbFBvaW50QjE7XG4gICAgICB2YXIgbG9jYWxQb2ludEIyO1xuICAgICAgdmFyIHBvaW50QVggPSAwO1xuICAgICAgdmFyIHBvaW50QVkgPSAwO1xuICAgICAgdmFyIHBvaW50QlggPSAwO1xuICAgICAgdmFyIHBvaW50QlkgPSAwO1xuICAgICAgdmFyIG5vcm1hbFggPSAwO1xuICAgICAgdmFyIG5vcm1hbFkgPSAwO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFZlYztcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBzZ24gPSAwO1xuICAgICAgaWYgKGNvdW50ID09IDEpIHtcbiAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9wb2ludHM7XG4gICAgICAgICBsb2NhbFBvaW50QSA9IHRoaXMubV9wcm94eUEuR2V0VmVydGV4KGNhY2hlLmluZGV4QVswXSk7XG4gICAgICAgICBsb2NhbFBvaW50QiA9IHRoaXMubV9wcm94eUIuR2V0VmVydGV4KGNhY2hlLmluZGV4QlswXSk7XG4gICAgICAgICB0VmVjID0gbG9jYWxQb2ludEE7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQS5SO1xuICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QVkgPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICB0VmVjID0gbG9jYWxQb2ludEI7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xuICAgICAgICAgcG9pbnRCWCA9IHRyYW5zZm9ybUIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QlkgPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICB0aGlzLm1fYXhpcy54ID0gcG9pbnRCWCAtIHBvaW50QVg7XG4gICAgICAgICB0aGlzLm1fYXhpcy55ID0gcG9pbnRCWSAtIHBvaW50QVk7XG4gICAgICAgICB0aGlzLm1fYXhpcy5Ob3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhY2hlLmluZGV4QlswXSA9PSBjYWNoZS5pbmRleEJbMV0pIHtcbiAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQTtcbiAgICAgICAgIGxvY2FsUG9pbnRBMSA9IHRoaXMubV9wcm94eUEuR2V0VmVydGV4KGNhY2hlLmluZGV4QVswXSk7XG4gICAgICAgICBsb2NhbFBvaW50QTIgPSB0aGlzLm1fcHJveHlBLkdldFZlcnRleChjYWNoZS5pbmRleEFbMV0pO1xuICAgICAgICAgbG9jYWxQb2ludEIgPSB0aGlzLm1fcHJveHlCLkdldFZlcnRleChjYWNoZS5pbmRleEJbMF0pO1xuICAgICAgICAgdGhpcy5tX2xvY2FsUG9pbnQueCA9IDAuNSAqIChsb2NhbFBvaW50QTEueCArIGxvY2FsUG9pbnRBMi54KTtcbiAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50LnkgPSAwLjUgKiAobG9jYWxQb2ludEExLnkgKyBsb2NhbFBvaW50QTIueSk7XG4gICAgICAgICB0aGlzLm1fYXhpcyA9IGIyTWF0aC5Dcm9zc1ZGKGIyTWF0aC5TdWJ0cmFjdFZWKGxvY2FsUG9pbnRBMiwgbG9jYWxQb2ludEExKSwgMS4wKTtcbiAgICAgICAgIHRoaXMubV9heGlzLk5vcm1hbGl6ZSgpO1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9heGlzO1xuICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUEuUjtcbiAgICAgICAgIG5vcm1hbFggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgbm9ybWFsWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX2xvY2FsUG9pbnQ7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQS5SO1xuICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QVkgPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICB0VmVjID0gbG9jYWxQb2ludEI7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xuICAgICAgICAgcG9pbnRCWCA9IHRyYW5zZm9ybUIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QlkgPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICBzID0gKHBvaW50QlggLSBwb2ludEFYKSAqIG5vcm1hbFggKyAocG9pbnRCWSAtIHBvaW50QVkpICogbm9ybWFsWTtcbiAgICAgICAgIGlmIChzIDwgMC4wKSB7XG4gICAgICAgICAgICB0aGlzLm1fYXhpcy5OZWdhdGl2ZVNlbGYoKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhY2hlLmluZGV4QVswXSA9PSBjYWNoZS5pbmRleEFbMF0pIHtcbiAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQjtcbiAgICAgICAgIGxvY2FsUG9pbnRCMSA9IHRoaXMubV9wcm94eUIuR2V0VmVydGV4KGNhY2hlLmluZGV4QlswXSk7XG4gICAgICAgICBsb2NhbFBvaW50QjIgPSB0aGlzLm1fcHJveHlCLkdldFZlcnRleChjYWNoZS5pbmRleEJbMV0pO1xuICAgICAgICAgbG9jYWxQb2ludEEgPSB0aGlzLm1fcHJveHlBLkdldFZlcnRleChjYWNoZS5pbmRleEFbMF0pO1xuICAgICAgICAgdGhpcy5tX2xvY2FsUG9pbnQueCA9IDAuNSAqIChsb2NhbFBvaW50QjEueCArIGxvY2FsUG9pbnRCMi54KTtcbiAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50LnkgPSAwLjUgKiAobG9jYWxQb2ludEIxLnkgKyBsb2NhbFBvaW50QjIueSk7XG4gICAgICAgICB0aGlzLm1fYXhpcyA9IGIyTWF0aC5Dcm9zc1ZGKGIyTWF0aC5TdWJ0cmFjdFZWKGxvY2FsUG9pbnRCMiwgbG9jYWxQb2ludEIxKSwgMS4wKTtcbiAgICAgICAgIHRoaXMubV9heGlzLk5vcm1hbGl6ZSgpO1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9heGlzO1xuICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUIuUjtcbiAgICAgICAgIG5vcm1hbFggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgbm9ybWFsWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX2xvY2FsUG9pbnQ7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xuICAgICAgICAgcG9pbnRCWCA9IHRyYW5zZm9ybUIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QlkgPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICB0VmVjID0gbG9jYWxQb2ludEE7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQS5SO1xuICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgIHBvaW50QVkgPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICBzID0gKHBvaW50QVggLSBwb2ludEJYKSAqIG5vcm1hbFggKyAocG9pbnRBWSAtIHBvaW50QlkpICogbm9ybWFsWTtcbiAgICAgICAgIGlmIChzIDwgMC4wKSB7XG4gICAgICAgICAgICB0aGlzLm1fYXhpcy5OZWdhdGl2ZVNlbGYoKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgbG9jYWxQb2ludEExID0gdGhpcy5tX3Byb3h5QS5HZXRWZXJ0ZXgoY2FjaGUuaW5kZXhBWzBdKTtcbiAgICAgICAgIGxvY2FsUG9pbnRBMiA9IHRoaXMubV9wcm94eUEuR2V0VmVydGV4KGNhY2hlLmluZGV4QVsxXSk7XG4gICAgICAgICBsb2NhbFBvaW50QjEgPSB0aGlzLm1fcHJveHlCLkdldFZlcnRleChjYWNoZS5pbmRleEJbMF0pO1xuICAgICAgICAgbG9jYWxQb2ludEIyID0gdGhpcy5tX3Byb3h5Qi5HZXRWZXJ0ZXgoY2FjaGUuaW5kZXhCWzFdKTtcbiAgICAgICAgIHZhciBwQSA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUEsIGxvY2FsUG9pbnRBKTtcbiAgICAgICAgIHZhciBkQSA9IGIyTWF0aC5NdWxNVih0cmFuc2Zvcm1BLlIsIGIyTWF0aC5TdWJ0cmFjdFZWKGxvY2FsUG9pbnRBMiwgbG9jYWxQb2ludEExKSk7XG4gICAgICAgICB2YXIgcEIgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCBsb2NhbFBvaW50Qik7XG4gICAgICAgICB2YXIgZEIgPSBiMk1hdGguTXVsTVYodHJhbnNmb3JtQi5SLCBiMk1hdGguU3VidHJhY3RWVihsb2NhbFBvaW50QjIsIGxvY2FsUG9pbnRCMSkpO1xuICAgICAgICAgdmFyIGEgPSBkQS54ICogZEEueCArIGRBLnkgKiBkQS55O1xuICAgICAgICAgdmFyIGUgPSBkQi54ICogZEIueCArIGRCLnkgKiBkQi55O1xuICAgICAgICAgdmFyIHIgPSBiMk1hdGguU3VidHJhY3RWVihkQiwgZEEpO1xuICAgICAgICAgdmFyIGMgPSBkQS54ICogci54ICsgZEEueSAqIHIueTtcbiAgICAgICAgIHZhciBmID0gZEIueCAqIHIueCArIGRCLnkgKiByLnk7XG4gICAgICAgICB2YXIgYiA9IGRBLnggKiBkQi54ICsgZEEueSAqIGRCLnk7XG4gICAgICAgICB2YXIgZGVub20gPSBhICogZSAtIGIgKiBiO1xuICAgICAgICAgcyA9IDAuMDtcbiAgICAgICAgIGlmIChkZW5vbSAhPSAwLjApIHtcbiAgICAgICAgICAgIHMgPSBiMk1hdGguQ2xhbXAoKGIgKiBmIC0gYyAqIGUpIC8gZGVub20sIDAuMCwgMS4wKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciB0ID0gKGIgKiBzICsgZikgLyBlO1xuICAgICAgICAgaWYgKHQgPCAwLjApIHtcbiAgICAgICAgICAgIHQgPSAwLjA7XG4gICAgICAgICAgICBzID0gYjJNYXRoLkNsYW1wKChiIC0gYykgLyBhLCAwLjAsIDEuMCk7XG4gICAgICAgICB9XG4gICAgICAgICBsb2NhbFBvaW50QSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgICAgIGxvY2FsUG9pbnRBLnggPSBsb2NhbFBvaW50QTEueCArIHMgKiAobG9jYWxQb2ludEEyLnggLSBsb2NhbFBvaW50QTEueCk7XG4gICAgICAgICBsb2NhbFBvaW50QS55ID0gbG9jYWxQb2ludEExLnkgKyBzICogKGxvY2FsUG9pbnRBMi55IC0gbG9jYWxQb2ludEExLnkpO1xuICAgICAgICAgbG9jYWxQb2ludEIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICAgICBsb2NhbFBvaW50Qi54ID0gbG9jYWxQb2ludEIxLnggKyBzICogKGxvY2FsUG9pbnRCMi54IC0gbG9jYWxQb2ludEIxLngpO1xuICAgICAgICAgbG9jYWxQb2ludEIueSA9IGxvY2FsUG9pbnRCMS55ICsgcyAqIChsb2NhbFBvaW50QjIueSAtIGxvY2FsUG9pbnRCMS55KTtcbiAgICAgICAgIGlmIChzID09IDAuMCB8fCBzID09IDEuMCkge1xuICAgICAgICAgICAgdGhpcy5tX3R5cGUgPSBiMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VCO1xuICAgICAgICAgICAgdGhpcy5tX2F4aXMgPSBiMk1hdGguQ3Jvc3NWRihiMk1hdGguU3VidHJhY3RWVihsb2NhbFBvaW50QjIsIGxvY2FsUG9pbnRCMSksIDEuMCk7XG4gICAgICAgICAgICB0aGlzLm1fYXhpcy5Ob3JtYWxpemUoKTtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gbG9jYWxQb2ludEI7XG4gICAgICAgICAgICB0VmVjID0gdGhpcy5tX2F4aXM7XG4gICAgICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xuICAgICAgICAgICAgbm9ybWFsWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICBub3JtYWxZID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHRWZWMgPSB0aGlzLm1fbG9jYWxQb2ludDtcbiAgICAgICAgICAgIHRNYXQgPSB0cmFuc2Zvcm1CLlI7XG4gICAgICAgICAgICBwb2ludEJYID0gdHJhbnNmb3JtQi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgcG9pbnRCWSA9IHRyYW5zZm9ybUIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgICAgICAgIHRWZWMgPSBsb2NhbFBvaW50QTtcbiAgICAgICAgICAgIHRNYXQgPSB0cmFuc2Zvcm1BLlI7XG4gICAgICAgICAgICBwb2ludEFYID0gdHJhbnNmb3JtQS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgcG9pbnRBWSA9IHRyYW5zZm9ybUEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgICAgICAgIHNnbiA9IChwb2ludEFYIC0gcG9pbnRCWCkgKiBub3JtYWxYICsgKHBvaW50QVkgLSBwb2ludEJZKSAqIG5vcm1hbFk7XG4gICAgICAgICAgICBpZiAocyA8IDAuMCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX2F4aXMuTmVnYXRpdmVTZWxmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQTtcbiAgICAgICAgICAgIHRoaXMubV9heGlzID0gYjJNYXRoLkNyb3NzVkYoYjJNYXRoLlN1YnRyYWN0VlYobG9jYWxQb2ludEEyLCBsb2NhbFBvaW50QTEpLCAxLjApO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsUG9pbnQgPSBsb2NhbFBvaW50QTtcbiAgICAgICAgICAgIHRWZWMgPSB0aGlzLm1fYXhpcztcbiAgICAgICAgICAgIHRNYXQgPSB0cmFuc2Zvcm1BLlI7XG4gICAgICAgICAgICBub3JtYWxYID0gdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcbiAgICAgICAgICAgIG5vcm1hbFkgPSB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xuICAgICAgICAgICAgdFZlYyA9IHRoaXMubV9sb2NhbFBvaW50O1xuICAgICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUEuUjtcbiAgICAgICAgICAgIHBvaW50QVggPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICAgICAgICBwb2ludEFZID0gdHJhbnNmb3JtQS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgdFZlYyA9IGxvY2FsUG9pbnRCO1xuICAgICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUIuUjtcbiAgICAgICAgICAgIHBvaW50QlggPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICAgICAgICBwb2ludEJZID0gdHJhbnNmb3JtQi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgc2duID0gKHBvaW50QlggLSBwb2ludEFYKSAqIG5vcm1hbFggKyAocG9pbnRCWSAtIHBvaW50QVkpICogbm9ybWFsWTtcbiAgICAgICAgICAgIGlmIChzIDwgMC4wKSB7XG4gICAgICAgICAgICAgICB0aGlzLm1fYXhpcy5OZWdhdGl2ZVNlbGYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLnByb3RvdHlwZS5FdmFsdWF0ZSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1BLCB0cmFuc2Zvcm1CKSB7XG4gICAgICB2YXIgYXhpc0E7XG4gICAgICB2YXIgYXhpc0I7XG4gICAgICB2YXIgbG9jYWxQb2ludEE7XG4gICAgICB2YXIgbG9jYWxQb2ludEI7XG4gICAgICB2YXIgcG9pbnRBO1xuICAgICAgdmFyIHBvaW50QjtcbiAgICAgIHZhciBzZXBlcmF0aW9uID0gMDtcbiAgICAgIHZhciBub3JtYWw7XG4gICAgICBzd2l0Y2ggKHRoaXMubV90eXBlKSB7XG4gICAgICBjYXNlIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLmVfcG9pbnRzOlxuICAgICAgICAge1xuICAgICAgICAgICAgYXhpc0EgPSBiMk1hdGguTXVsVE1WKHRyYW5zZm9ybUEuUiwgdGhpcy5tX2F4aXMpO1xuICAgICAgICAgICAgYXhpc0IgPSBiMk1hdGguTXVsVE1WKHRyYW5zZm9ybUIuUiwgdGhpcy5tX2F4aXMuR2V0TmVnYXRpdmUoKSk7XG4gICAgICAgICAgICBsb2NhbFBvaW50QSA9IHRoaXMubV9wcm94eUEuR2V0U3VwcG9ydFZlcnRleChheGlzQSk7XG4gICAgICAgICAgICBsb2NhbFBvaW50QiA9IHRoaXMubV9wcm94eUIuR2V0U3VwcG9ydFZlcnRleChheGlzQik7XG4gICAgICAgICAgICBwb2ludEEgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCBsb2NhbFBvaW50QSk7XG4gICAgICAgICAgICBwb2ludEIgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCBsb2NhbFBvaW50Qik7XG4gICAgICAgICAgICBzZXBlcmF0aW9uID0gKHBvaW50Qi54IC0gcG9pbnRBLngpICogdGhpcy5tX2F4aXMueCArIChwb2ludEIueSAtIHBvaW50QS55KSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICAgICByZXR1cm4gc2VwZXJhdGlvbjtcbiAgICAgICAgIH1cbiAgICAgIGNhc2UgYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQTpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIG5vcm1hbCA9IGIyTWF0aC5NdWxNVih0cmFuc2Zvcm1BLlIsIHRoaXMubV9heGlzKTtcbiAgICAgICAgICAgIHBvaW50QSA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUEsIHRoaXMubV9sb2NhbFBvaW50KTtcbiAgICAgICAgICAgIGF4aXNCID0gYjJNYXRoLk11bFRNVih0cmFuc2Zvcm1CLlIsIG5vcm1hbC5HZXROZWdhdGl2ZSgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9pbnRCID0gdGhpcy5tX3Byb3h5Qi5HZXRTdXBwb3J0VmVydGV4KGF4aXNCKTtcbiAgICAgICAgICAgIHBvaW50QiA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUIsIGxvY2FsUG9pbnRCKTtcbiAgICAgICAgICAgIHNlcGVyYXRpb24gPSAocG9pbnRCLnggLSBwb2ludEEueCkgKiBub3JtYWwueCArIChwb2ludEIueSAtIHBvaW50QS55KSAqIG5vcm1hbC55O1xuICAgICAgICAgICAgcmV0dXJuIHNlcGVyYXRpb247XG4gICAgICAgICB9XG4gICAgICBjYXNlIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLmVfZmFjZUI6XG4gICAgICAgICB7XG4gICAgICAgICAgICBub3JtYWwgPSBiMk1hdGguTXVsTVYodHJhbnNmb3JtQi5SLCB0aGlzLm1fYXhpcyk7XG4gICAgICAgICAgICBwb2ludEIgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCB0aGlzLm1fbG9jYWxQb2ludCk7XG4gICAgICAgICAgICBheGlzQSA9IGIyTWF0aC5NdWxUTVYodHJhbnNmb3JtQS5SLCBub3JtYWwuR2V0TmVnYXRpdmUoKSk7XG4gICAgICAgICAgICBsb2NhbFBvaW50QSA9IHRoaXMubV9wcm94eUEuR2V0U3VwcG9ydFZlcnRleChheGlzQSk7XG4gICAgICAgICAgICBwb2ludEEgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCBsb2NhbFBvaW50QSk7XG4gICAgICAgICAgICBzZXBlcmF0aW9uID0gKHBvaW50QS54IC0gcG9pbnRCLngpICogbm9ybWFsLnggKyAocG9pbnRBLnkgLSBwb2ludEIueSkgKiBub3JtYWwueTtcbiAgICAgICAgICAgIHJldHVybiBzZXBlcmF0aW9uO1xuICAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xuICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyU2VwYXJhdGlvbkZ1bmN0aW9uLmVfcG9pbnRzID0gMHgwMTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VBID0gMHgwMjtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VCID0gMHgwNDtcbiAgIH0pO1xuICAgYjJTaW1wbGV4LmIyU2ltcGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV92MSA9IG5ldyBiMlNpbXBsZXhWZXJ0ZXgoKTtcbiAgICAgIHRoaXMubV92MiA9IG5ldyBiMlNpbXBsZXhWZXJ0ZXgoKTtcbiAgICAgIHRoaXMubV92MyA9IG5ldyBiMlNpbXBsZXhWZXJ0ZXgoKTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlcyA9IG5ldyBWZWN0b3IoMyk7XG4gICB9O1xuICAgYjJTaW1wbGV4LnByb3RvdHlwZS5iMlNpbXBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMF0gPSB0aGlzLm1fdjE7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMV0gPSB0aGlzLm1fdjI7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMl0gPSB0aGlzLm1fdjM7XG4gICB9XG4gICBiMlNpbXBsZXgucHJvdG90eXBlLlJlYWRDYWNoZSA9IGZ1bmN0aW9uIChjYWNoZSwgcHJveHlBLCB0cmFuc2Zvcm1BLCBwcm94eUIsIHRyYW5zZm9ybUIpIHtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMCA8PSBjYWNoZS5jb3VudCAmJiBjYWNoZS5jb3VudCA8PSAzKTtcbiAgICAgIHZhciB3QUxvY2FsO1xuICAgICAgdmFyIHdCTG9jYWw7XG4gICAgICB0aGlzLm1fY291bnQgPSBjYWNoZS5jb3VudDtcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMubV92ZXJ0aWNlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyBpKyspIHtcbiAgICAgICAgIHZhciB2ID0gdmVydGljZXNbaV07XG4gICAgICAgICB2LmluZGV4QSA9IGNhY2hlLmluZGV4QVtpXTtcbiAgICAgICAgIHYuaW5kZXhCID0gY2FjaGUuaW5kZXhCW2ldO1xuICAgICAgICAgd0FMb2NhbCA9IHByb3h5QS5HZXRWZXJ0ZXgodi5pbmRleEEpO1xuICAgICAgICAgd0JMb2NhbCA9IHByb3h5Qi5HZXRWZXJ0ZXgodi5pbmRleEIpO1xuICAgICAgICAgdi53QSA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUEsIHdBTG9jYWwpO1xuICAgICAgICAgdi53QiA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUIsIHdCTG9jYWwpO1xuICAgICAgICAgdi53ID0gYjJNYXRoLlN1YnRyYWN0VlYodi53Qiwgdi53QSk7XG4gICAgICAgICB2LmEgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9jb3VudCA+IDEpIHtcbiAgICAgICAgIHZhciBtZXRyaWMxID0gY2FjaGUubWV0cmljO1xuICAgICAgICAgdmFyIG1ldHJpYzIgPSB0aGlzLkdldE1ldHJpYygpO1xuICAgICAgICAgaWYgKG1ldHJpYzIgPCAuNSAqIG1ldHJpYzEgfHwgMi4wICogbWV0cmljMSA8IG1ldHJpYzIgfHwgbWV0cmljMiA8IE51bWJlci5NSU5fVkFMVUUpIHtcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IDA7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2NvdW50ID09IDApIHtcbiAgICAgICAgIHYgPSB2ZXJ0aWNlc1swXTtcbiAgICAgICAgIHYuaW5kZXhBID0gMDtcbiAgICAgICAgIHYuaW5kZXhCID0gMDtcbiAgICAgICAgIHdBTG9jYWwgPSBwcm94eUEuR2V0VmVydGV4KDApO1xuICAgICAgICAgd0JMb2NhbCA9IHByb3h5Qi5HZXRWZXJ0ZXgoMCk7XG4gICAgICAgICB2LndBID0gYjJNYXRoLk11bFgodHJhbnNmb3JtQSwgd0FMb2NhbCk7XG4gICAgICAgICB2LndCID0gYjJNYXRoLk11bFgodHJhbnNmb3JtQiwgd0JMb2NhbCk7XG4gICAgICAgICB2LncgPSBiMk1hdGguU3VidHJhY3RWVih2LndCLCB2LndBKTtcbiAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICB9XG4gICB9XG4gICBiMlNpbXBsZXgucHJvdG90eXBlLldyaXRlQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlLm1ldHJpYyA9IHRoaXMuR2V0TWV0cmljKCk7XG4gICAgICBjYWNoZS5jb3VudCA9IEJveDJELnBhcnNlVUludCh0aGlzLm1fY291bnQpO1xuICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5tX3ZlcnRpY2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7IGkrKykge1xuICAgICAgICAgY2FjaGUuaW5kZXhBW2ldID0gQm94MkQucGFyc2VVSW50KHZlcnRpY2VzW2ldLmluZGV4QSk7XG4gICAgICAgICBjYWNoZS5pbmRleEJbaV0gPSBCb3gyRC5wYXJzZVVJbnQodmVydGljZXNbaV0uaW5kZXhCKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuR2V0U2VhcmNoRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3dpdGNoICh0aGlzLm1fY291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgIHJldHVybiB0aGlzLm1fdjEudy5HZXROZWdhdGl2ZSgpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGUxMiA9IGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV92Mi53LCB0aGlzLm1fdjEudyk7XG4gICAgICAgICAgICB2YXIgc2duID0gYjJNYXRoLkNyb3NzVlYoZTEyLCB0aGlzLm1fdjEudy5HZXROZWdhdGl2ZSgpKTtcbiAgICAgICAgICAgIGlmIChzZ24gPiAwLjApIHtcbiAgICAgICAgICAgICAgIHJldHVybiBiMk1hdGguQ3Jvc3NGVigxLjAsIGUxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIHJldHVybiBiMk1hdGguQ3Jvc3NWRihlMTIsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XG4gICAgICAgICByZXR1cm4gbmV3IGIyVmVjMigpO1xuICAgICAgfVxuICAgfVxuICAgYjJTaW1wbGV4LnByb3RvdHlwZS5HZXRDbG9zZXN0UG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XG4gICAgICAgICByZXR1cm4gbmV3IGIyVmVjMigpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAgcmV0dXJuIHRoaXMubV92MS53O1xuICAgICAgY2FzZSAyOlxuICAgICAgICAgcmV0dXJuIG5ldyBiMlZlYzIodGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEudy54ICsgdGhpcy5tX3YyLmEgKiB0aGlzLm1fdjIudy54LCB0aGlzLm1fdjEuYSAqIHRoaXMubV92MS53LnkgKyB0aGlzLm1fdjIuYSAqIHRoaXMubV92Mi53LnkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xuICAgICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuR2V0V2l0bmVzc1BvaW50cyA9IGZ1bmN0aW9uIChwQSwgcEIpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5tX2NvdW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAgcEEuU2V0Vih0aGlzLm1fdjEud0EpO1xuICAgICAgICAgcEIuU2V0Vih0aGlzLm1fdjEud0IpO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgICBwQS54ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0EueCArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndBLng7XG4gICAgICAgICBwQS55ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0EueSArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndBLnk7XG4gICAgICAgICBwQi54ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0IueCArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndCLng7XG4gICAgICAgICBwQi55ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0IueSArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndCLnk7XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgIHBCLnggPSBwQS54ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0EueCArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndBLnggKyB0aGlzLm1fdjMuYSAqIHRoaXMubV92My53QS54O1xuICAgICAgICAgcEIueSA9IHBBLnkgPSB0aGlzLm1fdjEuYSAqIHRoaXMubV92MS53QS55ICsgdGhpcy5tX3YyLmEgKiB0aGlzLm1fdjIud0EueSArIHRoaXMubV92My5hICogdGhpcy5tX3YzLndBLnk7XG4gICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgfVxuICAgYjJTaW1wbGV4LnByb3RvdHlwZS5HZXRNZXRyaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XG4gICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgIHJldHVybiBiMk1hdGguU3VidHJhY3RWVih0aGlzLm1fdjEudywgdGhpcy5tX3YyLncpLkxlbmd0aCgpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICAgcmV0dXJuIGIyTWF0aC5Dcm9zc1ZWKGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV92Mi53LCB0aGlzLm1fdjEudyksIGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV92My53LCB0aGlzLm1fdjEudykpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xuICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuU29sdmUyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHcxID0gdGhpcy5tX3YxLnc7XG4gICAgICB2YXIgdzIgPSB0aGlzLm1fdjIudztcbiAgICAgIHZhciBlMTIgPSBiMk1hdGguU3VidHJhY3RWVih3MiwgdzEpO1xuICAgICAgdmFyIGQxMl8yID0gKC0odzEueCAqIGUxMi54ICsgdzEueSAqIGUxMi55KSk7XG4gICAgICBpZiAoZDEyXzIgPD0gMC4wKSB7XG4gICAgICAgICB0aGlzLm1fdjEuYSA9IDEuMDtcbiAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZDEyXzEgPSAodzIueCAqIGUxMi54ICsgdzIueSAqIGUxMi55KTtcbiAgICAgIGlmIChkMTJfMSA8PSAwLjApIHtcbiAgICAgICAgIHRoaXMubV92Mi5hID0gMS4wO1xuICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgIHRoaXMubV92MS5TZXQodGhpcy5tX3YyKTtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbnZfZDEyID0gMS4wIC8gKGQxMl8xICsgZDEyXzIpO1xuICAgICAgdGhpcy5tX3YxLmEgPSBkMTJfMSAqIGludl9kMTI7XG4gICAgICB0aGlzLm1fdjIuYSA9IGQxMl8yICogaW52X2QxMjtcbiAgICAgIHRoaXMubV9jb3VudCA9IDI7XG4gICB9XG4gICBiMlNpbXBsZXgucHJvdG90eXBlLlNvbHZlMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3MSA9IHRoaXMubV92MS53O1xuICAgICAgdmFyIHcyID0gdGhpcy5tX3YyLnc7XG4gICAgICB2YXIgdzMgPSB0aGlzLm1fdjMudztcbiAgICAgIHZhciBlMTIgPSBiMk1hdGguU3VidHJhY3RWVih3MiwgdzEpO1xuICAgICAgdmFyIHcxZTEyID0gYjJNYXRoLkRvdCh3MSwgZTEyKTtcbiAgICAgIHZhciB3MmUxMiA9IGIyTWF0aC5Eb3QodzIsIGUxMik7XG4gICAgICB2YXIgZDEyXzEgPSB3MmUxMjtcbiAgICAgIHZhciBkMTJfMiA9ICgtdzFlMTIpO1xuICAgICAgdmFyIGUxMyA9IGIyTWF0aC5TdWJ0cmFjdFZWKHczLCB3MSk7XG4gICAgICB2YXIgdzFlMTMgPSBiMk1hdGguRG90KHcxLCBlMTMpO1xuICAgICAgdmFyIHczZTEzID0gYjJNYXRoLkRvdCh3MywgZTEzKTtcbiAgICAgIHZhciBkMTNfMSA9IHczZTEzO1xuICAgICAgdmFyIGQxM18yID0gKC13MWUxMyk7XG4gICAgICB2YXIgZTIzID0gYjJNYXRoLlN1YnRyYWN0VlYodzMsIHcyKTtcbiAgICAgIHZhciB3MmUyMyA9IGIyTWF0aC5Eb3QodzIsIGUyMyk7XG4gICAgICB2YXIgdzNlMjMgPSBiMk1hdGguRG90KHczLCBlMjMpO1xuICAgICAgdmFyIGQyM18xID0gdzNlMjM7XG4gICAgICB2YXIgZDIzXzIgPSAoLXcyZTIzKTtcbiAgICAgIHZhciBuMTIzID0gYjJNYXRoLkNyb3NzVlYoZTEyLCBlMTMpO1xuICAgICAgdmFyIGQxMjNfMSA9IG4xMjMgKiBiMk1hdGguQ3Jvc3NWVih3MiwgdzMpO1xuICAgICAgdmFyIGQxMjNfMiA9IG4xMjMgKiBiMk1hdGguQ3Jvc3NWVih3MywgdzEpO1xuICAgICAgdmFyIGQxMjNfMyA9IG4xMjMgKiBiMk1hdGguQ3Jvc3NWVih3MSwgdzIpO1xuICAgICAgaWYgKGQxMl8yIDw9IDAuMCAmJiBkMTNfMiA8PSAwLjApIHtcbiAgICAgICAgIHRoaXMubV92MS5hID0gMS4wO1xuICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkMTJfMSA+IDAuMCAmJiBkMTJfMiA+IDAuMCAmJiBkMTIzXzMgPD0gMC4wKSB7XG4gICAgICAgICB2YXIgaW52X2QxMiA9IDEuMCAvIChkMTJfMSArIGQxMl8yKTtcbiAgICAgICAgIHRoaXMubV92MS5hID0gZDEyXzEgKiBpbnZfZDEyO1xuICAgICAgICAgdGhpcy5tX3YyLmEgPSBkMTJfMiAqIGludl9kMTI7XG4gICAgICAgICB0aGlzLm1fY291bnQgPSAyO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGQxM18xID4gMC4wICYmIGQxM18yID4gMC4wICYmIGQxMjNfMiA8PSAwLjApIHtcbiAgICAgICAgIHZhciBpbnZfZDEzID0gMS4wIC8gKGQxM18xICsgZDEzXzIpO1xuICAgICAgICAgdGhpcy5tX3YxLmEgPSBkMTNfMSAqIGludl9kMTM7XG4gICAgICAgICB0aGlzLm1fdjMuYSA9IGQxM18yICogaW52X2QxMztcbiAgICAgICAgIHRoaXMubV9jb3VudCA9IDI7XG4gICAgICAgICB0aGlzLm1fdjIuU2V0KHRoaXMubV92Myk7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZDEyXzEgPD0gMC4wICYmIGQyM18yIDw9IDAuMCkge1xuICAgICAgICAgdGhpcy5tX3YyLmEgPSAxLjA7XG4gICAgICAgICB0aGlzLm1fY291bnQgPSAxO1xuICAgICAgICAgdGhpcy5tX3YxLlNldCh0aGlzLm1fdjIpO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGQxM18xIDw9IDAuMCAmJiBkMjNfMSA8PSAwLjApIHtcbiAgICAgICAgIHRoaXMubV92My5hID0gMS4wO1xuICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcbiAgICAgICAgIHRoaXMubV92MS5TZXQodGhpcy5tX3YzKTtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkMjNfMSA+IDAuMCAmJiBkMjNfMiA+IDAuMCAmJiBkMTIzXzEgPD0gMC4wKSB7XG4gICAgICAgICB2YXIgaW52X2QyMyA9IDEuMCAvIChkMjNfMSArIGQyM18yKTtcbiAgICAgICAgIHRoaXMubV92Mi5hID0gZDIzXzEgKiBpbnZfZDIzO1xuICAgICAgICAgdGhpcy5tX3YzLmEgPSBkMjNfMiAqIGludl9kMjM7XG4gICAgICAgICB0aGlzLm1fY291bnQgPSAyO1xuICAgICAgICAgdGhpcy5tX3YxLlNldCh0aGlzLm1fdjMpO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGludl9kMTIzID0gMS4wIC8gKGQxMjNfMSArIGQxMjNfMiArIGQxMjNfMyk7XG4gICAgICB0aGlzLm1fdjEuYSA9IGQxMjNfMSAqIGludl9kMTIzO1xuICAgICAgdGhpcy5tX3YyLmEgPSBkMTIzXzIgKiBpbnZfZDEyMztcbiAgICAgIHRoaXMubV92My5hID0gZDEyM18zICogaW52X2QxMjM7XG4gICAgICB0aGlzLm1fY291bnQgPSAzO1xuICAgfVxuICAgYjJTaW1wbGV4Q2FjaGUuYjJTaW1wbGV4Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmluZGV4QSA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigzKTtcbiAgICAgIHRoaXMuaW5kZXhCID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKDMpO1xuICAgfTtcbiAgIGIyU2ltcGxleFZlcnRleC5iMlNpbXBsZXhWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7fTtcbiAgIGIyU2ltcGxleFZlcnRleC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICB0aGlzLndBLlNldFYob3RoZXIud0EpO1xuICAgICAgdGhpcy53Qi5TZXRWKG90aGVyLndCKTtcbiAgICAgIHRoaXMudy5TZXRWKG90aGVyLncpO1xuICAgICAgdGhpcy5hID0gb3RoZXIuYTtcbiAgICAgIHRoaXMuaW5kZXhBID0gb3RoZXIuaW5kZXhBO1xuICAgICAgdGhpcy5pbmRleEIgPSBvdGhlci5pbmRleEI7XG4gICB9XG4gICBiMlRpbWVPZkltcGFjdC5iMlRpbWVPZkltcGFjdCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJUaW1lT2ZJbXBhY3QuVGltZU9mSW1wYWN0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICArK2IyVGltZU9mSW1wYWN0LmIyX3RvaUNhbGxzO1xuICAgICAgdmFyIHByb3h5QSA9IGlucHV0LnByb3h5QTtcbiAgICAgIHZhciBwcm94eUIgPSBpbnB1dC5wcm94eUI7XG4gICAgICB2YXIgc3dlZXBBID0gaW5wdXQuc3dlZXBBO1xuICAgICAgdmFyIHN3ZWVwQiA9IGlucHV0LnN3ZWVwQjtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoc3dlZXBBLnQwID09IHN3ZWVwQi50MCk7XG4gICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KDEuMCAtIHN3ZWVwQS50MCA+IE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgdmFyIHJhZGl1cyA9IHByb3h5QS5tX3JhZGl1cyArIHByb3h5Qi5tX3JhZGl1cztcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBpbnB1dC50b2xlcmFuY2U7XG4gICAgICB2YXIgYWxwaGEgPSAwLjA7XG4gICAgICB2YXIga19tYXhJdGVyYXRpb25zID0gMTAwMDtcbiAgICAgIHZhciBpdGVyID0gMDtcbiAgICAgIHZhciB0YXJnZXQgPSAwLjA7XG4gICAgICBiMlRpbWVPZkltcGFjdC5zX2NhY2hlLmNvdW50ID0gMDtcbiAgICAgIGIyVGltZU9mSW1wYWN0LnNfZGlzdGFuY2VJbnB1dC51c2VSYWRpaSA9IGZhbHNlO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICAgc3dlZXBBLkdldFRyYW5zZm9ybShiMlRpbWVPZkltcGFjdC5zX3hmQSwgYWxwaGEpO1xuICAgICAgICAgc3dlZXBCLkdldFRyYW5zZm9ybShiMlRpbWVPZkltcGFjdC5zX3hmQiwgYWxwaGEpO1xuICAgICAgICAgYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZUlucHV0LnByb3h5QSA9IHByb3h5QTtcbiAgICAgICAgIGIyVGltZU9mSW1wYWN0LnNfZGlzdGFuY2VJbnB1dC5wcm94eUIgPSBwcm94eUI7XG4gICAgICAgICBiMlRpbWVPZkltcGFjdC5zX2Rpc3RhbmNlSW5wdXQudHJhbnNmb3JtQSA9IGIyVGltZU9mSW1wYWN0LnNfeGZBO1xuICAgICAgICAgYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZUlucHV0LnRyYW5zZm9ybUIgPSBiMlRpbWVPZkltcGFjdC5zX3hmQjtcbiAgICAgICAgIGIyRGlzdGFuY2UuRGlzdGFuY2UoYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZU91dHB1dCwgYjJUaW1lT2ZJbXBhY3Quc19jYWNoZSwgYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZUlucHV0KTtcbiAgICAgICAgIGlmIChiMlRpbWVPZkltcGFjdC5zX2Rpc3RhbmNlT3V0cHV0LmRpc3RhbmNlIDw9IDAuMCkge1xuICAgICAgICAgICAgYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIH1cbiAgICAgICAgIGIyVGltZU9mSW1wYWN0LnNfZmNuLkluaXRpYWxpemUoYjJUaW1lT2ZJbXBhY3Quc19jYWNoZSwgcHJveHlBLCBiMlRpbWVPZkltcGFjdC5zX3hmQSwgcHJveHlCLCBiMlRpbWVPZkltcGFjdC5zX3hmQik7XG4gICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IGIyVGltZU9mSW1wYWN0LnNfZmNuLkV2YWx1YXRlKGIyVGltZU9mSW1wYWN0LnNfeGZBLCBiMlRpbWVPZkltcGFjdC5zX3hmQik7XG4gICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSAwLjApIHtcbiAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAoaXRlciA9PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA+IHJhZGl1cykge1xuICAgICAgICAgICAgICAgdGFyZ2V0ID0gYjJNYXRoLk1heChyYWRpdXMgLSB0b2xlcmFuY2UsIDAuNzUgKiByYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICB0YXJnZXQgPSBiMk1hdGguTWF4KHNlcGFyYXRpb24gLSB0b2xlcmFuY2UsIDAuMDIgKiByYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKHNlcGFyYXRpb24gLSB0YXJnZXQgPCAwLjUgKiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIGlmIChpdGVyID09IDApIHtcbiAgICAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciBuZXdBbHBoYSA9IGFscGhhOyB7XG4gICAgICAgICAgICB2YXIgeDEgPSBhbHBoYTtcbiAgICAgICAgICAgIHZhciB4MiA9IDEuMDtcbiAgICAgICAgICAgIHZhciBmMSA9IHNlcGFyYXRpb247XG4gICAgICAgICAgICBzd2VlcEEuR2V0VHJhbnNmb3JtKGIyVGltZU9mSW1wYWN0LnNfeGZBLCB4Mik7XG4gICAgICAgICAgICBzd2VlcEIuR2V0VHJhbnNmb3JtKGIyVGltZU9mSW1wYWN0LnNfeGZCLCB4Mik7XG4gICAgICAgICAgICB2YXIgZjIgPSBiMlRpbWVPZkltcGFjdC5zX2Zjbi5FdmFsdWF0ZShiMlRpbWVPZkltcGFjdC5zX3hmQSwgYjJUaW1lT2ZJbXBhY3Quc194ZkIpO1xuICAgICAgICAgICAgaWYgKGYyID49IHRhcmdldCkge1xuICAgICAgICAgICAgICAgYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb290SXRlckNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgICAgIGlmIChyb290SXRlckNvdW50ICYgMSkge1xuICAgICAgICAgICAgICAgICAgeCA9IHgxICsgKHRhcmdldCAtIGYxKSAqICh4MiAtIHgxKSAvIChmMiAtIGYxKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeCA9IDAuNSAqICh4MSArIHgyKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHN3ZWVwQS5HZXRUcmFuc2Zvcm0oYjJUaW1lT2ZJbXBhY3Quc194ZkEsIHgpO1xuICAgICAgICAgICAgICAgc3dlZXBCLkdldFRyYW5zZm9ybShiMlRpbWVPZkltcGFjdC5zX3hmQiwgeCk7XG4gICAgICAgICAgICAgICB2YXIgZiA9IGIyVGltZU9mSW1wYWN0LnNfZmNuLkV2YWx1YXRlKGIyVGltZU9mSW1wYWN0LnNfeGZBLCBiMlRpbWVPZkltcGFjdC5zX3hmQik7XG4gICAgICAgICAgICAgICBpZiAoYjJNYXRoLkFicyhmIC0gdGFyZ2V0KSA8IDAuMDI1ICogdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IHg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChmID4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICB4MSA9IHg7XG4gICAgICAgICAgICAgICAgICBmMSA9IGY7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHgyID0geDtcbiAgICAgICAgICAgICAgICAgIGYyID0gZjtcbiAgICAgICAgICAgICAgIH0rK3Jvb3RJdGVyQ291bnQ7XG4gICAgICAgICAgICAgICArK2IyVGltZU9mSW1wYWN0LmIyX3RvaVJvb3RJdGVycztcbiAgICAgICAgICAgICAgIGlmIChyb290SXRlckNvdW50ID09IDUwKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIyVGltZU9mSW1wYWN0LmIyX3RvaU1heFJvb3RJdGVycyA9IGIyTWF0aC5NYXgoYjJUaW1lT2ZJbXBhY3QuYjJfdG9pTWF4Um9vdEl0ZXJzLCByb290SXRlckNvdW50KTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChuZXdBbHBoYSA8ICgxLjAgKyAxMDAuMCAqIE51bWJlci5NSU5fVkFMVUUpICogYWxwaGEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgICAgYWxwaGEgPSBuZXdBbHBoYTtcbiAgICAgICAgIGl0ZXIrKztcbiAgICAgICAgICsrYjJUaW1lT2ZJbXBhY3QuYjJfdG9pSXRlcnM7XG4gICAgICAgICBpZiAoaXRlciA9PSBrX21heEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgYjJUaW1lT2ZJbXBhY3QuYjJfdG9pTWF4SXRlcnMgPSBiMk1hdGguTWF4KGIyVGltZU9mSW1wYWN0LmIyX3RvaU1heEl0ZXJzLCBpdGVyKTtcbiAgICAgIHJldHVybiBhbHBoYTtcbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LmIyX3RvaUNhbGxzID0gMDtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdC5iMl90b2lJdGVycyA9IDA7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QuYjJfdG9pTWF4SXRlcnMgPSAwO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LmIyX3RvaVJvb3RJdGVycyA9IDA7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QuYjJfdG9pTWF4Um9vdEl0ZXJzID0gMDtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdC5zX2NhY2hlID0gbmV3IGIyU2ltcGxleENhY2hlKCk7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZUlucHV0ID0gbmV3IGIyRGlzdGFuY2VJbnB1dCgpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LnNfeGZBID0gbmV3IGIyVHJhbnNmb3JtKCk7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3Quc194ZkIgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdC5zX2ZjbiA9IG5ldyBiMlNlcGFyYXRpb25GdW5jdGlvbigpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LnNfZGlzdGFuY2VPdXRwdXQgPSBuZXcgYjJEaXN0YW5jZU91dHB1dCgpO1xuICAgfSk7XG4gICBiMlRPSUlucHV0LmIyVE9JSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnByb3h5QSA9IG5ldyBiMkRpc3RhbmNlUHJveHkoKTtcbiAgICAgIHRoaXMucHJveHlCID0gbmV3IGIyRGlzdGFuY2VQcm94eSgpO1xuICAgICAgdGhpcy5zd2VlcEEgPSBuZXcgYjJTd2VlcCgpO1xuICAgICAgdGhpcy5zd2VlcEIgPSBuZXcgYjJTd2VlcCgpO1xuICAgfTtcbiAgIGIyV29ybGRNYW5pZm9sZC5iMldvcmxkTWFuaWZvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fbm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyV29ybGRNYW5pZm9sZC5wcm90b3R5cGUuYjJXb3JsZE1hbmlmb2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX3BvaW50cyA9IG5ldyBWZWN0b3IoYjJTZXR0aW5ncy5iMl9tYXhNYW5pZm9sZFBvaW50cyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xuICAgICAgICAgdGhpcy5tX3BvaW50c1tpXSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyV29ybGRNYW5pZm9sZC5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgeGZBLCByYWRpdXNBLCB4ZkIsIHJhZGl1c0IpIHtcbiAgICAgIGlmIChyYWRpdXNBID09PSB1bmRlZmluZWQpIHJhZGl1c0EgPSAwO1xuICAgICAgaWYgKHJhZGl1c0IgPT09IHVuZGVmaW5lZCkgcmFkaXVzQiA9IDA7XG4gICAgICBpZiAobWFuaWZvbGQubV9wb2ludENvdW50ID09IDApIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgbm9ybWFsWCA9IDA7XG4gICAgICB2YXIgbm9ybWFsWSA9IDA7XG4gICAgICB2YXIgcGxhbmVQb2ludFggPSAwO1xuICAgICAgdmFyIHBsYW5lUG9pbnRZID0gMDtcbiAgICAgIHZhciBjbGlwUG9pbnRYID0gMDtcbiAgICAgIHZhciBjbGlwUG9pbnRZID0gMDtcbiAgICAgIHN3aXRjaCAobWFuaWZvbGQubV90eXBlKSB7XG4gICAgICBjYXNlIGIyTWFuaWZvbGQuZV9jaXJjbGVzOlxuICAgICAgICAge1xuICAgICAgICAgICAgdE1hdCA9IHhmQS5SO1xuICAgICAgICAgICAgdFZlYyA9IG1hbmlmb2xkLm1fbG9jYWxQb2ludDtcbiAgICAgICAgICAgIHZhciBwb2ludEFYID0geGZBLnBvc2l0aW9uLnggKyB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgICAgdmFyIHBvaW50QVkgPSB4ZkEucG9zaXRpb24ueSArIHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICAgICB0TWF0ID0geGZCLlI7XG4gICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9wb2ludHNbMF0ubV9sb2NhbFBvaW50O1xuICAgICAgICAgICAgdmFyIHBvaW50QlggPSB4ZkIucG9zaXRpb24ueCArIHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICB2YXIgcG9pbnRCWSA9IHhmQi5wb3NpdGlvbi55ICsgdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHZhciBkWCA9IHBvaW50QlggLSBwb2ludEFYO1xuICAgICAgICAgICAgdmFyIGRZID0gcG9pbnRCWSAtIHBvaW50QVk7XG4gICAgICAgICAgICB2YXIgZDIgPSBkWCAqIGRYICsgZFkgKiBkWTtcbiAgICAgICAgICAgIGlmIChkMiA+IE51bWJlci5NSU5fVkFMVUUgKiBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydChkMik7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnggPSBkWCAvIGQ7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgPSBkWSAvIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueCA9IDE7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNBWCA9IHBvaW50QVggKyByYWRpdXNBICogdGhpcy5tX25vcm1hbC54O1xuICAgICAgICAgICAgdmFyIGNBWSA9IHBvaW50QVkgKyByYWRpdXNBICogdGhpcy5tX25vcm1hbC55O1xuICAgICAgICAgICAgdmFyIGNCWCA9IHBvaW50QlggLSByYWRpdXNCICogdGhpcy5tX25vcm1hbC54O1xuICAgICAgICAgICAgdmFyIGNCWSA9IHBvaW50QlkgLSByYWRpdXNCICogdGhpcy5tX25vcm1hbC55O1xuICAgICAgICAgICAgdGhpcy5tX3BvaW50c1swXS54ID0gMC41ICogKGNBWCArIGNCWCk7XG4gICAgICAgICAgICB0aGlzLm1fcG9pbnRzWzBdLnkgPSAwLjUgKiAoY0FZICsgY0JZKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMk1hbmlmb2xkLmVfZmFjZUE6XG4gICAgICAgICB7XG4gICAgICAgICAgICB0TWF0ID0geGZBLlI7XG4gICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsO1xuICAgICAgICAgICAgbm9ybWFsWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICBub3JtYWxZID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHRNYXQgPSB4ZkEuUjtcbiAgICAgICAgICAgIHRWZWMgPSBtYW5pZm9sZC5tX2xvY2FsUG9pbnQ7XG4gICAgICAgICAgICBwbGFuZVBvaW50WCA9IHhmQS5wb3NpdGlvbi54ICsgdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcbiAgICAgICAgICAgIHBsYW5lUG9pbnRZID0geGZBLnBvc2l0aW9uLnkgKyB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ID0gbm9ybWFsWDtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueSA9IG5vcm1hbFk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwO1xuICAgICAgICAgICAgaSA8IG1hbmlmb2xkLm1fcG9pbnRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICB0TWF0ID0geGZCLlI7XG4gICAgICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9wb2ludHNbaV0ubV9sb2NhbFBvaW50O1xuICAgICAgICAgICAgICAgY2xpcFBvaW50WCA9IHhmQi5wb3NpdGlvbi54ICsgdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFkgPSB4ZkIucG9zaXRpb24ueSArIHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICAgICAgICB0aGlzLm1fcG9pbnRzW2ldLnggPSBjbGlwUG9pbnRYICsgMC41ICogKHJhZGl1c0EgLSAoY2xpcFBvaW50WCAtIHBsYW5lUG9pbnRYKSAqIG5vcm1hbFggLSAoY2xpcFBvaW50WSAtIHBsYW5lUG9pbnRZKSAqIG5vcm1hbFkgLSByYWRpdXNCKSAqIG5vcm1hbFg7XG4gICAgICAgICAgICAgICB0aGlzLm1fcG9pbnRzW2ldLnkgPSBjbGlwUG9pbnRZICsgMC41ICogKHJhZGl1c0EgLSAoY2xpcFBvaW50WCAtIHBsYW5lUG9pbnRYKSAqIG5vcm1hbFggLSAoY2xpcFBvaW50WSAtIHBsYW5lUG9pbnRZKSAqIG5vcm1hbFkgLSByYWRpdXNCKSAqIG5vcm1hbFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJNYW5pZm9sZC5lX2ZhY2VCOlxuICAgICAgICAge1xuICAgICAgICAgICAgdE1hdCA9IHhmQi5SO1xuICAgICAgICAgICAgdFZlYyA9IG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbDtcbiAgICAgICAgICAgIG5vcm1hbFggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgICAgbm9ybWFsWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICAgICB0TWF0ID0geGZCLlI7XG4gICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9sb2NhbFBvaW50O1xuICAgICAgICAgICAgcGxhbmVQb2ludFggPSB4ZkIucG9zaXRpb24ueCArIHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICBwbGFuZVBvaW50WSA9IHhmQi5wb3NpdGlvbi55ICsgdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueCA9ICgtbm9ybWFsWCk7XG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgPSAoLW5vcm1hbFkpO1xuICAgICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgICAgIGkgPCBtYW5pZm9sZC5tX3BvaW50Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgdE1hdCA9IHhmQS5SO1xuICAgICAgICAgICAgICAgdFZlYyA9IG1hbmlmb2xkLm1fcG9pbnRzW2ldLm1fbG9jYWxQb2ludDtcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFggPSB4ZkEucG9zaXRpb24ueCArIHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICAgICAgICBjbGlwUG9pbnRZID0geGZBLnBvc2l0aW9uLnkgKyB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xuICAgICAgICAgICAgICAgdGhpcy5tX3BvaW50c1tpXS54ID0gY2xpcFBvaW50WCArIDAuNSAqIChyYWRpdXNCIC0gKGNsaXBQb2ludFggLSBwbGFuZVBvaW50WCkgKiBub3JtYWxYIC0gKGNsaXBQb2ludFkgLSBwbGFuZVBvaW50WSkgKiBub3JtYWxZIC0gcmFkaXVzQSkgKiBub3JtYWxYO1xuICAgICAgICAgICAgICAgdGhpcy5tX3BvaW50c1tpXS55ID0gY2xpcFBvaW50WSArIDAuNSAqIChyYWRpdXNCIC0gKGNsaXBQb2ludFggLSBwbGFuZVBvaW50WCkgKiBub3JtYWxYIC0gKGNsaXBQb2ludFkgLSBwbGFuZVBvaW50WSkgKiBub3JtYWxZIC0gcmFkaXVzQSkgKiBub3JtYWxZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICB9XG4gICBDbGlwVmVydGV4LkNsaXBWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnYgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmlkID0gbmV3IGIyQ29udGFjdElEKCk7XG4gICB9O1xuICAgQ2xpcFZlcnRleC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICB0aGlzLnYuU2V0VihvdGhlci52KTtcbiAgICAgIHRoaXMuaWQuU2V0KG90aGVyLmlkKTtcbiAgIH1cbiAgIEZlYXR1cmVzLkZlYXR1cmVzID0gZnVuY3Rpb24gKCkge307XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVhdHVyZXMucHJvdG90eXBlLCAncmVmZXJlbmNlRWRnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlRWRnZTtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ3JlZmVyZW5jZUVkZ2UnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSAwO1xuICAgICAgICAgdGhpcy5fcmVmZXJlbmNlRWRnZSA9IHZhbHVlO1xuICAgICAgICAgdGhpcy5fbV9pZC5fa2V5ID0gKHRoaXMuX21faWQuX2tleSAmIDB4ZmZmZmZmMDApIHwgKHRoaXMuX3JlZmVyZW5jZUVkZ2UgJiAweDAwMDAwMGZmKTtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ2luY2lkZW50RWRnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5faW5jaWRlbnRFZGdlO1xuICAgICAgfVxuICAgfSk7XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVhdHVyZXMucHJvdG90eXBlLCAnaW5jaWRlbnRFZGdlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gMDtcbiAgICAgICAgIHRoaXMuX2luY2lkZW50RWRnZSA9IHZhbHVlO1xuICAgICAgICAgdGhpcy5fbV9pZC5fa2V5ID0gKHRoaXMuX21faWQuX2tleSAmIDB4ZmZmZjAwZmYpIHwgKCh0aGlzLl9pbmNpZGVudEVkZ2UgPDwgOCkgJiAweDAwMDBmZjAwKTtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ2luY2lkZW50VmVydGV4Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9pbmNpZGVudFZlcnRleDtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ2luY2lkZW50VmVydGV4Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gMDtcbiAgICAgICAgIHRoaXMuX2luY2lkZW50VmVydGV4ID0gdmFsdWU7XG4gICAgICAgICB0aGlzLl9tX2lkLl9rZXkgPSAodGhpcy5fbV9pZC5fa2V5ICYgMHhmZjAwZmZmZikgfCAoKHRoaXMuX2luY2lkZW50VmVydGV4IDw8IDE2KSAmIDB4MDBmZjAwMDApO1xuICAgICAgfVxuICAgfSk7XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVhdHVyZXMucHJvdG90eXBlLCAnZmxpcCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZmxpcDtcbiAgICAgIH1cbiAgIH0pO1xuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ2ZsaXAnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSAwO1xuICAgICAgICAgdGhpcy5fZmxpcCA9IHZhbHVlO1xuICAgICAgICAgdGhpcy5fbV9pZC5fa2V5ID0gKHRoaXMuX21faWQuX2tleSAmIDB4MDBmZmZmZmYpIHwgKCh0aGlzLl9mbGlwIDw8IDI0KSAmIDB4ZmYwMDAwMDApO1xuICAgICAgfVxuICAgfSk7XG59KSgpO1xuKGZ1bmN0aW9uICgpIHtcbiAgIHZhciBiMkNvbG9yID0gQm94MkQuQ29tbW9uLmIyQ29sb3IsXG4gICAgICBiMmludGVybmFsID0gQm94MkQuQ29tbW9uLmIyaW50ZXJuYWwsXG4gICAgICBiMlNldHRpbmdzID0gQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MsXG4gICAgICBiMkNpcmNsZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkNpcmNsZVNoYXBlLFxuICAgICAgYjJFZGdlQ2hhaW5EZWYgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZUNoYWluRGVmLFxuICAgICAgYjJFZGdlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZVNoYXBlLFxuICAgICAgYjJNYXNzRGF0YSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJNYXNzRGF0YSxcbiAgICAgIGIyUG9seWdvblNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlBvbHlnb25TaGFwZSxcbiAgICAgIGIyU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUsXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcbiAgICAgIGIyTWF0MzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDMzLFxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXG4gICAgICBiMlRyYW5zZm9ybSA9IEJveDJELkNvbW1vbi5NYXRoLmIyVHJhbnNmb3JtLFxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzLFxuICAgICAgYjJCb2R5ID0gQm94MkQuRHluYW1pY3MuYjJCb2R5LFxuICAgICAgYjJCb2R5RGVmID0gQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmLFxuICAgICAgYjJDb250YWN0RmlsdGVyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyLFxuICAgICAgYjJDb250YWN0SW1wdWxzZSA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEltcHVsc2UsXG4gICAgICBiMkNvbnRhY3RMaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyLFxuICAgICAgYjJDb250YWN0TWFuYWdlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIsXG4gICAgICBiMkRlYnVnRHJhdyA9IEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LFxuICAgICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gQm94MkQuRHluYW1pY3MuYjJEZXN0cnVjdGlvbkxpc3RlbmVyLFxuICAgICAgYjJGaWx0ZXJEYXRhID0gQm94MkQuRHluYW1pY3MuYjJGaWx0ZXJEYXRhLFxuICAgICAgYjJGaXh0dXJlID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlLFxuICAgICAgYjJGaXh0dXJlRGVmID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlRGVmLFxuICAgICAgYjJJc2xhbmQgPSBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCxcbiAgICAgIGIyVGltZVN0ZXAgPSBCb3gyRC5EeW5hbWljcy5iMlRpbWVTdGVwLFxuICAgICAgYjJXb3JsZCA9IEJveDJELkR5bmFtaWNzLmIyV29ybGQsXG4gICAgICBiMkFBQkIgPSBCb3gyRC5Db2xsaXNpb24uYjJBQUJCLFxuICAgICAgYjJCb3VuZCA9IEJveDJELkNvbGxpc2lvbi5iMkJvdW5kLFxuICAgICAgYjJCb3VuZFZhbHVlcyA9IEJveDJELkNvbGxpc2lvbi5iMkJvdW5kVmFsdWVzLFxuICAgICAgYjJDb2xsaXNpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24sXG4gICAgICBiMkNvbnRhY3RJRCA9IEJveDJELkNvbGxpc2lvbi5iMkNvbnRhY3RJRCxcbiAgICAgIGIyQ29udGFjdFBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdFBvaW50LFxuICAgICAgYjJEaXN0YW5jZSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlLFxuICAgICAgYjJEaXN0YW5jZUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VJbnB1dCxcbiAgICAgIGIyRGlzdGFuY2VPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZU91dHB1dCxcbiAgICAgIGIyRGlzdGFuY2VQcm94eSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlUHJveHksXG4gICAgICBiMkR5bmFtaWNUcmVlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWUsXG4gICAgICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSxcbiAgICAgIGIyRHluYW1pY1RyZWVOb2RlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVOb2RlLFxuICAgICAgYjJEeW5hbWljVHJlZVBhaXIgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZVBhaXIsXG4gICAgICBiMk1hbmlmb2xkID0gQm94MkQuQ29sbGlzaW9uLmIyTWFuaWZvbGQsXG4gICAgICBiMk1hbmlmb2xkUG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZFBvaW50LFxuICAgICAgYjJQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMlBvaW50LFxuICAgICAgYjJSYXlDYXN0SW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0SW5wdXQsXG4gICAgICBiMlJheUNhc3RPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0T3V0cHV0LFxuICAgICAgYjJTZWdtZW50ID0gQm94MkQuQ29sbGlzaW9uLmIyU2VnbWVudCxcbiAgICAgIGIyU2VwYXJhdGlvbkZ1bmN0aW9uID0gQm94MkQuQ29sbGlzaW9uLmIyU2VwYXJhdGlvbkZ1bmN0aW9uLFxuICAgICAgYjJTaW1wbGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleCxcbiAgICAgIGIyU2ltcGxleENhY2hlID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleENhY2hlLFxuICAgICAgYjJTaW1wbGV4VmVydGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleFZlcnRleCxcbiAgICAgIGIyVGltZU9mSW1wYWN0ID0gQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LFxuICAgICAgYjJUT0lJbnB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlRPSUlucHV0LFxuICAgICAgYjJXb3JsZE1hbmlmb2xkID0gQm94MkQuQ29sbGlzaW9uLmIyV29ybGRNYW5pZm9sZCxcbiAgICAgIENsaXBWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uQ2xpcFZlcnRleCxcbiAgICAgIEZlYXR1cmVzID0gQm94MkQuQ29sbGlzaW9uLkZlYXR1cmVzLFxuICAgICAgSUJyb2FkUGhhc2UgPSBCb3gyRC5Db2xsaXNpb24uSUJyb2FkUGhhc2U7XG5cbiAgIEJveDJELmluaGVyaXQoYjJDaXJjbGVTaGFwZSwgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlKTtcbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUucHJvdG90eXBlO1xuICAgYjJDaXJjbGVTaGFwZS5iMkNpcmNsZVNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmIyU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubV9wID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcyA9IG5ldyBiMkNpcmNsZVNoYXBlKCk7XG4gICAgICBzLlNldCh0aGlzKTtcbiAgICAgIHJldHVybiBzO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuU2V0LmNhbGwodGhpcywgb3RoZXIpO1xuICAgICAgaWYgKEJveDJELmlzKG90aGVyLCBiMkNpcmNsZVNoYXBlKSkge1xuICAgICAgICAgdmFyIG90aGVyMiA9IChvdGhlciBpbnN0YW5jZW9mIGIyQ2lyY2xlU2hhcGUgPyBvdGhlciA6IG51bGwpO1xuICAgICAgICAgdGhpcy5tX3AuU2V0VihvdGhlcjIubV9wKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLlRlc3RQb2ludCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIHApIHtcbiAgICAgIHZhciB0TWF0ID0gdHJhbnNmb3JtLlI7XG4gICAgICB2YXIgZFggPSB0cmFuc2Zvcm0ucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9wLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV9wLnkpO1xuICAgICAgdmFyIGRZID0gdHJhbnNmb3JtLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0aGlzLm1fcC54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fcC55KTtcbiAgICAgIGRYID0gcC54IC0gZFg7XG4gICAgICBkWSA9IHAueSAtIGRZO1xuICAgICAgcmV0dXJuIChkWCAqIGRYICsgZFkgKiBkWSkgPD0gdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXM7XG4gICB9XG4gICBiMkNpcmNsZVNoYXBlLnByb3RvdHlwZS5SYXlDYXN0ID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXQsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIHRNYXQgPSB0cmFuc2Zvcm0uUjtcbiAgICAgIHZhciBwb3NpdGlvblggPSB0cmFuc2Zvcm0ucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9wLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV9wLnkpO1xuICAgICAgdmFyIHBvc2l0aW9uWSA9IHRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX3AueCArIHRNYXQuY29sMi55ICogdGhpcy5tX3AueSk7XG4gICAgICB2YXIgc1ggPSBpbnB1dC5wMS54IC0gcG9zaXRpb25YO1xuICAgICAgdmFyIHNZID0gaW5wdXQucDEueSAtIHBvc2l0aW9uWTtcbiAgICAgIHZhciBiID0gKHNYICogc1ggKyBzWSAqIHNZKSAtIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xuICAgICAgdmFyIHJYID0gaW5wdXQucDIueCAtIGlucHV0LnAxLng7XG4gICAgICB2YXIgclkgPSBpbnB1dC5wMi55IC0gaW5wdXQucDEueTtcbiAgICAgIHZhciBjID0gKHNYICogclggKyBzWSAqIHJZKTtcbiAgICAgIHZhciByciA9IChyWCAqIHJYICsgclkgKiByWSk7XG4gICAgICB2YXIgc2lnbWEgPSBjICogYyAtIHJyICogYjtcbiAgICAgIGlmIChzaWdtYSA8IDAuMCB8fCByciA8IE51bWJlci5NSU5fVkFMVUUpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gKC0oYyArIE1hdGguc3FydChzaWdtYSkpKTtcbiAgICAgIGlmICgwLjAgPD0gYSAmJiBhIDw9IGlucHV0Lm1heEZyYWN0aW9uICogcnIpIHtcbiAgICAgICAgIGEgLz0gcnI7XG4gICAgICAgICBvdXRwdXQuZnJhY3Rpb24gPSBhO1xuICAgICAgICAgb3V0cHV0Lm5vcm1hbC54ID0gc1ggKyBhICogclg7XG4gICAgICAgICBvdXRwdXQubm9ybWFsLnkgPSBzWSArIGEgKiByWTtcbiAgICAgICAgIG91dHB1dC5ub3JtYWwuTm9ybWFsaXplKCk7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKGFhYmIsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIHRNYXQgPSB0cmFuc2Zvcm0uUjtcbiAgICAgIHZhciBwWCA9IHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3AueCArIHRNYXQuY29sMi54ICogdGhpcy5tX3AueSk7XG4gICAgICB2YXIgcFkgPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV9wLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubV9wLnkpO1xuICAgICAgYWFiYi5sb3dlckJvdW5kLlNldChwWCAtIHRoaXMubV9yYWRpdXMsIHBZIC0gdGhpcy5tX3JhZGl1cyk7XG4gICAgICBhYWJiLnVwcGVyQm91bmQuU2V0KHBYICsgdGhpcy5tX3JhZGl1cywgcFkgKyB0aGlzLm1fcmFkaXVzKTtcbiAgIH1cbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVNYXNzID0gZnVuY3Rpb24gKG1hc3NEYXRhLCBkZW5zaXR5KSB7XG4gICAgICBpZiAoZGVuc2l0eSA9PT0gdW5kZWZpbmVkKSBkZW5zaXR5ID0gMDtcbiAgICAgIG1hc3NEYXRhLm1hc3MgPSBkZW5zaXR5ICogYjJTZXR0aW5ncy5iMl9waSAqIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xuICAgICAgbWFzc0RhdGEuY2VudGVyLlNldFYodGhpcy5tX3ApO1xuICAgICAgbWFzc0RhdGEuSSA9IG1hc3NEYXRhLm1hc3MgKiAoMC41ICogdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXMgKyAodGhpcy5tX3AueCAqIHRoaXMubV9wLnggKyB0aGlzLm1fcC55ICogdGhpcy5tX3AueSkpO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuQ29tcHV0ZVN1Ym1lcmdlZEFyZWEgPSBmdW5jdGlvbiAobm9ybWFsLCBvZmZzZXQsIHhmLCBjKSB7XG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIG9mZnNldCA9IDA7XG4gICAgICB2YXIgcCA9IGIyTWF0aC5NdWxYKHhmLCB0aGlzLm1fcCk7XG4gICAgICB2YXIgbCA9ICgtKGIyTWF0aC5Eb3Qobm9ybWFsLCBwKSAtIG9mZnNldCkpO1xuICAgICAgaWYgKGwgPCAoLXRoaXMubV9yYWRpdXMpICsgTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAobCA+IHRoaXMubV9yYWRpdXMpIHtcbiAgICAgICAgIGMuU2V0VihwKTtcbiAgICAgICAgIHJldHVybiBNYXRoLlBJICogdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXM7XG4gICAgICB9XG4gICAgICB2YXIgcjIgPSB0aGlzLm1fcmFkaXVzICogdGhpcy5tX3JhZGl1cztcbiAgICAgIHZhciBsMiA9IGwgKiBsO1xuICAgICAgdmFyIGFyZWEgPSByMiAqIChNYXRoLmFzaW4obCAvIHRoaXMubV9yYWRpdXMpICsgTWF0aC5QSSAvIDIpICsgbCAqIE1hdGguc3FydChyMiAtIGwyKTtcbiAgICAgIHZhciBjb20gPSAoLTIgLyAzICogTWF0aC5wb3cocjIgLSBsMiwgMS41KSAvIGFyZWEpO1xuICAgICAgYy54ID0gcC54ICsgbm9ybWFsLnggKiBjb207XG4gICAgICBjLnkgPSBwLnkgKyBub3JtYWwueSAqIGNvbTtcbiAgICAgIHJldHVybiBhcmVhO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuR2V0TG9jYWxQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fcDtcbiAgIH1cbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLlNldExvY2FsUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgIHRoaXMubV9wLlNldFYocG9zaXRpb24pO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuR2V0UmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9yYWRpdXM7XG4gICB9XG4gICBiMkNpcmNsZVNoYXBlLnByb3RvdHlwZS5TZXRSYWRpdXMgPSBmdW5jdGlvbiAocmFkaXVzKSB7XG4gICAgICBpZiAocmFkaXVzID09PSB1bmRlZmluZWQpIHJhZGl1cyA9IDA7XG4gICAgICB0aGlzLm1fcmFkaXVzID0gcmFkaXVzO1xuICAgfVxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuYjJDaXJjbGVTaGFwZSA9IGZ1bmN0aW9uIChyYWRpdXMpIHtcbiAgICAgIGlmIChyYWRpdXMgPT09IHVuZGVmaW5lZCkgcmFkaXVzID0gMDtcbiAgICAgIHRoaXMuX19zdXBlci5iMlNoYXBlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1fdHlwZSA9IGIyU2hhcGUuZV9jaXJjbGVTaGFwZTtcbiAgICAgIHRoaXMubV9yYWRpdXMgPSByYWRpdXM7XG4gICB9XG4gICBiMkVkZ2VDaGFpbkRlZi5iMkVkZ2VDaGFpbkRlZiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJFZGdlQ2hhaW5EZWYucHJvdG90eXBlLmIyRWRnZUNoYWluRGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XG4gICAgICB0aGlzLmlzQUxvb3AgPSB0cnVlO1xuICAgICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMkVkZ2VTaGFwZSwgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlKTtcbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLnByb3RvdHlwZTtcbiAgIGIyRWRnZVNoYXBlLmIyRWRnZVNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmIyU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuc19zdXBwb3J0VmVjID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3YxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3YyID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2NvcmVWMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9jb3JlVjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2RpcmVjdGlvbiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2Nvcm5lckRpcjIgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLlRlc3RQb2ludCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5SYXlDYXN0ID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXQsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgclggPSBpbnB1dC5wMi54IC0gaW5wdXQucDEueDtcbiAgICAgIHZhciByWSA9IGlucHV0LnAyLnkgLSBpbnB1dC5wMS55O1xuICAgICAgdE1hdCA9IHRyYW5zZm9ybS5SO1xuICAgICAgdmFyIHYxWCA9IHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3YxLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV92MS55KTtcbiAgICAgIHZhciB2MVkgPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV92MS54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fdjEueSk7XG4gICAgICB2YXIgblggPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV92Mi54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fdjIueSkgLSB2MVk7XG4gICAgICB2YXIgblkgPSAoLSh0cmFuc2Zvcm0ucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV92Mi54ICsgdE1hdC5jb2wyLnggKiB0aGlzLm1fdjIueSkgLSB2MVgpKTtcbiAgICAgIHZhciBrX3Nsb3AgPSAxMDAuMCAqIE51bWJlci5NSU5fVkFMVUU7XG4gICAgICB2YXIgZGVub20gPSAoLShyWCAqIG5YICsgclkgKiBuWSkpO1xuICAgICAgaWYgKGRlbm9tID4ga19zbG9wKSB7XG4gICAgICAgICB2YXIgYlggPSBpbnB1dC5wMS54IC0gdjFYO1xuICAgICAgICAgdmFyIGJZID0gaW5wdXQucDEueSAtIHYxWTtcbiAgICAgICAgIHZhciBhID0gKGJYICogblggKyBiWSAqIG5ZKTtcbiAgICAgICAgIGlmICgwLjAgPD0gYSAmJiBhIDw9IGlucHV0Lm1heEZyYWN0aW9uICogZGVub20pIHtcbiAgICAgICAgICAgIHZhciBtdTIgPSAoLXJYICogYlkpICsgclkgKiBiWDtcbiAgICAgICAgICAgIGlmICgoLWtfc2xvcCAqIGRlbm9tKSA8PSBtdTIgJiYgbXUyIDw9IGRlbm9tICogKDEuMCArIGtfc2xvcCkpIHtcbiAgICAgICAgICAgICAgIGEgLz0gZGVub207XG4gICAgICAgICAgICAgICBvdXRwdXQuZnJhY3Rpb24gPSBhO1xuICAgICAgICAgICAgICAgdmFyIG5MZW4gPSBNYXRoLnNxcnQoblggKiBuWCArIG5ZICogblkpO1xuICAgICAgICAgICAgICAgb3V0cHV0Lm5vcm1hbC54ID0gblggLyBuTGVuO1xuICAgICAgICAgICAgICAgb3V0cHV0Lm5vcm1hbC55ID0gblkgLyBuTGVuO1xuICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuQ29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAoYWFiYiwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgdE1hdCA9IHRyYW5zZm9ybS5SO1xuICAgICAgdmFyIHYxWCA9IHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3YxLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV92MS55KTtcbiAgICAgIHZhciB2MVkgPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV92MS54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fdjEueSk7XG4gICAgICB2YXIgdjJYID0gdHJhbnNmb3JtLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0aGlzLm1fdjIueCArIHRNYXQuY29sMi54ICogdGhpcy5tX3YyLnkpO1xuICAgICAgdmFyIHYyWSA9IHRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX3YyLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubV92Mi55KTtcbiAgICAgIGlmICh2MVggPCB2MlgpIHtcbiAgICAgICAgIGFhYmIubG93ZXJCb3VuZC54ID0gdjFYO1xuICAgICAgICAgYWFiYi51cHBlckJvdW5kLnggPSB2Mlg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIGFhYmIubG93ZXJCb3VuZC54ID0gdjJYO1xuICAgICAgICAgYWFiYi51cHBlckJvdW5kLnggPSB2MVg7XG4gICAgICB9XG4gICAgICBpZiAodjFZIDwgdjJZKSB7XG4gICAgICAgICBhYWJiLmxvd2VyQm91bmQueSA9IHYxWTtcbiAgICAgICAgIGFhYmIudXBwZXJCb3VuZC55ID0gdjJZO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBhYWJiLmxvd2VyQm91bmQueSA9IHYyWTtcbiAgICAgICAgIGFhYmIudXBwZXJCb3VuZC55ID0gdjFZO1xuICAgICAgfVxuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVNYXNzID0gZnVuY3Rpb24gKG1hc3NEYXRhLCBkZW5zaXR5KSB7XG4gICAgICBpZiAoZGVuc2l0eSA9PT0gdW5kZWZpbmVkKSBkZW5zaXR5ID0gMDtcbiAgICAgIG1hc3NEYXRhLm1hc3MgPSAwO1xuICAgICAgbWFzc0RhdGEuY2VudGVyLlNldFYodGhpcy5tX3YxKTtcbiAgICAgIG1hc3NEYXRhLkkgPSAwO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVTdWJtZXJnZWRBcmVhID0gZnVuY3Rpb24gKG5vcm1hbCwgb2Zmc2V0LCB4ZiwgYykge1xuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xuICAgICAgdmFyIHYwID0gbmV3IGIyVmVjMihub3JtYWwueCAqIG9mZnNldCwgbm9ybWFsLnkgKiBvZmZzZXQpO1xuICAgICAgdmFyIHYxID0gYjJNYXRoLk11bFgoeGYsIHRoaXMubV92MSk7XG4gICAgICB2YXIgdjIgPSBiMk1hdGguTXVsWCh4ZiwgdGhpcy5tX3YyKTtcbiAgICAgIHZhciBkMSA9IGIyTWF0aC5Eb3Qobm9ybWFsLCB2MSkgLSBvZmZzZXQ7XG4gICAgICB2YXIgZDIgPSBiMk1hdGguRG90KG5vcm1hbCwgdjIpIC0gb2Zmc2V0O1xuICAgICAgaWYgKGQxID4gMCkge1xuICAgICAgICAgaWYgKGQyID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYxLnggPSAoLWQyIC8gKGQxIC0gZDIpICogdjEueCkgKyBkMSAvIChkMSAtIGQyKSAqIHYyLng7XG4gICAgICAgICAgICB2MS55ID0gKC1kMiAvIChkMSAtIGQyKSAqIHYxLnkpICsgZDEgLyAoZDEgLSBkMikgKiB2Mi55O1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBpZiAoZDIgPiAwKSB7XG4gICAgICAgICAgICB2Mi54ID0gKC1kMiAvIChkMSAtIGQyKSAqIHYxLngpICsgZDEgLyAoZDEgLSBkMikgKiB2Mi54O1xuICAgICAgICAgICAgdjIueSA9ICgtZDIgLyAoZDEgLSBkMikgKiB2MS55KSArIGQxIC8gKGQxIC0gZDIpICogdjIueTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge31cbiAgICAgIH1cbiAgICAgIGMueCA9ICh2MC54ICsgdjEueCArIHYyLngpIC8gMztcbiAgICAgIGMueSA9ICh2MC55ICsgdjEueSArIHYyLnkpIC8gMztcbiAgICAgIHJldHVybiAwLjUgKiAoKHYxLnggLSB2MC54KSAqICh2Mi55IC0gdjAueSkgLSAodjEueSAtIHYwLnkpICogKHYyLnggLSB2MC54KSk7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9sZW5ndGg7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0VmVydGV4MSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdjE7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0VmVydGV4MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdjI7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0Q29yZVZlcnRleDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2NvcmVWMTtcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5HZXRDb3JlVmVydGV4MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY29yZVYyO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldE5vcm1hbFZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbm9ybWFsO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldERpcmVjdGlvblZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZGlyZWN0aW9uO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldENvcm5lcjFWZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2Nvcm5lckRpcjE7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0Q29ybmVyMlZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY29ybmVyRGlyMjtcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5Db3JuZXIxSXNDb252ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2Nvcm5lckNvbnZleDE7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuQ29ybmVyMklzQ29udmV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9jb3JuZXJDb252ZXgyO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldEZpcnN0VmVydGV4ID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICB2YXIgdE1hdCA9IHhmLlI7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMih4Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX2NvcmVWMS54ICsgdE1hdC5jb2wyLnggKiB0aGlzLm1fY29yZVYxLnkpLCB4Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX2NvcmVWMS54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fY29yZVYxLnkpKTtcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5HZXROZXh0RWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbmV4dEVkZ2U7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0UHJldkVkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3ByZXZFZGdlO1xuICAgfVxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLlN1cHBvcnQgPSBmdW5jdGlvbiAoeGYsIGRYLCBkWSkge1xuICAgICAgaWYgKGRYID09PSB1bmRlZmluZWQpIGRYID0gMDtcbiAgICAgIGlmIChkWSA9PT0gdW5kZWZpbmVkKSBkWSA9IDA7XG4gICAgICB2YXIgdE1hdCA9IHhmLlI7XG4gICAgICB2YXIgdjFYID0geGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9jb3JlVjEueCArIHRNYXQuY29sMi54ICogdGhpcy5tX2NvcmVWMS55KTtcbiAgICAgIHZhciB2MVkgPSB4Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX2NvcmVWMS54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fY29yZVYxLnkpO1xuICAgICAgdmFyIHYyWCA9IHhmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0aGlzLm1fY29yZVYyLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV9jb3JlVjIueSk7XG4gICAgICB2YXIgdjJZID0geGYucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV9jb3JlVjIueCArIHRNYXQuY29sMi55ICogdGhpcy5tX2NvcmVWMi55KTtcbiAgICAgIGlmICgodjFYICogZFggKyB2MVkgKiBkWSkgPiAodjJYICogZFggKyB2MlkgKiBkWSkpIHtcbiAgICAgICAgIHRoaXMuc19zdXBwb3J0VmVjLnggPSB2MVg7XG4gICAgICAgICB0aGlzLnNfc3VwcG9ydFZlYy55ID0gdjFZO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLnNfc3VwcG9ydFZlYy54ID0gdjJYO1xuICAgICAgICAgdGhpcy5zX3N1cHBvcnRWZWMueSA9IHYyWTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNfc3VwcG9ydFZlYztcbiAgIH1cbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5iMkVkZ2VTaGFwZSA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMlNoYXBlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1fdHlwZSA9IGIyU2hhcGUuZV9lZGdlU2hhcGU7XG4gICAgICB0aGlzLm1fcHJldkVkZ2UgPSBudWxsO1xuICAgICAgdGhpcy5tX25leHRFZGdlID0gbnVsbDtcbiAgICAgIHRoaXMubV92MSA9IHYxO1xuICAgICAgdGhpcy5tX3YyID0gdjI7XG4gICAgICB0aGlzLm1fZGlyZWN0aW9uLlNldCh0aGlzLm1fdjIueCAtIHRoaXMubV92MS54LCB0aGlzLm1fdjIueSAtIHRoaXMubV92MS55KTtcbiAgICAgIHRoaXMubV9sZW5ndGggPSB0aGlzLm1fZGlyZWN0aW9uLk5vcm1hbGl6ZSgpO1xuICAgICAgdGhpcy5tX25vcm1hbC5TZXQodGhpcy5tX2RpcmVjdGlvbi55LCAoLXRoaXMubV9kaXJlY3Rpb24ueCkpO1xuICAgICAgdGhpcy5tX2NvcmVWMS5TZXQoKC1iMlNldHRpbmdzLmIyX3RvaVNsb3AgKiAodGhpcy5tX25vcm1hbC54IC0gdGhpcy5tX2RpcmVjdGlvbi54KSkgKyB0aGlzLm1fdjEueCwgKC1iMlNldHRpbmdzLmIyX3RvaVNsb3AgKiAodGhpcy5tX25vcm1hbC55IC0gdGhpcy5tX2RpcmVjdGlvbi55KSkgKyB0aGlzLm1fdjEueSk7XG4gICAgICB0aGlzLm1fY29yZVYyLlNldCgoLWIyU2V0dGluZ3MuYjJfdG9pU2xvcCAqICh0aGlzLm1fbm9ybWFsLnggKyB0aGlzLm1fZGlyZWN0aW9uLngpKSArIHRoaXMubV92Mi54LCAoLWIyU2V0dGluZ3MuYjJfdG9pU2xvcCAqICh0aGlzLm1fbm9ybWFsLnkgKyB0aGlzLm1fZGlyZWN0aW9uLnkpKSArIHRoaXMubV92Mi55KTtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIxID0gdGhpcy5tX25vcm1hbDtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIyLlNldCgoLXRoaXMubV9ub3JtYWwueCksICgtdGhpcy5tX25vcm1hbC55KSk7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuU2V0UHJldkVkZ2UgPSBmdW5jdGlvbiAoZWRnZSwgY29yZSwgY29ybmVyRGlyLCBjb252ZXgpIHtcbiAgICAgIHRoaXMubV9wcmV2RWRnZSA9IGVkZ2U7XG4gICAgICB0aGlzLm1fY29yZVYxID0gY29yZTtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIxID0gY29ybmVyRGlyO1xuICAgICAgdGhpcy5tX2Nvcm5lckNvbnZleDEgPSBjb252ZXg7XG4gICB9XG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuU2V0TmV4dEVkZ2UgPSBmdW5jdGlvbiAoZWRnZSwgY29yZSwgY29ybmVyRGlyLCBjb252ZXgpIHtcbiAgICAgIHRoaXMubV9uZXh0RWRnZSA9IGVkZ2U7XG4gICAgICB0aGlzLm1fY29yZVYyID0gY29yZTtcbiAgICAgIHRoaXMubV9jb3JuZXJEaXIyID0gY29ybmVyRGlyO1xuICAgICAgdGhpcy5tX2Nvcm5lckNvbnZleDIgPSBjb252ZXg7XG4gICB9XG4gICBiMk1hc3NEYXRhLmIyTWFzc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1hc3MgPSAwLjA7XG4gICAgICB0aGlzLmNlbnRlciA9IG5ldyBiMlZlYzIoMCwgMCk7XG4gICAgICB0aGlzLkkgPSAwLjA7XG4gICB9O1xuICAgQm94MkQuaW5oZXJpdChiMlBvbHlnb25TaGFwZSwgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlKTtcbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLnByb3RvdHlwZTtcbiAgIGIyUG9seWdvblNoYXBlLmIyUG9seWdvblNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmIyU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XG4gICAgICBzLlNldCh0aGlzKTtcbiAgICAgIHJldHVybiBzO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgdGhpcy5fX3N1cGVyLlNldC5jYWxsKHRoaXMsIG90aGVyKTtcbiAgICAgIGlmIChCb3gyRC5pcyhvdGhlciwgYjJQb2x5Z29uU2hhcGUpKSB7XG4gICAgICAgICB2YXIgb3RoZXIyID0gKG90aGVyIGluc3RhbmNlb2YgYjJQb2x5Z29uU2hhcGUgPyBvdGhlciA6IG51bGwpO1xuICAgICAgICAgdGhpcy5tX2NlbnRyb2lkLlNldFYob3RoZXIyLm1fY2VudHJvaWQpO1xuICAgICAgICAgdGhpcy5tX3ZlcnRleENvdW50ID0gb3RoZXIyLm1fdmVydGV4Q291bnQ7XG4gICAgICAgICB0aGlzLlJlc2VydmUodGhpcy5tX3ZlcnRleENvdW50KTtcbiAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1tpXS5TZXRWKG90aGVyMi5tX3ZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWxzW2ldLlNldFYob3RoZXIyLm1fbm9ybWFsc1tpXSk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0QXNBcnJheSA9IGZ1bmN0aW9uICh2ZXJ0aWNlcywgdmVydGV4Q291bnQpIHtcbiAgICAgIGlmICh2ZXJ0ZXhDb3VudCA9PT0gdW5kZWZpbmVkKSB2ZXJ0ZXhDb3VudCA9IDA7XG4gICAgICB2YXIgdiA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgIHRWZWM7XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICB0VmVjID0gdmVydGljZXNbaV07XG4gICAgICAgICB2LnB1c2godFZlYyk7XG4gICAgICB9XG4gICAgICB0aGlzLlNldEFzVmVjdG9yKHYsIHZlcnRleENvdW50KTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLkFzQXJyYXkgPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50KSB7XG4gICAgICBpZiAodmVydGV4Q291bnQgPT09IHVuZGVmaW5lZCkgdmVydGV4Q291bnQgPSAwO1xuICAgICAgdmFyIHBvbHlnb25TaGFwZSA9IG5ldyBiMlBvbHlnb25TaGFwZSgpO1xuICAgICAgcG9seWdvblNoYXBlLlNldEFzQXJyYXkodmVydGljZXMsIHZlcnRleENvdW50KTtcbiAgICAgIHJldHVybiBwb2x5Z29uU2hhcGU7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0QXNWZWN0b3IgPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50KSB7XG4gICAgICBpZiAodmVydGV4Q291bnQgPT09IHVuZGVmaW5lZCkgdmVydGV4Q291bnQgPSAwO1xuICAgICAgaWYgKHZlcnRleENvdW50ID09IDApIHZlcnRleENvdW50ID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydCgyIDw9IHZlcnRleENvdW50KTtcbiAgICAgIHRoaXMubV92ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xuICAgICAgdGhpcy5SZXNlcnZlKHZlcnRleENvdW50KTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyBpKyspIHtcbiAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1tpXS5TZXRWKHZlcnRpY2VzW2ldKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcbiAgICAgICAgIHZhciBpMSA9IHBhcnNlSW50KGkpO1xuICAgICAgICAgdmFyIGkyID0gcGFyc2VJbnQoaSArIDEgPCB0aGlzLm1fdmVydGV4Q291bnQgPyBpICsgMSA6IDApO1xuICAgICAgICAgdmFyIGVkZ2UgPSBiMk1hdGguU3VidHJhY3RWVih0aGlzLm1fdmVydGljZXNbaTJdLCB0aGlzLm1fdmVydGljZXNbaTFdKTtcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZWRnZS5MZW5ndGhTcXVhcmVkKCkgPiBOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgICAgIHRoaXMubV9ub3JtYWxzW2ldLlNldFYoYjJNYXRoLkNyb3NzVkYoZWRnZSwgMS4wKSk7XG4gICAgICAgICB0aGlzLm1fbm9ybWFsc1tpXS5Ob3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9jZW50cm9pZCA9IGIyUG9seWdvblNoYXBlLkNvbXB1dGVDZW50cm9pZCh0aGlzLm1fdmVydGljZXMsIHRoaXMubV92ZXJ0ZXhDb3VudCk7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5Bc1ZlY3RvciA9IGZ1bmN0aW9uICh2ZXJ0aWNlcywgdmVydGV4Q291bnQpIHtcbiAgICAgIGlmICh2ZXJ0ZXhDb3VudCA9PT0gdW5kZWZpbmVkKSB2ZXJ0ZXhDb3VudCA9IDA7XG4gICAgICB2YXIgcG9seWdvblNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XG4gICAgICBwb2x5Z29uU2hhcGUuU2V0QXNWZWN0b3IodmVydGljZXMsIHZlcnRleENvdW50KTtcbiAgICAgIHJldHVybiBwb2x5Z29uU2hhcGU7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0QXNCb3ggPSBmdW5jdGlvbiAoaHgsIGh5KSB7XG4gICAgICBpZiAoaHggPT09IHVuZGVmaW5lZCkgaHggPSAwO1xuICAgICAgaWYgKGh5ID09PSB1bmRlZmluZWQpIGh5ID0gMDtcbiAgICAgIHRoaXMubV92ZXJ0ZXhDb3VudCA9IDQ7XG4gICAgICB0aGlzLlJlc2VydmUoNCk7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMF0uU2V0KCgtaHgpLCAoLWh5KSk7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMV0uU2V0KGh4LCAoLWh5KSk7XG4gICAgICB0aGlzLm1fdmVydGljZXNbMl0uU2V0KGh4LCBoeSk7XG4gICAgICB0aGlzLm1fdmVydGljZXNbM10uU2V0KCgtaHgpLCBoeSk7XG4gICAgICB0aGlzLm1fbm9ybWFsc1swXS5TZXQoMC4wLCAoLTEuMCkpO1xuICAgICAgdGhpcy5tX25vcm1hbHNbMV0uU2V0KDEuMCwgMC4wKTtcbiAgICAgIHRoaXMubV9ub3JtYWxzWzJdLlNldCgwLjAsIDEuMCk7XG4gICAgICB0aGlzLm1fbm9ybWFsc1szXS5TZXQoKC0xLjApLCAwLjApO1xuICAgICAgdGhpcy5tX2NlbnRyb2lkLlNldFplcm8oKTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLkFzQm94ID0gZnVuY3Rpb24gKGh4LCBoeSkge1xuICAgICAgaWYgKGh4ID09PSB1bmRlZmluZWQpIGh4ID0gMDtcbiAgICAgIGlmIChoeSA9PT0gdW5kZWZpbmVkKSBoeSA9IDA7XG4gICAgICB2YXIgcG9seWdvblNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XG4gICAgICBwb2x5Z29uU2hhcGUuU2V0QXNCb3goaHgsIGh5KTtcbiAgICAgIHJldHVybiBwb2x5Z29uU2hhcGU7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0QXNPcmllbnRlZEJveCA9IGZ1bmN0aW9uIChoeCwgaHksIGNlbnRlciwgYW5nbGUpIHtcbiAgICAgIGlmIChoeCA9PT0gdW5kZWZpbmVkKSBoeCA9IDA7XG4gICAgICBpZiAoaHkgPT09IHVuZGVmaW5lZCkgaHkgPSAwO1xuICAgICAgaWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSBjZW50ZXIgPSBudWxsO1xuICAgICAgaWYgKGFuZ2xlID09PSB1bmRlZmluZWQpIGFuZ2xlID0gMC4wO1xuICAgICAgdGhpcy5tX3ZlcnRleENvdW50ID0gNDtcbiAgICAgIHRoaXMuUmVzZXJ2ZSg0KTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1swXS5TZXQoKC1oeCksICgtaHkpKTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1sxXS5TZXQoaHgsICgtaHkpKTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1syXS5TZXQoaHgsIGh5KTtcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1szXS5TZXQoKC1oeCksIGh5KTtcbiAgICAgIHRoaXMubV9ub3JtYWxzWzBdLlNldCgwLjAsICgtMS4wKSk7XG4gICAgICB0aGlzLm1fbm9ybWFsc1sxXS5TZXQoMS4wLCAwLjApO1xuICAgICAgdGhpcy5tX25vcm1hbHNbMl0uU2V0KDAuMCwgMS4wKTtcbiAgICAgIHRoaXMubV9ub3JtYWxzWzNdLlNldCgoLTEuMCksIDAuMCk7XG4gICAgICB0aGlzLm1fY2VudHJvaWQgPSBjZW50ZXI7XG4gICAgICB2YXIgeGYgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcbiAgICAgIHhmLnBvc2l0aW9uID0gY2VudGVyO1xuICAgICAgeGYuUi5TZXQoYW5nbGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW2ldID0gYjJNYXRoLk11bFgoeGYsIHRoaXMubV92ZXJ0aWNlc1tpXSk7XG4gICAgICAgICB0aGlzLm1fbm9ybWFsc1tpXSA9IGIyTWF0aC5NdWxNVih4Zi5SLCB0aGlzLm1fbm9ybWFsc1tpXSk7XG4gICAgICB9XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5Bc09yaWVudGVkQm94ID0gZnVuY3Rpb24gKGh4LCBoeSwgY2VudGVyLCBhbmdsZSkge1xuICAgICAgaWYgKGh4ID09PSB1bmRlZmluZWQpIGh4ID0gMDtcbiAgICAgIGlmIChoeSA9PT0gdW5kZWZpbmVkKSBoeSA9IDA7XG4gICAgICBpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIGNlbnRlciA9IG51bGw7XG4gICAgICBpZiAoYW5nbGUgPT09IHVuZGVmaW5lZCkgYW5nbGUgPSAwLjA7XG4gICAgICB2YXIgcG9seWdvblNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XG4gICAgICBwb2x5Z29uU2hhcGUuU2V0QXNPcmllbnRlZEJveChoeCwgaHksIGNlbnRlciwgYW5nbGUpO1xuICAgICAgcmV0dXJuIHBvbHlnb25TaGFwZTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5TZXRBc0VkZ2UgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICB0aGlzLm1fdmVydGV4Q291bnQgPSAyO1xuICAgICAgdGhpcy5SZXNlcnZlKDIpO1xuICAgICAgdGhpcy5tX3ZlcnRpY2VzWzBdLlNldFYodjEpO1xuICAgICAgdGhpcy5tX3ZlcnRpY2VzWzFdLlNldFYodjIpO1xuICAgICAgdGhpcy5tX2NlbnRyb2lkLnggPSAwLjUgKiAodjEueCArIHYyLngpO1xuICAgICAgdGhpcy5tX2NlbnRyb2lkLnkgPSAwLjUgKiAodjEueSArIHYyLnkpO1xuICAgICAgdGhpcy5tX25vcm1hbHNbMF0gPSBiMk1hdGguQ3Jvc3NWRihiMk1hdGguU3VidHJhY3RWVih2MiwgdjEpLCAxLjApO1xuICAgICAgdGhpcy5tX25vcm1hbHNbMF0uTm9ybWFsaXplKCk7XG4gICAgICB0aGlzLm1fbm9ybWFsc1sxXS54ID0gKC10aGlzLm1fbm9ybWFsc1swXS54KTtcbiAgICAgIHRoaXMubV9ub3JtYWxzWzFdLnkgPSAoLXRoaXMubV9ub3JtYWxzWzBdLnkpO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUuQXNFZGdlID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgdmFyIHBvbHlnb25TaGFwZSA9IG5ldyBiMlBvbHlnb25TaGFwZSgpO1xuICAgICAgcG9seWdvblNoYXBlLlNldEFzRWRnZSh2MSwgdjIpO1xuICAgICAgcmV0dXJuIHBvbHlnb25TaGFwZTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5UZXN0UG9pbnQgPSBmdW5jdGlvbiAoeGYsIHApIHtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdmFyIHRNYXQgPSB4Zi5SO1xuICAgICAgdmFyIHRYID0gcC54IC0geGYucG9zaXRpb24ueDtcbiAgICAgIHZhciB0WSA9IHAueSAtIHhmLnBvc2l0aW9uLnk7XG4gICAgICB2YXIgcExvY2FsWCA9ICh0WCAqIHRNYXQuY29sMS54ICsgdFkgKiB0TWF0LmNvbDEueSk7XG4gICAgICB2YXIgcExvY2FsWSA9ICh0WCAqIHRNYXQuY29sMi54ICsgdFkgKiB0TWF0LmNvbDIueSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV92ZXJ0ZXhDb3VudDsgKytpKSB7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX3ZlcnRpY2VzW2ldO1xuICAgICAgICAgdFggPSBwTG9jYWxYIC0gdFZlYy54O1xuICAgICAgICAgdFkgPSBwTG9jYWxZIC0gdFZlYy55O1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9ub3JtYWxzW2ldO1xuICAgICAgICAgdmFyIGRvdCA9ICh0VmVjLnggKiB0WCArIHRWZWMueSAqIHRZKTtcbiAgICAgICAgIGlmIChkb3QgPiAwLjApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgbG93ZXIgPSAwLjA7XG4gICAgICB2YXIgdXBwZXIgPSBpbnB1dC5tYXhGcmFjdGlvbjtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgdFkgPSAwO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFZlYztcbiAgICAgIHRYID0gaW5wdXQucDEueCAtIHRyYW5zZm9ybS5wb3NpdGlvbi54O1xuICAgICAgdFkgPSBpbnB1dC5wMS55IC0gdHJhbnNmb3JtLnBvc2l0aW9uLnk7XG4gICAgICB0TWF0ID0gdHJhbnNmb3JtLlI7XG4gICAgICB2YXIgcDFYID0gKHRYICogdE1hdC5jb2wxLnggKyB0WSAqIHRNYXQuY29sMS55KTtcbiAgICAgIHZhciBwMVkgPSAodFggKiB0TWF0LmNvbDIueCArIHRZICogdE1hdC5jb2wyLnkpO1xuICAgICAgdFggPSBpbnB1dC5wMi54IC0gdHJhbnNmb3JtLnBvc2l0aW9uLng7XG4gICAgICB0WSA9IGlucHV0LnAyLnkgLSB0cmFuc2Zvcm0ucG9zaXRpb24ueTtcbiAgICAgIHRNYXQgPSB0cmFuc2Zvcm0uUjtcbiAgICAgIHZhciBwMlggPSAodFggKiB0TWF0LmNvbDEueCArIHRZICogdE1hdC5jb2wxLnkpO1xuICAgICAgdmFyIHAyWSA9ICh0WCAqIHRNYXQuY29sMi54ICsgdFkgKiB0TWF0LmNvbDIueSk7XG4gICAgICB2YXIgZFggPSBwMlggLSBwMVg7XG4gICAgICB2YXIgZFkgPSBwMlkgLSBwMVk7XG4gICAgICB2YXIgaW5kZXggPSBwYXJzZUludCgoLTEpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcbiAgICAgICAgIHRWZWMgPSB0aGlzLm1fdmVydGljZXNbaV07XG4gICAgICAgICB0WCA9IHRWZWMueCAtIHAxWDtcbiAgICAgICAgIHRZID0gdFZlYy55IC0gcDFZO1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9ub3JtYWxzW2ldO1xuICAgICAgICAgdmFyIG51bWVyYXRvciA9ICh0VmVjLnggKiB0WCArIHRWZWMueSAqIHRZKTtcbiAgICAgICAgIHZhciBkZW5vbWluYXRvciA9ICh0VmVjLnggKiBkWCArIHRWZWMueSAqIGRZKTtcbiAgICAgICAgIGlmIChkZW5vbWluYXRvciA9PSAwLjApIHtcbiAgICAgICAgICAgIGlmIChudW1lcmF0b3IgPCAwLjApIHtcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRlbm9taW5hdG9yIDwgMC4wICYmIG51bWVyYXRvciA8IGxvd2VyICogZGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgICAgIGxvd2VyID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZW5vbWluYXRvciA+IDAuMCAmJiBudW1lcmF0b3IgPCB1cHBlciAqIGRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICAgICB1cHBlciA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKHVwcGVyIDwgbG93ZXIgLSBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgb3V0cHV0LmZyYWN0aW9uID0gbG93ZXI7XG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtLlI7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX25vcm1hbHNbaW5kZXhdO1xuICAgICAgICAgb3V0cHV0Lm5vcm1hbC54ID0gKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgb3V0cHV0Lm5vcm1hbC55ID0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuQ29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAoYWFiYiwgeGYpIHtcbiAgICAgIHZhciB0TWF0ID0geGYuUjtcbiAgICAgIHZhciB0VmVjID0gdGhpcy5tX3ZlcnRpY2VzWzBdO1xuICAgICAgdmFyIGxvd2VyWCA9IHhmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB2YXIgbG93ZXJZID0geGYucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgIHZhciB1cHBlclggPSBsb3dlclg7XG4gICAgICB2YXIgdXBwZXJZID0gbG93ZXJZO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgdFZlYyA9IHRoaXMubV92ZXJ0aWNlc1tpXTtcbiAgICAgICAgIHZhciB2WCA9IHhmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICAgICB2YXIgdlkgPSB4Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgbG93ZXJYID0gbG93ZXJYIDwgdlggPyBsb3dlclggOiB2WDtcbiAgICAgICAgIGxvd2VyWSA9IGxvd2VyWSA8IHZZID8gbG93ZXJZIDogdlk7XG4gICAgICAgICB1cHBlclggPSB1cHBlclggPiB2WCA/IHVwcGVyWCA6IHZYO1xuICAgICAgICAgdXBwZXJZID0gdXBwZXJZID4gdlkgPyB1cHBlclkgOiB2WTtcbiAgICAgIH1cbiAgICAgIGFhYmIubG93ZXJCb3VuZC54ID0gbG93ZXJYIC0gdGhpcy5tX3JhZGl1cztcbiAgICAgIGFhYmIubG93ZXJCb3VuZC55ID0gbG93ZXJZIC0gdGhpcy5tX3JhZGl1cztcbiAgICAgIGFhYmIudXBwZXJCb3VuZC54ID0gdXBwZXJYICsgdGhpcy5tX3JhZGl1cztcbiAgICAgIGFhYmIudXBwZXJCb3VuZC55ID0gdXBwZXJZICsgdGhpcy5tX3JhZGl1cztcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5Db21wdXRlTWFzcyA9IGZ1bmN0aW9uIChtYXNzRGF0YSwgZGVuc2l0eSkge1xuICAgICAgaWYgKGRlbnNpdHkgPT09IHVuZGVmaW5lZCkgZGVuc2l0eSA9IDA7XG4gICAgICBpZiAodGhpcy5tX3ZlcnRleENvdW50ID09IDIpIHtcbiAgICAgICAgIG1hc3NEYXRhLmNlbnRlci54ID0gMC41ICogKHRoaXMubV92ZXJ0aWNlc1swXS54ICsgdGhpcy5tX3ZlcnRpY2VzWzFdLngpO1xuICAgICAgICAgbWFzc0RhdGEuY2VudGVyLnkgPSAwLjUgKiAodGhpcy5tX3ZlcnRpY2VzWzBdLnkgKyB0aGlzLm1fdmVydGljZXNbMV0ueSk7XG4gICAgICAgICBtYXNzRGF0YS5tYXNzID0gMC4wO1xuICAgICAgICAgbWFzc0RhdGEuSSA9IDAuMDtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjZW50ZXJYID0gMC4wO1xuICAgICAgdmFyIGNlbnRlclkgPSAwLjA7XG4gICAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICAgIHZhciBJID0gMC4wO1xuICAgICAgdmFyIHAxWCA9IDAuMDtcbiAgICAgIHZhciBwMVkgPSAwLjA7XG4gICAgICB2YXIga19pbnYzID0gMS4wIC8gMy4wO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgdmFyIHAyID0gdGhpcy5tX3ZlcnRpY2VzW2ldO1xuICAgICAgICAgdmFyIHAzID0gaSArIDEgPCB0aGlzLm1fdmVydGV4Q291bnQgPyB0aGlzLm1fdmVydGljZXNbcGFyc2VJbnQoaSArIDEpXSA6IHRoaXMubV92ZXJ0aWNlc1swXTtcbiAgICAgICAgIHZhciBlMVggPSBwMi54IC0gcDFYO1xuICAgICAgICAgdmFyIGUxWSA9IHAyLnkgLSBwMVk7XG4gICAgICAgICB2YXIgZTJYID0gcDMueCAtIHAxWDtcbiAgICAgICAgIHZhciBlMlkgPSBwMy55IC0gcDFZO1xuICAgICAgICAgdmFyIEQgPSBlMVggKiBlMlkgLSBlMVkgKiBlMlg7XG4gICAgICAgICB2YXIgdHJpYW5nbGVBcmVhID0gMC41ICogRDthcmVhICs9IHRyaWFuZ2xlQXJlYTtcbiAgICAgICAgIGNlbnRlclggKz0gdHJpYW5nbGVBcmVhICoga19pbnYzICogKHAxWCArIHAyLnggKyBwMy54KTtcbiAgICAgICAgIGNlbnRlclkgKz0gdHJpYW5nbGVBcmVhICoga19pbnYzICogKHAxWSArIHAyLnkgKyBwMy55KTtcbiAgICAgICAgIHZhciBweCA9IHAxWDtcbiAgICAgICAgIHZhciBweSA9IHAxWTtcbiAgICAgICAgIHZhciBleDEgPSBlMVg7XG4gICAgICAgICB2YXIgZXkxID0gZTFZO1xuICAgICAgICAgdmFyIGV4MiA9IGUyWDtcbiAgICAgICAgIHZhciBleTIgPSBlMlk7XG4gICAgICAgICB2YXIgaW50eDIgPSBrX2ludjMgKiAoMC4yNSAqIChleDEgKiBleDEgKyBleDIgKiBleDEgKyBleDIgKiBleDIpICsgKHB4ICogZXgxICsgcHggKiBleDIpKSArIDAuNSAqIHB4ICogcHg7XG4gICAgICAgICB2YXIgaW50eTIgPSBrX2ludjMgKiAoMC4yNSAqIChleTEgKiBleTEgKyBleTIgKiBleTEgKyBleTIgKiBleTIpICsgKHB5ICogZXkxICsgcHkgKiBleTIpKSArIDAuNSAqIHB5ICogcHk7SSArPSBEICogKGludHgyICsgaW50eTIpO1xuICAgICAgfVxuICAgICAgbWFzc0RhdGEubWFzcyA9IGRlbnNpdHkgKiBhcmVhO1xuICAgICAgY2VudGVyWCAqPSAxLjAgLyBhcmVhO1xuICAgICAgY2VudGVyWSAqPSAxLjAgLyBhcmVhO1xuICAgICAgbWFzc0RhdGEuY2VudGVyLlNldChjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIG1hc3NEYXRhLkkgPSBkZW5zaXR5ICogSTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5Db21wdXRlU3VibWVyZ2VkQXJlYSA9IGZ1bmN0aW9uIChub3JtYWwsIG9mZnNldCwgeGYsIGMpIHtcbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBub3JtYWxMID0gYjJNYXRoLk11bFRNVih4Zi5SLCBub3JtYWwpO1xuICAgICAgdmFyIG9mZnNldEwgPSBvZmZzZXQgLSBiMk1hdGguRG90KG5vcm1hbCwgeGYucG9zaXRpb24pO1xuICAgICAgdmFyIGRlcHRocyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigpO1xuICAgICAgdmFyIGRpdmVDb3VudCA9IDA7XG4gICAgICB2YXIgaW50b0luZGV4ID0gcGFyc2VJbnQoKC0xKSk7XG4gICAgICB2YXIgb3V0b0luZGV4ID0gcGFyc2VJbnQoKC0xKSk7XG4gICAgICB2YXIgbGFzdFN1Ym1lcmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yIChpID0gMDtcbiAgICAgIGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xuICAgICAgICAgZGVwdGhzW2ldID0gYjJNYXRoLkRvdChub3JtYWxMLCB0aGlzLm1fdmVydGljZXNbaV0pIC0gb2Zmc2V0TDtcbiAgICAgICAgIHZhciBpc1N1Ym1lcmdlZCA9IGRlcHRoc1tpXSA8ICgtTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChpc1N1Ym1lcmdlZCkge1xuICAgICAgICAgICAgICAgaWYgKCFsYXN0U3VibWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgICBpbnRvSW5kZXggPSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgIGRpdmVDb3VudCsrO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICBpZiAobGFzdFN1Ym1lcmdlZCkge1xuICAgICAgICAgICAgICAgICAgb3V0b0luZGV4ID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICBkaXZlQ291bnQrKztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGxhc3RTdWJtZXJnZWQgPSBpc1N1Ym1lcmdlZDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGl2ZUNvdW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgICBpZiAobGFzdFN1Ym1lcmdlZCkge1xuICAgICAgICAgICAgdmFyIG1kID0gbmV3IGIyTWFzc0RhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuQ29tcHV0ZU1hc3MobWQsIDEpO1xuICAgICAgICAgICAgYy5TZXRWKGIyTWF0aC5NdWxYKHhmLCBtZC5jZW50ZXIpKTtcbiAgICAgICAgICAgIHJldHVybiBtZC5tYXNzO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAgaWYgKGludG9JbmRleCA9PSAoLTEpKSB7XG4gICAgICAgICAgICBpbnRvSW5kZXggPSB0aGlzLm1fdmVydGV4Q291bnQgLSAxO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRvSW5kZXggPSB0aGlzLm1fdmVydGV4Q291bnQgLSAxO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgaW50b0luZGV4MiA9IHBhcnNlSW50KChpbnRvSW5kZXggKyAxKSAlIHRoaXMubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgb3V0b0luZGV4MiA9IHBhcnNlSW50KChvdXRvSW5kZXggKyAxKSAlIHRoaXMubV92ZXJ0ZXhDb3VudCk7XG4gICAgICB2YXIgaW50b0xhbWRkYSA9ICgwIC0gZGVwdGhzW2ludG9JbmRleF0pIC8gKGRlcHRoc1tpbnRvSW5kZXgyXSAtIGRlcHRoc1tpbnRvSW5kZXhdKTtcbiAgICAgIHZhciBvdXRvTGFtZGRhID0gKDAgLSBkZXB0aHNbb3V0b0luZGV4XSkgLyAoZGVwdGhzW291dG9JbmRleDJdIC0gZGVwdGhzW291dG9JbmRleF0pO1xuICAgICAgdmFyIGludG9WZWMgPSBuZXcgYjJWZWMyKHRoaXMubV92ZXJ0aWNlc1tpbnRvSW5kZXhdLnggKiAoMSAtIGludG9MYW1kZGEpICsgdGhpcy5tX3ZlcnRpY2VzW2ludG9JbmRleDJdLnggKiBpbnRvTGFtZGRhLCB0aGlzLm1fdmVydGljZXNbaW50b0luZGV4XS55ICogKDEgLSBpbnRvTGFtZGRhKSArIHRoaXMubV92ZXJ0aWNlc1tpbnRvSW5kZXgyXS55ICogaW50b0xhbWRkYSk7XG4gICAgICB2YXIgb3V0b1ZlYyA9IG5ldyBiMlZlYzIodGhpcy5tX3ZlcnRpY2VzW291dG9JbmRleF0ueCAqICgxIC0gb3V0b0xhbWRkYSkgKyB0aGlzLm1fdmVydGljZXNbb3V0b0luZGV4Ml0ueCAqIG91dG9MYW1kZGEsIHRoaXMubV92ZXJ0aWNlc1tvdXRvSW5kZXhdLnkgKiAoMSAtIG91dG9MYW1kZGEpICsgdGhpcy5tX3ZlcnRpY2VzW291dG9JbmRleDJdLnkgKiBvdXRvTGFtZGRhKTtcbiAgICAgIHZhciBhcmVhID0gMDtcbiAgICAgIHZhciBjZW50ZXIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB2YXIgcDIgPSB0aGlzLm1fdmVydGljZXNbaW50b0luZGV4Ml07XG4gICAgICB2YXIgcDM7XG4gICAgICBpID0gaW50b0luZGV4MjtcbiAgICAgIHdoaWxlIChpICE9IG91dG9JbmRleDIpIHtcbiAgICAgICAgIGkgPSAoaSArIDEpICUgdGhpcy5tX3ZlcnRleENvdW50O1xuICAgICAgICAgaWYgKGkgPT0gb3V0b0luZGV4MikgcDMgPSBvdXRvVmVjO1xuICAgICAgICAgZWxzZSBwMyA9IHRoaXMubV92ZXJ0aWNlc1tpXTtcbiAgICAgICAgIHZhciB0cmlhbmdsZUFyZWEgPSAwLjUgKiAoKHAyLnggLSBpbnRvVmVjLngpICogKHAzLnkgLSBpbnRvVmVjLnkpIC0gKHAyLnkgLSBpbnRvVmVjLnkpICogKHAzLnggLSBpbnRvVmVjLngpKTtcbiAgICAgICAgIGFyZWEgKz0gdHJpYW5nbGVBcmVhO1xuICAgICAgICAgY2VudGVyLnggKz0gdHJpYW5nbGVBcmVhICogKGludG9WZWMueCArIHAyLnggKyBwMy54KSAvIDM7XG4gICAgICAgICBjZW50ZXIueSArPSB0cmlhbmdsZUFyZWEgKiAoaW50b1ZlYy55ICsgcDIueSArIHAzLnkpIC8gMztcbiAgICAgICAgIHAyID0gcDM7XG4gICAgICB9XG4gICAgICBjZW50ZXIuTXVsdGlwbHkoMSAvIGFyZWEpO1xuICAgICAgYy5TZXRWKGIyTWF0aC5NdWxYKHhmLCBjZW50ZXIpKTtcbiAgICAgIHJldHVybiBhcmVhO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLkdldFZlcnRleENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV92ZXJ0ZXhDb3VudDtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5HZXRWZXJ0aWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXM7XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuR2V0Tm9ybWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbm9ybWFscztcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5HZXRTdXBwb3J0ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBiZXN0SW5kZXggPSAwO1xuICAgICAgdmFyIGJlc3RWYWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1swXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzWzBdLnkgKiBkLnk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubV92ZXJ0ZXhDb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1fdmVydGljZXNbaV0ueCAqIGQueCArIHRoaXMubV92ZXJ0aWNlc1tpXS55ICogZC55O1xuICAgICAgICAgaWYgKHZhbHVlID4gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmVzdEluZGV4O1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLkdldFN1cHBvcnRWZXJ0ZXggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGJlc3RJbmRleCA9IDA7XG4gICAgICB2YXIgYmVzdFZhbHVlID0gdGhpcy5tX3ZlcnRpY2VzWzBdLnggKiBkLnggKyB0aGlzLm1fdmVydGljZXNbMF0ueSAqIGQueTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcbiAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1tpXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzW2ldLnkgKiBkLnk7XG4gICAgICAgICBpZiAodmFsdWUgPiBiZXN0VmFsdWUpIHtcbiAgICAgICAgICAgIGJlc3RJbmRleCA9IGk7XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbYmVzdEluZGV4XTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5WYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5iMlBvbHlnb25TaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMlNoYXBlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1fdHlwZSA9IGIyU2hhcGUuZV9wb2x5Z29uU2hhcGU7XG4gICAgICB0aGlzLm1fY2VudHJvaWQgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fdmVydGljZXMgPSBuZXcgVmVjdG9yKCk7XG4gICAgICB0aGlzLm1fbm9ybWFscyA9IG5ldyBWZWN0b3IoKTtcbiAgIH1cbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5SZXNlcnZlID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgY291bnQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IHBhcnNlSW50KHRoaXMubV92ZXJ0aWNlcy5sZW5ndGgpOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW2ldID0gbmV3IGIyVmVjMigpO1xuICAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0gPSBuZXcgYjJWZWMyKCk7XG4gICAgICB9XG4gICB9XG4gICBiMlBvbHlnb25TaGFwZS5Db21wdXRlQ2VudHJvaWQgPSBmdW5jdGlvbiAodnMsIGNvdW50KSB7XG4gICAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgY291bnQgPSAwO1xuICAgICAgdmFyIGMgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICAgIHZhciBwMVggPSAwLjA7XG4gICAgICB2YXIgcDFZID0gMC4wO1xuICAgICAgdmFyIGludjMgPSAxLjAgLyAzLjA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgIHZhciBwMiA9IHZzW2ldO1xuICAgICAgICAgdmFyIHAzID0gaSArIDEgPCBjb3VudCA/IHZzW3BhcnNlSW50KGkgKyAxKV0gOiB2c1swXTtcbiAgICAgICAgIHZhciBlMVggPSBwMi54IC0gcDFYO1xuICAgICAgICAgdmFyIGUxWSA9IHAyLnkgLSBwMVk7XG4gICAgICAgICB2YXIgZTJYID0gcDMueCAtIHAxWDtcbiAgICAgICAgIHZhciBlMlkgPSBwMy55IC0gcDFZO1xuICAgICAgICAgdmFyIEQgPSAoZTFYICogZTJZIC0gZTFZICogZTJYKTtcbiAgICAgICAgIHZhciB0cmlhbmdsZUFyZWEgPSAwLjUgKiBEO2FyZWEgKz0gdHJpYW5nbGVBcmVhO1xuICAgICAgICAgYy54ICs9IHRyaWFuZ2xlQXJlYSAqIGludjMgKiAocDFYICsgcDIueCArIHAzLngpO1xuICAgICAgICAgYy55ICs9IHRyaWFuZ2xlQXJlYSAqIGludjMgKiAocDFZICsgcDIueSArIHAzLnkpO1xuICAgICAgfVxuICAgICAgYy54ICo9IDEuMCAvIGFyZWE7XG4gICAgICBjLnkgKj0gMS4wIC8gYXJlYTtcbiAgICAgIHJldHVybiBjO1xuICAgfVxuICAgYjJQb2x5Z29uU2hhcGUuQ29tcHV0ZU9CQiA9IGZ1bmN0aW9uIChvYmIsIHZzLCBjb3VudCkge1xuICAgICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIGNvdW50ID0gMDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBwID0gbmV3IFZlY3Rvcihjb3VudCArIDEpO1xuICAgICAgZm9yIChpID0gMDtcbiAgICAgIGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICBwW2ldID0gdnNbaV07XG4gICAgICB9XG4gICAgICBwW2NvdW50XSA9IHBbMF07XG4gICAgICB2YXIgbWluQXJlYSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBmb3IgKGkgPSAxO1xuICAgICAgaSA8PSBjb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgcm9vdCA9IHBbcGFyc2VJbnQoaSAtIDEpXTtcbiAgICAgICAgIHZhciB1eFggPSBwW2ldLnggLSByb290Lng7XG4gICAgICAgICB2YXIgdXhZID0gcFtpXS55IC0gcm9vdC55O1xuICAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydCh1eFggKiB1eFggKyB1eFkgKiB1eFkpO1xuICAgICAgICAgdXhYIC89IGxlbmd0aDtcbiAgICAgICAgIHV4WSAvPSBsZW5ndGg7XG4gICAgICAgICB2YXIgdXlYID0gKC11eFkpO1xuICAgICAgICAgdmFyIHV5WSA9IHV4WDtcbiAgICAgICAgIHZhciBsb3dlclggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgdmFyIGxvd2VyWSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICB2YXIgdXBwZXJYID0gKC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgIHZhciB1cHBlclkgPSAoLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgZFggPSBwW2pdLnggLSByb290Lng7XG4gICAgICAgICAgICB2YXIgZFkgPSBwW2pdLnkgLSByb290Lnk7XG4gICAgICAgICAgICB2YXIgclggPSAodXhYICogZFggKyB1eFkgKiBkWSk7XG4gICAgICAgICAgICB2YXIgclkgPSAodXlYICogZFggKyB1eVkgKiBkWSk7XG4gICAgICAgICAgICBpZiAoclggPCBsb3dlclgpIGxvd2VyWCA9IHJYO1xuICAgICAgICAgICAgaWYgKHJZIDwgbG93ZXJZKSBsb3dlclkgPSByWTtcbiAgICAgICAgICAgIGlmIChyWCA+IHVwcGVyWCkgdXBwZXJYID0gclg7XG4gICAgICAgICAgICBpZiAoclkgPiB1cHBlclkpIHVwcGVyWSA9IHJZO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIGFyZWEgPSAodXBwZXJYIC0gbG93ZXJYKSAqICh1cHBlclkgLSBsb3dlclkpO1xuICAgICAgICAgaWYgKGFyZWEgPCAwLjk1ICogbWluQXJlYSkge1xuICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICBvYmIuUi5jb2wxLnggPSB1eFg7XG4gICAgICAgICAgICBvYmIuUi5jb2wxLnkgPSB1eFk7XG4gICAgICAgICAgICBvYmIuUi5jb2wyLnggPSB1eVg7XG4gICAgICAgICAgICBvYmIuUi5jb2wyLnkgPSB1eVk7XG4gICAgICAgICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIChsb3dlclggKyB1cHBlclgpO1xuICAgICAgICAgICAgdmFyIGNlbnRlclkgPSAwLjUgKiAobG93ZXJZICsgdXBwZXJZKTtcbiAgICAgICAgICAgIHZhciB0TWF0ID0gb2JiLlI7XG4gICAgICAgICAgICBvYmIuY2VudGVyLnggPSByb290LnggKyAodE1hdC5jb2wxLnggKiBjZW50ZXJYICsgdE1hdC5jb2wyLnggKiBjZW50ZXJZKTtcbiAgICAgICAgICAgIG9iYi5jZW50ZXIueSA9IHJvb3QueSArICh0TWF0LmNvbDEueSAqIGNlbnRlclggKyB0TWF0LmNvbDIueSAqIGNlbnRlclkpO1xuICAgICAgICAgICAgb2JiLmV4dGVudHMueCA9IDAuNSAqICh1cHBlclggLSBsb3dlclgpO1xuICAgICAgICAgICAgb2JiLmV4dGVudHMueSA9IDAuNSAqICh1cHBlclkgLSBsb3dlclkpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyUG9seWdvblNoYXBlLnNfbWF0ID0gbmV3IGIyTWF0MjIoKTtcbiAgIH0pO1xuICAgYjJTaGFwZS5iMlNoYXBlID0gZnVuY3Rpb24gKCkge307XG4gICBiMlNoYXBlLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICB9XG4gICBiMlNoYXBlLnByb3RvdHlwZS5TZXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgIHRoaXMubV9yYWRpdXMgPSBvdGhlci5tX3JhZGl1cztcbiAgIH1cbiAgIGIyU2hhcGUucHJvdG90eXBlLkdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3R5cGU7XG4gICB9XG4gICBiMlNoYXBlLnByb3RvdHlwZS5UZXN0UG9pbnQgPSBmdW5jdGlvbiAoeGYsIHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIGIyU2hhcGUucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCwgdHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBiMlNoYXBlLnByb3RvdHlwZS5Db21wdXRlQUFCQiA9IGZ1bmN0aW9uIChhYWJiLCB4Zikge31cbiAgIGIyU2hhcGUucHJvdG90eXBlLkNvbXB1dGVNYXNzID0gZnVuY3Rpb24gKG1hc3NEYXRhLCBkZW5zaXR5KSB7XG4gICAgICBpZiAoZGVuc2l0eSA9PT0gdW5kZWZpbmVkKSBkZW5zaXR5ID0gMDtcbiAgIH1cbiAgIGIyU2hhcGUucHJvdG90eXBlLkNvbXB1dGVTdWJtZXJnZWRBcmVhID0gZnVuY3Rpb24gKG5vcm1hbCwgb2Zmc2V0LCB4ZiwgYykge1xuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xuICAgICAgcmV0dXJuIDA7XG4gICB9XG4gICBiMlNoYXBlLlRlc3RPdmVybGFwID0gZnVuY3Rpb24gKHNoYXBlMSwgdHJhbnNmb3JtMSwgc2hhcGUyLCB0cmFuc2Zvcm0yKSB7XG4gICAgICB2YXIgaW5wdXQgPSBuZXcgYjJEaXN0YW5jZUlucHV0KCk7XG4gICAgICBpbnB1dC5wcm94eUEgPSBuZXcgYjJEaXN0YW5jZVByb3h5KCk7XG4gICAgICBpbnB1dC5wcm94eUEuU2V0KHNoYXBlMSk7XG4gICAgICBpbnB1dC5wcm94eUIgPSBuZXcgYjJEaXN0YW5jZVByb3h5KCk7XG4gICAgICBpbnB1dC5wcm94eUIuU2V0KHNoYXBlMik7XG4gICAgICBpbnB1dC50cmFuc2Zvcm1BID0gdHJhbnNmb3JtMTtcbiAgICAgIGlucHV0LnRyYW5zZm9ybUIgPSB0cmFuc2Zvcm0yO1xuICAgICAgaW5wdXQudXNlUmFkaWkgPSB0cnVlO1xuICAgICAgdmFyIHNpbXBsZXhDYWNoZSA9IG5ldyBiMlNpbXBsZXhDYWNoZSgpO1xuICAgICAgc2ltcGxleENhY2hlLmNvdW50ID0gMDtcbiAgICAgIHZhciBvdXRwdXQgPSBuZXcgYjJEaXN0YW5jZU91dHB1dCgpO1xuICAgICAgYjJEaXN0YW5jZS5EaXN0YW5jZShvdXRwdXQsIHNpbXBsZXhDYWNoZSwgaW5wdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dC5kaXN0YW5jZSA8IDEwLjAgKiBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgfVxuICAgYjJTaGFwZS5wcm90b3R5cGUuYjJTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV90eXBlID0gYjJTaGFwZS5lX3Vua25vd25TaGFwZTtcbiAgICAgIHRoaXMubV9yYWRpdXMgPSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX3Vua25vd25TaGFwZSA9IHBhcnNlSW50KCgtMSkpO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmVfY2lyY2xlU2hhcGUgPSAwO1xuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmVfcG9seWdvblNoYXBlID0gMTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX2VkZ2VTaGFwZSA9IDI7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUuZV9zaGFwZVR5cGVDb3VudCA9IDM7XG4gICAgICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUuZV9oaXRDb2xsaWRlID0gMTtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX21pc3NDb2xsaWRlID0gMDtcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX3N0YXJ0c0luc2lkZUNvbGxpZGUgPSBwYXJzZUludCgoLTEpKTtcbiAgIH0pO1xufSkoKTtcbihmdW5jdGlvbiAoKSB7XG4gICB2YXIgYjJDb2xvciA9IEJveDJELkNvbW1vbi5iMkNvbG9yLFxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxuICAgICAgYjJNYXQyMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MjIsXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcbiAgICAgIGIyU3dlZXAgPSBCb3gyRC5Db21tb24uTWF0aC5iMlN3ZWVwLFxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcbiAgICAgIGIyVmVjMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMztcblxuICAgYjJDb2xvci5iMkNvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fciA9IDA7XG4gICAgICB0aGlzLl9nID0gMDtcbiAgICAgIHRoaXMuX2IgPSAwO1xuICAgfTtcbiAgIGIyQ29sb3IucHJvdG90eXBlLmIyQ29sb3IgPSBmdW5jdGlvbiAocnIsIGdnLCBiYikge1xuICAgICAgaWYgKHJyID09PSB1bmRlZmluZWQpIHJyID0gMDtcbiAgICAgIGlmIChnZyA9PT0gdW5kZWZpbmVkKSBnZyA9IDA7XG4gICAgICBpZiAoYmIgPT09IHVuZGVmaW5lZCkgYmIgPSAwO1xuICAgICAgdGhpcy5fciA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAocnIsIDAuMCwgMS4wKSk7XG4gICAgICB0aGlzLl9nID0gQm94MkQucGFyc2VVSW50KDI1NSAqIGIyTWF0aC5DbGFtcChnZywgMC4wLCAxLjApKTtcbiAgICAgIHRoaXMuX2IgPSBCb3gyRC5wYXJzZVVJbnQoMjU1ICogYjJNYXRoLkNsYW1wKGJiLCAwLjAsIDEuMCkpO1xuICAgfVxuICAgYjJDb2xvci5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKHJyLCBnZywgYmIpIHtcbiAgICAgIGlmIChyciA9PT0gdW5kZWZpbmVkKSByciA9IDA7XG4gICAgICBpZiAoZ2cgPT09IHVuZGVmaW5lZCkgZ2cgPSAwO1xuICAgICAgaWYgKGJiID09PSB1bmRlZmluZWQpIGJiID0gMDtcbiAgICAgIHRoaXMuX3IgPSBCb3gyRC5wYXJzZVVJbnQoMjU1ICogYjJNYXRoLkNsYW1wKHJyLCAwLjAsIDEuMCkpO1xuICAgICAgdGhpcy5fZyA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAoZ2csIDAuMCwgMS4wKSk7XG4gICAgICB0aGlzLl9iID0gQm94MkQucGFyc2VVSW50KDI1NSAqIGIyTWF0aC5DbGFtcChiYiwgMC4wLCAxLjApKTtcbiAgIH1cbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbG9yLnByb3RvdHlwZSwgJ3InLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHJyKSB7XG4gICAgICAgICBpZiAocnIgPT09IHVuZGVmaW5lZCkgcnIgPSAwO1xuICAgICAgICAgdGhpcy5fciA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAocnIsIDAuMCwgMS4wKSk7XG4gICAgICB9XG4gICB9KTtcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbG9yLnByb3RvdHlwZSwgJ2cnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGdnKSB7XG4gICAgICAgICBpZiAoZ2cgPT09IHVuZGVmaW5lZCkgZ2cgPSAwO1xuICAgICAgICAgdGhpcy5fZyA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAoZ2csIDAuMCwgMS4wKSk7XG4gICAgICB9XG4gICB9KTtcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbG9yLnByb3RvdHlwZSwgJ2InLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGJiKSB7XG4gICAgICAgICBpZiAoYmIgPT09IHVuZGVmaW5lZCkgYmIgPSAwO1xuICAgICAgICAgdGhpcy5fYiA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAoYmIsIDAuMCwgMS4wKSk7XG4gICAgICB9XG4gICB9KTtcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbG9yLnByb3RvdHlwZSwgJ2NvbG9yJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIHJldHVybiAodGhpcy5fciA8PCAxNikgfCAodGhpcy5fZyA8PCA4KSB8ICh0aGlzLl9iKTtcbiAgICAgIH1cbiAgIH0pO1xuICAgYjJTZXR0aW5ncy5iMlNldHRpbmdzID0gZnVuY3Rpb24gKCkge307XG4gICBiMlNldHRpbmdzLmIyTWl4RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24xLCBmcmljdGlvbjIpIHtcbiAgICAgIGlmIChmcmljdGlvbjEgPT09IHVuZGVmaW5lZCkgZnJpY3Rpb24xID0gMDtcbiAgICAgIGlmIChmcmljdGlvbjIgPT09IHVuZGVmaW5lZCkgZnJpY3Rpb24yID0gMDtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZnJpY3Rpb24xICogZnJpY3Rpb24yKTtcbiAgIH1cbiAgIGIyU2V0dGluZ3MuYjJNaXhSZXN0aXR1dGlvbiA9IGZ1bmN0aW9uIChyZXN0aXR1dGlvbjEsIHJlc3RpdHV0aW9uMikge1xuICAgICAgaWYgKHJlc3RpdHV0aW9uMSA9PT0gdW5kZWZpbmVkKSByZXN0aXR1dGlvbjEgPSAwO1xuICAgICAgaWYgKHJlc3RpdHV0aW9uMiA9PT0gdW5kZWZpbmVkKSByZXN0aXR1dGlvbjIgPSAwO1xuICAgICAgcmV0dXJuIHJlc3RpdHV0aW9uMSA+IHJlc3RpdHV0aW9uMiA/IHJlc3RpdHV0aW9uMSA6IHJlc3RpdHV0aW9uMjtcbiAgIH1cbiAgIGIyU2V0dGluZ3MuYjJBc3NlcnQgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgaWYgKCFhKSB7XG4gICAgICAgICB0aHJvdyBcIkFzc2VydGlvbiBGYWlsZWRcIjtcbiAgICAgIH1cbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuVkVSU0lPTiA9IFwiMi4xYWxwaGFcIjtcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLlVTSFJUX01BWCA9IDB4MDAwMGZmZmY7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9waSA9IE1hdGguUEk7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9tYXhNYW5pZm9sZFBvaW50cyA9IDI7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9hYWJiRXh0ZW5zaW9uID0gMC4xO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfYWFiYk11bHRpcGxpZXIgPSAyLjA7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9wb2x5Z29uUmFkaXVzID0gMi4wICogYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCA9IDAuMDA1O1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3AgPSAyLjAgLyAxODAuMCAqIGIyU2V0dGluZ3MuYjJfcGk7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl90b2lTbG9wID0gOC4wICogYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4VE9JQ29udGFjdHNQZXJJc2xhbmQgPSAzMjtcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX21heFRPSUpvaW50c1BlcklzbGFuZCA9IDMyO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfdmVsb2NpdHlUaHJlc2hvbGQgPSAxLjA7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uID0gMC4yO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4QW5ndWxhckNvcnJlY3Rpb24gPSA4LjAgLyAxODAuMCAqIGIyU2V0dGluZ3MuYjJfcGk7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvbiA9IDIuMDtcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX21heFRyYW5zbGF0aW9uU3F1YXJlZCA9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBiMlNldHRpbmdzLmIyX21heFRyYW5zbGF0aW9uO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb24gPSAwLjUgKiBiMlNldHRpbmdzLmIyX3BpO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb25TcXVhcmVkID0gYjJTZXR0aW5ncy5iMl9tYXhSb3RhdGlvbiAqIGIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb247XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9jb250YWN0QmF1bWdhcnRlID0gMC4yO1xuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfdGltZVRvU2xlZXAgPSAwLjU7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9saW5lYXJTbGVlcFRvbGVyYW5jZSA9IDAuMDE7XG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xlZXBUb2xlcmFuY2UgPSAyLjAgLyAxODAuMCAqIGIyU2V0dGluZ3MuYjJfcGk7XG4gICB9KTtcbn0pKCk7XG4oZnVuY3Rpb24gKCkge1xuICAgdmFyIGIyQUFCQiA9IEJveDJELkNvbGxpc2lvbi5iMkFBQkIsXG4gICAgICBiMkNvbG9yID0gQm94MkQuQ29tbW9uLmIyQ29sb3IsXG4gICAgICBiMmludGVybmFsID0gQm94MkQuQ29tbW9uLmIyaW50ZXJuYWwsXG4gICAgICBiMlNldHRpbmdzID0gQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MsXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcbiAgICAgIGIyTWF0MzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDMzLFxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXG4gICAgICBiMlRyYW5zZm9ybSA9IEJveDJELkNvbW1vbi5NYXRoLmIyVHJhbnNmb3JtLFxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzO1xuXG4gICBiMk1hdDIyLmIyTWF0MjIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbDEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmNvbDIgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJNYXQyMi5wcm90b3R5cGUuYjJNYXQyMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuU2V0SWRlbnRpdHkoKTtcbiAgIH1cbiAgIGIyTWF0MjIuRnJvbUFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IHVuZGVmaW5lZCkgYW5nbGUgPSAwO1xuICAgICAgdmFyIG1hdCA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICBtYXQuU2V0KGFuZ2xlKTtcbiAgICAgIHJldHVybiBtYXQ7XG4gICB9XG4gICBiMk1hdDIyLkZyb21WViA9IGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICAgIHZhciBtYXQgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgbWF0LlNldFZWKGMxLCBjMik7XG4gICAgICByZXR1cm4gbWF0O1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IHVuZGVmaW5lZCkgYW5nbGUgPSAwO1xuICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHRoaXMuY29sMS54ID0gYztcbiAgICAgIHRoaXMuY29sMi54ID0gKC1zKTtcbiAgICAgIHRoaXMuY29sMS55ID0gcztcbiAgICAgIHRoaXMuY29sMi55ID0gYztcbiAgIH1cbiAgIGIyTWF0MjIucHJvdG90eXBlLlNldFZWID0gZnVuY3Rpb24gKGMxLCBjMikge1xuICAgICAgdGhpcy5jb2wxLlNldFYoYzEpO1xuICAgICAgdGhpcy5jb2wyLlNldFYoYzIpO1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXQgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgbWF0LlNldE0odGhpcyk7XG4gICAgICByZXR1cm4gbWF0O1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuU2V0TSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICB0aGlzLmNvbDEuU2V0VihtLmNvbDEpO1xuICAgICAgdGhpcy5jb2wyLlNldFYobS5jb2wyKTtcbiAgIH1cbiAgIGIyTWF0MjIucHJvdG90eXBlLkFkZE0gPSBmdW5jdGlvbiAobSkge1xuICAgICAgdGhpcy5jb2wxLnggKz0gbS5jb2wxLng7XG4gICAgICB0aGlzLmNvbDEueSArPSBtLmNvbDEueTtcbiAgICAgIHRoaXMuY29sMi54ICs9IG0uY29sMi54O1xuICAgICAgdGhpcy5jb2wyLnkgKz0gbS5jb2wyLnk7XG4gICB9XG4gICBiMk1hdDIyLnByb3RvdHlwZS5TZXRJZGVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY29sMS54ID0gMS4wO1xuICAgICAgdGhpcy5jb2wyLnggPSAwLjA7XG4gICAgICB0aGlzLmNvbDEueSA9IDAuMDtcbiAgICAgIHRoaXMuY29sMi55ID0gMS4wO1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuU2V0WmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY29sMS54ID0gMC4wO1xuICAgICAgdGhpcy5jb2wyLnggPSAwLjA7XG4gICAgICB0aGlzLmNvbDEueSA9IDAuMDtcbiAgICAgIHRoaXMuY29sMi55ID0gMC4wO1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuR2V0QW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLmNvbDEueSwgdGhpcy5jb2wxLngpO1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuR2V0SW52ZXJzZSA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgIHZhciBhID0gdGhpcy5jb2wxLng7XG4gICAgICB2YXIgYiA9IHRoaXMuY29sMi54O1xuICAgICAgdmFyIGMgPSB0aGlzLmNvbDEueTtcbiAgICAgIHZhciBkID0gdGhpcy5jb2wyLnk7XG4gICAgICB2YXIgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgICAgIGlmIChkZXQgIT0gMC4wKSB7XG4gICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICB9XG4gICAgICBvdXQuY29sMS54ID0gZGV0ICogZDtcbiAgICAgIG91dC5jb2wyLnggPSAoLWRldCAqIGIpO1xuICAgICAgb3V0LmNvbDEueSA9ICgtZGV0ICogYyk7XG4gICAgICBvdXQuY29sMi55ID0gZGV0ICogYTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICB9XG4gICBiMk1hdDIyLnByb3RvdHlwZS5Tb2x2ZSA9IGZ1bmN0aW9uIChvdXQsIGJYLCBiWSkge1xuICAgICAgaWYgKGJYID09PSB1bmRlZmluZWQpIGJYID0gMDtcbiAgICAgIGlmIChiWSA9PT0gdW5kZWZpbmVkKSBiWSA9IDA7XG4gICAgICB2YXIgYTExID0gdGhpcy5jb2wxLng7XG4gICAgICB2YXIgYTEyID0gdGhpcy5jb2wyLng7XG4gICAgICB2YXIgYTIxID0gdGhpcy5jb2wxLnk7XG4gICAgICB2YXIgYTIyID0gdGhpcy5jb2wyLnk7XG4gICAgICB2YXIgZGV0ID0gYTExICogYTIyIC0gYTEyICogYTIxO1xuICAgICAgaWYgKGRldCAhPSAwLjApIHtcbiAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICAgIH1cbiAgICAgIG91dC54ID0gZGV0ICogKGEyMiAqIGJYIC0gYTEyICogYlkpO1xuICAgICAgb3V0LnkgPSBkZXQgKiAoYTExICogYlkgLSBhMjEgKiBiWCk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgfVxuICAgYjJNYXQyMi5wcm90b3R5cGUuQWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb2wxLkFicygpO1xuICAgICAgdGhpcy5jb2wyLkFicygpO1xuICAgfVxuICAgYjJNYXQzMy5iMk1hdDMzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb2wxID0gbmV3IGIyVmVjMygpO1xuICAgICAgdGhpcy5jb2wyID0gbmV3IGIyVmVjMygpO1xuICAgICAgdGhpcy5jb2wzID0gbmV3IGIyVmVjMygpO1xuICAgfTtcbiAgIGIyTWF0MzMucHJvdG90eXBlLmIyTWF0MzMgPSBmdW5jdGlvbiAoYzEsIGMyLCBjMykge1xuICAgICAgaWYgKGMxID09PSB1bmRlZmluZWQpIGMxID0gbnVsbDtcbiAgICAgIGlmIChjMiA9PT0gdW5kZWZpbmVkKSBjMiA9IG51bGw7XG4gICAgICBpZiAoYzMgPT09IHVuZGVmaW5lZCkgYzMgPSBudWxsO1xuICAgICAgaWYgKCFjMSAmJiAhYzIgJiYgIWMzKSB7XG4gICAgICAgICB0aGlzLmNvbDEuU2V0WmVybygpO1xuICAgICAgICAgdGhpcy5jb2wyLlNldFplcm8oKTtcbiAgICAgICAgIHRoaXMuY29sMy5TZXRaZXJvKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMuY29sMS5TZXRWKGMxKTtcbiAgICAgICAgIHRoaXMuY29sMi5TZXRWKGMyKTtcbiAgICAgICAgIHRoaXMuY29sMy5TZXRWKGMzKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyTWF0MzMucHJvdG90eXBlLlNldFZWViA9IGZ1bmN0aW9uIChjMSwgYzIsIGMzKSB7XG4gICAgICB0aGlzLmNvbDEuU2V0VihjMSk7XG4gICAgICB0aGlzLmNvbDIuU2V0VihjMik7XG4gICAgICB0aGlzLmNvbDMuU2V0VihjMyk7XG4gICB9XG4gICBiMk1hdDMzLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBiMk1hdDMzKHRoaXMuY29sMSwgdGhpcy5jb2wyLCB0aGlzLmNvbDMpO1xuICAgfVxuICAgYjJNYXQzMy5wcm90b3R5cGUuU2V0TSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICB0aGlzLmNvbDEuU2V0VihtLmNvbDEpO1xuICAgICAgdGhpcy5jb2wyLlNldFYobS5jb2wyKTtcbiAgICAgIHRoaXMuY29sMy5TZXRWKG0uY29sMyk7XG4gICB9XG4gICBiMk1hdDMzLnByb3RvdHlwZS5BZGRNID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgIHRoaXMuY29sMS54ICs9IG0uY29sMS54O1xuICAgICAgdGhpcy5jb2wxLnkgKz0gbS5jb2wxLnk7XG4gICAgICB0aGlzLmNvbDEueiArPSBtLmNvbDEuejtcbiAgICAgIHRoaXMuY29sMi54ICs9IG0uY29sMi54O1xuICAgICAgdGhpcy5jb2wyLnkgKz0gbS5jb2wyLnk7XG4gICAgICB0aGlzLmNvbDIueiArPSBtLmNvbDIuejtcbiAgICAgIHRoaXMuY29sMy54ICs9IG0uY29sMy54O1xuICAgICAgdGhpcy5jb2wzLnkgKz0gbS5jb2wzLnk7XG4gICAgICB0aGlzLmNvbDMueiArPSBtLmNvbDMuejtcbiAgIH1cbiAgIGIyTWF0MzMucHJvdG90eXBlLlNldElkZW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb2wxLnggPSAxLjA7XG4gICAgICB0aGlzLmNvbDIueCA9IDAuMDtcbiAgICAgIHRoaXMuY29sMy54ID0gMC4wO1xuICAgICAgdGhpcy5jb2wxLnkgPSAwLjA7XG4gICAgICB0aGlzLmNvbDIueSA9IDEuMDtcbiAgICAgIHRoaXMuY29sMy55ID0gMC4wO1xuICAgICAgdGhpcy5jb2wxLnogPSAwLjA7XG4gICAgICB0aGlzLmNvbDIueiA9IDAuMDtcbiAgICAgIHRoaXMuY29sMy56ID0gMS4wO1xuICAgfVxuICAgYjJNYXQzMy5wcm90b3R5cGUuU2V0WmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY29sMS54ID0gMC4wO1xuICAgICAgdGhpcy5jb2wyLnggPSAwLjA7XG4gICAgICB0aGlzLmNvbDMueCA9IDAuMDtcbiAgICAgIHRoaXMuY29sMS55ID0gMC4wO1xuICAgICAgdGhpcy5jb2wyLnkgPSAwLjA7XG4gICAgICB0aGlzLmNvbDMueSA9IDAuMDtcbiAgICAgIHRoaXMuY29sMS56ID0gMC4wO1xuICAgICAgdGhpcy5jb2wyLnogPSAwLjA7XG4gICAgICB0aGlzLmNvbDMueiA9IDAuMDtcbiAgIH1cbiAgIGIyTWF0MzMucHJvdG90eXBlLlNvbHZlMjIgPSBmdW5jdGlvbiAob3V0LCBiWCwgYlkpIHtcbiAgICAgIGlmIChiWCA9PT0gdW5kZWZpbmVkKSBiWCA9IDA7XG4gICAgICBpZiAoYlkgPT09IHVuZGVmaW5lZCkgYlkgPSAwO1xuICAgICAgdmFyIGExMSA9IHRoaXMuY29sMS54O1xuICAgICAgdmFyIGExMiA9IHRoaXMuY29sMi54O1xuICAgICAgdmFyIGEyMSA9IHRoaXMuY29sMS55O1xuICAgICAgdmFyIGEyMiA9IHRoaXMuY29sMi55O1xuICAgICAgdmFyIGRldCA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgICAgIGlmIChkZXQgIT0gMC4wKSB7XG4gICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICB9XG4gICAgICBvdXQueCA9IGRldCAqIChhMjIgKiBiWCAtIGExMiAqIGJZKTtcbiAgICAgIG91dC55ID0gZGV0ICogKGExMSAqIGJZIC0gYTIxICogYlgpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgIH1cbiAgIGIyTWF0MzMucHJvdG90eXBlLlNvbHZlMzMgPSBmdW5jdGlvbiAob3V0LCBiWCwgYlksIGJaKSB7XG4gICAgICBpZiAoYlggPT09IHVuZGVmaW5lZCkgYlggPSAwO1xuICAgICAgaWYgKGJZID09PSB1bmRlZmluZWQpIGJZID0gMDtcbiAgICAgIGlmIChiWiA9PT0gdW5kZWZpbmVkKSBiWiA9IDA7XG4gICAgICB2YXIgYTExID0gdGhpcy5jb2wxLng7XG4gICAgICB2YXIgYTIxID0gdGhpcy5jb2wxLnk7XG4gICAgICB2YXIgYTMxID0gdGhpcy5jb2wxLno7XG4gICAgICB2YXIgYTEyID0gdGhpcy5jb2wyLng7XG4gICAgICB2YXIgYTIyID0gdGhpcy5jb2wyLnk7XG4gICAgICB2YXIgYTMyID0gdGhpcy5jb2wyLno7XG4gICAgICB2YXIgYTEzID0gdGhpcy5jb2wzLng7XG4gICAgICB2YXIgYTIzID0gdGhpcy5jb2wzLnk7XG4gICAgICB2YXIgYTMzID0gdGhpcy5jb2wzLno7XG4gICAgICB2YXIgZGV0ID0gYTExICogKGEyMiAqIGEzMyAtIGEzMiAqIGEyMykgKyBhMjEgKiAoYTMyICogYTEzIC0gYTEyICogYTMzKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMjIgKiBhMTMpO1xuICAgICAgaWYgKGRldCAhPSAwLjApIHtcbiAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICAgIH1cbiAgICAgIG91dC54ID0gZGV0ICogKGJYICogKGEyMiAqIGEzMyAtIGEzMiAqIGEyMykgKyBiWSAqIChhMzIgKiBhMTMgLSBhMTIgKiBhMzMpICsgYlogKiAoYTEyICogYTIzIC0gYTIyICogYTEzKSk7XG4gICAgICBvdXQueSA9IGRldCAqIChhMTEgKiAoYlkgKiBhMzMgLSBiWiAqIGEyMykgKyBhMjEgKiAoYlogKiBhMTMgLSBiWCAqIGEzMykgKyBhMzEgKiAoYlggKiBhMjMgLSBiWSAqIGExMykpO1xuICAgICAgb3V0LnogPSBkZXQgKiAoYTExICogKGEyMiAqIGJaIC0gYTMyICogYlkpICsgYTIxICogKGEzMiAqIGJYIC0gYTEyICogYlopICsgYTMxICogKGExMiAqIGJZIC0gYTIyICogYlgpKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICB9XG4gICBiMk1hdGguYjJNYXRoID0gZnVuY3Rpb24gKCkge307XG4gICBiMk1hdGguSXNWYWxpZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB4ID0gMDtcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh4KTtcbiAgIH1cbiAgIGIyTWF0aC5Eb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEueCAqIGIueCArIGEueSAqIGIueTtcbiAgIH1cbiAgIGIyTWF0aC5Dcm9zc1ZWID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XG4gICB9XG4gICBiMk1hdGguQ3Jvc3NWRiA9IGZ1bmN0aW9uIChhLCBzKSB7XG4gICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMDtcbiAgICAgIHZhciB2ID0gbmV3IGIyVmVjMihzICogYS55LCAoLXMgKiBhLngpKTtcbiAgICAgIHJldHVybiB2O1xuICAgfVxuICAgYjJNYXRoLkNyb3NzRlYgPSBmdW5jdGlvbiAocywgYSkge1xuICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDA7XG4gICAgICB2YXIgdiA9IG5ldyBiMlZlYzIoKC1zICogYS55KSwgcyAqIGEueCk7XG4gICAgICByZXR1cm4gdjtcbiAgIH1cbiAgIGIyTWF0aC5NdWxNViA9IGZ1bmN0aW9uIChBLCB2KSB7XG4gICAgICB2YXIgdSA9IG5ldyBiMlZlYzIoQS5jb2wxLnggKiB2LnggKyBBLmNvbDIueCAqIHYueSwgQS5jb2wxLnkgKiB2LnggKyBBLmNvbDIueSAqIHYueSk7XG4gICAgICByZXR1cm4gdTtcbiAgIH1cbiAgIGIyTWF0aC5NdWxUTVYgPSBmdW5jdGlvbiAoQSwgdikge1xuICAgICAgdmFyIHUgPSBuZXcgYjJWZWMyKGIyTWF0aC5Eb3QodiwgQS5jb2wxKSwgYjJNYXRoLkRvdCh2LCBBLmNvbDIpKTtcbiAgICAgIHJldHVybiB1O1xuICAgfVxuICAgYjJNYXRoLk11bFggPSBmdW5jdGlvbiAoVCwgdikge1xuICAgICAgdmFyIGEgPSBiMk1hdGguTXVsTVYoVC5SLCB2KTtcbiAgICAgIGEueCArPSBULnBvc2l0aW9uLng7XG4gICAgICBhLnkgKz0gVC5wb3NpdGlvbi55O1xuICAgICAgcmV0dXJuIGE7XG4gICB9XG4gICBiMk1hdGguTXVsWFQgPSBmdW5jdGlvbiAoVCwgdikge1xuICAgICAgdmFyIGEgPSBiMk1hdGguU3VidHJhY3RWVih2LCBULnBvc2l0aW9uKTtcbiAgICAgIHZhciB0WCA9IChhLnggKiBULlIuY29sMS54ICsgYS55ICogVC5SLmNvbDEueSk7XG4gICAgICBhLnkgPSAoYS54ICogVC5SLmNvbDIueCArIGEueSAqIFQuUi5jb2wyLnkpO1xuICAgICAgYS54ID0gdFg7XG4gICAgICByZXR1cm4gYTtcbiAgIH1cbiAgIGIyTWF0aC5BZGRWViA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgdiA9IG5ldyBiMlZlYzIoYS54ICsgYi54LCBhLnkgKyBiLnkpO1xuICAgICAgcmV0dXJuIHY7XG4gICB9XG4gICBiMk1hdGguU3VidHJhY3RWViA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgdiA9IG5ldyBiMlZlYzIoYS54IC0gYi54LCBhLnkgLSBiLnkpO1xuICAgICAgcmV0dXJuIHY7XG4gICB9XG4gICBiMk1hdGguRGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGNYID0gYS54IC0gYi54O1xuICAgICAgdmFyIGNZID0gYS55IC0gYi55O1xuICAgICAgcmV0dXJuIE1hdGguc3FydChjWCAqIGNYICsgY1kgKiBjWSk7XG4gICB9XG4gICBiMk1hdGguRGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBjWCA9IGEueCAtIGIueDtcbiAgICAgIHZhciBjWSA9IGEueSAtIGIueTtcbiAgICAgIHJldHVybiAoY1ggKiBjWCArIGNZICogY1kpO1xuICAgfVxuICAgYjJNYXRoLk11bEZWID0gZnVuY3Rpb24gKHMsIGEpIHtcbiAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAwO1xuICAgICAgdmFyIHYgPSBuZXcgYjJWZWMyKHMgKiBhLngsIHMgKiBhLnkpO1xuICAgICAgcmV0dXJuIHY7XG4gICB9XG4gICBiMk1hdGguQWRkTU0gPSBmdW5jdGlvbiAoQSwgQikge1xuICAgICAgdmFyIEMgPSBiMk1hdDIyLkZyb21WVihiMk1hdGguQWRkVlYoQS5jb2wxLCBCLmNvbDEpLCBiMk1hdGguQWRkVlYoQS5jb2wyLCBCLmNvbDIpKTtcbiAgICAgIHJldHVybiBDO1xuICAgfVxuICAgYjJNYXRoLk11bE1NID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgICAgIHZhciBDID0gYjJNYXQyMi5Gcm9tVlYoYjJNYXRoLk11bE1WKEEsIEIuY29sMSksIGIyTWF0aC5NdWxNVihBLCBCLmNvbDIpKTtcbiAgICAgIHJldHVybiBDO1xuICAgfVxuICAgYjJNYXRoLk11bFRNTSA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gICAgICB2YXIgYzEgPSBuZXcgYjJWZWMyKGIyTWF0aC5Eb3QoQS5jb2wxLCBCLmNvbDEpLCBiMk1hdGguRG90KEEuY29sMiwgQi5jb2wxKSk7XG4gICAgICB2YXIgYzIgPSBuZXcgYjJWZWMyKGIyTWF0aC5Eb3QoQS5jb2wxLCBCLmNvbDIpLCBiMk1hdGguRG90KEEuY29sMiwgQi5jb2wyKSk7XG4gICAgICB2YXIgQyA9IGIyTWF0MjIuRnJvbVZWKGMxLCBjMik7XG4gICAgICByZXR1cm4gQztcbiAgIH1cbiAgIGIyTWF0aC5BYnMgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgYSA9IDA7XG4gICAgICByZXR1cm4gYSA+IDAuMCA/IGEgOiAoLWEpO1xuICAgfVxuICAgYjJNYXRoLkFic1YgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgdmFyIGIgPSBuZXcgYjJWZWMyKGIyTWF0aC5BYnMoYS54KSwgYjJNYXRoLkFicyhhLnkpKTtcbiAgICAgIHJldHVybiBiO1xuICAgfVxuICAgYjJNYXRoLkFic00gPSBmdW5jdGlvbiAoQSkge1xuICAgICAgdmFyIEIgPSBiMk1hdDIyLkZyb21WVihiMk1hdGguQWJzVihBLmNvbDEpLCBiMk1hdGguQWJzVihBLmNvbDIpKTtcbiAgICAgIHJldHVybiBCO1xuICAgfVxuICAgYjJNYXRoLk1pbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIGIgPSAwO1xuICAgICAgcmV0dXJuIGEgPCBiID8gYSA6IGI7XG4gICB9XG4gICBiMk1hdGguTWluViA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgYyA9IG5ldyBiMlZlYzIoYjJNYXRoLk1pbihhLngsIGIueCksIGIyTWF0aC5NaW4oYS55LCBiLnkpKTtcbiAgICAgIHJldHVybiBjO1xuICAgfVxuICAgYjJNYXRoLk1heCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIGIgPSAwO1xuICAgICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7XG4gICB9XG4gICBiMk1hdGguTWF4ViA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgYyA9IG5ldyBiMlZlYzIoYjJNYXRoLk1heChhLngsIGIueCksIGIyTWF0aC5NYXgoYS55LCBiLnkpKTtcbiAgICAgIHJldHVybiBjO1xuICAgfVxuICAgYjJNYXRoLkNsYW1wID0gZnVuY3Rpb24gKGEsIGxvdywgaGlnaCkge1xuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgYSA9IDA7XG4gICAgICBpZiAobG93ID09PSB1bmRlZmluZWQpIGxvdyA9IDA7XG4gICAgICBpZiAoaGlnaCA9PT0gdW5kZWZpbmVkKSBoaWdoID0gMDtcbiAgICAgIHJldHVybiBhIDwgbG93ID8gbG93IDogYSA+IGhpZ2ggPyBoaWdoIDogYTtcbiAgIH1cbiAgIGIyTWF0aC5DbGFtcFYgPSBmdW5jdGlvbiAoYSwgbG93LCBoaWdoKSB7XG4gICAgICByZXR1cm4gYjJNYXRoLk1heFYobG93LCBiMk1hdGguTWluVihhLCBoaWdoKSk7XG4gICB9XG4gICBiMk1hdGguU3dhcCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgdG1wID0gYVswXTtcbiAgICAgIGFbMF0gPSBiWzBdO1xuICAgICAgYlswXSA9IHRtcDtcbiAgIH1cbiAgIGIyTWF0aC5SYW5kb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgfVxuICAgYjJNYXRoLlJhbmRvbVJhbmdlID0gZnVuY3Rpb24gKGxvLCBoaSkge1xuICAgICAgaWYgKGxvID09PSB1bmRlZmluZWQpIGxvID0gMDtcbiAgICAgIGlmIChoaSA9PT0gdW5kZWZpbmVkKSBoaSA9IDA7XG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCk7XG4gICAgICByID0gKGhpIC0gbG8pICogciArIGxvO1xuICAgICAgcmV0dXJuIHI7XG4gICB9XG4gICBiMk1hdGguTmV4dFBvd2VyT2ZUd28gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeCA9IDA7XG4gICAgICB4IHw9ICh4ID4+IDEpICYgMHg3RkZGRkZGRjtcbiAgICAgIHggfD0gKHggPj4gMikgJiAweDNGRkZGRkZGO1xuICAgICAgeCB8PSAoeCA+PiA0KSAmIDB4MEZGRkZGRkY7XG4gICAgICB4IHw9ICh4ID4+IDgpICYgMHgwMEZGRkZGRjtcbiAgICAgIHggfD0gKHggPj4gMTYpICYgMHgwMDAwRkZGRjtcbiAgICAgIHJldHVybiB4ICsgMTtcbiAgIH1cbiAgIGIyTWF0aC5Jc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeCA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0geCA+IDAgJiYgKHggJiAoeCAtIDEpKSA9PSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLmIyVmVjMl96ZXJvID0gbmV3IGIyVmVjMigwLjAsIDAuMCk7XG4gICAgICBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGguYjJNYXQyMl9pZGVudGl0eSA9IGIyTWF0MjIuRnJvbVZWKG5ldyBiMlZlYzIoMS4wLCAwLjApLCBuZXcgYjJWZWMyKDAuMCwgMS4wKSk7XG4gICAgICBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGguYjJUcmFuc2Zvcm1faWRlbnRpdHkgPSBuZXcgYjJUcmFuc2Zvcm0oYjJNYXRoLmIyVmVjMl96ZXJvLCBiMk1hdGguYjJNYXQyMl9pZGVudGl0eSk7XG4gICB9KTtcbiAgIGIyU3dlZXAuYjJTd2VlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubG9jYWxDZW50ZXIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmMwID0gbmV3IGIyVmVjMjtcbiAgICAgIHRoaXMuYyA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMlN3ZWVwLnByb3RvdHlwZS5TZXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgIHRoaXMubG9jYWxDZW50ZXIuU2V0VihvdGhlci5sb2NhbENlbnRlcik7XG4gICAgICB0aGlzLmMwLlNldFYob3RoZXIuYzApO1xuICAgICAgdGhpcy5jLlNldFYob3RoZXIuYyk7XG4gICAgICB0aGlzLmEwID0gb3RoZXIuYTA7XG4gICAgICB0aGlzLmEgPSBvdGhlci5hO1xuICAgICAgdGhpcy50MCA9IG90aGVyLnQwO1xuICAgfVxuICAgYjJTd2VlcC5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb3B5ID0gbmV3IGIyU3dlZXAoKTtcbiAgICAgIGNvcHkubG9jYWxDZW50ZXIuU2V0Vih0aGlzLmxvY2FsQ2VudGVyKTtcbiAgICAgIGNvcHkuYzAuU2V0Vih0aGlzLmMwKTtcbiAgICAgIGNvcHkuYy5TZXRWKHRoaXMuYyk7XG4gICAgICBjb3B5LmEwID0gdGhpcy5hMDtcbiAgICAgIGNvcHkuYSA9IHRoaXMuYTtcbiAgICAgIGNvcHkudDAgPSB0aGlzLnQwO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICB9XG4gICBiMlN3ZWVwLnByb3RvdHlwZS5HZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoeGYsIGFscGhhKSB7XG4gICAgICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkgYWxwaGEgPSAwO1xuICAgICAgeGYucG9zaXRpb24ueCA9ICgxLjAgLSBhbHBoYSkgKiB0aGlzLmMwLnggKyBhbHBoYSAqIHRoaXMuYy54O1xuICAgICAgeGYucG9zaXRpb24ueSA9ICgxLjAgLSBhbHBoYSkgKiB0aGlzLmMwLnkgKyBhbHBoYSAqIHRoaXMuYy55O1xuICAgICAgdmFyIGFuZ2xlID0gKDEuMCAtIGFscGhhKSAqIHRoaXMuYTAgKyBhbHBoYSAqIHRoaXMuYTtcbiAgICAgIHhmLlIuU2V0KGFuZ2xlKTtcbiAgICAgIHZhciB0TWF0ID0geGYuUjtcbiAgICAgIHhmLnBvc2l0aW9uLnggLT0gKHRNYXQuY29sMS54ICogdGhpcy5sb2NhbENlbnRlci54ICsgdE1hdC5jb2wyLnggKiB0aGlzLmxvY2FsQ2VudGVyLnkpO1xuICAgICAgeGYucG9zaXRpb24ueSAtPSAodE1hdC5jb2wxLnkgKiB0aGlzLmxvY2FsQ2VudGVyLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubG9jYWxDZW50ZXIueSk7XG4gICB9XG4gICBiMlN3ZWVwLnByb3RvdHlwZS5BZHZhbmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHQgPSAwO1xuICAgICAgaWYgKHRoaXMudDAgPCB0ICYmIDEuMCAtIHRoaXMudDAgPiBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICB2YXIgYWxwaGEgPSAodCAtIHRoaXMudDApIC8gKDEuMCAtIHRoaXMudDApO1xuICAgICAgICAgdGhpcy5jMC54ID0gKDEuMCAtIGFscGhhKSAqIHRoaXMuYzAueCArIGFscGhhICogdGhpcy5jLng7XG4gICAgICAgICB0aGlzLmMwLnkgPSAoMS4wIC0gYWxwaGEpICogdGhpcy5jMC55ICsgYWxwaGEgKiB0aGlzLmMueTtcbiAgICAgICAgIHRoaXMuYTAgPSAoMS4wIC0gYWxwaGEpICogdGhpcy5hMCArIGFscGhhICogdGhpcy5hO1xuICAgICAgICAgdGhpcy50MCA9IHQ7XG4gICAgICB9XG4gICB9XG4gICBiMlRyYW5zZm9ybS5iMlRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgYjJWZWMyO1xuICAgICAgdGhpcy5SID0gbmV3IGIyTWF0MjIoKTtcbiAgIH07XG4gICBiMlRyYW5zZm9ybS5wcm90b3R5cGUuYjJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocG9zLCByKSB7XG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHBvcyA9IG51bGw7XG4gICAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByID0gbnVsbDtcbiAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgIHRoaXMucG9zaXRpb24uU2V0Vihwb3MpO1xuICAgICAgICAgdGhpcy5SLlNldE0ocik7XG4gICAgICB9XG4gICB9XG4gICBiMlRyYW5zZm9ybS5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChwb3MsIHIpIHtcbiAgICAgIHRoaXMucG9zaXRpb24uU2V0Vihwb3MpO1xuICAgICAgdGhpcy5SLlNldE0ocik7XG4gICB9XG4gICBiMlRyYW5zZm9ybS5wcm90b3R5cGUuU2V0SWRlbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uLlNldFplcm8oKTtcbiAgICAgIHRoaXMuUi5TZXRJZGVudGl0eSgpO1xuICAgfVxuICAgYjJUcmFuc2Zvcm0ucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnBvc2l0aW9uLlNldFYoeC5wb3NpdGlvbik7XG4gICAgICB0aGlzLlIuU2V0TSh4LlIpO1xuICAgfVxuICAgYjJUcmFuc2Zvcm0ucHJvdG90eXBlLkdldEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5SLmNvbDEueSwgdGhpcy5SLmNvbDEueCk7XG4gICB9XG4gICBiMlZlYzIuYjJWZWMyID0gZnVuY3Rpb24gKCkge307XG4gICBiMlZlYzIucHJvdG90eXBlLmIyVmVjMiA9IGZ1bmN0aW9uICh4XywgeV8pIHtcbiAgICAgIGlmICh4XyA9PT0gdW5kZWZpbmVkKSB4XyA9IDA7XG4gICAgICBpZiAoeV8gPT09IHVuZGVmaW5lZCkgeV8gPSAwO1xuICAgICAgdGhpcy54ID0geF87XG4gICAgICB0aGlzLnkgPSB5XztcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuU2V0WmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMueCA9IDAuMDtcbiAgICAgIHRoaXMueSA9IDAuMDtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKHhfLCB5Xykge1xuICAgICAgaWYgKHhfID09PSB1bmRlZmluZWQpIHhfID0gMDtcbiAgICAgIGlmICh5XyA9PT0gdW5kZWZpbmVkKSB5XyA9IDA7XG4gICAgICB0aGlzLnggPSB4XztcbiAgICAgIHRoaXMueSA9IHlfO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5TZXRWID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgIHRoaXMueSA9IHYueTtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuR2V0TmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMigoLXRoaXMueCksICgtdGhpcy55KSk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLk5lZ2F0aXZlU2VsZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMueCA9ICgtdGhpcy54KTtcbiAgICAgIHRoaXMueSA9ICgtdGhpcy55KTtcbiAgIH1cbiAgIGIyVmVjMi5NYWtlID0gZnVuY3Rpb24gKHhfLCB5Xykge1xuICAgICAgaWYgKHhfID09PSB1bmRlZmluZWQpIHhfID0gMDtcbiAgICAgIGlmICh5XyA9PT0gdW5kZWZpbmVkKSB5XyA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMih4XywgeV8pO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIodGhpcy54LCB0aGlzLnkpO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5BZGQgPSBmdW5jdGlvbiAodikge1xuICAgICAgdGhpcy54ICs9IHYueDtcbiAgICAgIHRoaXMueSArPSB2Lnk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLlN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHRoaXMueCAtPSB2Lng7XG4gICAgICB0aGlzLnkgLT0gdi55O1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5NdWx0aXBseSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcbiAgICAgIHRoaXMueCAqPSBhO1xuICAgICAgdGhpcy55ICo9IGE7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLk11bE0gPSBmdW5jdGlvbiAoQSkge1xuICAgICAgdmFyIHRYID0gdGhpcy54O1xuICAgICAgdGhpcy54ID0gQS5jb2wxLnggKiB0WCArIEEuY29sMi54ICogdGhpcy55O1xuICAgICAgdGhpcy55ID0gQS5jb2wxLnkgKiB0WCArIEEuY29sMi55ICogdGhpcy55O1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5NdWxUTSA9IGZ1bmN0aW9uIChBKSB7XG4gICAgICB2YXIgdFggPSBiMk1hdGguRG90KHRoaXMsIEEuY29sMSk7XG4gICAgICB0aGlzLnkgPSBiMk1hdGguRG90KHRoaXMsIEEuY29sMik7XG4gICAgICB0aGlzLnggPSB0WDtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuQ3Jvc3NWRiA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMDtcbiAgICAgIHZhciB0WCA9IHRoaXMueDtcbiAgICAgIHRoaXMueCA9IHMgKiB0aGlzLnk7XG4gICAgICB0aGlzLnkgPSAoLXMgKiB0WCk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLkNyb3NzRlYgPSBmdW5jdGlvbiAocykge1xuICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDA7XG4gICAgICB2YXIgdFggPSB0aGlzLng7XG4gICAgICB0aGlzLnggPSAoLXMgKiB0aGlzLnkpO1xuICAgICAgdGhpcy55ID0gcyAqIHRYO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5NaW5WID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHRoaXMueCA9IHRoaXMueCA8IGIueCA/IHRoaXMueCA6IGIueDtcbiAgICAgIHRoaXMueSA9IHRoaXMueSA8IGIueSA/IHRoaXMueSA6IGIueTtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuTWF4ViA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICB0aGlzLnggPSB0aGlzLnggPiBiLnggPyB0aGlzLnggOiBiLng7XG4gICAgICB0aGlzLnkgPSB0aGlzLnkgPiBiLnkgPyB0aGlzLnkgOiBiLnk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLkFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnggPCAwKSB0aGlzLnggPSAoLXRoaXMueCk7XG4gICAgICBpZiAodGhpcy55IDwgMCkgdGhpcy55ID0gKC10aGlzLnkpO1xuICAgfVxuICAgYjJWZWMyLnByb3RvdHlwZS5MZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLkxlbmd0aFNxdWFyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICB9XG4gICBiMlZlYzIucHJvdG90eXBlLk5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICAgIGlmIChsZW5ndGggPCBOdW1iZXIuTUlOX1ZBTFVFKSB7XG4gICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgfVxuICAgICAgdmFyIGludkxlbmd0aCA9IDEuMCAvIGxlbmd0aDtcbiAgICAgIHRoaXMueCAqPSBpbnZMZW5ndGg7XG4gICAgICB0aGlzLnkgKj0gaW52TGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgIH1cbiAgIGIyVmVjMi5wcm90b3R5cGUuSXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiMk1hdGguSXNWYWxpZCh0aGlzLngpICYmIGIyTWF0aC5Jc1ZhbGlkKHRoaXMueSk7XG4gICB9XG4gICBiMlZlYzMuYjJWZWMzID0gZnVuY3Rpb24gKCkge307XG4gICBiMlZlYzMucHJvdG90eXBlLmIyVmVjMyA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB4ID0gMDtcbiAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHkgPSAwO1xuICAgICAgaWYgKHogPT09IHVuZGVmaW5lZCkgeiA9IDA7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMueiA9IHo7XG4gICB9XG4gICBiMlZlYzMucHJvdG90eXBlLlNldFplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLnogPSAwLjA7XG4gICB9XG4gICBiMlZlYzMucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB4ID0gMDtcbiAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHkgPSAwO1xuICAgICAgaWYgKHogPT09IHVuZGVmaW5lZCkgeiA9IDA7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMueiA9IHo7XG4gICB9XG4gICBiMlZlYzMucHJvdG90eXBlLlNldFYgPSBmdW5jdGlvbiAodikge1xuICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgdGhpcy56ID0gdi56O1xuICAgfVxuICAgYjJWZWMzLnByb3RvdHlwZS5HZXROZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgYjJWZWMzKCgtdGhpcy54KSwgKC10aGlzLnkpLCAoLXRoaXMueikpO1xuICAgfVxuICAgYjJWZWMzLnByb3RvdHlwZS5OZWdhdGl2ZVNlbGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnggPSAoLXRoaXMueCk7XG4gICAgICB0aGlzLnkgPSAoLXRoaXMueSk7XG4gICAgICB0aGlzLnogPSAoLXRoaXMueik7XG4gICB9XG4gICBiMlZlYzMucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMyh0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcbiAgIH1cbiAgIGIyVmVjMy5wcm90b3R5cGUuQWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICB0aGlzLnkgKz0gdi55O1xuICAgICAgdGhpcy56ICs9IHYuejtcbiAgIH1cbiAgIGIyVmVjMy5wcm90b3R5cGUuU3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xuICAgICAgdGhpcy54IC09IHYueDtcbiAgICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgICB0aGlzLnogLT0gdi56O1xuICAgfVxuICAgYjJWZWMzLnByb3RvdHlwZS5NdWx0aXBseSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcbiAgICAgIHRoaXMueCAqPSBhO1xuICAgICAgdGhpcy55ICo9IGE7XG4gICAgICB0aGlzLnogKj0gYTtcbiAgIH1cbn0pKCk7XG4oZnVuY3Rpb24gKCkge1xuICAgdmFyIGIyQ29udHJvbGxlckVkZ2UgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXJFZGdlLFxuICAgICAgYjJNYXQyMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MjIsXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcbiAgICAgIGIyU3dlZXAgPSBCb3gyRC5Db21tb24uTWF0aC5iMlN3ZWVwLFxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcbiAgICAgIGIyVmVjMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMyxcbiAgICAgIGIyQ29sb3IgPSBCb3gyRC5Db21tb24uYjJDb2xvcixcbiAgICAgIGIyaW50ZXJuYWwgPSBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCxcbiAgICAgIGIyU2V0dGluZ3MgPSBCb3gyRC5Db21tb24uYjJTZXR0aW5ncyxcbiAgICAgIGIyQUFCQiA9IEJveDJELkNvbGxpc2lvbi5iMkFBQkIsXG4gICAgICBiMkJvdW5kID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmQsXG4gICAgICBiMkJvdW5kVmFsdWVzID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmRWYWx1ZXMsXG4gICAgICBiMkNvbGxpc2lvbiA9IEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbixcbiAgICAgIGIyQ29udGFjdElEID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdElELFxuICAgICAgYjJDb250YWN0UG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJDb250YWN0UG9pbnQsXG4gICAgICBiMkRpc3RhbmNlID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2UsXG4gICAgICBiMkRpc3RhbmNlSW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZUlucHV0LFxuICAgICAgYjJEaXN0YW5jZU91dHB1dCA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlT3V0cHV0LFxuICAgICAgYjJEaXN0YW5jZVByb3h5ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VQcm94eSxcbiAgICAgIGIyRHluYW1pY1RyZWUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZSxcbiAgICAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLFxuICAgICAgYjJEeW5hbWljVHJlZU5vZGUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZU5vZGUsXG4gICAgICBiMkR5bmFtaWNUcmVlUGFpciA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlUGFpcixcbiAgICAgIGIyTWFuaWZvbGQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZCxcbiAgICAgIGIyTWFuaWZvbGRQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkUG9pbnQsXG4gICAgICBiMlBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyUG9pbnQsXG4gICAgICBiMlJheUNhc3RJbnB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RJbnB1dCxcbiAgICAgIGIyUmF5Q2FzdE91dHB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RPdXRwdXQsXG4gICAgICBiMlNlZ21lbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJTZWdtZW50LFxuICAgICAgYjJTZXBhcmF0aW9uRnVuY3Rpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJTZXBhcmF0aW9uRnVuY3Rpb24sXG4gICAgICBiMlNpbXBsZXggPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4LFxuICAgICAgYjJTaW1wbGV4Q2FjaGUgPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4Q2FjaGUsXG4gICAgICBiMlNpbXBsZXhWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4VmVydGV4LFxuICAgICAgYjJUaW1lT2ZJbXBhY3QgPSBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QsXG4gICAgICBiMlRPSUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyVE9JSW5wdXQsXG4gICAgICBiMldvcmxkTWFuaWZvbGQgPSBCb3gyRC5Db2xsaXNpb24uYjJXb3JsZE1hbmlmb2xkLFxuICAgICAgQ2xpcFZlcnRleCA9IEJveDJELkNvbGxpc2lvbi5DbGlwVmVydGV4LFxuICAgICAgRmVhdHVyZXMgPSBCb3gyRC5Db2xsaXNpb24uRmVhdHVyZXMsXG4gICAgICBJQnJvYWRQaGFzZSA9IEJveDJELkNvbGxpc2lvbi5JQnJvYWRQaGFzZSxcbiAgICAgIGIyQ2lyY2xlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyQ2lyY2xlU2hhcGUsXG4gICAgICBiMkVkZ2VDaGFpbkRlZiA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlQ2hhaW5EZWYsXG4gICAgICBiMkVkZ2VTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlU2hhcGUsXG4gICAgICBiMk1hc3NEYXRhID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMk1hc3NEYXRhLFxuICAgICAgYjJQb2x5Z29uU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyUG9seWdvblNoYXBlLFxuICAgICAgYjJTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZSxcbiAgICAgIGIyQm9keSA9IEJveDJELkR5bmFtaWNzLmIyQm9keSxcbiAgICAgIGIyQm9keURlZiA9IEJveDJELkR5bmFtaWNzLmIyQm9keURlZixcbiAgICAgIGIyQ29udGFjdEZpbHRlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEZpbHRlcixcbiAgICAgIGIyQ29udGFjdEltcHVsc2UgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RJbXB1bHNlLFxuICAgICAgYjJDb250YWN0TGlzdGVuZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lcixcbiAgICAgIGIyQ29udGFjdE1hbmFnZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RNYW5hZ2VyLFxuICAgICAgYjJEZWJ1Z0RyYXcgPSBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdyxcbiAgICAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcixcbiAgICAgIGIyRmlsdGVyRGF0YSA9IEJveDJELkR5bmFtaWNzLmIyRmlsdGVyRGF0YSxcbiAgICAgIGIyRml4dHVyZSA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZSxcbiAgICAgIGIyRml4dHVyZURlZiA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZixcbiAgICAgIGIySXNsYW5kID0gQm94MkQuRHluYW1pY3MuYjJJc2xhbmQsXG4gICAgICBiMlRpbWVTdGVwID0gQm94MkQuRHluYW1pY3MuYjJUaW1lU3RlcCxcbiAgICAgIGIyV29ybGQgPSBCb3gyRC5EeW5hbWljcy5iMldvcmxkLFxuICAgICAgYjJDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDaXJjbGVDb250YWN0LFxuICAgICAgYjJDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LFxuICAgICAgYjJDb250YWN0Q29uc3RyYWludCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdENvbnN0cmFpbnQsXG4gICAgICBiMkNvbnRhY3RDb25zdHJhaW50UG9pbnQgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RDb25zdHJhaW50UG9pbnQsXG4gICAgICBiMkNvbnRhY3RFZGdlID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0RWRnZSxcbiAgICAgIGIyQ29udGFjdEZhY3RvcnkgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RGYWN0b3J5LFxuICAgICAgYjJDb250YWN0UmVnaXN0ZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RSZWdpc3RlcixcbiAgICAgIGIyQ29udGFjdFJlc3VsdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFJlc3VsdCxcbiAgICAgIGIyQ29udGFjdFNvbHZlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFNvbHZlcixcbiAgICAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkVkZ2VBbmRDaXJjbGVDb250YWN0LFxuICAgICAgYjJOdWxsQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyTnVsbENvbnRhY3QsXG4gICAgICBiMlBvbHlBbmRDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCxcbiAgICAgIGIyUG9seUFuZEVkZ2VDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kRWRnZUNvbnRhY3QsXG4gICAgICBiMlBvbHlnb25Db250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5Z29uQ29udGFjdCxcbiAgICAgIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCxcbiAgICAgIGIyQ29udHJvbGxlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcixcbiAgICAgIGIyRGlzdGFuY2VKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkRpc3RhbmNlSm9pbnQsXG4gICAgICBiMkRpc3RhbmNlSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJEaXN0YW5jZUpvaW50RGVmLFxuICAgICAgYjJGcmljdGlvbkpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyRnJpY3Rpb25Kb2ludCxcbiAgICAgIGIyRnJpY3Rpb25Kb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkZyaWN0aW9uSm9pbnREZWYsXG4gICAgICBiMkdlYXJKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkdlYXJKb2ludCxcbiAgICAgIGIyR2VhckpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyR2VhckpvaW50RGVmLFxuICAgICAgYjJKYWNvYmlhbiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkphY29iaWFuLFxuICAgICAgYjJKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LFxuICAgICAgYjJKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLFxuICAgICAgYjJKb2ludEVkZ2UgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludEVkZ2UsXG4gICAgICBiMkxpbmVKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkxpbmVKb2ludCxcbiAgICAgIGIyTGluZUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTGluZUpvaW50RGVmLFxuICAgICAgYjJNb3VzZUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTW91c2VKb2ludCxcbiAgICAgIGIyTW91c2VKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMk1vdXNlSm9pbnREZWYsXG4gICAgICBiMlByaXNtYXRpY0pvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHJpc21hdGljSm9pbnQsXG4gICAgICBiMlByaXNtYXRpY0pvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHJpc21hdGljSm9pbnREZWYsXG4gICAgICBiMlB1bGxleUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnQsXG4gICAgICBiMlB1bGxleUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnREZWYsXG4gICAgICBiMlJldm9sdXRlSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJSZXZvbHV0ZUpvaW50LFxuICAgICAgYjJSZXZvbHV0ZUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludERlZixcbiAgICAgIGIyV2VsZEpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyV2VsZEpvaW50LFxuICAgICAgYjJXZWxkSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJXZWxkSm9pbnREZWY7XG5cbiAgIGIyQm9keS5iMkJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1feGYgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcbiAgICAgIHRoaXMubV9zd2VlcCA9IG5ldyBiMlN3ZWVwKCk7XG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fZm9yY2UgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJCb2R5LnByb3RvdHlwZS5jb25uZWN0RWRnZXMgPSBmdW5jdGlvbiAoczEsIHMyLCBhbmdsZTEpIHtcbiAgICAgIGlmIChhbmdsZTEgPT09IHVuZGVmaW5lZCkgYW5nbGUxID0gMDtcbiAgICAgIHZhciBhbmdsZTIgPSBNYXRoLmF0YW4yKHMyLkdldERpcmVjdGlvblZlY3RvcigpLnksIHMyLkdldERpcmVjdGlvblZlY3RvcigpLngpO1xuICAgICAgdmFyIGNvcmVPZmZzZXQgPSBNYXRoLnRhbigoYW5nbGUyIC0gYW5nbGUxKSAqIDAuNSk7XG4gICAgICB2YXIgY29yZSA9IGIyTWF0aC5NdWxGVihjb3JlT2Zmc2V0LCBzMi5HZXREaXJlY3Rpb25WZWN0b3IoKSk7XG4gICAgICBjb3JlID0gYjJNYXRoLlN1YnRyYWN0VlYoY29yZSwgczIuR2V0Tm9ybWFsVmVjdG9yKCkpO1xuICAgICAgY29yZSA9IGIyTWF0aC5NdWxGVihiMlNldHRpbmdzLmIyX3RvaVNsb3AsIGNvcmUpO1xuICAgICAgY29yZSA9IGIyTWF0aC5BZGRWVihjb3JlLCBzMi5HZXRWZXJ0ZXgxKCkpO1xuICAgICAgdmFyIGNvcm5lckRpciA9IGIyTWF0aC5BZGRWVihzMS5HZXREaXJlY3Rpb25WZWN0b3IoKSwgczIuR2V0RGlyZWN0aW9uVmVjdG9yKCkpO1xuICAgICAgY29ybmVyRGlyLk5vcm1hbGl6ZSgpO1xuICAgICAgdmFyIGNvbnZleCA9IGIyTWF0aC5Eb3QoczEuR2V0RGlyZWN0aW9uVmVjdG9yKCksIHMyLkdldE5vcm1hbFZlY3RvcigpKSA+IDAuMDtcbiAgICAgIHMxLlNldE5leHRFZGdlKHMyLCBjb3JlLCBjb3JuZXJEaXIsIGNvbnZleCk7XG4gICAgICBzMi5TZXRQcmV2RWRnZShzMSwgY29yZSwgY29ybmVyRGlyLCBjb252ZXgpO1xuICAgICAgcmV0dXJuIGFuZ2xlMjtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuQ3JlYXRlRml4dHVyZSA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIGlmICh0aGlzLm1fd29ybGQuSXNMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBmaXh0dXJlID0gbmV3IGIyRml4dHVyZSgpO1xuICAgICAgZml4dHVyZS5DcmVhdGUodGhpcywgdGhpcy5tX3hmLCBkZWYpO1xuICAgICAgaWYgKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2FjdGl2ZUZsYWcpIHtcbiAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlO1xuICAgICAgICAgZml4dHVyZS5DcmVhdGVQcm94eShicm9hZFBoYXNlLCB0aGlzLm1feGYpO1xuICAgICAgfVxuICAgICAgZml4dHVyZS5tX25leHQgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICB0aGlzLm1fZml4dHVyZUxpc3QgPSBmaXh0dXJlO1xuICAgICAgKyt0aGlzLm1fZml4dHVyZUNvdW50O1xuICAgICAgZml4dHVyZS5tX2JvZHkgPSB0aGlzO1xuICAgICAgaWYgKGZpeHR1cmUubV9kZW5zaXR5ID4gMC4wKSB7XG4gICAgICAgICB0aGlzLlJlc2V0TWFzc0RhdGEoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV93b3JsZC5tX2ZsYWdzIHw9IGIyV29ybGQuZV9uZXdGaXh0dXJlO1xuICAgICAgcmV0dXJuIGZpeHR1cmU7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkNyZWF0ZUZpeHR1cmUyID0gZnVuY3Rpb24gKHNoYXBlLCBkZW5zaXR5KSB7XG4gICAgICBpZiAoZGVuc2l0eSA9PT0gdW5kZWZpbmVkKSBkZW5zaXR5ID0gMC4wO1xuICAgICAgdmFyIGRlZiA9IG5ldyBiMkZpeHR1cmVEZWYoKTtcbiAgICAgIGRlZi5zaGFwZSA9IHNoYXBlO1xuICAgICAgZGVmLmRlbnNpdHkgPSBkZW5zaXR5O1xuICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlRml4dHVyZShkZWYpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5EZXN0cm95Rml4dHVyZSA9IGZ1bmN0aW9uIChmaXh0dXJlKSB7XG4gICAgICBpZiAodGhpcy5tX3dvcmxkLklzTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICB2YXIgcHBGID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgaWYgKG5vZGUgPT0gZml4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHBwRikgcHBGLm1fbmV4dCA9IGZpeHR1cmUubV9uZXh0O1xuICAgICAgICAgICAgZWxzZSB0aGlzLm1fZml4dHVyZUxpc3QgPSBmaXh0dXJlLm1fbmV4dDtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgICAgcHBGID0gbm9kZTtcbiAgICAgICAgIG5vZGUgPSBub2RlLm1fbmV4dDtcbiAgICAgIH1cbiAgICAgIHZhciBlZGdlID0gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgIHZhciBjID0gZWRnZS5jb250YWN0O1xuICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgIHZhciBmaXh0dXJlQSA9IGMuR2V0Rml4dHVyZUEoKTtcbiAgICAgICAgIHZhciBmaXh0dXJlQiA9IGMuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgIGlmIChmaXh0dXJlID09IGZpeHR1cmVBIHx8IGZpeHR1cmUgPT0gZml4dHVyZUIpIHtcbiAgICAgICAgICAgIHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLkRlc3Ryb3koYyk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfYWN0aXZlRmxhZykge1xuICAgICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICBmaXh0dXJlLkRlc3Ryb3lQcm94eShicm9hZFBoYXNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge31cbiAgICAgIGZpeHR1cmUuRGVzdHJveSgpO1xuICAgICAgZml4dHVyZS5tX2JvZHkgPSBudWxsO1xuICAgICAgZml4dHVyZS5tX25leHQgPSBudWxsO1xuICAgICAgLS10aGlzLm1fZml4dHVyZUNvdW50O1xuICAgICAgdGhpcy5SZXNldE1hc3NEYXRhKCk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldFBvc2l0aW9uQW5kQW5nbGUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IHVuZGVmaW5lZCkgYW5nbGUgPSAwO1xuICAgICAgdmFyIGY7XG4gICAgICBpZiAodGhpcy5tX3dvcmxkLklzTG9ja2VkKCkgPT0gdHJ1ZSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tX3hmLlIuU2V0KGFuZ2xlKTtcbiAgICAgIHRoaXMubV94Zi5wb3NpdGlvbi5TZXRWKHBvc2l0aW9uKTtcbiAgICAgIHZhciB0TWF0ID0gdGhpcy5tX3hmLlI7XG4gICAgICB2YXIgdFZlYyA9IHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgIHRoaXMubV9zd2VlcC5jLnggPSAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB0aGlzLm1fc3dlZXAuYy55ID0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdGhpcy5tX3N3ZWVwLmMueCArPSB0aGlzLm1feGYucG9zaXRpb24ueDtcbiAgICAgIHRoaXMubV9zd2VlcC5jLnkgKz0gdGhpcy5tX3hmLnBvc2l0aW9uLnk7XG4gICAgICB0aGlzLm1fc3dlZXAuYzAuU2V0Vih0aGlzLm1fc3dlZXAuYyk7XG4gICAgICB0aGlzLm1fc3dlZXAuYTAgPSB0aGlzLm1fc3dlZXAuYSA9IGFuZ2xlO1xuICAgICAgdmFyIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICBmb3IgKGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgIGYuU3luY2hyb25pemUoYnJvYWRQaGFzZSwgdGhpcy5tX3hmLCB0aGlzLm1feGYpO1xuICAgICAgfVxuICAgICAgdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIuRmluZE5ld0NvbnRhY3RzKCk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4Zikge1xuICAgICAgdGhpcy5TZXRQb3NpdGlvbkFuZEFuZ2xlKHhmLnBvc2l0aW9uLCB4Zi5HZXRBbmdsZSgpKTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV94ZjtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3hmLnBvc2l0aW9uO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgdGhpcy5TZXRQb3NpdGlvbkFuZEFuZ2xlKHBvc2l0aW9uLCB0aGlzLkdldEFuZ2xlKCkpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRBbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fc3dlZXAuYTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gdW5kZWZpbmVkKSBhbmdsZSA9IDA7XG4gICAgICB0aGlzLlNldFBvc2l0aW9uQW5kQW5nbGUodGhpcy5HZXRQb3NpdGlvbigpLCBhbmdsZSk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldFdvcmxkQ2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9zd2VlcC5jO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRMb2NhbENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXI7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmICh0aGlzLm1fdHlwZSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LlNldFYodik7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9saW5lYXJWZWxvY2l0eTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24gKG9tZWdhKSB7XG4gICAgICBpZiAob21lZ2EgPT09IHVuZGVmaW5lZCkgb21lZ2EgPSAwO1xuICAgICAgaWYgKHRoaXMubV90eXBlID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gb21lZ2E7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldEFuZ3VsYXJWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXREZWZpbml0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJkID0gbmV3IGIyQm9keURlZigpO1xuICAgICAgYmQudHlwZSA9IHRoaXMuR2V0VHlwZSgpO1xuICAgICAgYmQuYWxsb3dTbGVlcCA9ICh0aGlzLm1fZmxhZ3MgJiBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZykgPT0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICAgICBiZC5hbmdsZSA9IHRoaXMuR2V0QW5nbGUoKTtcbiAgICAgIGJkLmFuZ3VsYXJEYW1waW5nID0gdGhpcy5tX2FuZ3VsYXJEYW1waW5nO1xuICAgICAgYmQuYW5ndWxhclZlbG9jaXR5ID0gdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIGJkLmZpeGVkUm90YXRpb24gPSAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfZml4ZWRSb3RhdGlvbkZsYWcpID09IGIyQm9keS5lX2ZpeGVkUm90YXRpb25GbGFnO1xuICAgICAgYmQuYnVsbGV0ID0gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2J1bGxldEZsYWcpID09IGIyQm9keS5lX2J1bGxldEZsYWc7XG4gICAgICBiZC5hd2FrZSA9ICh0aGlzLm1fZmxhZ3MgJiBiMkJvZHkuZV9hd2FrZUZsYWcpID09IGIyQm9keS5lX2F3YWtlRmxhZztcbiAgICAgIGJkLmxpbmVhckRhbXBpbmcgPSB0aGlzLm1fbGluZWFyRGFtcGluZztcbiAgICAgIGJkLmxpbmVhclZlbG9jaXR5LlNldFYodGhpcy5HZXRMaW5lYXJWZWxvY2l0eSgpKTtcbiAgICAgIGJkLnBvc2l0aW9uID0gdGhpcy5HZXRQb3NpdGlvbigpO1xuICAgICAgYmQudXNlckRhdGEgPSB0aGlzLkdldFVzZXJEYXRhKCk7XG4gICAgICByZXR1cm4gYmQ7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UsIHBvaW50KSB7XG4gICAgICBpZiAodGhpcy5tX3R5cGUgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5Jc0F3YWtlKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgIHRoaXMuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fZm9yY2UueCArPSBmb3JjZS54O1xuICAgICAgdGhpcy5tX2ZvcmNlLnkgKz0gZm9yY2UueTtcbiAgICAgIHRoaXMubV90b3JxdWUgKz0gKChwb2ludC54IC0gdGhpcy5tX3N3ZWVwLmMueCkgKiBmb3JjZS55IC0gKHBvaW50LnkgLSB0aGlzLm1fc3dlZXAuYy55KSAqIGZvcmNlLngpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5BcHBseVRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcbiAgICAgIGlmICh0b3JxdWUgPT09IHVuZGVmaW5lZCkgdG9ycXVlID0gMDtcbiAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgdGhpcy5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV90b3JxdWUgKz0gdG9ycXVlO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5BcHBseUltcHVsc2UgPSBmdW5jdGlvbiAoaW1wdWxzZSwgcG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgdGhpcy5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS54ICs9IHRoaXMubV9pbnZNYXNzICogaW1wdWxzZS54O1xuICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LnkgKz0gdGhpcy5tX2ludk1hc3MgKiBpbXB1bHNlLnk7XG4gICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMubV9pbnZJICogKChwb2ludC54IC0gdGhpcy5tX3N3ZWVwLmMueCkgKiBpbXB1bHNlLnkgLSAocG9pbnQueSAtIHRoaXMubV9zd2VlcC5jLnkpICogaW1wdWxzZS54KTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU3BsaXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaW5lYXJWZWxvY2l0eSA9IHRoaXMuR2V0TGluZWFyVmVsb2NpdHkoKS5Db3B5KCk7XG4gICAgICB2YXIgYW5ndWxhclZlbG9jaXR5ID0gdGhpcy5HZXRBbmd1bGFyVmVsb2NpdHkoKTtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLkdldFdvcmxkQ2VudGVyKCk7XG4gICAgICB2YXIgYm9keTEgPSB0aGlzO1xuICAgICAgdmFyIGJvZHkyID0gdGhpcy5tX3dvcmxkLkNyZWF0ZUJvZHkodGhpcy5HZXREZWZpbml0aW9uKCkpO1xuICAgICAgdmFyIHByZXY7XG4gICAgICBmb3IgKHZhciBmID0gYm9keTEubV9maXh0dXJlTGlzdDsgZjspIHtcbiAgICAgICAgIGlmIChjYWxsYmFjayhmKSkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBmLm1fbmV4dDtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICBwcmV2Lm1fbmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIGJvZHkxLm1fZml4dHVyZUxpc3QgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keTEubV9maXh0dXJlQ291bnQtLTtcbiAgICAgICAgICAgIGYubV9uZXh0ID0gYm9keTIubV9maXh0dXJlTGlzdDtcbiAgICAgICAgICAgIGJvZHkyLm1fZml4dHVyZUxpc3QgPSBmO1xuICAgICAgICAgICAgYm9keTIubV9maXh0dXJlQ291bnQrKztcbiAgICAgICAgICAgIGYubV9ib2R5ID0gYm9keTI7XG4gICAgICAgICAgICBmID0gbmV4dDtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldiA9IGY7XG4gICAgICAgICAgICBmID0gZi5tX25leHQ7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBib2R5MS5SZXNldE1hc3NEYXRhKCk7XG4gICAgICBib2R5Mi5SZXNldE1hc3NEYXRhKCk7XG4gICAgICB2YXIgY2VudGVyMSA9IGJvZHkxLkdldFdvcmxkQ2VudGVyKCk7XG4gICAgICB2YXIgY2VudGVyMiA9IGJvZHkyLkdldFdvcmxkQ2VudGVyKCk7XG4gICAgICB2YXIgdmVsb2NpdHkxID0gYjJNYXRoLkFkZFZWKGxpbmVhclZlbG9jaXR5LCBiMk1hdGguQ3Jvc3NGVihhbmd1bGFyVmVsb2NpdHksIGIyTWF0aC5TdWJ0cmFjdFZWKGNlbnRlcjEsIGNlbnRlcikpKTtcbiAgICAgIHZhciB2ZWxvY2l0eTIgPSBiMk1hdGguQWRkVlYobGluZWFyVmVsb2NpdHksIGIyTWF0aC5Dcm9zc0ZWKGFuZ3VsYXJWZWxvY2l0eSwgYjJNYXRoLlN1YnRyYWN0VlYoY2VudGVyMiwgY2VudGVyKSkpO1xuICAgICAgYm9keTEuU2V0TGluZWFyVmVsb2NpdHkodmVsb2NpdHkxKTtcbiAgICAgIGJvZHkyLlNldExpbmVhclZlbG9jaXR5KHZlbG9jaXR5Mik7XG4gICAgICBib2R5MS5TZXRBbmd1bGFyVmVsb2NpdHkoYW5ndWxhclZlbG9jaXR5KTtcbiAgICAgIGJvZHkyLlNldEFuZ3VsYXJWZWxvY2l0eShhbmd1bGFyVmVsb2NpdHkpO1xuICAgICAgYm9keTEuU3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgYm9keTIuU3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgcmV0dXJuIGJvZHkyO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5NZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgdmFyIGY7XG4gICAgICBmb3IgKGYgPSBvdGhlci5tX2ZpeHR1cmVMaXN0O1xuICAgICAgZjspIHtcbiAgICAgICAgIHZhciBuZXh0ID0gZi5tX25leHQ7XG4gICAgICAgICBvdGhlci5tX2ZpeHR1cmVDb3VudC0tO1xuICAgICAgICAgZi5tX25leHQgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICAgICB0aGlzLm1fZml4dHVyZUxpc3QgPSBmO1xuICAgICAgICAgdGhpcy5tX2ZpeHR1cmVDb3VudCsrO1xuICAgICAgICAgZi5tX2JvZHkgPSBib2R5MjtcbiAgICAgICAgIGYgPSBuZXh0O1xuICAgICAgfVxuICAgICAgYm9keTEubV9maXh0dXJlQ291bnQgPSAwO1xuICAgICAgdmFyIGJvZHkxID0gdGhpcztcbiAgICAgIHZhciBib2R5MiA9IG90aGVyO1xuICAgICAgdmFyIGNlbnRlcjEgPSBib2R5MS5HZXRXb3JsZENlbnRlcigpO1xuICAgICAgdmFyIGNlbnRlcjIgPSBib2R5Mi5HZXRXb3JsZENlbnRlcigpO1xuICAgICAgdmFyIHZlbG9jaXR5MSA9IGJvZHkxLkdldExpbmVhclZlbG9jaXR5KCkuQ29weSgpO1xuICAgICAgdmFyIHZlbG9jaXR5MiA9IGJvZHkyLkdldExpbmVhclZlbG9jaXR5KCkuQ29weSgpO1xuICAgICAgdmFyIGFuZ3VsYXIxID0gYm9keTEuR2V0QW5ndWxhclZlbG9jaXR5KCk7XG4gICAgICB2YXIgYW5ndWxhciA9IGJvZHkyLkdldEFuZ3VsYXJWZWxvY2l0eSgpO1xuICAgICAgYm9keTEuUmVzZXRNYXNzRGF0YSgpO1xuICAgICAgdGhpcy5TeW5jaHJvbml6ZUZpeHR1cmVzKCk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldE1hc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX21hc3M7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldEluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX0k7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldE1hc3NEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGRhdGEubWFzcyA9IHRoaXMubV9tYXNzO1xuICAgICAgZGF0YS5JID0gdGhpcy5tX0k7XG4gICAgICBkYXRhLmNlbnRlci5TZXRWKHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcik7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldE1hc3NEYXRhID0gZnVuY3Rpb24gKG1hc3NEYXRhKSB7XG4gICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KHRoaXMubV93b3JsZC5Jc0xvY2tlZCgpID09IGZhbHNlKTtcbiAgICAgIGlmICh0aGlzLm1fd29ybGQuSXNMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX3R5cGUgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1faW52TWFzcyA9IDAuMDtcbiAgICAgIHRoaXMubV9JID0gMC4wO1xuICAgICAgdGhpcy5tX2ludkkgPSAwLjA7XG4gICAgICB0aGlzLm1fbWFzcyA9IG1hc3NEYXRhLm1hc3M7XG4gICAgICBpZiAodGhpcy5tX21hc3MgPD0gMC4wKSB7XG4gICAgICAgICB0aGlzLm1fbWFzcyA9IDEuMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9pbnZNYXNzID0gMS4wIC8gdGhpcy5tX21hc3M7XG4gICAgICBpZiAobWFzc0RhdGEuSSA+IDAuMCAmJiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfZml4ZWRSb3RhdGlvbkZsYWcpID09IDApIHtcbiAgICAgICAgIHRoaXMubV9JID0gbWFzc0RhdGEuSSAtIHRoaXMubV9tYXNzICogKG1hc3NEYXRhLmNlbnRlci54ICogbWFzc0RhdGEuY2VudGVyLnggKyBtYXNzRGF0YS5jZW50ZXIueSAqIG1hc3NEYXRhLmNlbnRlci55KTtcbiAgICAgICAgIHRoaXMubV9pbnZJID0gMS4wIC8gdGhpcy5tX0k7XG4gICAgICB9XG4gICAgICB2YXIgb2xkQ2VudGVyID0gdGhpcy5tX3N3ZWVwLmMuQ29weSgpO1xuICAgICAgdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyLlNldFYobWFzc0RhdGEuY2VudGVyKTtcbiAgICAgIHRoaXMubV9zd2VlcC5jMC5TZXRWKGIyTWF0aC5NdWxYKHRoaXMubV94ZiwgdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyKSk7XG4gICAgICB0aGlzLm1fc3dlZXAuYy5TZXRWKHRoaXMubV9zd2VlcC5jMCk7XG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkueCArPSB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICogKC0odGhpcy5tX3N3ZWVwLmMueSAtIG9sZENlbnRlci55KSk7XG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkueSArPSB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICogKCsodGhpcy5tX3N3ZWVwLmMueCAtIG9sZENlbnRlci54KSk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlJlc2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fbWFzcyA9IDAuMDtcbiAgICAgIHRoaXMubV9pbnZNYXNzID0gMC4wO1xuICAgICAgdGhpcy5tX0kgPSAwLjA7XG4gICAgICB0aGlzLm1faW52SSA9IDAuMDtcbiAgICAgIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlci5TZXRaZXJvKCk7XG4gICAgICBpZiAodGhpcy5tX3R5cGUgPT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkgfHwgdGhpcy5tX3R5cGUgPT0gYjJCb2R5LmIyX2tpbmVtYXRpY0JvZHkpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjZW50ZXIgPSBiMlZlYzIuTWFrZSgwLCAwKTtcbiAgICAgIGZvciAodmFyIGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7IGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgaWYgKGYubV9kZW5zaXR5ID09IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICB9XG4gICAgICAgICB2YXIgbWFzc0RhdGEgPSBmLkdldE1hc3NEYXRhKCk7XG4gICAgICAgICB0aGlzLm1fbWFzcyArPSBtYXNzRGF0YS5tYXNzO1xuICAgICAgICAgY2VudGVyLnggKz0gbWFzc0RhdGEuY2VudGVyLnggKiBtYXNzRGF0YS5tYXNzO1xuICAgICAgICAgY2VudGVyLnkgKz0gbWFzc0RhdGEuY2VudGVyLnkgKiBtYXNzRGF0YS5tYXNzO1xuICAgICAgICAgdGhpcy5tX0kgKz0gbWFzc0RhdGEuSTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1fbWFzcyA+IDAuMCkge1xuICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjAgLyB0aGlzLm1fbWFzcztcbiAgICAgICAgIGNlbnRlci54ICo9IHRoaXMubV9pbnZNYXNzO1xuICAgICAgICAgY2VudGVyLnkgKj0gdGhpcy5tX2ludk1hc3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9tYXNzID0gMS4wO1xuICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX0kgPiAwLjAgJiYgKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2ZpeGVkUm90YXRpb25GbGFnKSA9PSAwKSB7XG4gICAgICAgICB0aGlzLm1fSSAtPSB0aGlzLm1fbWFzcyAqIChjZW50ZXIueCAqIGNlbnRlci54ICsgY2VudGVyLnkgKiBjZW50ZXIueSk7XG4gICAgICAgICB0aGlzLm1fSSAqPSB0aGlzLm1faW5lcnRpYVNjYWxlO1xuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydCh0aGlzLm1fSSA+IDApO1xuICAgICAgICAgdGhpcy5tX2ludkkgPSAxLjAgLyB0aGlzLm1fSTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX0kgPSAwLjA7XG4gICAgICAgICB0aGlzLm1faW52SSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIHZhciBvbGRDZW50ZXIgPSB0aGlzLm1fc3dlZXAuYy5Db3B5KCk7XG4gICAgICB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIuU2V0VihjZW50ZXIpO1xuICAgICAgdGhpcy5tX3N3ZWVwLmMwLlNldFYoYjJNYXRoLk11bFgodGhpcy5tX3hmLCB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIpKTtcbiAgICAgIHRoaXMubV9zd2VlcC5jLlNldFYodGhpcy5tX3N3ZWVwLmMwKTtcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS54ICs9IHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKiAoLSh0aGlzLm1fc3dlZXAuYy55IC0gb2xkQ2VudGVyLnkpKTtcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS55ICs9IHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKiAoKyh0aGlzLm1fc3dlZXAuYy54IC0gb2xkQ2VudGVyLngpKTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0V29ybGRQb2ludCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XG4gICAgICB2YXIgQSA9IHRoaXMubV94Zi5SO1xuICAgICAgdmFyIHUgPSBuZXcgYjJWZWMyKEEuY29sMS54ICogbG9jYWxQb2ludC54ICsgQS5jb2wyLnggKiBsb2NhbFBvaW50LnksIEEuY29sMS55ICogbG9jYWxQb2ludC54ICsgQS5jb2wyLnkgKiBsb2NhbFBvaW50LnkpO1xuICAgICAgdS54ICs9IHRoaXMubV94Zi5wb3NpdGlvbi54O1xuICAgICAgdS55ICs9IHRoaXMubV94Zi5wb3NpdGlvbi55O1xuICAgICAgcmV0dXJuIHU7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldFdvcmxkVmVjdG9yID0gZnVuY3Rpb24gKGxvY2FsVmVjdG9yKSB7XG4gICAgICByZXR1cm4gYjJNYXRoLk11bE1WKHRoaXMubV94Zi5SLCBsb2NhbFZlY3Rvcik7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldExvY2FsUG9pbnQgPSBmdW5jdGlvbiAod29ybGRQb2ludCkge1xuICAgICAgcmV0dXJuIGIyTWF0aC5NdWxYVCh0aGlzLm1feGYsIHdvcmxkUG9pbnQpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRMb2NhbFZlY3RvciA9IGZ1bmN0aW9uICh3b3JsZFZlY3Rvcikge1xuICAgICAgcmV0dXJuIGIyTWF0aC5NdWxUTVYodGhpcy5tX3hmLlIsIHdvcmxkVmVjdG9yKTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludCA9IGZ1bmN0aW9uICh3b3JsZFBvaW50KSB7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMih0aGlzLm1fbGluZWFyVmVsb2NpdHkueCAtIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKiAod29ybGRQb2ludC55IC0gdGhpcy5tX3N3ZWVwLmMueSksIHRoaXMubV9saW5lYXJWZWxvY2l0eS55ICsgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSAqICh3b3JsZFBvaW50LnggLSB0aGlzLm1fc3dlZXAuYy54KSk7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldExpbmVhclZlbG9jaXR5RnJvbUxvY2FsUG9pbnQgPSBmdW5jdGlvbiAobG9jYWxQb2ludCkge1xuICAgICAgdmFyIEEgPSB0aGlzLm1feGYuUjtcbiAgICAgIHZhciB3b3JsZFBvaW50ID0gbmV3IGIyVmVjMihBLmNvbDEueCAqIGxvY2FsUG9pbnQueCArIEEuY29sMi54ICogbG9jYWxQb2ludC55LCBBLmNvbDEueSAqIGxvY2FsUG9pbnQueCArIEEuY29sMi55ICogbG9jYWxQb2ludC55KTtcbiAgICAgIHdvcmxkUG9pbnQueCArPSB0aGlzLm1feGYucG9zaXRpb24ueDtcbiAgICAgIHdvcmxkUG9pbnQueSArPSB0aGlzLm1feGYucG9zaXRpb24ueTtcbiAgICAgIHJldHVybiBuZXcgYjJWZWMyKHRoaXMubV9saW5lYXJWZWxvY2l0eS54IC0gdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSAqICh3b3JsZFBvaW50LnkgLSB0aGlzLm1fc3dlZXAuYy55KSwgdGhpcy5tX2xpbmVhclZlbG9jaXR5LnkgKyB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICogKHdvcmxkUG9pbnQueCAtIHRoaXMubV9zd2VlcC5jLngpKTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbGluZWFyRGFtcGluZztcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uIChsaW5lYXJEYW1waW5nKSB7XG4gICAgICBpZiAobGluZWFyRGFtcGluZyA9PT0gdW5kZWZpbmVkKSBsaW5lYXJEYW1waW5nID0gMDtcbiAgICAgIHRoaXMubV9saW5lYXJEYW1waW5nID0gbGluZWFyRGFtcGluZztcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0QW5ndWxhckRhbXBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2FuZ3VsYXJEYW1waW5nO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRBbmd1bGFyRGFtcGluZyA9IGZ1bmN0aW9uIChhbmd1bGFyRGFtcGluZykge1xuICAgICAgaWYgKGFuZ3VsYXJEYW1waW5nID09PSB1bmRlZmluZWQpIGFuZ3VsYXJEYW1waW5nID0gMDtcbiAgICAgIHRoaXMubV9hbmd1bGFyRGFtcGluZyA9IGFuZ3VsYXJEYW1waW5nO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHR5cGUgPSAwO1xuICAgICAgaWYgKHRoaXMubV90eXBlID09IHR5cGUpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubV90eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuUmVzZXRNYXNzRGF0YSgpO1xuICAgICAgaWYgKHRoaXMubV90eXBlID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkuU2V0WmVybygpO1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fZm9yY2UuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX3RvcnF1ZSA9IDAuMDtcbiAgICAgIGZvciAodmFyIGNlID0gdGhpcy5tX2NvbnRhY3RMaXN0OyBjZTsgY2UgPSBjZS5uZXh0KSB7XG4gICAgICAgICBjZS5jb250YWN0LkZsYWdGb3JGaWx0ZXJpbmcoKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QnVsbGV0ID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYnVsbGV0RmxhZztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkJvZHkuZV9idWxsZXRGbGFnO1xuICAgICAgfVxuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5Jc0J1bGxldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfYnVsbGV0RmxhZykgPT0gYjJCb2R5LmVfYnVsbGV0RmxhZztcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0U2xlZXBpbmdBbGxvd2VkID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyAmPSB+YjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICAgICAgICB0aGlzLlNldEF3YWtlKHRydWUpO1xuICAgICAgfVxuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRBd2FrZSA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQm9keS5lX2F3YWtlRmxhZztcbiAgICAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwLjA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyAmPSB+YjJCb2R5LmVfYXdha2VGbGFnO1xuICAgICAgICAgdGhpcy5tX3NsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5TZXRaZXJvKCk7XG4gICAgICAgICB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ID0gMC4wO1xuICAgICAgICAgdGhpcy5tX2ZvcmNlLlNldFplcm8oKTtcbiAgICAgICAgIHRoaXMubV90b3JxdWUgPSAwLjA7XG4gICAgICB9XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLklzQXdha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2F3YWtlRmxhZykgPT0gYjJCb2R5LmVfYXdha2VGbGFnO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRGaXhlZFJvdGF0aW9uID0gZnVuY3Rpb24gKGZpeGVkKSB7XG4gICAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcbiAgICAgIH1cbiAgICAgIHRoaXMuUmVzZXRNYXNzRGF0YSgpO1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5Jc0ZpeGVkUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2ZpeGVkUm90YXRpb25GbGFnKSA9PSBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QWN0aXZlID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgIGlmIChmbGFnID09IHRoaXMuSXNBY3RpdmUoKSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJyb2FkUGhhc2U7XG4gICAgICB2YXIgZjtcbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWN0aXZlRmxhZztcbiAgICAgICAgIGJyb2FkUGhhc2UgPSB0aGlzLm1fd29ybGQubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICAgICBmb3IgKGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XG4gICAgICAgICBmOyBmID0gZi5tX25leHQpIHtcbiAgICAgICAgICAgIGYuQ3JlYXRlUHJveHkoYnJvYWRQaGFzZSwgdGhpcy5tX3hmKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkJvZHkuZV9hY3RpdmVGbGFnO1xuICAgICAgICAgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgIGZvciAoZiA9IHRoaXMubV9maXh0dXJlTGlzdDtcbiAgICAgICAgIGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgICAgZi5EZXN0cm95UHJveHkoYnJvYWRQaGFzZSk7XG4gICAgICAgICB9XG4gICAgICAgICB2YXIgY2UgPSB0aGlzLm1fY29udGFjdExpc3Q7XG4gICAgICAgICB3aGlsZSAoY2UpIHtcbiAgICAgICAgICAgIHZhciBjZTAgPSBjZTtcbiAgICAgICAgICAgIGNlID0gY2UubmV4dDtcbiAgICAgICAgICAgIHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLkRlc3Ryb3koY2UwLmNvbnRhY3QpO1xuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5tX2NvbnRhY3RMaXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuSXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2FjdGl2ZUZsYWcpID09IGIyQm9keS5lX2FjdGl2ZUZsYWc7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLklzU2xlZXBpbmdBbGxvd2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICh0aGlzLm1fZmxhZ3MgJiBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZykgPT0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldEZpeHR1cmVMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9maXh0dXJlTGlzdDtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0Sm9pbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9qb2ludExpc3Q7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldENvbnRyb2xsZXJMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9jb250cm9sbGVyTGlzdDtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0Q29udGFjdExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9uZXh0O1xuICAgfVxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRVc2VyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdXNlckRhdGE7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRhdGE7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkdldFdvcmxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV93b3JsZDtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuYjJCb2R5ID0gZnVuY3Rpb24gKGJkLCB3b3JsZCkge1xuICAgICAgdGhpcy5tX2ZsYWdzID0gMDtcbiAgICAgIGlmIChiZC5idWxsZXQpIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9idWxsZXRGbGFnO1xuICAgICAgfVxuICAgICAgaWYgKGJkLmZpeGVkUm90YXRpb24pIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcbiAgICAgIH1cbiAgICAgIGlmIChiZC5hbGxvd1NsZWVwKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XG4gICAgICB9XG4gICAgICBpZiAoYmQuYXdha2UpIHtcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9hd2FrZUZsYWc7XG4gICAgICB9XG4gICAgICBpZiAoYmQuYWN0aXZlKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWN0aXZlRmxhZztcbiAgICAgIH1cbiAgICAgIHRoaXMubV93b3JsZCA9IHdvcmxkO1xuICAgICAgdGhpcy5tX3hmLnBvc2l0aW9uLlNldFYoYmQucG9zaXRpb24pO1xuICAgICAgdGhpcy5tX3hmLlIuU2V0KGJkLmFuZ2xlKTtcbiAgICAgIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlci5TZXRaZXJvKCk7XG4gICAgICB0aGlzLm1fc3dlZXAudDAgPSAxLjA7XG4gICAgICB0aGlzLm1fc3dlZXAuYTAgPSB0aGlzLm1fc3dlZXAuYSA9IGJkLmFuZ2xlO1xuICAgICAgdmFyIHRNYXQgPSB0aGlzLm1feGYuUjtcbiAgICAgIHZhciB0VmVjID0gdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xuICAgICAgdGhpcy5tX3N3ZWVwLmMueCA9ICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHRoaXMubV9zd2VlcC5jLnkgPSAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICB0aGlzLm1fc3dlZXAuYy54ICs9IHRoaXMubV94Zi5wb3NpdGlvbi54O1xuICAgICAgdGhpcy5tX3N3ZWVwLmMueSArPSB0aGlzLm1feGYucG9zaXRpb24ueTtcbiAgICAgIHRoaXMubV9zd2VlcC5jMC5TZXRWKHRoaXMubV9zd2VlcC5jKTtcbiAgICAgIHRoaXMubV9qb2ludExpc3QgPSBudWxsO1xuICAgICAgdGhpcy5tX2NvbnRyb2xsZXJMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgICB0aGlzLm1fY29udHJvbGxlckNvdW50ID0gMDtcbiAgICAgIHRoaXMubV9wcmV2ID0gbnVsbDtcbiAgICAgIHRoaXMubV9uZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5TZXRWKGJkLmxpbmVhclZlbG9jaXR5KTtcbiAgICAgIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgPSBiZC5hbmd1bGFyVmVsb2NpdHk7XG4gICAgICB0aGlzLm1fbGluZWFyRGFtcGluZyA9IGJkLmxpbmVhckRhbXBpbmc7XG4gICAgICB0aGlzLm1fYW5ndWxhckRhbXBpbmcgPSBiZC5hbmd1bGFyRGFtcGluZztcbiAgICAgIHRoaXMubV9mb3JjZS5TZXQoMC4wLCAwLjApO1xuICAgICAgdGhpcy5tX3RvcnF1ZSA9IDAuMDtcbiAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwLjA7XG4gICAgICB0aGlzLm1fdHlwZSA9IGJkLnR5cGU7XG4gICAgICBpZiAodGhpcy5tX3R5cGUgPT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICB0aGlzLm1fbWFzcyA9IDEuMDtcbiAgICAgICAgIHRoaXMubV9pbnZNYXNzID0gMS4wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fbWFzcyA9IDAuMDtcbiAgICAgICAgIHRoaXMubV9pbnZNYXNzID0gMC4wO1xuICAgICAgfVxuICAgICAgdGhpcy5tX0kgPSAwLjA7XG4gICAgICB0aGlzLm1faW52SSA9IDAuMDtcbiAgICAgIHRoaXMubV9pbmVydGlhU2NhbGUgPSBiZC5pbmVydGlhU2NhbGU7XG4gICAgICB0aGlzLm1fdXNlckRhdGEgPSBiZC51c2VyRGF0YTtcbiAgICAgIHRoaXMubV9maXh0dXJlTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLm1fZml4dHVyZUNvdW50ID0gMDtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU3luY2hyb25pemVGaXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB4ZjEgPSBiMkJvZHkuc194ZjE7XG4gICAgICB4ZjEuUi5TZXQodGhpcy5tX3N3ZWVwLmEwKTtcbiAgICAgIHZhciB0TWF0ID0geGYxLlI7XG4gICAgICB2YXIgdFZlYyA9IHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgIHhmMS5wb3NpdGlvbi54ID0gdGhpcy5tX3N3ZWVwLmMwLnggLSAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICB4ZjEucG9zaXRpb24ueSA9IHRoaXMubV9zd2VlcC5jMC55IC0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgdmFyIGY7XG4gICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcbiAgICAgIGZvciAoZiA9IHRoaXMubV9maXh0dXJlTGlzdDtcbiAgICAgIGY7IGYgPSBmLm1fbmV4dCkge1xuICAgICAgICAgZi5TeW5jaHJvbml6ZShicm9hZFBoYXNlLCB4ZjEsIHRoaXMubV94Zik7XG4gICAgICB9XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLlN5bmNocm9uaXplVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX3hmLlIuU2V0KHRoaXMubV9zd2VlcC5hKTtcbiAgICAgIHZhciB0TWF0ID0gdGhpcy5tX3hmLlI7XG4gICAgICB2YXIgdFZlYyA9IHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcbiAgICAgIHRoaXMubV94Zi5wb3NpdGlvbi54ID0gdGhpcy5tX3N3ZWVwLmMueCAtICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgIHRoaXMubV94Zi5wb3NpdGlvbi55ID0gdGhpcy5tX3N3ZWVwLmMueSAtICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgIH1cbiAgIGIyQm9keS5wcm90b3R5cGUuU2hvdWxkQ29sbGlkZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgaWYgKHRoaXMubV90eXBlICE9IGIyQm9keS5iMl9keW5hbWljQm9keSAmJiBvdGhlci5tX3R5cGUgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqbiA9IHRoaXMubV9qb2ludExpc3Q7IGpuOyBqbiA9IGpuLm5leHQpIHtcbiAgICAgICAgIGlmIChqbi5vdGhlciA9PSBvdGhlcikgaWYgKGpuLmpvaW50Lm1fY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICB9XG4gICBiMkJvZHkucHJvdG90eXBlLkFkdmFuY2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgdCA9IDA7XG4gICAgICB0aGlzLm1fc3dlZXAuQWR2YW5jZSh0KTtcbiAgICAgIHRoaXMubV9zd2VlcC5jLlNldFYodGhpcy5tX3N3ZWVwLmMwKTtcbiAgICAgIHRoaXMubV9zd2VlcC5hID0gdGhpcy5tX3N3ZWVwLmEwO1xuICAgICAgdGhpcy5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuc194ZjEgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQm9keS5lX2lzbGFuZEZsYWcgPSAweDAwMDE7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuZV9hd2FrZUZsYWcgPSAweDAwMDI7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuZV9hbGxvd1NsZWVwRmxhZyA9IDB4MDAwNDtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQm9keS5lX2J1bGxldEZsYWcgPSAweDAwMDg7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZyA9IDB4MDAxMDtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQm9keS5lX2FjdGl2ZUZsYWcgPSAweDAwMjA7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuYjJfc3RhdGljQm9keSA9IDA7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuYjJfa2luZW1hdGljQm9keSA9IDE7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuYjJfZHluYW1pY0JvZHkgPSAyO1xuICAgfSk7XG4gICBiMkJvZHlEZWYuYjJCb2R5RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubGluZWFyVmVsb2NpdHkgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJCb2R5RGVmLnByb3RvdHlwZS5iMkJvZHlEZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnVzZXJEYXRhID0gbnVsbDtcbiAgICAgIHRoaXMucG9zaXRpb24uU2V0KDAuMCwgMC4wKTtcbiAgICAgIHRoaXMuYW5nbGUgPSAwLjA7XG4gICAgICB0aGlzLmxpbmVhclZlbG9jaXR5LlNldCgwLCAwKTtcbiAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gMC4wO1xuICAgICAgdGhpcy5saW5lYXJEYW1waW5nID0gMC4wO1xuICAgICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IDAuMDtcbiAgICAgIHRoaXMuYWxsb3dTbGVlcCA9IHRydWU7XG4gICAgICB0aGlzLmF3YWtlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZml4ZWRSb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5idWxsZXQgPSBmYWxzZTtcbiAgICAgIHRoaXMudHlwZSA9IGIyQm9keS5iMl9zdGF0aWNCb2R5O1xuICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgdGhpcy5pbmVydGlhU2NhbGUgPSAxLjA7XG4gICB9XG4gICBiMkNvbnRhY3RGaWx0ZXIuYjJDb250YWN0RmlsdGVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RGaWx0ZXIucHJvdG90eXBlLlNob3VsZENvbGxpZGUgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XG4gICAgICB2YXIgZmlsdGVyMSA9IGZpeHR1cmVBLkdldEZpbHRlckRhdGEoKTtcbiAgICAgIHZhciBmaWx0ZXIyID0gZml4dHVyZUIuR2V0RmlsdGVyRGF0YSgpO1xuICAgICAgaWYgKGZpbHRlcjEuZ3JvdXBJbmRleCA9PSBmaWx0ZXIyLmdyb3VwSW5kZXggJiYgZmlsdGVyMS5ncm91cEluZGV4ICE9IDApIHtcbiAgICAgICAgIHJldHVybiBmaWx0ZXIxLmdyb3VwSW5kZXggPiAwO1xuICAgICAgfVxuICAgICAgdmFyIGNvbGxpZGUgPSAoZmlsdGVyMS5tYXNrQml0cyAmIGZpbHRlcjIuY2F0ZWdvcnlCaXRzKSAhPSAwICYmIChmaWx0ZXIxLmNhdGVnb3J5Qml0cyAmIGZpbHRlcjIubWFza0JpdHMpICE9IDA7XG4gICAgICByZXR1cm4gY29sbGlkZTtcbiAgIH1cbiAgIGIyQ29udGFjdEZpbHRlci5wcm90b3R5cGUuUmF5Q29sbGlkZSA9IGZ1bmN0aW9uICh1c2VyRGF0YSwgZml4dHVyZSkge1xuICAgICAgaWYgKCF1c2VyRGF0YSkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5TaG91bGRDb2xsaWRlKCh1c2VyRGF0YSBpbnN0YW5jZW9mIGIyRml4dHVyZSA/IHVzZXJEYXRhIDogbnVsbCksIGZpeHR1cmUpO1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RGaWx0ZXIuYjJfZGVmYXVsdEZpbHRlciA9IG5ldyBiMkNvbnRhY3RGaWx0ZXIoKTtcbiAgIH0pO1xuICAgYjJDb250YWN0SW1wdWxzZS5iMkNvbnRhY3RJbXB1bHNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ub3JtYWxJbXB1bHNlcyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcihiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzKTtcbiAgICAgIHRoaXMudGFuZ2VudEltcHVsc2VzID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xuICAgfTtcbiAgIGIyQ29udGFjdExpc3RlbmVyLmIyQ29udGFjdExpc3RlbmVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RMaXN0ZW5lci5wcm90b3R5cGUuQmVnaW5Db250YWN0ID0gZnVuY3Rpb24gKGNvbnRhY3QpIHt9XG4gICBiMkNvbnRhY3RMaXN0ZW5lci5wcm90b3R5cGUuRW5kQ29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0KSB7fVxuICAgYjJDb250YWN0TGlzdGVuZXIucHJvdG90eXBlLlByZVNvbHZlID0gZnVuY3Rpb24gKGNvbnRhY3QsIG9sZE1hbmlmb2xkKSB7fVxuICAgYjJDb250YWN0TGlzdGVuZXIucHJvdG90eXBlLlBvc3RTb2x2ZSA9IGZ1bmN0aW9uIChjb250YWN0LCBpbXB1bHNlKSB7fVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lci5iMl9kZWZhdWx0TGlzdGVuZXIgPSBuZXcgYjJDb250YWN0TGlzdGVuZXIoKTtcbiAgIH0pO1xuICAgYjJDb250YWN0TWFuYWdlci5iMkNvbnRhY3RNYW5hZ2VyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RNYW5hZ2VyLnByb3RvdHlwZS5iMkNvbnRhY3RNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX3dvcmxkID0gbnVsbDtcbiAgICAgIHRoaXMubV9jb250YWN0Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2NvbnRhY3RGaWx0ZXIgPSBiMkNvbnRhY3RGaWx0ZXIuYjJfZGVmYXVsdEZpbHRlcjtcbiAgICAgIHRoaXMubV9jb250YWN0TGlzdGVuZXIgPSBiMkNvbnRhY3RMaXN0ZW5lci5iMl9kZWZhdWx0TGlzdGVuZXI7XG4gICAgICB0aGlzLm1fY29udGFjdEZhY3RvcnkgPSBuZXcgYjJDb250YWN0RmFjdG9yeSh0aGlzLm1fYWxsb2NhdG9yKTtcbiAgICAgIHRoaXMubV9icm9hZFBoYXNlID0gbmV3IGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlKCk7XG4gICB9XG4gICBiMkNvbnRhY3RNYW5hZ2VyLnByb3RvdHlwZS5BZGRQYWlyID0gZnVuY3Rpb24gKHByb3h5VXNlckRhdGFBLCBwcm94eVVzZXJEYXRhQikge1xuICAgICAgdmFyIGZpeHR1cmVBID0gKHByb3h5VXNlckRhdGFBIGluc3RhbmNlb2YgYjJGaXh0dXJlID8gcHJveHlVc2VyRGF0YUEgOiBudWxsKTtcbiAgICAgIHZhciBmaXh0dXJlQiA9IChwcm94eVVzZXJEYXRhQiBpbnN0YW5jZW9mIGIyRml4dHVyZSA/IHByb3h5VXNlckRhdGFCIDogbnVsbCk7XG4gICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5HZXRCb2R5KCk7XG4gICAgICBpZiAoYm9keUEgPT0gYm9keUIpIHJldHVybjtcbiAgICAgIHZhciBlZGdlID0gYm9keUIuR2V0Q29udGFjdExpc3QoKTtcbiAgICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBib2R5QSkge1xuICAgICAgICAgICAgdmFyIGZBID0gZWRnZS5jb250YWN0LkdldEZpeHR1cmVBKCk7XG4gICAgICAgICAgICB2YXIgZkIgPSBlZGdlLmNvbnRhY3QuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgIGlmIChmQSA9PSBmaXh0dXJlQSAmJiBmQiA9PSBmaXh0dXJlQikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGZBID09IGZpeHR1cmVCICYmIGZCID09IGZpeHR1cmVBKSByZXR1cm47XG4gICAgICAgICB9XG4gICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKGJvZHlCLlNob3VsZENvbGxpZGUoYm9keUEpID09IGZhbHNlKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2NvbnRhY3RGaWx0ZXIuU2hvdWxkQ29sbGlkZShmaXh0dXJlQSwgZml4dHVyZUIpID09IGZhbHNlKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYyA9IHRoaXMubV9jb250YWN0RmFjdG9yeS5DcmVhdGUoZml4dHVyZUEsIGZpeHR1cmVCKTtcbiAgICAgIGZpeHR1cmVBID0gYy5HZXRGaXh0dXJlQSgpO1xuICAgICAgZml4dHVyZUIgPSBjLkdldEZpeHR1cmVCKCk7XG4gICAgICBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgIGJvZHlCID0gZml4dHVyZUIubV9ib2R5O1xuICAgICAgYy5tX3ByZXYgPSBudWxsO1xuICAgICAgYy5tX25leHQgPSB0aGlzLm1fd29ybGQubV9jb250YWN0TGlzdDtcbiAgICAgIGlmICh0aGlzLm1fd29ybGQubV9jb250YWN0TGlzdCAhPSBudWxsKSB7XG4gICAgICAgICB0aGlzLm1fd29ybGQubV9jb250YWN0TGlzdC5tX3ByZXYgPSBjO1xuICAgICAgfVxuICAgICAgdGhpcy5tX3dvcmxkLm1fY29udGFjdExpc3QgPSBjO1xuICAgICAgYy5tX25vZGVBLmNvbnRhY3QgPSBjO1xuICAgICAgYy5tX25vZGVBLm90aGVyID0gYm9keUI7XG4gICAgICBjLm1fbm9kZUEucHJldiA9IG51bGw7XG4gICAgICBjLm1fbm9kZUEubmV4dCA9IGJvZHlBLm1fY29udGFjdExpc3Q7XG4gICAgICBpZiAoYm9keUEubV9jb250YWN0TGlzdCAhPSBudWxsKSB7XG4gICAgICAgICBib2R5QS5tX2NvbnRhY3RMaXN0LnByZXYgPSBjLm1fbm9kZUE7XG4gICAgICB9XG4gICAgICBib2R5QS5tX2NvbnRhY3RMaXN0ID0gYy5tX25vZGVBO1xuICAgICAgYy5tX25vZGVCLmNvbnRhY3QgPSBjO1xuICAgICAgYy5tX25vZGVCLm90aGVyID0gYm9keUE7XG4gICAgICBjLm1fbm9kZUIucHJldiA9IG51bGw7XG4gICAgICBjLm1fbm9kZUIubmV4dCA9IGJvZHlCLm1fY29udGFjdExpc3Q7XG4gICAgICBpZiAoYm9keUIubV9jb250YWN0TGlzdCAhPSBudWxsKSB7XG4gICAgICAgICBib2R5Qi5tX2NvbnRhY3RMaXN0LnByZXYgPSBjLm1fbm9kZUI7XG4gICAgICB9XG4gICAgICBib2R5Qi5tX2NvbnRhY3RMaXN0ID0gYy5tX25vZGVCO1xuICAgICAgKyt0aGlzLm1fd29ybGQubV9jb250YWN0Q291bnQ7XG4gICAgICByZXR1cm47XG4gICB9XG4gICBiMkNvbnRhY3RNYW5hZ2VyLnByb3RvdHlwZS5GaW5kTmV3Q29udGFjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fYnJvYWRQaGFzZS5VcGRhdGVQYWlycyhCb3gyRC5nZW5lcmF0ZUNhbGxiYWNrKHRoaXMsIHRoaXMuQWRkUGFpcikpO1xuICAgfVxuICAgYjJDb250YWN0TWFuYWdlci5wcm90b3R5cGUuRGVzdHJveSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgZml4dHVyZUEgPSBjLkdldEZpeHR1cmVBKCk7XG4gICAgICB2YXIgZml4dHVyZUIgPSBjLkdldEZpeHR1cmVCKCk7XG4gICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5HZXRCb2R5KCk7XG4gICAgICBpZiAoYy5Jc1RvdWNoaW5nKCkpIHtcbiAgICAgICAgIHRoaXMubV9jb250YWN0TGlzdGVuZXIuRW5kQ29udGFjdChjKTtcbiAgICAgIH1cbiAgICAgIGlmIChjLm1fcHJldikge1xuICAgICAgICAgYy5tX3ByZXYubV9uZXh0ID0gYy5tX25leHQ7XG4gICAgICB9XG4gICAgICBpZiAoYy5tX25leHQpIHtcbiAgICAgICAgIGMubV9uZXh0Lm1fcHJldiA9IGMubV9wcmV2O1xuICAgICAgfVxuICAgICAgaWYgKGMgPT0gdGhpcy5tX3dvcmxkLm1fY29udGFjdExpc3QpIHtcbiAgICAgICAgIHRoaXMubV93b3JsZC5tX2NvbnRhY3RMaXN0ID0gYy5tX25leHQ7XG4gICAgICB9XG4gICAgICBpZiAoYy5tX25vZGVBLnByZXYpIHtcbiAgICAgICAgIGMubV9ub2RlQS5wcmV2Lm5leHQgPSBjLm1fbm9kZUEubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChjLm1fbm9kZUEubmV4dCkge1xuICAgICAgICAgYy5tX25vZGVBLm5leHQucHJldiA9IGMubV9ub2RlQS5wcmV2O1xuICAgICAgfVxuICAgICAgaWYgKGMubV9ub2RlQSA9PSBib2R5QS5tX2NvbnRhY3RMaXN0KSB7XG4gICAgICAgICBib2R5QS5tX2NvbnRhY3RMaXN0ID0gYy5tX25vZGVBLm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAoYy5tX25vZGVCLnByZXYpIHtcbiAgICAgICAgIGMubV9ub2RlQi5wcmV2Lm5leHQgPSBjLm1fbm9kZUIubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChjLm1fbm9kZUIubmV4dCkge1xuICAgICAgICAgYy5tX25vZGVCLm5leHQucHJldiA9IGMubV9ub2RlQi5wcmV2O1xuICAgICAgfVxuICAgICAgaWYgKGMubV9ub2RlQiA9PSBib2R5Qi5tX2NvbnRhY3RMaXN0KSB7XG4gICAgICAgICBib2R5Qi5tX2NvbnRhY3RMaXN0ID0gYy5tX25vZGVCLm5leHQ7XG4gICAgICB9XG4gICAgICB0aGlzLm1fY29udGFjdEZhY3RvcnkuRGVzdHJveShjKTtcbiAgICAgIC0tdGhpcy5tX2NvbnRhY3RDb3VudDtcbiAgIH1cbiAgIGIyQ29udGFjdE1hbmFnZXIucHJvdG90eXBlLkNvbGxpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYyA9IHRoaXMubV93b3JsZC5tX2NvbnRhY3RMaXN0O1xuICAgICAgd2hpbGUgKGMpIHtcbiAgICAgICAgIHZhciBmaXh0dXJlQSA9IGMuR2V0Rml4dHVyZUEoKTtcbiAgICAgICAgIHZhciBmaXh0dXJlQiA9IGMuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLkdldEJvZHkoKTtcbiAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLkdldEJvZHkoKTtcbiAgICAgICAgIGlmIChib2R5QS5Jc0F3YWtlKCkgPT0gZmFsc2UgJiYgYm9keUIuSXNBd2FrZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICBjID0gYy5HZXROZXh0KCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChjLm1fZmxhZ3MgJiBiMkNvbnRhY3QuZV9maWx0ZXJGbGFnKSB7XG4gICAgICAgICAgICBpZiAoYm9keUIuU2hvdWxkQ29sbGlkZShib2R5QSkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgIHZhciBjTnVrZSA9IGM7XG4gICAgICAgICAgICAgICBjID0gY051a2UuR2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgdGhpcy5EZXN0cm95KGNOdWtlKTtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubV9jb250YWN0RmlsdGVyLlNob3VsZENvbGxpZGUoZml4dHVyZUEsIGZpeHR1cmVCKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgY051a2UgPSBjO1xuICAgICAgICAgICAgICAgYyA9IGNOdWtlLkdldE5leHQoKTtcbiAgICAgICAgICAgICAgIHRoaXMuRGVzdHJveShjTnVrZSk7XG4gICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMubV9mbGFncyAmPSB+YjJDb250YWN0LmVfZmlsdGVyRmxhZztcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciBwcm94eUEgPSBmaXh0dXJlQS5tX3Byb3h5O1xuICAgICAgICAgdmFyIHByb3h5QiA9IGZpeHR1cmVCLm1fcHJveHk7XG4gICAgICAgICB2YXIgb3ZlcmxhcCA9IHRoaXMubV9icm9hZFBoYXNlLlRlc3RPdmVybGFwKHByb3h5QSwgcHJveHlCKTtcbiAgICAgICAgIGlmIChvdmVybGFwID09IGZhbHNlKSB7XG4gICAgICAgICAgICBjTnVrZSA9IGM7XG4gICAgICAgICAgICBjID0gY051a2UuR2V0TmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5EZXN0cm95KGNOdWtlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgYy5VcGRhdGUodGhpcy5tX2NvbnRhY3RMaXN0ZW5lcik7XG4gICAgICAgICBjID0gYy5HZXROZXh0KCk7XG4gICAgICB9XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIuc19ldmFsQ1AgPSBuZXcgYjJDb250YWN0UG9pbnQoKTtcbiAgIH0pO1xuICAgYjJEZWJ1Z0RyYXcuYjJEZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoKSB7fTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5iMkRlYnVnRHJhdyA9IGZ1bmN0aW9uICgpIHt9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0RmxhZ3MgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RmxhZ3MgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkFwcGVuZEZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XG4gICAgICBpZiAoZmxhZ3MgPT09IHVuZGVmaW5lZCkgZmxhZ3MgPSAwO1xuICAgfVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkNsZWFyRmxhZ3MgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0U3ByaXRlID0gZnVuY3Rpb24gKHNwcml0ZSkge31cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXRTcHJpdGUgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldERyYXdTY2FsZSA9IGZ1bmN0aW9uIChkcmF3U2NhbGUpIHtcbiAgICAgIGlmIChkcmF3U2NhbGUgPT09IHVuZGVmaW5lZCkgZHJhd1NjYWxlID0gMDtcbiAgIH1cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXREcmF3U2NhbGUgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldExpbmVUaGlja25lc3MgPSBmdW5jdGlvbiAobGluZVRoaWNrbmVzcykge1xuICAgICAgaWYgKGxpbmVUaGlja25lc3MgPT09IHVuZGVmaW5lZCkgbGluZVRoaWNrbmVzcyA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0TGluZVRoaWNrbmVzcyA9IGZ1bmN0aW9uICgpIHt9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0QWxwaGEgPSBmdW5jdGlvbiAoYWxwaGEpIHtcbiAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSBhbHBoYSA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0QWxwaGEgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldEZpbGxBbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIGFscGhhID0gMDtcbiAgIH1cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXRGaWxsQWxwaGEgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldFhGb3JtU2NhbGUgPSBmdW5jdGlvbiAoeGZvcm1TY2FsZSkge1xuICAgICAgaWYgKHhmb3JtU2NhbGUgPT09IHVuZGVmaW5lZCkgeGZvcm1TY2FsZSA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0WEZvcm1TY2FsZSA9IGZ1bmN0aW9uICgpIHt9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd1BvbHlnb24gPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50LCBjb2xvcikge1xuICAgICAgaWYgKHZlcnRleENvdW50ID09PSB1bmRlZmluZWQpIHZlcnRleENvdW50ID0gMDtcbiAgIH1cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3U29saWRQb2x5Z29uID0gZnVuY3Rpb24gKHZlcnRpY2VzLCB2ZXJ0ZXhDb3VudCwgY29sb3IpIHtcbiAgICAgIGlmICh2ZXJ0ZXhDb3VudCA9PT0gdW5kZWZpbmVkKSB2ZXJ0ZXhDb3VudCA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd0NpcmNsZSA9IGZ1bmN0aW9uIChjZW50ZXIsIHJhZGl1cywgY29sb3IpIHtcbiAgICAgIGlmIChyYWRpdXMgPT09IHVuZGVmaW5lZCkgcmFkaXVzID0gMDtcbiAgIH1cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3U29saWRDaXJjbGUgPSBmdW5jdGlvbiAoY2VudGVyLCByYWRpdXMsIGF4aXMsIGNvbG9yKSB7XG4gICAgICBpZiAocmFkaXVzID09PSB1bmRlZmluZWQpIHJhZGl1cyA9IDA7XG4gICB9XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd1NlZ21lbnQgPSBmdW5jdGlvbiAocDEsIHAyLCBjb2xvcikge31cbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3VHJhbnNmb3JtID0gZnVuY3Rpb24gKHhmKSB7fVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdy5lX3NoYXBlQml0ID0gMHgwMDAxO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcuZV9qb2ludEJpdCA9IDB4MDAwMjtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LmVfYWFiYkJpdCA9IDB4MDAwNDtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LmVfcGFpckJpdCA9IDB4MDAwODtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LmVfY2VudGVyT2ZNYXNzQml0ID0gMHgwMDEwO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcuZV9jb250cm9sbGVyQml0ID0gMHgwMDIwO1xuICAgfSk7XG4gICBiMkRlc3RydWN0aW9uTGlzdGVuZXIuYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkRlc3RydWN0aW9uTGlzdGVuZXIucHJvdG90eXBlLlNheUdvb2RieWVKb2ludCA9IGZ1bmN0aW9uIChqb2ludCkge31cbiAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lci5wcm90b3R5cGUuU2F5R29vZGJ5ZUZpeHR1cmUgPSBmdW5jdGlvbiAoZml4dHVyZSkge31cbiAgIGIyRmlsdGVyRGF0YS5iMkZpbHRlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhdGVnb3J5Qml0cyA9IDB4MDAwMTtcbiAgICAgIHRoaXMubWFza0JpdHMgPSAweEZGRkY7XG4gICAgICB0aGlzLmdyb3VwSW5kZXggPSAwO1xuICAgfTtcbiAgIGIyRmlsdGVyRGF0YS5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb3B5ID0gbmV3IGIyRmlsdGVyRGF0YSgpO1xuICAgICAgY29weS5jYXRlZ29yeUJpdHMgPSB0aGlzLmNhdGVnb3J5Qml0cztcbiAgICAgIGNvcHkubWFza0JpdHMgPSB0aGlzLm1hc2tCaXRzO1xuICAgICAgY29weS5ncm91cEluZGV4ID0gdGhpcy5ncm91cEluZGV4O1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICB9XG4gICBiMkZpeHR1cmUuYjJGaXh0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX2ZpbHRlciA9IG5ldyBiMkZpbHRlckRhdGEoKTtcbiAgIH07XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLkdldFR5cGUoKTtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuR2V0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3NoYXBlO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5TZXRTZW5zb3IgPSBmdW5jdGlvbiAoc2Vuc29yKSB7XG4gICAgICBpZiAodGhpcy5tX2lzU2Vuc29yID09IHNlbnNvcikgcmV0dXJuO1xuICAgICAgdGhpcy5tX2lzU2Vuc29yID0gc2Vuc29yO1xuICAgICAgaWYgKHRoaXMubV9ib2R5ID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5tX2JvZHkuR2V0Q29udGFjdExpc3QoKTtcbiAgICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgICB2YXIgY29udGFjdCA9IGVkZ2UuY29udGFjdDtcbiAgICAgICAgIHZhciBmaXh0dXJlQSA9IGNvbnRhY3QuR2V0Rml4dHVyZUEoKTtcbiAgICAgICAgIHZhciBmaXh0dXJlQiA9IGNvbnRhY3QuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgIGlmIChmaXh0dXJlQSA9PSB0aGlzIHx8IGZpeHR1cmVCID09IHRoaXMpIGNvbnRhY3QuU2V0U2Vuc29yKGZpeHR1cmVBLklzU2Vuc29yKCkgfHwgZml4dHVyZUIuSXNTZW5zb3IoKSk7XG4gICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgfVxuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5Jc1NlbnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1faXNTZW5zb3I7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlNldEZpbHRlckRhdGEgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICB0aGlzLm1fZmlsdGVyID0gZmlsdGVyLkNvcHkoKTtcbiAgICAgIGlmICh0aGlzLm1fYm9keSkgcmV0dXJuO1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLm1fYm9keS5HZXRDb250YWN0TGlzdCgpO1xuICAgICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgIHZhciBjb250YWN0ID0gZWRnZS5jb250YWN0O1xuICAgICAgICAgdmFyIGZpeHR1cmVBID0gY29udGFjdC5HZXRGaXh0dXJlQSgpO1xuICAgICAgICAgdmFyIGZpeHR1cmVCID0gY29udGFjdC5HZXRGaXh0dXJlQigpO1xuICAgICAgICAgaWYgKGZpeHR1cmVBID09IHRoaXMgfHwgZml4dHVyZUIgPT0gdGhpcykgY29udGFjdC5GbGFnRm9yRmlsdGVyaW5nKCk7XG4gICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgfVxuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRGaWx0ZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9maWx0ZXIuQ29weSgpO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRCb2R5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5O1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9uZXh0O1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRVc2VyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdXNlckRhdGE7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRhdGE7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlRlc3RQb2ludCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLlRlc3RQb2ludCh0aGlzLm1fYm9keS5HZXRUcmFuc2Zvcm0oKSwgcCk7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9zaGFwZS5SYXlDYXN0KG91dHB1dCwgaW5wdXQsIHRoaXMubV9ib2R5LkdldFRyYW5zZm9ybSgpKTtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuR2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAobWFzc0RhdGEpIHtcbiAgICAgIGlmIChtYXNzRGF0YSA9PT0gdW5kZWZpbmVkKSBtYXNzRGF0YSA9IG51bGw7XG4gICAgICBpZiAobWFzc0RhdGEgPT0gbnVsbCkge1xuICAgICAgICAgbWFzc0RhdGEgPSBuZXcgYjJNYXNzRGF0YSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5tX3NoYXBlLkNvbXB1dGVNYXNzKG1hc3NEYXRhLCB0aGlzLm1fZGVuc2l0eSk7XG4gICAgICByZXR1cm4gbWFzc0RhdGE7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlNldERlbnNpdHkgPSBmdW5jdGlvbiAoZGVuc2l0eSkge1xuICAgICAgaWYgKGRlbnNpdHkgPT09IHVuZGVmaW5lZCkgZGVuc2l0eSA9IDA7XG4gICAgICB0aGlzLm1fZGVuc2l0eSA9IGRlbnNpdHk7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkdldERlbnNpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RlbnNpdHk7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkdldEZyaWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9mcmljdGlvbjtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuU2V0RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24pIHtcbiAgICAgIGlmIChmcmljdGlvbiA9PT0gdW5kZWZpbmVkKSBmcmljdGlvbiA9IDA7XG4gICAgICB0aGlzLm1fZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuR2V0UmVzdGl0dXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3Jlc3RpdHV0aW9uO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5TZXRSZXN0aXR1dGlvbiA9IGZ1bmN0aW9uIChyZXN0aXR1dGlvbikge1xuICAgICAgaWYgKHJlc3RpdHV0aW9uID09PSB1bmRlZmluZWQpIHJlc3RpdHV0aW9uID0gMDtcbiAgICAgIHRoaXMubV9yZXN0aXR1dGlvbiA9IHJlc3RpdHV0aW9uO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRBQUJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9hYWJiO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5iMkZpeHR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fYWFiYiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHRoaXMubV91c2VyRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLm1fYm9keSA9IG51bGw7XG4gICAgICB0aGlzLm1fbmV4dCA9IG51bGw7XG4gICAgICB0aGlzLm1fc2hhcGUgPSBudWxsO1xuICAgICAgdGhpcy5tX2RlbnNpdHkgPSAwLjA7XG4gICAgICB0aGlzLm1fZnJpY3Rpb24gPSAwLjA7XG4gICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSAwLjA7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkNyZWF0ZSA9IGZ1bmN0aW9uIChib2R5LCB4ZiwgZGVmKSB7XG4gICAgICB0aGlzLm1fdXNlckRhdGEgPSBkZWYudXNlckRhdGE7XG4gICAgICB0aGlzLm1fZnJpY3Rpb24gPSBkZWYuZnJpY3Rpb247XG4gICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSBkZWYucmVzdGl0dXRpb247XG4gICAgICB0aGlzLm1fYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLm1fbmV4dCA9IG51bGw7XG4gICAgICB0aGlzLm1fZmlsdGVyID0gZGVmLmZpbHRlci5Db3B5KCk7XG4gICAgICB0aGlzLm1faXNTZW5zb3IgPSBkZWYuaXNTZW5zb3I7XG4gICAgICB0aGlzLm1fc2hhcGUgPSBkZWYuc2hhcGUuQ29weSgpO1xuICAgICAgdGhpcy5tX2RlbnNpdHkgPSBkZWYuZGVuc2l0eTtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9zaGFwZSA9IG51bGw7XG4gICB9XG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkNyZWF0ZVByb3h5ID0gZnVuY3Rpb24gKGJyb2FkUGhhc2UsIHhmKSB7XG4gICAgICB0aGlzLm1fc2hhcGUuQ29tcHV0ZUFBQkIodGhpcy5tX2FhYmIsIHhmKTtcbiAgICAgIHRoaXMubV9wcm94eSA9IGJyb2FkUGhhc2UuQ3JlYXRlUHJveHkodGhpcy5tX2FhYmIsIHRoaXMpO1xuICAgfVxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5EZXN0cm95UHJveHkgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSkge1xuICAgICAgaWYgKHRoaXMubV9wcm94eSA9PSBudWxsKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicm9hZFBoYXNlLkRlc3Ryb3lQcm94eSh0aGlzLm1fcHJveHkpO1xuICAgICAgdGhpcy5tX3Byb3h5ID0gbnVsbDtcbiAgIH1cbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuU3luY2hyb25pemUgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSwgdHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICAgICAgaWYgKCF0aGlzLm1fcHJveHkpIHJldHVybjtcbiAgICAgIHZhciBhYWJiMSA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHZhciBhYWJiMiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHRoaXMubV9zaGFwZS5Db21wdXRlQUFCQihhYWJiMSwgdHJhbnNmb3JtMSk7XG4gICAgICB0aGlzLm1fc2hhcGUuQ29tcHV0ZUFBQkIoYWFiYjIsIHRyYW5zZm9ybTIpO1xuICAgICAgdGhpcy5tX2FhYmIuQ29tYmluZShhYWJiMSwgYWFiYjIpO1xuICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IGIyTWF0aC5TdWJ0cmFjdFZWKHRyYW5zZm9ybTIucG9zaXRpb24sIHRyYW5zZm9ybTEucG9zaXRpb24pO1xuICAgICAgYnJvYWRQaGFzZS5Nb3ZlUHJveHkodGhpcy5tX3Byb3h5LCB0aGlzLm1fYWFiYiwgZGlzcGxhY2VtZW50KTtcbiAgIH1cbiAgIGIyRml4dHVyZURlZi5iMkZpeHR1cmVEZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmZpbHRlciA9IG5ldyBiMkZpbHRlckRhdGEoKTtcbiAgIH07XG4gICBiMkZpeHR1cmVEZWYucHJvdG90eXBlLmIyRml4dHVyZURlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2hhcGUgPSBudWxsO1xuICAgICAgdGhpcy51c2VyRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmZyaWN0aW9uID0gMC4yO1xuICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IDAuMDtcbiAgICAgIHRoaXMuZGVuc2l0eSA9IDAuMDtcbiAgICAgIHRoaXMuZmlsdGVyLmNhdGVnb3J5Qml0cyA9IDB4MDAwMTtcbiAgICAgIHRoaXMuZmlsdGVyLm1hc2tCaXRzID0gMHhGRkZGO1xuICAgICAgdGhpcy5maWx0ZXIuZ3JvdXBJbmRleCA9IDA7XG4gICAgICB0aGlzLmlzU2Vuc29yID0gZmFsc2U7XG4gICB9XG4gICBiMklzbGFuZC5iMklzbGFuZCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJJc2xhbmQucHJvdG90eXBlLmIySXNsYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX2JvZGllcyA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHRoaXMubV9jb250YWN0cyA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHRoaXMubV9qb2ludHMgPSBuZXcgVmVjdG9yKCk7XG4gICB9XG4gICBiMklzbGFuZC5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChib2R5Q2FwYWNpdHksIGNvbnRhY3RDYXBhY2l0eSwgam9pbnRDYXBhY2l0eSwgYWxsb2NhdG9yLCBsaXN0ZW5lciwgY29udGFjdFNvbHZlcikge1xuICAgICAgaWYgKGJvZHlDYXBhY2l0eSA9PT0gdW5kZWZpbmVkKSBib2R5Q2FwYWNpdHkgPSAwO1xuICAgICAgaWYgKGNvbnRhY3RDYXBhY2l0eSA9PT0gdW5kZWZpbmVkKSBjb250YWN0Q2FwYWNpdHkgPSAwO1xuICAgICAgaWYgKGpvaW50Q2FwYWNpdHkgPT09IHVuZGVmaW5lZCkgam9pbnRDYXBhY2l0eSA9IDA7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB0aGlzLm1fYm9keUNhcGFjaXR5ID0gYm9keUNhcGFjaXR5O1xuICAgICAgdGhpcy5tX2NvbnRhY3RDYXBhY2l0eSA9IGNvbnRhY3RDYXBhY2l0eTtcbiAgICAgIHRoaXMubV9qb2ludENhcGFjaXR5ID0gam9pbnRDYXBhY2l0eTtcbiAgICAgIHRoaXMubV9ib2R5Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2NvbnRhY3RDb3VudCA9IDA7XG4gICAgICB0aGlzLm1fam9pbnRDb3VudCA9IDA7XG4gICAgICB0aGlzLm1fYWxsb2NhdG9yID0gYWxsb2NhdG9yO1xuICAgICAgdGhpcy5tX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzLm1fY29udGFjdFNvbHZlciA9IGNvbnRhY3RTb2x2ZXI7XG4gICAgICBmb3IgKGkgPSB0aGlzLm1fYm9kaWVzLmxlbmd0aDtcbiAgICAgIGkgPCBib2R5Q2FwYWNpdHk7IGkrKylcbiAgICAgIHRoaXMubV9ib2RpZXNbaV0gPSBudWxsO1xuICAgICAgZm9yIChpID0gdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDtcbiAgICAgIGkgPCBjb250YWN0Q2FwYWNpdHk7IGkrKylcbiAgICAgIHRoaXMubV9jb250YWN0c1tpXSA9IG51bGw7XG4gICAgICBmb3IgKGkgPSB0aGlzLm1fam9pbnRzLmxlbmd0aDtcbiAgICAgIGkgPCBqb2ludENhcGFjaXR5OyBpKyspXG4gICAgICB0aGlzLm1fam9pbnRzW2ldID0gbnVsbDtcbiAgIH1cbiAgIGIySXNsYW5kLnByb3RvdHlwZS5DbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9ib2R5Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2NvbnRhY3RDb3VudCA9IDA7XG4gICAgICB0aGlzLm1fam9pbnRDb3VudCA9IDA7XG4gICB9XG4gICBiMklzbGFuZC5wcm90b3R5cGUuU29sdmUgPSBmdW5jdGlvbiAoc3RlcCwgZ3Jhdml0eSwgYWxsb3dTbGVlcCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIGI7XG4gICAgICB2YXIgam9pbnQ7XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHRoaXMubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgYiA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgICBpZiAoYi5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSBjb250aW51ZTtcbiAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS54ICs9IHN0ZXAuZHQgKiAoZ3Jhdml0eS54ICsgYi5tX2ludk1hc3MgKiBiLm1fZm9yY2UueCk7XG4gICAgICAgICBiLm1fbGluZWFyVmVsb2NpdHkueSArPSBzdGVwLmR0ICogKGdyYXZpdHkueSArIGIubV9pbnZNYXNzICogYi5tX2ZvcmNlLnkpO1xuICAgICAgICAgYi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBzdGVwLmR0ICogYi5tX2ludkkgKiBiLm1fdG9ycXVlO1xuICAgICAgICAgYi5tX2xpbmVhclZlbG9jaXR5Lk11bHRpcGx5KGIyTWF0aC5DbGFtcCgxLjAgLSBzdGVwLmR0ICogYi5tX2xpbmVhckRhbXBpbmcsIDAuMCwgMS4wKSk7XG4gICAgICAgICBiLm1fYW5ndWxhclZlbG9jaXR5ICo9IGIyTWF0aC5DbGFtcCgxLjAgLSBzdGVwLmR0ICogYi5tX2FuZ3VsYXJEYW1waW5nLCAwLjAsIDEuMCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fY29udGFjdFNvbHZlci5Jbml0aWFsaXplKHN0ZXAsIHRoaXMubV9jb250YWN0cywgdGhpcy5tX2NvbnRhY3RDb3VudCwgdGhpcy5tX2FsbG9jYXRvcik7XG4gICAgICB2YXIgY29udGFjdFNvbHZlciA9IHRoaXMubV9jb250YWN0U29sdmVyO1xuICAgICAgY29udGFjdFNvbHZlci5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyhzdGVwKTtcbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgam9pbnQgPSB0aGlzLm1fam9pbnRzW2ldO1xuICAgICAgICAgam9pbnQuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMoc3RlcCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgIGZvciAoaiA9IDA7XG4gICAgICAgICBqIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgam9pbnQgPSB0aGlzLm1fam9pbnRzW2pdO1xuICAgICAgICAgICAgam9pbnQuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHN0ZXApO1xuICAgICAgICAgfVxuICAgICAgICAgY29udGFjdFNvbHZlci5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgam9pbnQgPSB0aGlzLm1fam9pbnRzW2ldO1xuICAgICAgICAgam9pbnQuRmluYWxpemVWZWxvY2l0eUNvbnN0cmFpbnRzKCk7XG4gICAgICB9XG4gICAgICBjb250YWN0U29sdmVyLkZpbmFsaXplVmVsb2NpdHlDb25zdHJhaW50cygpO1xuICAgICAgZm9yIChpID0gMDtcbiAgICAgIGkgPCB0aGlzLm1fYm9keUNvdW50OyArK2kpIHtcbiAgICAgICAgIGIgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSBjb250aW51ZTtcbiAgICAgICAgIHZhciB0cmFuc2xhdGlvblggPSBzdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lng7XG4gICAgICAgICB2YXIgdHJhbnNsYXRpb25ZID0gc3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS55O1xuICAgICAgICAgaWYgKCh0cmFuc2xhdGlvblggKiB0cmFuc2xhdGlvblggKyB0cmFuc2xhdGlvblkgKiB0cmFuc2xhdGlvblkpID4gYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvblNxdWFyZWQpIHtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS5Ob3JtYWxpemUoKTtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS54ICo9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBzdGVwLmludl9kdDtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS55ICo9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBzdGVwLmludl9kdDtcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciByb3RhdGlvbiA9IHN0ZXAuZHQgKiBiLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uU3F1YXJlZCkge1xuICAgICAgICAgICAgaWYgKGIubV9hbmd1bGFyVmVsb2NpdHkgPCAwLjApIHtcbiAgICAgICAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgPSAoLWIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb24gKiBzdGVwLmludl9kdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgPSBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uICogc3RlcC5pbnZfZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBiLm1fc3dlZXAuYzAuU2V0VihiLm1fc3dlZXAuYyk7XG4gICAgICAgICBiLm1fc3dlZXAuYTAgPSBiLm1fc3dlZXAuYTtcbiAgICAgICAgIGIubV9zd2VlcC5jLnggKz0gc3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS54O1xuICAgICAgICAgYi5tX3N3ZWVwLmMueSArPSBzdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lnk7XG4gICAgICAgICBiLm1fc3dlZXAuYSArPSBzdGVwLmR0ICogYi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgIGIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgc3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgdmFyIGNvbnRhY3RzT2theSA9IGNvbnRhY3RTb2x2ZXIuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKGIyU2V0dGluZ3MuYjJfY29udGFjdEJhdW1nYXJ0ZSk7XG4gICAgICAgICB2YXIgam9pbnRzT2theSA9IHRydWU7XG4gICAgICAgICBmb3IgKGogPSAwO1xuICAgICAgICAgaiA8IHRoaXMubV9qb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgIGpvaW50ID0gdGhpcy5tX2pvaW50c1tqXTtcbiAgICAgICAgICAgIHZhciBqb2ludE9rYXkgPSBqb2ludC5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoYjJTZXR0aW5ncy5iMl9jb250YWN0QmF1bWdhcnRlKTtcbiAgICAgICAgICAgIGpvaW50c09rYXkgPSBqb2ludHNPa2F5ICYmIGpvaW50T2theTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChjb250YWN0c09rYXkgJiYgam9pbnRzT2theSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLlJlcG9ydChjb250YWN0U29sdmVyLm1fY29uc3RyYWludHMpO1xuICAgICAgaWYgKGFsbG93U2xlZXApIHtcbiAgICAgICAgIHZhciBtaW5TbGVlcFRpbWUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgdmFyIGxpblRvbFNxciA9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xlZXBUb2xlcmFuY2UgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsZWVwVG9sZXJhbmNlO1xuICAgICAgICAgdmFyIGFuZ1RvbFNxciA9IGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsZWVwVG9sZXJhbmNlICogYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xlZXBUb2xlcmFuY2U7XG4gICAgICAgICBmb3IgKGkgPSAwO1xuICAgICAgICAgaSA8IHRoaXMubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgYiA9IHRoaXMubV9ib2RpZXNbaV07XG4gICAgICAgICAgICBpZiAoYi5HZXRUeXBlKCkgPT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkpIHtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChiLm1fZmxhZ3MgJiBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZykgPT0gMCkge1xuICAgICAgICAgICAgICAgYi5tX3NsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYi5tX2ZsYWdzICYgYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWcpID09IDAgfHwgYi5tX2FuZ3VsYXJWZWxvY2l0eSAqIGIubV9hbmd1bGFyVmVsb2NpdHkgPiBhbmdUb2xTcXIgfHwgYjJNYXRoLkRvdChiLm1fbGluZWFyVmVsb2NpdHksIGIubV9saW5lYXJWZWxvY2l0eSkgPiBsaW5Ub2xTcXIpIHtcbiAgICAgICAgICAgICAgIGIubV9zbGVlcFRpbWUgPSAwLjA7XG4gICAgICAgICAgICAgICBtaW5TbGVlcFRpbWUgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIGIubV9zbGVlcFRpbWUgKz0gc3RlcC5kdDtcbiAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IGIyTWF0aC5NaW4obWluU2xlZXBUaW1lLCBiLm1fc2xlZXBUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChtaW5TbGVlcFRpbWUgPj0gYjJTZXR0aW5ncy5iMl90aW1lVG9TbGVlcCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgICAgIGkgPCB0aGlzLm1fYm9keUNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgIGIgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgYi5TZXRBd2FrZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBiMklzbGFuZC5wcm90b3R5cGUuU29sdmVUT0kgPSBmdW5jdGlvbiAoc3ViU3RlcCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdGhpcy5tX2NvbnRhY3RTb2x2ZXIuSW5pdGlhbGl6ZShzdWJTdGVwLCB0aGlzLm1fY29udGFjdHMsIHRoaXMubV9jb250YWN0Q291bnQsIHRoaXMubV9hbGxvY2F0b3IpO1xuICAgICAgdmFyIGNvbnRhY3RTb2x2ZXIgPSB0aGlzLm1fY29udGFjdFNvbHZlcjtcbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgdGhpcy5tX2pvaW50c1tpXS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyhzdWJTdGVwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7XG4gICAgICBpIDwgc3ViU3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgY29udGFjdFNvbHZlci5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoKTtcbiAgICAgICAgIGZvciAoaiA9IDA7XG4gICAgICAgICBqIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraikge1xuICAgICAgICAgICAgdGhpcy5tX2pvaW50c1tqXS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoc3ViU3RlcCk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHRoaXMubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgdmFyIGIgPSB0aGlzLm1fYm9kaWVzW2ldO1xuICAgICAgICAgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSBjb250aW51ZTtcbiAgICAgICAgIHZhciB0cmFuc2xhdGlvblggPSBzdWJTdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lng7XG4gICAgICAgICB2YXIgdHJhbnNsYXRpb25ZID0gc3ViU3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS55O1xuICAgICAgICAgaWYgKCh0cmFuc2xhdGlvblggKiB0cmFuc2xhdGlvblggKyB0cmFuc2xhdGlvblkgKiB0cmFuc2xhdGlvblkpID4gYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvblNxdWFyZWQpIHtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS5Ob3JtYWxpemUoKTtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS54ICo9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBzdWJTdGVwLmludl9kdDtcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS55ICo9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBzdWJTdGVwLmludl9kdDtcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciByb3RhdGlvbiA9IHN1YlN0ZXAuZHQgKiBiLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uU3F1YXJlZCkge1xuICAgICAgICAgICAgaWYgKGIubV9hbmd1bGFyVmVsb2NpdHkgPCAwLjApIHtcbiAgICAgICAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgPSAoLWIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb24gKiBzdWJTdGVwLmludl9kdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgPSBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uICogc3ViU3RlcC5pbnZfZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBiLm1fc3dlZXAuYzAuU2V0VihiLm1fc3dlZXAuYyk7XG4gICAgICAgICBiLm1fc3dlZXAuYTAgPSBiLm1fc3dlZXAuYTtcbiAgICAgICAgIGIubV9zd2VlcC5jLnggKz0gc3ViU3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS54O1xuICAgICAgICAgYi5tX3N3ZWVwLmMueSArPSBzdWJTdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lnk7XG4gICAgICAgICBiLm1fc3dlZXAuYSArPSBzdWJTdGVwLmR0ICogYi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgIGIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBrX3RvaUJhdW1nYXJ0ZSA9IDAuNzU7XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IHN1YlN0ZXAucG9zaXRpb25JdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgIHZhciBjb250YWN0c09rYXkgPSBjb250YWN0U29sdmVyLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyhrX3RvaUJhdW1nYXJ0ZSk7XG4gICAgICAgICB2YXIgam9pbnRzT2theSA9IHRydWU7XG4gICAgICAgICBmb3IgKGogPSAwO1xuICAgICAgICAgaiA8IHRoaXMubV9qb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgIHZhciBqb2ludE9rYXkgPSB0aGlzLm1fam9pbnRzW2pdLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyhiMlNldHRpbmdzLmIyX2NvbnRhY3RCYXVtZ2FydGUpO1xuICAgICAgICAgICAgam9pbnRzT2theSA9IGpvaW50c09rYXkgJiYgam9pbnRPa2F5O1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKGNvbnRhY3RzT2theSAmJiBqb2ludHNPa2F5KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuUmVwb3J0KGNvbnRhY3RTb2x2ZXIubV9jb25zdHJhaW50cyk7XG4gICB9XG4gICBiMklzbGFuZC5wcm90b3R5cGUuUmVwb3J0ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XG4gICAgICBpZiAodGhpcy5tX2xpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnRhY3RDb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgYyA9IHRoaXMubV9jb250YWN0c1tpXTtcbiAgICAgICAgIHZhciBjYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYy5wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgIGIySXNsYW5kLnNfaW1wdWxzZS5ub3JtYWxJbXB1bHNlc1tqXSA9IGNjLnBvaW50c1tqXS5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgYjJJc2xhbmQuc19pbXB1bHNlLnRhbmdlbnRJbXB1bHNlc1tqXSA9IGNjLnBvaW50c1tqXS50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMubV9saXN0ZW5lci5Qb3N0U29sdmUoYywgYjJJc2xhbmQuc19pbXB1bHNlKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIySXNsYW5kLnByb3RvdHlwZS5BZGRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgIGJvZHkubV9pc2xhbmRJbmRleCA9IHRoaXMubV9ib2R5Q291bnQ7XG4gICAgICB0aGlzLm1fYm9kaWVzW3RoaXMubV9ib2R5Q291bnQrK10gPSBib2R5O1xuICAgfVxuICAgYjJJc2xhbmQucHJvdG90eXBlLkFkZENvbnRhY3QgPSBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgdGhpcy5tX2NvbnRhY3RzW3RoaXMubV9jb250YWN0Q291bnQrK10gPSBjb250YWN0O1xuICAgfVxuICAgYjJJc2xhbmQucHJvdG90eXBlLkFkZEpvaW50ID0gZnVuY3Rpb24gKGpvaW50KSB7XG4gICAgICB0aGlzLm1fam9pbnRzW3RoaXMubV9qb2ludENvdW50KytdID0gam9pbnQ7XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIySXNsYW5kLnNfaW1wdWxzZSA9IG5ldyBiMkNvbnRhY3RJbXB1bHNlKCk7XG4gICB9KTtcbiAgIGIyVGltZVN0ZXAuYjJUaW1lU3RlcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJUaW1lU3RlcC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHRoaXMuZHQgPSBzdGVwLmR0O1xuICAgICAgdGhpcy5pbnZfZHQgPSBzdGVwLmludl9kdDtcbiAgICAgIHRoaXMucG9zaXRpb25JdGVyYXRpb25zID0gc3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnM7XG4gICAgICB0aGlzLnZlbG9jaXR5SXRlcmF0aW9ucyA9IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zO1xuICAgICAgdGhpcy53YXJtU3RhcnRpbmcgPSBzdGVwLndhcm1TdGFydGluZztcbiAgIH1cbiAgIGIyV29ybGQuYjJXb3JsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc19zdGFjayA9IG5ldyBWZWN0b3IoKTtcbiAgICAgIHRoaXMubV9jb250YWN0TWFuYWdlciA9IG5ldyBiMkNvbnRhY3RNYW5hZ2VyKCk7XG4gICAgICB0aGlzLm1fY29udGFjdFNvbHZlciA9IG5ldyBiMkNvbnRhY3RTb2x2ZXIoKTtcbiAgICAgIHRoaXMubV9pc2xhbmQgPSBuZXcgYjJJc2xhbmQoKTtcbiAgIH07XG4gICBiMldvcmxkLnByb3RvdHlwZS5iMldvcmxkID0gZnVuY3Rpb24gKGdyYXZpdHksIGRvU2xlZXApIHtcbiAgICAgIHRoaXMubV9kZXN0cnVjdGlvbkxpc3RlbmVyID0gbnVsbDtcbiAgICAgIHRoaXMubV9kZWJ1Z0RyYXcgPSBudWxsO1xuICAgICAgdGhpcy5tX2JvZHlMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9jb250YWN0TGlzdCA9IG51bGw7XG4gICAgICB0aGlzLm1fam9pbnRMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9jb250cm9sbGVyTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLm1fYm9keUNvdW50ID0gMDtcbiAgICAgIHRoaXMubV9jb250YWN0Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2pvaW50Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX2NvbnRyb2xsZXJDb3VudCA9IDA7XG4gICAgICBiMldvcmxkLm1fd2FybVN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAgIGIyV29ybGQubV9jb250aW51b3VzUGh5c2ljcyA9IHRydWU7XG4gICAgICB0aGlzLm1fYWxsb3dTbGVlcCA9IGRvU2xlZXA7XG4gICAgICB0aGlzLm1fZ3Jhdml0eSA9IGdyYXZpdHk7XG4gICAgICB0aGlzLm1faW52X2R0MCA9IDAuMDtcbiAgICAgIHRoaXMubV9jb250YWN0TWFuYWdlci5tX3dvcmxkID0gdGhpcztcbiAgICAgIHZhciBiZCA9IG5ldyBiMkJvZHlEZWYoKTtcbiAgICAgIHRoaXMubV9ncm91bmRCb2R5ID0gdGhpcy5DcmVhdGVCb2R5KGJkKTtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldERlc3RydWN0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMubV9kZXN0cnVjdGlvbkxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5TZXRDb250YWN0RmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fY29udGFjdEZpbHRlciA9IGZpbHRlcjtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldENvbnRhY3RMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fY29udGFjdExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5TZXREZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoZGVidWdEcmF3KSB7XG4gICAgICB0aGlzLm1fZGVidWdEcmF3ID0gZGVidWdEcmF3O1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuU2V0QnJvYWRQaGFzZSA9IGZ1bmN0aW9uIChicm9hZFBoYXNlKSB7XG4gICAgICB2YXIgb2xkQnJvYWRQaGFzZSA9IHRoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICB0aGlzLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlID0gYnJvYWRQaGFzZTtcbiAgICAgIGZvciAodmFyIGIgPSB0aGlzLm1fYm9keUxpc3Q7IGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgZm9yICh2YXIgZiA9IGIubV9maXh0dXJlTGlzdDsgZjsgZiA9IGYubV9uZXh0KSB7XG4gICAgICAgICAgICBmLm1fcHJveHkgPSBicm9hZFBoYXNlLkNyZWF0ZVByb3h5KG9sZEJyb2FkUGhhc2UuR2V0RmF0QUFCQihmLm1fcHJveHkpLCBmKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZS5WYWxpZGF0ZSgpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0UHJveHlDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlLkdldFByb3h5Q291bnQoKTtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkNyZWF0ZUJvZHkgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICBpZiAodGhpcy5Jc0xvY2tlZCgpID09IHRydWUpIHtcbiAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGIgPSBuZXcgYjJCb2R5KGRlZiwgdGhpcyk7XG4gICAgICBiLm1fcHJldiA9IG51bGw7XG4gICAgICBiLm1fbmV4dCA9IHRoaXMubV9ib2R5TGlzdDtcbiAgICAgIGlmICh0aGlzLm1fYm9keUxpc3QpIHtcbiAgICAgICAgIHRoaXMubV9ib2R5TGlzdC5tX3ByZXYgPSBiO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2JvZHlMaXN0ID0gYjtcbiAgICAgICsrdGhpcy5tX2JvZHlDb3VudDtcbiAgICAgIHJldHVybiBiO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuRGVzdHJveUJvZHkgPSBmdW5jdGlvbiAoYikge1xuICAgICAgaWYgKHRoaXMuSXNMb2NrZWQoKSA9PSB0cnVlKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgam4gPSBiLm1fam9pbnRMaXN0O1xuICAgICAgd2hpbGUgKGpuKSB7XG4gICAgICAgICB2YXIgam4wID0gam47XG4gICAgICAgICBqbiA9IGpuLm5leHQ7XG4gICAgICAgICBpZiAodGhpcy5tX2Rlc3RydWN0aW9uTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMubV9kZXN0cnVjdGlvbkxpc3RlbmVyLlNheUdvb2RieWVKb2ludChqbjAuam9pbnQpO1xuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5EZXN0cm95Sm9pbnQoam4wLmpvaW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2UgPSBiLm1fY29udHJvbGxlckxpc3Q7XG4gICAgICB3aGlsZSAoY29lKSB7XG4gICAgICAgICB2YXIgY29lMCA9IGNvZTtcbiAgICAgICAgIGNvZSA9IGNvZS5uZXh0Q29udHJvbGxlcjtcbiAgICAgICAgIGNvZTAuY29udHJvbGxlci5SZW1vdmVCb2R5KGIpO1xuICAgICAgfVxuICAgICAgdmFyIGNlID0gYi5tX2NvbnRhY3RMaXN0O1xuICAgICAgd2hpbGUgKGNlKSB7XG4gICAgICAgICB2YXIgY2UwID0gY2U7XG4gICAgICAgICBjZSA9IGNlLm5leHQ7XG4gICAgICAgICB0aGlzLm1fY29udGFjdE1hbmFnZXIuRGVzdHJveShjZTAuY29udGFjdCk7XG4gICAgICB9XG4gICAgICBiLm1fY29udGFjdExpc3QgPSBudWxsO1xuICAgICAgdmFyIGYgPSBiLm1fZml4dHVyZUxpc3Q7XG4gICAgICB3aGlsZSAoZikge1xuICAgICAgICAgdmFyIGYwID0gZjtcbiAgICAgICAgIGYgPSBmLm1fbmV4dDtcbiAgICAgICAgIGlmICh0aGlzLm1fZGVzdHJ1Y3Rpb25MaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5tX2Rlc3RydWN0aW9uTGlzdGVuZXIuU2F5R29vZGJ5ZUZpeHR1cmUoZjApO1xuICAgICAgICAgfVxuICAgICAgICAgZjAuRGVzdHJveVByb3h5KHRoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2UpO1xuICAgICAgICAgZjAuRGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgYi5tX2ZpeHR1cmVMaXN0ID0gbnVsbDtcbiAgICAgIGIubV9maXh0dXJlQ291bnQgPSAwO1xuICAgICAgaWYgKGIubV9wcmV2KSB7XG4gICAgICAgICBiLm1fcHJldi5tX25leHQgPSBiLm1fbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChiLm1fbmV4dCkge1xuICAgICAgICAgYi5tX25leHQubV9wcmV2ID0gYi5tX3ByZXY7XG4gICAgICB9XG4gICAgICBpZiAoYiA9PSB0aGlzLm1fYm9keUxpc3QpIHtcbiAgICAgICAgIHRoaXMubV9ib2R5TGlzdCA9IGIubV9uZXh0O1xuICAgICAgfS0tdGhpcy5tX2JvZHlDb3VudDtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkNyZWF0ZUpvaW50ID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgdmFyIGogPSBiMkpvaW50LkNyZWF0ZShkZWYsIG51bGwpO1xuICAgICAgai5tX3ByZXYgPSBudWxsO1xuICAgICAgai5tX25leHQgPSB0aGlzLm1fam9pbnRMaXN0O1xuICAgICAgaWYgKHRoaXMubV9qb2ludExpc3QpIHtcbiAgICAgICAgIHRoaXMubV9qb2ludExpc3QubV9wcmV2ID0gajtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9qb2ludExpc3QgPSBqO1xuICAgICAgKyt0aGlzLm1fam9pbnRDb3VudDtcbiAgICAgIGoubV9lZGdlQS5qb2ludCA9IGo7XG4gICAgICBqLm1fZWRnZUEub3RoZXIgPSBqLm1fYm9keUI7XG4gICAgICBqLm1fZWRnZUEucHJldiA9IG51bGw7XG4gICAgICBqLm1fZWRnZUEubmV4dCA9IGoubV9ib2R5QS5tX2pvaW50TGlzdDtcbiAgICAgIGlmIChqLm1fYm9keUEubV9qb2ludExpc3QpIGoubV9ib2R5QS5tX2pvaW50TGlzdC5wcmV2ID0gai5tX2VkZ2VBO1xuICAgICAgai5tX2JvZHlBLm1fam9pbnRMaXN0ID0gai5tX2VkZ2VBO1xuICAgICAgai5tX2VkZ2VCLmpvaW50ID0gajtcbiAgICAgIGoubV9lZGdlQi5vdGhlciA9IGoubV9ib2R5QTtcbiAgICAgIGoubV9lZGdlQi5wcmV2ID0gbnVsbDtcbiAgICAgIGoubV9lZGdlQi5uZXh0ID0gai5tX2JvZHlCLm1fam9pbnRMaXN0O1xuICAgICAgaWYgKGoubV9ib2R5Qi5tX2pvaW50TGlzdCkgai5tX2JvZHlCLm1fam9pbnRMaXN0LnByZXYgPSBqLm1fZWRnZUI7XG4gICAgICBqLm1fYm9keUIubV9qb2ludExpc3QgPSBqLm1fZWRnZUI7XG4gICAgICB2YXIgYm9keUEgPSBkZWYuYm9keUE7XG4gICAgICB2YXIgYm9keUIgPSBkZWYuYm9keUI7XG4gICAgICBpZiAoZGVmLmNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgIHZhciBlZGdlID0gYm9keUIuR2V0Q29udGFjdExpc3QoKTtcbiAgICAgICAgIHdoaWxlIChlZGdlKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBib2R5QSkge1xuICAgICAgICAgICAgICAgZWRnZS5jb250YWN0LkZsYWdGb3JGaWx0ZXJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gajtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkRlc3Ryb3lKb2ludCA9IGZ1bmN0aW9uIChqKSB7XG4gICAgICB2YXIgY29sbGlkZUNvbm5lY3RlZCA9IGoubV9jb2xsaWRlQ29ubmVjdGVkO1xuICAgICAgaWYgKGoubV9wcmV2KSB7XG4gICAgICAgICBqLm1fcHJldi5tX25leHQgPSBqLm1fbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChqLm1fbmV4dCkge1xuICAgICAgICAgai5tX25leHQubV9wcmV2ID0gai5tX3ByZXY7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PSB0aGlzLm1fam9pbnRMaXN0KSB7XG4gICAgICAgICB0aGlzLm1fam9pbnRMaXN0ID0gai5tX25leHQ7XG4gICAgICB9XG4gICAgICB2YXIgYm9keUEgPSBqLm1fYm9keUE7XG4gICAgICB2YXIgYm9keUIgPSBqLm1fYm9keUI7XG4gICAgICBib2R5QS5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIGJvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgaWYgKGoubV9lZGdlQS5wcmV2KSB7XG4gICAgICAgICBqLm1fZWRnZUEucHJldi5uZXh0ID0gai5tX2VkZ2VBLm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAoai5tX2VkZ2VBLm5leHQpIHtcbiAgICAgICAgIGoubV9lZGdlQS5uZXh0LnByZXYgPSBqLm1fZWRnZUEucHJldjtcbiAgICAgIH1cbiAgICAgIGlmIChqLm1fZWRnZUEgPT0gYm9keUEubV9qb2ludExpc3QpIHtcbiAgICAgICAgIGJvZHlBLm1fam9pbnRMaXN0ID0gai5tX2VkZ2VBLm5leHQ7XG4gICAgICB9XG4gICAgICBqLm1fZWRnZUEucHJldiA9IG51bGw7XG4gICAgICBqLm1fZWRnZUEubmV4dCA9IG51bGw7XG4gICAgICBpZiAoai5tX2VkZ2VCLnByZXYpIHtcbiAgICAgICAgIGoubV9lZGdlQi5wcmV2Lm5leHQgPSBqLm1fZWRnZUIubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChqLm1fZWRnZUIubmV4dCkge1xuICAgICAgICAgai5tX2VkZ2VCLm5leHQucHJldiA9IGoubV9lZGdlQi5wcmV2O1xuICAgICAgfVxuICAgICAgaWYgKGoubV9lZGdlQiA9PSBib2R5Qi5tX2pvaW50TGlzdCkge1xuICAgICAgICAgYm9keUIubV9qb2ludExpc3QgPSBqLm1fZWRnZUIubmV4dDtcbiAgICAgIH1cbiAgICAgIGoubV9lZGdlQi5wcmV2ID0gbnVsbDtcbiAgICAgIGoubV9lZGdlQi5uZXh0ID0gbnVsbDtcbiAgICAgIGIySm9pbnQuRGVzdHJveShqLCBudWxsKTtcbiAgICAgIC0tdGhpcy5tX2pvaW50Q291bnQ7XG4gICAgICBpZiAoY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZSkge1xuICAgICAgICAgdmFyIGVkZ2UgPSBib2R5Qi5HZXRDb250YWN0TGlzdCgpO1xuICAgICAgICAgd2hpbGUgKGVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLm90aGVyID09IGJvZHlBKSB7XG4gICAgICAgICAgICAgICBlZGdlLmNvbnRhY3QuRmxhZ0ZvckZpbHRlcmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkFkZENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgYy5tX25leHQgPSB0aGlzLm1fY29udHJvbGxlckxpc3Q7XG4gICAgICBjLm1fcHJldiA9IG51bGw7XG4gICAgICB0aGlzLm1fY29udHJvbGxlckxpc3QgPSBjO1xuICAgICAgYy5tX3dvcmxkID0gdGhpcztcbiAgICAgIHRoaXMubV9jb250cm9sbGVyQ291bnQrKztcbiAgICAgIHJldHVybiBjO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuUmVtb3ZlQ29udHJvbGxlciA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5tX3ByZXYpIGMubV9wcmV2Lm1fbmV4dCA9IGMubV9uZXh0O1xuICAgICAgaWYgKGMubV9uZXh0KSBjLm1fbmV4dC5tX3ByZXYgPSBjLm1fcHJldjtcbiAgICAgIGlmICh0aGlzLm1fY29udHJvbGxlckxpc3QgPT0gYykgdGhpcy5tX2NvbnRyb2xsZXJMaXN0ID0gYy5tX25leHQ7XG4gICAgICB0aGlzLm1fY29udHJvbGxlckNvdW50LS07XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5DcmVhdGVDb250cm9sbGVyID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChjb250cm9sbGVyLm1fd29ybGQgIT0gdGhpcykgdGhyb3cgbmV3IEVycm9yKFwiQ29udHJvbGxlciBjYW4gb25seSBiZSBhIG1lbWJlciBvZiBvbmUgd29ybGRcIik7XG4gICAgICBjb250cm9sbGVyLm1fbmV4dCA9IHRoaXMubV9jb250cm9sbGVyTGlzdDtcbiAgICAgIGNvbnRyb2xsZXIubV9wcmV2ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm1fY29udHJvbGxlckxpc3QpIHRoaXMubV9jb250cm9sbGVyTGlzdC5tX3ByZXYgPSBjb250cm9sbGVyO1xuICAgICAgdGhpcy5tX2NvbnRyb2xsZXJMaXN0ID0gY29udHJvbGxlcjtcbiAgICAgICsrdGhpcy5tX2NvbnRyb2xsZXJDb3VudDtcbiAgICAgIGNvbnRyb2xsZXIubV93b3JsZCA9IHRoaXM7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkRlc3Ryb3lDb250cm9sbGVyID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuQ2xlYXIoKTtcbiAgICAgIGlmIChjb250cm9sbGVyLm1fbmV4dCkgY29udHJvbGxlci5tX25leHQubV9wcmV2ID0gY29udHJvbGxlci5tX3ByZXY7XG4gICAgICBpZiAoY29udHJvbGxlci5tX3ByZXYpIGNvbnRyb2xsZXIubV9wcmV2Lm1fbmV4dCA9IGNvbnRyb2xsZXIubV9uZXh0O1xuICAgICAgaWYgKGNvbnRyb2xsZXIgPT0gdGhpcy5tX2NvbnRyb2xsZXJMaXN0KSB0aGlzLm1fY29udHJvbGxlckxpc3QgPSBjb250cm9sbGVyLm1fbmV4dDtcbiAgICAgIC0tdGhpcy5tX2NvbnRyb2xsZXJDb3VudDtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldFdhcm1TdGFydGluZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICBiMldvcmxkLm1fd2FybVN0YXJ0aW5nID0gZmxhZztcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldENvbnRpbnVvdXNQaHlzaWNzID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgIGIyV29ybGQubV9jb250aW51b3VzUGh5c2ljcyA9IGZsYWc7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5HZXRCb2R5Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlDb3VudDtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkdldEpvaW50Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2pvaW50Q291bnQ7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5HZXRDb250YWN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2NvbnRhY3RDb3VudDtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlNldEdyYXZpdHkgPSBmdW5jdGlvbiAoZ3Jhdml0eSkge1xuICAgICAgdGhpcy5tX2dyYXZpdHkgPSBncmF2aXR5O1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0R3Jhdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZ3Jhdml0eTtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkdldEdyb3VuZEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2dyb3VuZEJvZHk7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5TdGVwID0gZnVuY3Rpb24gKGR0LCB2ZWxvY2l0eUl0ZXJhdGlvbnMsIHBvc2l0aW9uSXRlcmF0aW9ucykge1xuICAgICAgaWYgKGR0ID09PSB1bmRlZmluZWQpIGR0ID0gMDtcbiAgICAgIGlmICh2ZWxvY2l0eUl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgdmVsb2NpdHlJdGVyYXRpb25zID0gMDtcbiAgICAgIGlmIChwb3NpdGlvbkl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgcG9zaXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgIGlmICh0aGlzLm1fZmxhZ3MgJiBiMldvcmxkLmVfbmV3Rml4dHVyZSkge1xuICAgICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLkZpbmROZXdDb250YWN0cygpO1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMldvcmxkLmVfbmV3Rml4dHVyZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9mbGFncyB8PSBiMldvcmxkLmVfbG9ja2VkO1xuICAgICAgdmFyIHN0ZXAgPSBiMldvcmxkLnNfdGltZXN0ZXAyO1xuICAgICAgc3RlcC5kdCA9IGR0O1xuICAgICAgc3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnMgPSB2ZWxvY2l0eUl0ZXJhdGlvbnM7XG4gICAgICBzdGVwLnBvc2l0aW9uSXRlcmF0aW9ucyA9IHBvc2l0aW9uSXRlcmF0aW9ucztcbiAgICAgIGlmIChkdCA+IDAuMCkge1xuICAgICAgICAgc3RlcC5pbnZfZHQgPSAxLjAgLyBkdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgc3RlcC5pbnZfZHQgPSAwLjA7XG4gICAgICB9XG4gICAgICBzdGVwLmR0UmF0aW8gPSB0aGlzLm1faW52X2R0MCAqIGR0O1xuICAgICAgc3RlcC53YXJtU3RhcnRpbmcgPSBiMldvcmxkLm1fd2FybVN0YXJ0aW5nO1xuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLkNvbGxpZGUoKTtcbiAgICAgIGlmIChzdGVwLmR0ID4gMC4wKSB7XG4gICAgICAgICB0aGlzLlNvbHZlKHN0ZXApO1xuICAgICAgfVxuICAgICAgaWYgKGIyV29ybGQubV9jb250aW51b3VzUGh5c2ljcyAmJiBzdGVwLmR0ID4gMC4wKSB7XG4gICAgICAgICB0aGlzLlNvbHZlVE9JKHN0ZXApO1xuICAgICAgfVxuICAgICAgaWYgKHN0ZXAuZHQgPiAwLjApIHtcbiAgICAgICAgIHRoaXMubV9pbnZfZHQwID0gc3RlcC5pbnZfZHQ7XG4gICAgICB9XG4gICAgICB0aGlzLm1fZmxhZ3MgJj0gfmIyV29ybGQuZV9sb2NrZWQ7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5DbGVhckZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGJvZHkgPSB0aGlzLm1fYm9keUxpc3Q7IGJvZHk7IGJvZHkgPSBib2R5Lm1fbmV4dCkge1xuICAgICAgICAgYm9keS5tX2ZvcmNlLlNldFplcm8oKTtcbiAgICAgICAgIGJvZHkubV90b3JxdWUgPSAwLjA7XG4gICAgICB9XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5EcmF3RGVidWdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMubV9kZWJ1Z0RyYXcgPT0gbnVsbCkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2RlYnVnRHJhdy5tX3Nwcml0ZS5ncmFwaGljcy5jbGVhcigpO1xuICAgICAgdmFyIGZsYWdzID0gdGhpcy5tX2RlYnVnRHJhdy5HZXRGbGFncygpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGI7XG4gICAgICB2YXIgZjtcbiAgICAgIHZhciBzO1xuICAgICAgdmFyIGo7XG4gICAgICB2YXIgYnA7XG4gICAgICB2YXIgaW52USA9IG5ldyBiMlZlYzI7XG4gICAgICB2YXIgeDEgPSBuZXcgYjJWZWMyO1xuICAgICAgdmFyIHgyID0gbmV3IGIyVmVjMjtcbiAgICAgIHZhciB4ZjtcbiAgICAgIHZhciBiMSA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHZhciBiMiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHZhciB2cyA9IFtuZXcgYjJWZWMyKCksIG5ldyBiMlZlYzIoKSwgbmV3IGIyVmVjMigpLCBuZXcgYjJWZWMyKCldO1xuICAgICAgdmFyIGNvbG9yID0gbmV3IGIyQ29sb3IoMCwgMCwgMCk7XG4gICAgICBpZiAoZmxhZ3MgJiBiMkRlYnVnRHJhdy5lX3NoYXBlQml0KSB7XG4gICAgICAgICBmb3IgKGIgPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICAgICBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgICAgICAgIHhmID0gYi5tX3hmO1xuICAgICAgICAgICAgZm9yIChmID0gYi5HZXRGaXh0dXJlTGlzdCgpO1xuICAgICAgICAgICAgZjsgZiA9IGYubV9uZXh0KSB7XG4gICAgICAgICAgICAgICBzID0gZi5HZXRTaGFwZSgpO1xuICAgICAgICAgICAgICAgaWYgKGIuSXNBY3RpdmUoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgY29sb3IuU2V0KDAuNSwgMC41LCAwLjMpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2hhcGUocywgeGYsIGNvbG9yKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2UgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICAgICAgICAgICBjb2xvci5TZXQoMC41LCAwLjksIDAuNSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLkRyYXdTaGFwZShzLCB4ZiwgY29sb3IpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5HZXRUeXBlKCkgPT0gYjJCb2R5LmIyX2tpbmVtYXRpY0JvZHkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yLlNldCgwLjUsIDAuNSwgMC45KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuRHJhd1NoYXBlKHMsIHhmLCBjb2xvcik7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBlbHNlIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgY29sb3IuU2V0KDAuNiwgMC42LCAwLjYpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2hhcGUocywgeGYsIGNvbG9yKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29sb3IuU2V0KDAuOSwgMC43LCAwLjcpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2hhcGUocywgeGYsIGNvbG9yKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIGIyRGVidWdEcmF3LmVfam9pbnRCaXQpIHtcbiAgICAgICAgIGZvciAoaiA9IHRoaXMubV9qb2ludExpc3Q7XG4gICAgICAgICBqOyBqID0gai5tX25leHQpIHtcbiAgICAgICAgICAgIHRoaXMuRHJhd0pvaW50KGopO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZsYWdzICYgYjJEZWJ1Z0RyYXcuZV9jb250cm9sbGVyQml0KSB7XG4gICAgICAgICBmb3IgKHZhciBjID0gdGhpcy5tX2NvbnRyb2xsZXJMaXN0OyBjOyBjID0gYy5tX25leHQpIHtcbiAgICAgICAgICAgIGMuRHJhdyh0aGlzLm1fZGVidWdEcmF3KTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIGIyRGVidWdEcmF3LmVfcGFpckJpdCkge1xuICAgICAgICAgY29sb3IuU2V0KDAuMywgMC45LCAwLjkpO1xuICAgICAgICAgZm9yICh2YXIgY29udGFjdCA9IHRoaXMubV9jb250YWN0TWFuYWdlci5tX2NvbnRhY3RMaXN0OyBjb250YWN0OyBjb250YWN0ID0gY29udGFjdC5HZXROZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQSA9IGNvbnRhY3QuR2V0Rml4dHVyZUEoKTtcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQiA9IGNvbnRhY3QuR2V0Rml4dHVyZUIoKTtcbiAgICAgICAgICAgIHZhciBjQSA9IGZpeHR1cmVBLkdldEFBQkIoKS5HZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHZhciBjQiA9IGZpeHR1cmVCLkdldEFBQkIoKS5HZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1NlZ21lbnQoY0EsIGNCLCBjb2xvcik7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MgJiBiMkRlYnVnRHJhdy5lX2FhYmJCaXQpIHtcbiAgICAgICAgIGJwID0gdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcbiAgICAgICAgIHZzID0gW25ldyBiMlZlYzIoKSwgbmV3IGIyVmVjMigpLCBuZXcgYjJWZWMyKCksIG5ldyBiMlZlYzIoKV07XG4gICAgICAgICBmb3IgKGIgPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICAgICBiOyBiID0gYi5HZXROZXh0KCkpIHtcbiAgICAgICAgICAgIGlmIChiLklzQWN0aXZlKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChmID0gYi5HZXRGaXh0dXJlTGlzdCgpO1xuICAgICAgICAgICAgZjsgZiA9IGYuR2V0TmV4dCgpKSB7XG4gICAgICAgICAgICAgICB2YXIgYWFiYiA9IGJwLkdldEZhdEFBQkIoZi5tX3Byb3h5KTtcbiAgICAgICAgICAgICAgIHZzWzBdLlNldChhYWJiLmxvd2VyQm91bmQueCwgYWFiYi5sb3dlckJvdW5kLnkpO1xuICAgICAgICAgICAgICAgdnNbMV0uU2V0KGFhYmIudXBwZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueSk7XG4gICAgICAgICAgICAgICB2c1syXS5TZXQoYWFiYi51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC55KTtcbiAgICAgICAgICAgICAgIHZzWzNdLlNldChhYWJiLmxvd2VyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLnkpO1xuICAgICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3UG9seWdvbih2cywgNCwgY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZsYWdzICYgYjJEZWJ1Z0RyYXcuZV9jZW50ZXJPZk1hc3NCaXQpIHtcbiAgICAgICAgIGZvciAoYiA9IHRoaXMubV9ib2R5TGlzdDtcbiAgICAgICAgIGI7IGIgPSBiLm1fbmV4dCkge1xuICAgICAgICAgICAgeGYgPSBiMldvcmxkLnNfeGY7XG4gICAgICAgICAgICB4Zi5SID0gYi5tX3hmLlI7XG4gICAgICAgICAgICB4Zi5wb3NpdGlvbiA9IGIuR2V0V29ybGRDZW50ZXIoKTtcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1RyYW5zZm9ybSh4Zik7XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5RdWVyeUFBQkIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFhYmIpIHtcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGJyb2FkUGhhc2UgPSBfX3RoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG5cbiAgICAgIGZ1bmN0aW9uIFdvcmxkUXVlcnlXcmFwcGVyKHByb3h5KSB7XG4gICAgICAgICByZXR1cm4gY2FsbGJhY2soYnJvYWRQaGFzZS5HZXRVc2VyRGF0YShwcm94eSkpO1xuICAgICAgfTtcbiAgICAgIGJyb2FkUGhhc2UuUXVlcnkoV29ybGRRdWVyeVdyYXBwZXIsIGFhYmIpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuUXVlcnlTaGFwZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgc2hhcGUsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIF9fdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodHJhbnNmb3JtID09PSB1bmRlZmluZWQpIHRyYW5zZm9ybSA9IG51bGw7XG4gICAgICBpZiAodHJhbnNmb3JtID09IG51bGwpIHtcbiAgICAgICAgIHRyYW5zZm9ybSA9IG5ldyBiMlRyYW5zZm9ybSgpO1xuICAgICAgICAgdHJhbnNmb3JtLlNldElkZW50aXR5KCk7XG4gICAgICB9XG4gICAgICB2YXIgYnJvYWRQaGFzZSA9IF9fdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcblxuICAgICAgZnVuY3Rpb24gV29ybGRRdWVyeVdyYXBwZXIocHJveHkpIHtcbiAgICAgICAgIHZhciBmaXh0dXJlID0gKGJyb2FkUGhhc2UuR2V0VXNlckRhdGEocHJveHkpIGluc3RhbmNlb2YgYjJGaXh0dXJlID8gYnJvYWRQaGFzZS5HZXRVc2VyRGF0YShwcm94eSkgOiBudWxsKTtcbiAgICAgICAgIGlmIChiMlNoYXBlLlRlc3RPdmVybGFwKHNoYXBlLCB0cmFuc2Zvcm0sIGZpeHR1cmUuR2V0U2hhcGUoKSwgZml4dHVyZS5HZXRCb2R5KCkuR2V0VHJhbnNmb3JtKCkpKSByZXR1cm4gY2FsbGJhY2soZml4dHVyZSk7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICB2YXIgYWFiYiA9IG5ldyBiMkFBQkIoKTtcbiAgICAgIHNoYXBlLkNvbXB1dGVBQUJCKGFhYmIsIHRyYW5zZm9ybSk7XG4gICAgICBicm9hZFBoYXNlLlF1ZXJ5KFdvcmxkUXVlcnlXcmFwcGVyLCBhYWJiKTtcbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLlF1ZXJ5UG9pbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHApIHtcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGJyb2FkUGhhc2UgPSBfX3RoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG5cbiAgICAgIGZ1bmN0aW9uIFdvcmxkUXVlcnlXcmFwcGVyKHByb3h5KSB7XG4gICAgICAgICB2YXIgZml4dHVyZSA9IChicm9hZFBoYXNlLkdldFVzZXJEYXRhKHByb3h5KSBpbnN0YW5jZW9mIGIyRml4dHVyZSA/IGJyb2FkUGhhc2UuR2V0VXNlckRhdGEocHJveHkpIDogbnVsbCk7XG4gICAgICAgICBpZiAoZml4dHVyZS5UZXN0UG9pbnQocCkpIHJldHVybiBjYWxsYmFjayhmaXh0dXJlKTtcbiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIHZhciBhYWJiID0gbmV3IGIyQUFCQigpO1xuICAgICAgYWFiYi5sb3dlckJvdW5kLlNldChwLnggLSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsIHAueSAtIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCk7XG4gICAgICBhYWJiLnVwcGVyQm91bmQuU2V0KHAueCArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgcC55ICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKTtcbiAgICAgIGJyb2FkUGhhc2UuUXVlcnkoV29ybGRRdWVyeVdyYXBwZXIsIGFhYmIpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuUmF5Q2FzdCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgcG9pbnQxLCBwb2ludDIpIHtcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGJyb2FkUGhhc2UgPSBfX3RoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XG4gICAgICB2YXIgb3V0cHV0ID0gbmV3IGIyUmF5Q2FzdE91dHB1dDtcblxuICAgICAgZnVuY3Rpb24gUmF5Q2FzdFdyYXBwZXIoaW5wdXQsIHByb3h5KSB7XG4gICAgICAgICB2YXIgdXNlckRhdGEgPSBicm9hZFBoYXNlLkdldFVzZXJEYXRhKHByb3h5KTtcbiAgICAgICAgIHZhciBmaXh0dXJlID0gKHVzZXJEYXRhIGluc3RhbmNlb2YgYjJGaXh0dXJlID8gdXNlckRhdGEgOiBudWxsKTtcbiAgICAgICAgIHZhciBoaXQgPSBmaXh0dXJlLlJheUNhc3Qob3V0cHV0LCBpbnB1dCk7XG4gICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICB2YXIgZnJhY3Rpb24gPSBvdXRwdXQuZnJhY3Rpb247XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgYjJWZWMyKCgxLjAgLSBmcmFjdGlvbikgKiBwb2ludDEueCArIGZyYWN0aW9uICogcG9pbnQyLngsICgxLjAgLSBmcmFjdGlvbikgKiBwb2ludDEueSArIGZyYWN0aW9uICogcG9pbnQyLnkpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZpeHR1cmUsIHBvaW50LCBvdXRwdXQubm9ybWFsLCBmcmFjdGlvbik7XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gaW5wdXQubWF4RnJhY3Rpb247XG4gICAgICB9O1xuICAgICAgdmFyIGlucHV0ID0gbmV3IGIyUmF5Q2FzdElucHV0KHBvaW50MSwgcG9pbnQyKTtcbiAgICAgIGJyb2FkUGhhc2UuUmF5Q2FzdChSYXlDYXN0V3JhcHBlciwgaW5wdXQpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuUmF5Q2FzdE9uZSA9IGZ1bmN0aW9uIChwb2ludDEsIHBvaW50Mikge1xuICAgICAgdmFyIF9fdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBmdW5jdGlvbiBSYXlDYXN0T25lV3JhcHBlcihmaXh0dXJlLCBwb2ludCwgbm9ybWFsLCBmcmFjdGlvbikge1xuICAgICAgICAgaWYgKGZyYWN0aW9uID09PSB1bmRlZmluZWQpIGZyYWN0aW9uID0gMDtcbiAgICAgICAgIHJlc3VsdCA9IGZpeHR1cmU7XG4gICAgICAgICByZXR1cm4gZnJhY3Rpb247XG4gICAgICB9O1xuICAgICAgX190aGlzLlJheUNhc3QoUmF5Q2FzdE9uZVdyYXBwZXIsIHBvaW50MSwgcG9pbnQyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5SYXlDYXN0QWxsID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgICB2YXIgX190aGlzID0gdGhpcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgVmVjdG9yKCk7XG5cbiAgICAgIGZ1bmN0aW9uIFJheUNhc3RBbGxXcmFwcGVyKGZpeHR1cmUsIHBvaW50LCBub3JtYWwsIGZyYWN0aW9uKSB7XG4gICAgICAgICBpZiAoZnJhY3Rpb24gPT09IHVuZGVmaW5lZCkgZnJhY3Rpb24gPSAwO1xuICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gZml4dHVyZTtcbiAgICAgICAgIHJldHVybiAxO1xuICAgICAgfTtcbiAgICAgIF9fdGhpcy5SYXlDYXN0KFJheUNhc3RBbGxXcmFwcGVyLCBwb2ludDEsIHBvaW50Mik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0Qm9keUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlMaXN0O1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0Sm9pbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9qb2ludExpc3Q7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5HZXRDb250YWN0TGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY29udGFjdExpc3Q7XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5Jc0xvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJXb3JsZC5lX2xvY2tlZCkgPiAwO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuU29sdmUgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGI7XG4gICAgICBmb3IgKHZhciBjb250cm9sbGVyID0gdGhpcy5tX2NvbnRyb2xsZXJMaXN0OyBjb250cm9sbGVyOyBjb250cm9sbGVyID0gY29udHJvbGxlci5tX25leHQpIHtcbiAgICAgICAgIGNvbnRyb2xsZXIuU3RlcChzdGVwKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc2xhbmQgPSB0aGlzLm1faXNsYW5kO1xuICAgICAgaXNsYW5kLkluaXRpYWxpemUodGhpcy5tX2JvZHlDb3VudCwgdGhpcy5tX2NvbnRhY3RDb3VudCwgdGhpcy5tX2pvaW50Q291bnQsIG51bGwsIHRoaXMubV9jb250YWN0TWFuYWdlci5tX2NvbnRhY3RMaXN0ZW5lciwgdGhpcy5tX2NvbnRhY3RTb2x2ZXIpO1xuICAgICAgZm9yIChiID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgYjsgYiA9IGIubV9uZXh0KSB7XG4gICAgICAgICBiLm1fZmxhZ3MgJj0gfmIyQm9keS5lX2lzbGFuZEZsYWc7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBjID0gdGhpcy5tX2NvbnRhY3RMaXN0OyBjOyBjID0gYy5tX25leHQpIHtcbiAgICAgICAgIGMubV9mbGFncyAmPSB+YjJDb250YWN0LmVfaXNsYW5kRmxhZztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSB0aGlzLm1fam9pbnRMaXN0OyBqOyBqID0gai5tX25leHQpIHtcbiAgICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc3RhY2tTaXplID0gcGFyc2VJbnQodGhpcy5tX2JvZHlDb3VudCk7XG4gICAgICB2YXIgc3RhY2sgPSB0aGlzLnNfc3RhY2s7XG4gICAgICBmb3IgKHZhciBzZWVkID0gdGhpcy5tX2JvZHlMaXN0OyBzZWVkOyBzZWVkID0gc2VlZC5tX25leHQpIHtcbiAgICAgICAgIGlmIChzZWVkLm1fZmxhZ3MgJiBiMkJvZHkuZV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChzZWVkLklzQXdha2UoKSA9PSBmYWxzZSB8fCBzZWVkLklzQWN0aXZlKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKHNlZWQuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlzbGFuZC5DbGVhcigpO1xuICAgICAgICAgdmFyIHN0YWNrQ291bnQgPSAwO1xuICAgICAgICAgc3RhY2tbc3RhY2tDb3VudCsrXSA9IHNlZWQ7XG4gICAgICAgICBzZWVkLm1fZmxhZ3MgfD0gYjJCb2R5LmVfaXNsYW5kRmxhZztcbiAgICAgICAgIHdoaWxlIChzdGFja0NvdW50ID4gMCkge1xuICAgICAgICAgICAgYiA9IHN0YWNrWy0tc3RhY2tDb3VudF07XG4gICAgICAgICAgICBpc2xhbmQuQWRkQm9keShiKTtcbiAgICAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgYi5TZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiLkdldFR5cGUoKSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xuICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3RoZXI7XG4gICAgICAgICAgICBmb3IgKHZhciBjZSA9IGIubV9jb250YWN0TGlzdDsgY2U7IGNlID0gY2UubmV4dCkge1xuICAgICAgICAgICAgICAgaWYgKGNlLmNvbnRhY3QubV9mbGFncyAmIGIyQ29udGFjdC5lX2lzbGFuZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgaWYgKGNlLmNvbnRhY3QuSXNTZW5zb3IoKSA9PSB0cnVlIHx8IGNlLmNvbnRhY3QuSXNFbmFibGVkKCkgPT0gZmFsc2UgfHwgY2UuY29udGFjdC5Jc1RvdWNoaW5nKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgaXNsYW5kLkFkZENvbnRhY3QoY2UuY29udGFjdCk7XG4gICAgICAgICAgICAgICBjZS5jb250YWN0Lm1fZmxhZ3MgfD0gYjJDb250YWN0LmVfaXNsYW5kRmxhZztcbiAgICAgICAgICAgICAgIG90aGVyID0gY2Uub3RoZXI7XG4gICAgICAgICAgICAgICBpZiAob3RoZXIubV9mbGFncyAmIGIyQm9keS5lX2lzbGFuZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgc3RhY2tbc3RhY2tDb3VudCsrXSA9IG90aGVyO1xuICAgICAgICAgICAgICAgb3RoZXIubV9mbGFncyB8PSBiMkJvZHkuZV9pc2xhbmRGbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgam4gPSBiLm1fam9pbnRMaXN0OyBqbjsgam4gPSBqbi5uZXh0KSB7XG4gICAgICAgICAgICAgICBpZiAoam4uam9pbnQubV9pc2xhbmRGbGFnID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgb3RoZXIgPSBqbi5vdGhlcjtcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5Jc0FjdGl2ZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlzbGFuZC5BZGRKb2ludChqbi5qb2ludCk7XG4gICAgICAgICAgICAgICBqbi5qb2ludC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgaWYgKG90aGVyLm1fZmxhZ3MgJiBiMkJvZHkuZV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrQ291bnQrK10gPSBvdGhlcjtcbiAgICAgICAgICAgICAgIG90aGVyLm1fZmxhZ3MgfD0gYjJCb2R5LmVfaXNsYW5kRmxhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGlzbGFuZC5Tb2x2ZShzdGVwLCB0aGlzLm1fZ3Jhdml0eSwgdGhpcy5tX2FsbG93U2xlZXApO1xuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpc2xhbmQubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgYiA9IGlzbGFuZC5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgIGlmIChiLkdldFR5cGUoKSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xuICAgICAgICAgICAgICAgYi5tX2ZsYWdzICY9IH5iMkJvZHkuZV9pc2xhbmRGbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpID0gMDtcbiAgICAgIGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgaWYgKCFzdGFja1tpXSkgYnJlYWs7XG4gICAgICAgICBzdGFja1tpXSA9IG51bGw7XG4gICAgICB9XG4gICAgICBmb3IgKGIgPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICBiOyBiID0gYi5tX25leHQpIHtcbiAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSB8fCBiLklzQWN0aXZlKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGIuU3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLkZpbmROZXdDb250YWN0cygpO1xuICAgfVxuICAgYjJXb3JsZC5wcm90b3R5cGUuU29sdmVUT0kgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGI7XG4gICAgICB2YXIgZkE7XG4gICAgICB2YXIgZkI7XG4gICAgICB2YXIgYkE7XG4gICAgICB2YXIgYkI7XG4gICAgICB2YXIgY0VkZ2U7XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBpc2xhbmQgPSB0aGlzLm1faXNsYW5kO1xuICAgICAgaXNsYW5kLkluaXRpYWxpemUodGhpcy5tX2JvZHlDb3VudCwgYjJTZXR0aW5ncy5iMl9tYXhUT0lDb250YWN0c1BlcklzbGFuZCwgYjJTZXR0aW5ncy5iMl9tYXhUT0lKb2ludHNQZXJJc2xhbmQsIG51bGwsIHRoaXMubV9jb250YWN0TWFuYWdlci5tX2NvbnRhY3RMaXN0ZW5lciwgdGhpcy5tX2NvbnRhY3RTb2x2ZXIpO1xuICAgICAgdmFyIHF1ZXVlID0gYjJXb3JsZC5zX3F1ZXVlO1xuICAgICAgZm9yIChiID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgYjsgYiA9IGIubV9uZXh0KSB7XG4gICAgICAgICBiLm1fZmxhZ3MgJj0gfmIyQm9keS5lX2lzbGFuZEZsYWc7XG4gICAgICAgICBiLm1fc3dlZXAudDAgPSAwLjA7XG4gICAgICB9XG4gICAgICB2YXIgYztcbiAgICAgIGZvciAoYyA9IHRoaXMubV9jb250YWN0TGlzdDtcbiAgICAgIGM7IGMgPSBjLm1fbmV4dCkge1xuICAgICAgICAgYy5tX2ZsYWdzICY9IH4gKGIyQ29udGFjdC5lX3RvaUZsYWcgfCBiMkNvbnRhY3QuZV9pc2xhbmRGbGFnKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IHRoaXMubV9qb2ludExpc3Q7XG4gICAgICBqOyBqID0gai5tX25leHQpIHtcbiAgICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgICB2YXIgbWluQ29udGFjdCA9IG51bGw7XG4gICAgICAgICB2YXIgbWluVE9JID0gMS4wO1xuICAgICAgICAgZm9yIChjID0gdGhpcy5tX2NvbnRhY3RMaXN0O1xuICAgICAgICAgYzsgYyA9IGMubV9uZXh0KSB7XG4gICAgICAgICAgICBpZiAoYy5Jc1NlbnNvcigpID09IHRydWUgfHwgYy5Jc0VuYWJsZWQoKSA9PSBmYWxzZSB8fCBjLklzQ29udGludW91cygpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b2kgPSAxLjA7XG4gICAgICAgICAgICBpZiAoYy5tX2ZsYWdzICYgYjJDb250YWN0LmVfdG9pRmxhZykge1xuICAgICAgICAgICAgICAgdG9pID0gYy5tX3RvaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgZkEgPSBjLm1fZml4dHVyZUE7XG4gICAgICAgICAgICAgICBmQiA9IGMubV9maXh0dXJlQjtcbiAgICAgICAgICAgICAgIGJBID0gZkEubV9ib2R5O1xuICAgICAgICAgICAgICAgYkIgPSBmQi5tX2JvZHk7XG4gICAgICAgICAgICAgICBpZiAoKGJBLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkgfHwgYkEuSXNBd2FrZSgpID09IGZhbHNlKSAmJiAoYkIuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9keW5hbWljQm9keSB8fCBiQi5Jc0F3YWtlKCkgPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHZhciB0MCA9IGJBLm1fc3dlZXAudDA7XG4gICAgICAgICAgICAgICBpZiAoYkEubV9zd2VlcC50MCA8IGJCLm1fc3dlZXAudDApIHtcbiAgICAgICAgICAgICAgICAgIHQwID0gYkIubV9zd2VlcC50MDtcbiAgICAgICAgICAgICAgICAgIGJBLm1fc3dlZXAuQWR2YW5jZSh0MCk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBlbHNlIGlmIChiQi5tX3N3ZWVwLnQwIDwgYkEubV9zd2VlcC50MCkge1xuICAgICAgICAgICAgICAgICAgdDAgPSBiQS5tX3N3ZWVwLnQwO1xuICAgICAgICAgICAgICAgICAgYkIubV9zd2VlcC5BZHZhbmNlKHQwKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHRvaSA9IGMuQ29tcHV0ZVRPSShiQS5tX3N3ZWVwLCBiQi5tX3N3ZWVwKTtcbiAgICAgICAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMC4wIDw9IHRvaSAmJiB0b2kgPD0gMS4wKTtcbiAgICAgICAgICAgICAgIGlmICh0b2kgPiAwLjAgJiYgdG9pIDwgMS4wKSB7XG4gICAgICAgICAgICAgICAgICB0b2kgPSAoMS4wIC0gdG9pKSAqIHQwICsgdG9pO1xuICAgICAgICAgICAgICAgICAgaWYgKHRvaSA+IDEpIHRvaSA9IDE7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBjLm1fdG9pID0gdG9pO1xuICAgICAgICAgICAgICAgYy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX3RvaUZsYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTnVtYmVyLk1JTl9WQUxVRSA8IHRvaSAmJiB0b2kgPCBtaW5UT0kpIHtcbiAgICAgICAgICAgICAgIG1pbkNvbnRhY3QgPSBjO1xuICAgICAgICAgICAgICAgbWluVE9JID0gdG9pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKG1pbkNvbnRhY3QgPT0gbnVsbCB8fCAxLjAgLSAxMDAuMCAqIE51bWJlci5NSU5fVkFMVUUgPCBtaW5UT0kpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgICAgZkEgPSBtaW5Db250YWN0Lm1fZml4dHVyZUE7XG4gICAgICAgICBmQiA9IG1pbkNvbnRhY3QubV9maXh0dXJlQjtcbiAgICAgICAgIGJBID0gZkEubV9ib2R5O1xuICAgICAgICAgYkIgPSBmQi5tX2JvZHk7XG4gICAgICAgICBiMldvcmxkLnNfYmFja3VwQS5TZXQoYkEubV9zd2VlcCk7XG4gICAgICAgICBiMldvcmxkLnNfYmFja3VwQi5TZXQoYkIubV9zd2VlcCk7XG4gICAgICAgICBiQS5BZHZhbmNlKG1pblRPSSk7XG4gICAgICAgICBiQi5BZHZhbmNlKG1pblRPSSk7XG4gICAgICAgICBtaW5Db250YWN0LlVwZGF0ZSh0aGlzLm1fY29udGFjdE1hbmFnZXIubV9jb250YWN0TGlzdGVuZXIpO1xuICAgICAgICAgbWluQ29udGFjdC5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV90b2lGbGFnO1xuICAgICAgICAgaWYgKG1pbkNvbnRhY3QuSXNTZW5zb3IoKSA9PSB0cnVlIHx8IG1pbkNvbnRhY3QuSXNFbmFibGVkKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJBLm1fc3dlZXAuU2V0KGIyV29ybGQuc19iYWNrdXBBKTtcbiAgICAgICAgICAgIGJCLm1fc3dlZXAuU2V0KGIyV29ybGQuc19iYWNrdXBCKTtcbiAgICAgICAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAobWluQ29udGFjdC5Jc1RvdWNoaW5nKCkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIHNlZWQgPSBiQTtcbiAgICAgICAgIGlmIChzZWVkLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcbiAgICAgICAgICAgIHNlZWQgPSBiQjtcbiAgICAgICAgIH1cbiAgICAgICAgIGlzbGFuZC5DbGVhcigpO1xuICAgICAgICAgdmFyIHF1ZXVlU3RhcnQgPSAwO1xuICAgICAgICAgdmFyIHF1ZXVlU2l6ZSA9IDA7XG4gICAgICAgICBxdWV1ZVtxdWV1ZVN0YXJ0ICsgcXVldWVTaXplKytdID0gc2VlZDtcbiAgICAgICAgIHNlZWQubV9mbGFncyB8PSBiMkJvZHkuZV9pc2xhbmRGbGFnO1xuICAgICAgICAgd2hpbGUgKHF1ZXVlU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGIgPSBxdWV1ZVtxdWV1ZVN0YXJ0KytdO1xuICAgICAgICAgICAgLS1xdWV1ZVNpemU7XG4gICAgICAgICAgICBpc2xhbmQuQWRkQm9keShiKTtcbiAgICAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgYi5TZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjRWRnZSA9IGIubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIGNFZGdlOyBjRWRnZSA9IGNFZGdlLm5leHQpIHtcbiAgICAgICAgICAgICAgIGlmIChpc2xhbmQubV9jb250YWN0Q291bnQgPT0gaXNsYW5kLm1fY29udGFjdENhcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChjRWRnZS5jb250YWN0Lm1fZmxhZ3MgJiBiMkNvbnRhY3QuZV9pc2xhbmRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlmIChjRWRnZS5jb250YWN0LklzU2Vuc29yKCkgPT0gdHJ1ZSB8fCBjRWRnZS5jb250YWN0LklzRW5hYmxlZCgpID09IGZhbHNlIHx8IGNFZGdlLmNvbnRhY3QuSXNUb3VjaGluZygpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlzbGFuZC5BZGRDb250YWN0KGNFZGdlLmNvbnRhY3QpO1xuICAgICAgICAgICAgICAgY0VkZ2UuY29udGFjdC5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2lzbGFuZEZsYWc7XG4gICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjRWRnZS5vdGhlcjtcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5tX2ZsYWdzICYgYjJCb2R5LmVfaXNsYW5kRmxhZykge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBpZiAob3RoZXIuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XG4gICAgICAgICAgICAgICAgICBvdGhlci5BZHZhbmNlKG1pblRPSSk7XG4gICAgICAgICAgICAgICAgICBvdGhlci5TZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHF1ZXVlW3F1ZXVlU3RhcnQgKyBxdWV1ZVNpemVdID0gb3RoZXI7XG4gICAgICAgICAgICAgICArK3F1ZXVlU2l6ZTtcbiAgICAgICAgICAgICAgIG90aGVyLm1fZmxhZ3MgfD0gYjJCb2R5LmVfaXNsYW5kRmxhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGpFZGdlID0gYi5tX2pvaW50TGlzdDsgakVkZ2U7IGpFZGdlID0gakVkZ2UubmV4dCkge1xuICAgICAgICAgICAgICAgaWYgKGlzbGFuZC5tX2pvaW50Q291bnQgPT0gaXNsYW5kLm1fam9pbnRDYXBhY2l0eSkgY29udGludWU7XG4gICAgICAgICAgICAgICBpZiAoakVkZ2Uuam9pbnQubV9pc2xhbmRGbGFnID09IHRydWUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgb3RoZXIgPSBqRWRnZS5vdGhlcjtcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5Jc0FjdGl2ZSgpID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGlzbGFuZC5BZGRKb2ludChqRWRnZS5qb2ludCk7XG4gICAgICAgICAgICAgICBqRWRnZS5qb2ludC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgaWYgKG90aGVyLm1fZmxhZ3MgJiBiMkJvZHkuZV9pc2xhbmRGbGFnKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkpIHtcbiAgICAgICAgICAgICAgICAgIG90aGVyLkFkdmFuY2UobWluVE9JKTtcbiAgICAgICAgICAgICAgICAgIG90aGVyLlNldEF3YWtlKHRydWUpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgcXVldWVbcXVldWVTdGFydCArIHF1ZXVlU2l6ZV0gPSBvdGhlcjtcbiAgICAgICAgICAgICAgICsrcXVldWVTaXplO1xuICAgICAgICAgICAgICAgb3RoZXIubV9mbGFncyB8PSBiMkJvZHkuZV9pc2xhbmRGbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgdmFyIHN1YlN0ZXAgPSBiMldvcmxkLnNfdGltZXN0ZXA7XG4gICAgICAgICBzdWJTdGVwLndhcm1TdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgc3ViU3RlcC5kdCA9ICgxLjAgLSBtaW5UT0kpICogc3RlcC5kdDtcbiAgICAgICAgIHN1YlN0ZXAuaW52X2R0ID0gMS4wIC8gc3ViU3RlcC5kdDtcbiAgICAgICAgIHN1YlN0ZXAuZHRSYXRpbyA9IDAuMDtcbiAgICAgICAgIHN1YlN0ZXAudmVsb2NpdHlJdGVyYXRpb25zID0gc3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnM7XG4gICAgICAgICBzdWJTdGVwLnBvc2l0aW9uSXRlcmF0aW9ucyA9IHN0ZXAucG9zaXRpb25JdGVyYXRpb25zO1xuICAgICAgICAgaXNsYW5kLlNvbHZlVE9JKHN1YlN0ZXApO1xuICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgIGkgPCBpc2xhbmQubV9ib2R5Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgYiA9IGlzbGFuZC5tX2JvZGllc1tpXTtcbiAgICAgICAgICAgIGIubV9mbGFncyAmPSB+YjJCb2R5LmVfaXNsYW5kRmxhZztcbiAgICAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYi5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XG4gICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIuU3luY2hyb25pemVGaXh0dXJlcygpO1xuICAgICAgICAgICAgZm9yIChjRWRnZSA9IGIubV9jb250YWN0TGlzdDtcbiAgICAgICAgICAgIGNFZGdlOyBjRWRnZSA9IGNFZGdlLm5leHQpIHtcbiAgICAgICAgICAgICAgIGNFZGdlLmNvbnRhY3QubV9mbGFncyAmPSB+YjJDb250YWN0LmVfdG9pRmxhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGZvciAoaSA9IDA7XG4gICAgICAgICBpIDwgaXNsYW5kLm1fY29udGFjdENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGMgPSBpc2xhbmQubV9jb250YWN0c1tpXTtcbiAgICAgICAgICAgIGMubV9mbGFncyAmPSB+IChiMkNvbnRhY3QuZV90b2lGbGFnIHwgYjJDb250YWN0LmVfaXNsYW5kRmxhZyk7XG4gICAgICAgICB9XG4gICAgICAgICBmb3IgKGkgPSAwO1xuICAgICAgICAgaSA8IGlzbGFuZC5tX2pvaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgaiA9IGlzbGFuZC5tX2pvaW50c1tpXTtcbiAgICAgICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLm1fY29udGFjdE1hbmFnZXIuRmluZE5ld0NvbnRhY3RzKCk7XG4gICAgICB9XG4gICB9XG4gICBiMldvcmxkLnByb3RvdHlwZS5EcmF3Sm9pbnQgPSBmdW5jdGlvbiAoam9pbnQpIHtcbiAgICAgIHZhciBiMSA9IGpvaW50LkdldEJvZHlBKCk7XG4gICAgICB2YXIgYjIgPSBqb2ludC5HZXRCb2R5QigpO1xuICAgICAgdmFyIHhmMSA9IGIxLm1feGY7XG4gICAgICB2YXIgeGYyID0gYjIubV94ZjtcbiAgICAgIHZhciB4MSA9IHhmMS5wb3NpdGlvbjtcbiAgICAgIHZhciB4MiA9IHhmMi5wb3NpdGlvbjtcbiAgICAgIHZhciBwMSA9IGpvaW50LkdldEFuY2hvckEoKTtcbiAgICAgIHZhciBwMiA9IGpvaW50LkdldEFuY2hvckIoKTtcbiAgICAgIHZhciBjb2xvciA9IGIyV29ybGQuc19qb2ludENvbG9yO1xuICAgICAgc3dpdGNoIChqb2ludC5tX3R5cGUpIHtcbiAgICAgIGNhc2UgYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQ6XG4gICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KHAxLCBwMiwgY29sb3IpO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIySm9pbnQuZV9wdWxsZXlKb2ludDpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwdWxsZXkgPSAoKGpvaW50IGluc3RhbmNlb2YgYjJQdWxsZXlKb2ludCA/IGpvaW50IDogbnVsbCkpO1xuICAgICAgICAgICAgdmFyIHMxID0gcHVsbGV5LkdldEdyb3VuZEFuY2hvckEoKTtcbiAgICAgICAgICAgIHZhciBzMiA9IHB1bGxleS5HZXRHcm91bmRBbmNob3JCKCk7XG4gICAgICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KHMxLCBwMSwgY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudChzMiwgcDIsIGNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1NlZ21lbnQoczEsIHMyLCBjb2xvcik7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJKb2ludC5lX21vdXNlSm9pbnQ6XG4gICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KHAxLCBwMiwgY29sb3IpO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgaWYgKGIxICE9IHRoaXMubV9ncm91bmRCb2R5KSB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KHgxLCBwMSwgY29sb3IpO1xuICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudChwMSwgcDIsIGNvbG9yKTtcbiAgICAgICAgIGlmIChiMiAhPSB0aGlzLm1fZ3JvdW5kQm9keSkgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudCh4MiwgcDIsIGNvbG9yKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyV29ybGQucHJvdG90eXBlLkRyYXdTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSwgeGYsIGNvbG9yKSB7XG4gICAgICBzd2l0Y2ggKHNoYXBlLm1fdHlwZSkge1xuICAgICAgY2FzZSBiMlNoYXBlLmVfY2lyY2xlU2hhcGU6XG4gICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY2lyY2xlID0gKChzaGFwZSBpbnN0YW5jZW9mIGIyQ2lyY2xlU2hhcGUgPyBzaGFwZSA6IG51bGwpKTtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBiMk1hdGguTXVsWCh4ZiwgY2lyY2xlLm1fcCk7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gY2lyY2xlLm1fcmFkaXVzO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB4Zi5SLmNvbDE7XG4gICAgICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTb2xpZENpcmNsZShjZW50ZXIsIHJhZGl1cywgYXhpcywgY29sb3IpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIyU2hhcGUuZV9wb2x5Z29uU2hhcGU6XG4gICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgcG9seSA9ICgoc2hhcGUgaW5zdGFuY2VvZiBiMlBvbHlnb25TaGFwZSA/IHNoYXBlIDogbnVsbCkpO1xuICAgICAgICAgICAgdmFyIHZlcnRleENvdW50ID0gcGFyc2VJbnQocG9seS5HZXRWZXJ0ZXhDb3VudCgpKTtcbiAgICAgICAgICAgIHZhciBsb2NhbFZlcnRpY2VzID0gcG9seS5HZXRWZXJ0aWNlcygpO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gbmV3IFZlY3Rvcih2ZXJ0ZXhDb3VudCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwO1xuICAgICAgICAgICAgaSA8IHZlcnRleENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldID0gYjJNYXRoLk11bFgoeGYsIGxvY2FsVmVydGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U29saWRQb2x5Z29uKHZlcnRpY2VzLCB2ZXJ0ZXhDb3VudCwgY29sb3IpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIyU2hhcGUuZV9lZGdlU2hhcGU6XG4gICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IChzaGFwZSBpbnN0YW5jZW9mIGIyRWRnZVNoYXBlID8gc2hhcGUgOiBudWxsKTtcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1NlZ21lbnQoYjJNYXRoLk11bFgoeGYsIGVkZ2UuR2V0VmVydGV4MSgpKSwgYjJNYXRoLk11bFgoeGYsIGVkZ2UuR2V0VmVydGV4MigpKSwgY29sb3IpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyV29ybGQuc190aW1lc3RlcDIgPSBuZXcgYjJUaW1lU3RlcCgpO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5zX3hmID0gbmV3IGIyVHJhbnNmb3JtKCk7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLnNfYmFja3VwQSA9IG5ldyBiMlN3ZWVwKCk7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLnNfYmFja3VwQiA9IG5ldyBiMlN3ZWVwKCk7XG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLnNfdGltZXN0ZXAgPSBuZXcgYjJUaW1lU3RlcCgpO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5zX3F1ZXVlID0gbmV3IFZlY3RvcigpO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5zX2pvaW50Q29sb3IgPSBuZXcgYjJDb2xvcigwLjUsIDAuOCwgMC44KTtcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyV29ybGQuZV9uZXdGaXh0dXJlID0gMHgwMDAxO1xuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5lX2xvY2tlZCA9IDB4MDAwMjtcbiAgIH0pO1xufSkoKTtcbihmdW5jdGlvbiAoKSB7XG4gICB2YXIgYjJDaXJjbGVTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJDaXJjbGVTaGFwZSxcbiAgICAgIGIyRWRnZUNoYWluRGVmID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VDaGFpbkRlZixcbiAgICAgIGIyRWRnZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VTaGFwZSxcbiAgICAgIGIyTWFzc0RhdGEgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyTWFzc0RhdGEsXG4gICAgICBiMlBvbHlnb25TaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJQb2x5Z29uU2hhcGUsXG4gICAgICBiMlNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLFxuICAgICAgYjJDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDaXJjbGVDb250YWN0LFxuICAgICAgYjJDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LFxuICAgICAgYjJDb250YWN0Q29uc3RyYWludCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdENvbnN0cmFpbnQsXG4gICAgICBiMkNvbnRhY3RDb25zdHJhaW50UG9pbnQgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RDb25zdHJhaW50UG9pbnQsXG4gICAgICBiMkNvbnRhY3RFZGdlID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0RWRnZSxcbiAgICAgIGIyQ29udGFjdEZhY3RvcnkgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RGYWN0b3J5LFxuICAgICAgYjJDb250YWN0UmVnaXN0ZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RSZWdpc3RlcixcbiAgICAgIGIyQ29udGFjdFJlc3VsdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFJlc3VsdCxcbiAgICAgIGIyQ29udGFjdFNvbHZlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFNvbHZlcixcbiAgICAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkVkZ2VBbmRDaXJjbGVDb250YWN0LFxuICAgICAgYjJOdWxsQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyTnVsbENvbnRhY3QsXG4gICAgICBiMlBvbHlBbmRDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCxcbiAgICAgIGIyUG9seUFuZEVkZ2VDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kRWRnZUNvbnRhY3QsXG4gICAgICBiMlBvbHlnb25Db250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5Z29uQ29udGFjdCxcbiAgICAgIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCxcbiAgICAgIGIyQm9keSA9IEJveDJELkR5bmFtaWNzLmIyQm9keSxcbiAgICAgIGIyQm9keURlZiA9IEJveDJELkR5bmFtaWNzLmIyQm9keURlZixcbiAgICAgIGIyQ29udGFjdEZpbHRlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEZpbHRlcixcbiAgICAgIGIyQ29udGFjdEltcHVsc2UgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RJbXB1bHNlLFxuICAgICAgYjJDb250YWN0TGlzdGVuZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lcixcbiAgICAgIGIyQ29udGFjdE1hbmFnZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RNYW5hZ2VyLFxuICAgICAgYjJEZWJ1Z0RyYXcgPSBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdyxcbiAgICAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcixcbiAgICAgIGIyRmlsdGVyRGF0YSA9IEJveDJELkR5bmFtaWNzLmIyRmlsdGVyRGF0YSxcbiAgICAgIGIyRml4dHVyZSA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZSxcbiAgICAgIGIyRml4dHVyZURlZiA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZixcbiAgICAgIGIySXNsYW5kID0gQm94MkQuRHluYW1pY3MuYjJJc2xhbmQsXG4gICAgICBiMlRpbWVTdGVwID0gQm94MkQuRHluYW1pY3MuYjJUaW1lU3RlcCxcbiAgICAgIGIyV29ybGQgPSBCb3gyRC5EeW5hbWljcy5iMldvcmxkLFxuICAgICAgYjJDb2xvciA9IEJveDJELkNvbW1vbi5iMkNvbG9yLFxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxuICAgICAgYjJNYXQyMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MjIsXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcbiAgICAgIGIyU3dlZXAgPSBCb3gyRC5Db21tb24uTWF0aC5iMlN3ZWVwLFxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcbiAgICAgIGIyVmVjMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMyxcbiAgICAgIGIyQUFCQiA9IEJveDJELkNvbGxpc2lvbi5iMkFBQkIsXG4gICAgICBiMkJvdW5kID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmQsXG4gICAgICBiMkJvdW5kVmFsdWVzID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmRWYWx1ZXMsXG4gICAgICBiMkNvbGxpc2lvbiA9IEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbixcbiAgICAgIGIyQ29udGFjdElEID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdElELFxuICAgICAgYjJDb250YWN0UG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJDb250YWN0UG9pbnQsXG4gICAgICBiMkRpc3RhbmNlID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2UsXG4gICAgICBiMkRpc3RhbmNlSW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZUlucHV0LFxuICAgICAgYjJEaXN0YW5jZU91dHB1dCA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlT3V0cHV0LFxuICAgICAgYjJEaXN0YW5jZVByb3h5ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VQcm94eSxcbiAgICAgIGIyRHluYW1pY1RyZWUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZSxcbiAgICAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLFxuICAgICAgYjJEeW5hbWljVHJlZU5vZGUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZU5vZGUsXG4gICAgICBiMkR5bmFtaWNUcmVlUGFpciA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlUGFpcixcbiAgICAgIGIyTWFuaWZvbGQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZCxcbiAgICAgIGIyTWFuaWZvbGRQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkUG9pbnQsXG4gICAgICBiMlBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyUG9pbnQsXG4gICAgICBiMlJheUNhc3RJbnB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RJbnB1dCxcbiAgICAgIGIyUmF5Q2FzdE91dHB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RPdXRwdXQsXG4gICAgICBiMlNlZ21lbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJTZWdtZW50LFxuICAgICAgYjJTZXBhcmF0aW9uRnVuY3Rpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJTZXBhcmF0aW9uRnVuY3Rpb24sXG4gICAgICBiMlNpbXBsZXggPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4LFxuICAgICAgYjJTaW1wbGV4Q2FjaGUgPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4Q2FjaGUsXG4gICAgICBiMlNpbXBsZXhWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4VmVydGV4LFxuICAgICAgYjJUaW1lT2ZJbXBhY3QgPSBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QsXG4gICAgICBiMlRPSUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyVE9JSW5wdXQsXG4gICAgICBiMldvcmxkTWFuaWZvbGQgPSBCb3gyRC5Db2xsaXNpb24uYjJXb3JsZE1hbmlmb2xkLFxuICAgICAgQ2xpcFZlcnRleCA9IEJveDJELkNvbGxpc2lvbi5DbGlwVmVydGV4LFxuICAgICAgRmVhdHVyZXMgPSBCb3gyRC5Db2xsaXNpb24uRmVhdHVyZXMsXG4gICAgICBJQnJvYWRQaGFzZSA9IEJveDJELkNvbGxpc2lvbi5JQnJvYWRQaGFzZTtcblxuICAgQm94MkQuaW5oZXJpdChiMkNpcmNsZUNvbnRhY3QsIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdCk7XG4gICBiMkNpcmNsZUNvbnRhY3QucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QucHJvdG90eXBlO1xuICAgYjJDaXJjbGVDb250YWN0LmIyQ2lyY2xlQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5iMkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBiMkNpcmNsZUNvbnRhY3QuQ3JlYXRlID0gZnVuY3Rpb24gKGFsbG9jYXRvcikge1xuICAgICAgcmV0dXJuIG5ldyBiMkNpcmNsZUNvbnRhY3QoKTtcbiAgIH1cbiAgIGIyQ2lyY2xlQ29udGFjdC5EZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRhY3QsIGFsbG9jYXRvcikge31cbiAgIGIyQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuUmVzZXQuY2FsbCh0aGlzLCBmaXh0dXJlQSwgZml4dHVyZUIpO1xuICAgfVxuICAgYjJDaXJjbGVDb250YWN0LnByb3RvdHlwZS5FdmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9maXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fZml4dHVyZUIuR2V0Qm9keSgpO1xuICAgICAgYjJDb2xsaXNpb24uQ29sbGlkZUNpcmNsZXModGhpcy5tX21hbmlmb2xkLCAodGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMkNpcmNsZVNoYXBlID8gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgOiBudWxsKSwgYkEubV94ZiwgKHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJDaXJjbGVTaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xuICAgfVxuICAgYjJDb250YWN0LmIyQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9ub2RlQSA9IG5ldyBiMkNvbnRhY3RFZGdlKCk7XG4gICAgICB0aGlzLm1fbm9kZUIgPSBuZXcgYjJDb250YWN0RWRnZSgpO1xuICAgICAgdGhpcy5tX21hbmlmb2xkID0gbmV3IGIyTWFuaWZvbGQoKTtcbiAgICAgIHRoaXMubV9vbGRNYW5pZm9sZCA9IG5ldyBiMk1hbmlmb2xkKCk7XG4gICB9O1xuICAgYjJDb250YWN0LnByb3RvdHlwZS5HZXRNYW5pZm9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbWFuaWZvbGQ7XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLkdldFdvcmxkTWFuaWZvbGQgPSBmdW5jdGlvbiAod29ybGRNYW5pZm9sZCkge1xuICAgICAgdmFyIGJvZHlBID0gdGhpcy5tX2ZpeHR1cmVBLkdldEJvZHkoKTtcbiAgICAgIHZhciBib2R5QiA9IHRoaXMubV9maXh0dXJlQi5HZXRCb2R5KCk7XG4gICAgICB2YXIgc2hhcGVBID0gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCk7XG4gICAgICB2YXIgc2hhcGVCID0gdGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCk7XG4gICAgICB3b3JsZE1hbmlmb2xkLkluaXRpYWxpemUodGhpcy5tX21hbmlmb2xkLCBib2R5QS5HZXRUcmFuc2Zvcm0oKSwgc2hhcGVBLm1fcmFkaXVzLCBib2R5Qi5HZXRUcmFuc2Zvcm0oKSwgc2hhcGVCLm1fcmFkaXVzKTtcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuSXNUb3VjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJDb250YWN0LmVfdG91Y2hpbmdGbGFnKSA9PSBiMkNvbnRhY3QuZV90b3VjaGluZ0ZsYWc7XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLklzQ29udGludW91cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJDb250YWN0LmVfY29udGludW91c0ZsYWcpID09IGIyQ29udGFjdC5lX2NvbnRpbnVvdXNGbGFnO1xuICAgfVxuICAgYjJDb250YWN0LnByb3RvdHlwZS5TZXRTZW5zb3IgPSBmdW5jdGlvbiAoc2Vuc29yKSB7XG4gICAgICBpZiAoc2Vuc29yKSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJDb250YWN0LmVfc2Vuc29yRmxhZztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV9zZW5zb3JGbGFnO1xuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0LnByb3RvdHlwZS5Jc1NlbnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJDb250YWN0LmVfc2Vuc29yRmxhZykgPT0gYjJDb250YWN0LmVfc2Vuc29yRmxhZztcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuU2V0RW5hYmxlZCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2VuYWJsZWRGbGFnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fZmxhZ3MgJj0gfmIyQ29udGFjdC5lX2VuYWJsZWRGbGFnO1xuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0LnByb3RvdHlwZS5Jc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQ29udGFjdC5lX2VuYWJsZWRGbGFnKSA9PSBiMkNvbnRhY3QuZV9lbmFibGVkRmxhZztcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuR2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbmV4dDtcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuR2V0Rml4dHVyZUEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2ZpeHR1cmVBO1xuICAgfVxuICAgYjJDb250YWN0LnByb3RvdHlwZS5HZXRGaXh0dXJlQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZml4dHVyZUI7XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLkZsYWdGb3JGaWx0ZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJDb250YWN0LmVfZmlsdGVyRmxhZztcbiAgIH1cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuYjJDb250YWN0ID0gZnVuY3Rpb24gKCkge31cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XG4gICAgICBpZiAoZml4dHVyZUEgPT09IHVuZGVmaW5lZCkgZml4dHVyZUEgPSBudWxsO1xuICAgICAgaWYgKGZpeHR1cmVCID09PSB1bmRlZmluZWQpIGZpeHR1cmVCID0gbnVsbDtcbiAgICAgIHRoaXMubV9mbGFncyA9IGIyQ29udGFjdC5lX2VuYWJsZWRGbGFnO1xuICAgICAgaWYgKCFmaXh0dXJlQSB8fCAhZml4dHVyZUIpIHtcbiAgICAgICAgIHRoaXMubV9maXh0dXJlQSA9IG51bGw7XG4gICAgICAgICB0aGlzLm1fZml4dHVyZUIgPSBudWxsO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpeHR1cmVBLklzU2Vuc29yKCkgfHwgZml4dHVyZUIuSXNTZW5zb3IoKSkge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX3NlbnNvckZsYWc7XG4gICAgICB9XG4gICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5HZXRCb2R5KCk7XG4gICAgICBpZiAoYm9keUEuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9keW5hbWljQm9keSB8fCBib2R5QS5Jc0J1bGxldCgpIHx8IGJvZHlCLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkgfHwgYm9keUIuSXNCdWxsZXQoKSkge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2NvbnRpbnVvdXNGbGFnO1xuICAgICAgfVxuICAgICAgdGhpcy5tX2ZpeHR1cmVBID0gZml4dHVyZUE7XG4gICAgICB0aGlzLm1fZml4dHVyZUIgPSBmaXh0dXJlQjtcbiAgICAgIHRoaXMubV9tYW5pZm9sZC5tX3BvaW50Q291bnQgPSAwO1xuICAgICAgdGhpcy5tX3ByZXYgPSBudWxsO1xuICAgICAgdGhpcy5tX25leHQgPSBudWxsO1xuICAgICAgdGhpcy5tX25vZGVBLmNvbnRhY3QgPSBudWxsO1xuICAgICAgdGhpcy5tX25vZGVBLnByZXYgPSBudWxsO1xuICAgICAgdGhpcy5tX25vZGVBLm5leHQgPSBudWxsO1xuICAgICAgdGhpcy5tX25vZGVBLm90aGVyID0gbnVsbDtcbiAgICAgIHRoaXMubV9ub2RlQi5jb250YWN0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9ub2RlQi5wcmV2ID0gbnVsbDtcbiAgICAgIHRoaXMubV9ub2RlQi5uZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMubV9ub2RlQi5vdGhlciA9IG51bGw7XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLlVwZGF0ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgdmFyIHRNYW5pZm9sZCA9IHRoaXMubV9vbGRNYW5pZm9sZDtcbiAgICAgIHRoaXMubV9vbGRNYW5pZm9sZCA9IHRoaXMubV9tYW5pZm9sZDtcbiAgICAgIHRoaXMubV9tYW5pZm9sZCA9IHRNYW5pZm9sZDtcbiAgICAgIHRoaXMubV9mbGFncyB8PSBiMkNvbnRhY3QuZV9lbmFibGVkRmxhZztcbiAgICAgIHZhciB0b3VjaGluZyA9IGZhbHNlO1xuICAgICAgdmFyIHdhc1RvdWNoaW5nID0gKHRoaXMubV9mbGFncyAmIGIyQ29udGFjdC5lX3RvdWNoaW5nRmxhZykgPT0gYjJDb250YWN0LmVfdG91Y2hpbmdGbGFnO1xuICAgICAgdmFyIGJvZHlBID0gdGhpcy5tX2ZpeHR1cmVBLm1fYm9keTtcbiAgICAgIHZhciBib2R5QiA9IHRoaXMubV9maXh0dXJlQi5tX2JvZHk7XG4gICAgICB2YXIgYWFiYk92ZXJsYXAgPSB0aGlzLm1fZml4dHVyZUEubV9hYWJiLlRlc3RPdmVybGFwKHRoaXMubV9maXh0dXJlQi5tX2FhYmIpO1xuICAgICAgaWYgKHRoaXMubV9mbGFncyAmIGIyQ29udGFjdC5lX3NlbnNvckZsYWcpIHtcbiAgICAgICAgIGlmIChhYWJiT3ZlcmxhcCkge1xuICAgICAgICAgICAgdmFyIHNoYXBlQSA9IHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpO1xuICAgICAgICAgICAgdmFyIHNoYXBlQiA9IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpO1xuICAgICAgICAgICAgdmFyIHhmQSA9IGJvZHlBLkdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdmFyIHhmQiA9IGJvZHlCLkdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdG91Y2hpbmcgPSBiMlNoYXBlLlRlc3RPdmVybGFwKHNoYXBlQSwgeGZBLCBzaGFwZUIsIHhmQik7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLm1fbWFuaWZvbGQubV9wb2ludENvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgaWYgKGJvZHlBLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkgfHwgYm9keUEuSXNCdWxsZXQoKSB8fCBib2R5Qi5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5IHx8IGJvZHlCLklzQnVsbGV0KCkpIHtcbiAgICAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkNvbnRhY3QuZV9jb250aW51b3VzRmxhZztcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV9jb250aW51b3VzRmxhZztcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChhYWJiT3ZlcmxhcCkge1xuICAgICAgICAgICAgdGhpcy5FdmFsdWF0ZSgpO1xuICAgICAgICAgICAgdG91Y2hpbmcgPSB0aGlzLm1fbWFuaWZvbGQubV9wb2ludENvdW50ID4gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX21hbmlmb2xkLm1fcG9pbnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICB2YXIgbXAyID0gdGhpcy5tX21hbmlmb2xkLm1fcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgbXAyLm1fbm9ybWFsSW1wdWxzZSA9IDAuMDtcbiAgICAgICAgICAgICAgIG1wMi5tX3RhbmdlbnRJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgICAgdmFyIGlkMiA9IG1wMi5tX2lkO1xuICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm1fb2xkTWFuaWZvbGQubV9wb2ludENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtcDEgPSB0aGlzLm1fb2xkTWFuaWZvbGQubV9wb2ludHNbal07XG4gICAgICAgICAgICAgICAgICBpZiAobXAxLm1faWQua2V5ID09IGlkMi5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgIG1wMi5tX25vcm1hbEltcHVsc2UgPSBtcDEubV9ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgICAgICAgbXAyLm1fdGFuZ2VudEltcHVsc2UgPSBtcDEubV90YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1fbWFuaWZvbGQubV9wb2ludENvdW50ID0gMDtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmICh0b3VjaGluZyAhPSB3YXNUb3VjaGluZykge1xuICAgICAgICAgICAgYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICAgICAgICBib2R5Qi5TZXRBd2FrZSh0cnVlKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b3VjaGluZykge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX3RvdWNoaW5nRmxhZztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV90b3VjaGluZ0ZsYWc7XG4gICAgICB9XG4gICAgICBpZiAod2FzVG91Y2hpbmcgPT0gZmFsc2UgJiYgdG91Y2hpbmcgPT0gdHJ1ZSkge1xuICAgICAgICAgbGlzdGVuZXIuQmVnaW5Db250YWN0KHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHdhc1RvdWNoaW5nID09IHRydWUgJiYgdG91Y2hpbmcgPT0gZmFsc2UpIHtcbiAgICAgICAgIGxpc3RlbmVyLkVuZENvbnRhY3QodGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoKHRoaXMubV9mbGFncyAmIGIyQ29udGFjdC5lX3NlbnNvckZsYWcpID09IDApIHtcbiAgICAgICAgIGxpc3RlbmVyLlByZVNvbHZlKHRoaXMsIHRoaXMubV9vbGRNYW5pZm9sZCk7XG4gICAgICB9XG4gICB9XG4gICBiMkNvbnRhY3QucHJvdG90eXBlLkV2YWx1YXRlID0gZnVuY3Rpb24gKCkge31cbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuQ29tcHV0ZVRPSSA9IGZ1bmN0aW9uIChzd2VlcEEsIHN3ZWVwQikge1xuICAgICAgYjJDb250YWN0LnNfaW5wdXQucHJveHlBLlNldCh0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSk7XG4gICAgICBiMkNvbnRhY3Quc19pbnB1dC5wcm94eUIuU2V0KHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpKTtcbiAgICAgIGIyQ29udGFjdC5zX2lucHV0LnN3ZWVwQSA9IHN3ZWVwQTtcbiAgICAgIGIyQ29udGFjdC5zX2lucHV0LnN3ZWVwQiA9IHN3ZWVwQjtcbiAgICAgIGIyQ29udGFjdC5zX2lucHV0LnRvbGVyYW5jZSA9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcbiAgICAgIHJldHVybiBiMlRpbWVPZkltcGFjdC5UaW1lT2ZJbXBhY3QoYjJDb250YWN0LnNfaW5wdXQpO1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuZV9zZW5zb3JGbGFnID0gMHgwMDAxO1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmVfY29udGludW91c0ZsYWcgPSAweDAwMDI7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuZV9pc2xhbmRGbGFnID0gMHgwMDA0O1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmVfdG9pRmxhZyA9IDB4MDAwODtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5lX3RvdWNoaW5nRmxhZyA9IDB4MDAxMDtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5lX2VuYWJsZWRGbGFnID0gMHgwMDIwO1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmVfZmlsdGVyRmxhZyA9IDB4MDA0MDtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5zX2lucHV0ID0gbmV3IGIyVE9JSW5wdXQoKTtcbiAgIH0pO1xuICAgYjJDb250YWN0Q29uc3RyYWludC5iMkNvbnRhY3RDb25zdHJhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sb2NhbFBsYW5lTm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5sb2NhbFBvaW50ID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5ub3JtYWwgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm5vcm1hbE1hc3MgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgdGhpcy5LID0gbmV3IGIyTWF0MjIoKTtcbiAgIH07XG4gICBiMkNvbnRhY3RDb25zdHJhaW50LnByb3RvdHlwZS5iMkNvbnRhY3RDb25zdHJhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb2ludHMgPSBuZXcgVmVjdG9yKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzOyBpKyspIHtcbiAgICAgICAgIHRoaXMucG9pbnRzW2ldID0gbmV3IGIyQ29udGFjdENvbnN0cmFpbnRQb2ludCgpO1xuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0Q29uc3RyYWludFBvaW50LmIyQ29udGFjdENvbnN0cmFpbnRQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubG9jYWxQb2ludCA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMuckEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLnJCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyQ29udGFjdEVkZ2UuYjJDb250YWN0RWRnZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJDb250YWN0RmFjdG9yeS5iMkNvbnRhY3RGYWN0b3J5ID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RGYWN0b3J5LnByb3RvdHlwZS5iMkNvbnRhY3RGYWN0b3J5ID0gZnVuY3Rpb24gKGFsbG9jYXRvcikge1xuICAgICAgdGhpcy5tX2FsbG9jYXRvciA9IGFsbG9jYXRvcjtcbiAgICAgIHRoaXMuSW5pdGlhbGl6ZVJlZ2lzdGVycygpO1xuICAgfVxuICAgYjJDb250YWN0RmFjdG9yeS5wcm90b3R5cGUuQWRkVHlwZSA9IGZ1bmN0aW9uIChjcmVhdGVGY24sIGRlc3Ryb3lGY24sIHR5cGUxLCB0eXBlMikge1xuICAgICAgaWYgKHR5cGUxID09PSB1bmRlZmluZWQpIHR5cGUxID0gMDtcbiAgICAgIGlmICh0eXBlMiA9PT0gdW5kZWZpbmVkKSB0eXBlMiA9IDA7XG4gICAgICB0aGlzLm1fcmVnaXN0ZXJzW3R5cGUxXVt0eXBlMl0uY3JlYXRlRmNuID0gY3JlYXRlRmNuO1xuICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdLmRlc3Ryb3lGY24gPSBkZXN0cm95RmNuO1xuICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdLnByaW1hcnkgPSB0cnVlO1xuICAgICAgaWYgKHR5cGUxICE9IHR5cGUyKSB7XG4gICAgICAgICB0aGlzLm1fcmVnaXN0ZXJzW3R5cGUyXVt0eXBlMV0uY3JlYXRlRmNuID0gY3JlYXRlRmNuO1xuICAgICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMl1bdHlwZTFdLmRlc3Ryb3lGY24gPSBkZXN0cm95RmNuO1xuICAgICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMl1bdHlwZTFdLnByaW1hcnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQ29udGFjdEZhY3RvcnkucHJvdG90eXBlLkluaXRpYWxpemVSZWdpc3RlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fcmVnaXN0ZXJzID0gbmV3IFZlY3RvcihiMlNoYXBlLmVfc2hhcGVUeXBlQ291bnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNoYXBlLmVfc2hhcGVUeXBlQ291bnQ7IGkrKykge1xuICAgICAgICAgdGhpcy5tX3JlZ2lzdGVyc1tpXSA9IG5ldyBWZWN0b3IoYjJTaGFwZS5lX3NoYXBlVHlwZUNvdW50KTtcbiAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYjJTaGFwZS5lX3NoYXBlVHlwZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMubV9yZWdpc3RlcnNbaV1bal0gPSBuZXcgYjJDb250YWN0UmVnaXN0ZXIoKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuQWRkVHlwZShiMkNpcmNsZUNvbnRhY3QuQ3JlYXRlLCBiMkNpcmNsZUNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX2NpcmNsZVNoYXBlLCBiMlNoYXBlLmVfY2lyY2xlU2hhcGUpO1xuICAgICAgdGhpcy5BZGRUeXBlKGIyUG9seUFuZENpcmNsZUNvbnRhY3QuQ3JlYXRlLCBiMlBvbHlBbmRDaXJjbGVDb250YWN0LkRlc3Ryb3ksIGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUsIGIyU2hhcGUuZV9jaXJjbGVTaGFwZSk7XG4gICAgICB0aGlzLkFkZFR5cGUoYjJQb2x5Z29uQ29udGFjdC5DcmVhdGUsIGIyUG9seWdvbkNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX3BvbHlnb25TaGFwZSwgYjJTaGFwZS5lX3BvbHlnb25TaGFwZSk7XG4gICAgICB0aGlzLkFkZFR5cGUoYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5DcmVhdGUsIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX2VkZ2VTaGFwZSwgYjJTaGFwZS5lX2NpcmNsZVNoYXBlKTtcbiAgICAgIHRoaXMuQWRkVHlwZShiMlBvbHlBbmRFZGdlQ29udGFjdC5DcmVhdGUsIGIyUG9seUFuZEVkZ2VDb250YWN0LkRlc3Ryb3ksIGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUsIGIyU2hhcGUuZV9lZGdlU2hhcGUpO1xuICAgfVxuICAgYjJDb250YWN0RmFjdG9yeS5wcm90b3R5cGUuQ3JlYXRlID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xuICAgICAgdmFyIHR5cGUxID0gcGFyc2VJbnQoZml4dHVyZUEuR2V0VHlwZSgpKTtcbiAgICAgIHZhciB0eXBlMiA9IHBhcnNlSW50KGZpeHR1cmVCLkdldFR5cGUoKSk7XG4gICAgICB2YXIgcmVnID0gdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdO1xuICAgICAgdmFyIGM7XG4gICAgICBpZiAocmVnLnBvb2wpIHtcbiAgICAgICAgIGMgPSByZWcucG9vbDtcbiAgICAgICAgIHJlZy5wb29sID0gYy5tX25leHQ7XG4gICAgICAgICByZWcucG9vbENvdW50LS07XG4gICAgICAgICBjLlJlc2V0KGZpeHR1cmVBLCBmaXh0dXJlQik7XG4gICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIHZhciBjcmVhdGVGY24gPSByZWcuY3JlYXRlRmNuO1xuICAgICAgaWYgKGNyZWF0ZUZjbiAhPSBudWxsKSB7XG4gICAgICAgICBpZiAocmVnLnByaW1hcnkpIHtcbiAgICAgICAgICAgIGMgPSBjcmVhdGVGY24odGhpcy5tX2FsbG9jYXRvcik7XG4gICAgICAgICAgICBjLlJlc2V0KGZpeHR1cmVBLCBmaXh0dXJlQik7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyA9IGNyZWF0ZUZjbih0aGlzLm1fYWxsb2NhdG9yKTtcbiAgICAgICAgICAgIGMuUmVzZXQoZml4dHVyZUIsIGZpeHR1cmVBKTtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQ29udGFjdEZhY3RvcnkucHJvdG90eXBlLkRlc3Ryb3kgPSBmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgaWYgKGNvbnRhY3QubV9tYW5pZm9sZC5tX3BvaW50Q291bnQgPiAwKSB7XG4gICAgICAgICBjb250YWN0Lm1fZml4dHVyZUEubV9ib2R5LlNldEF3YWtlKHRydWUpO1xuICAgICAgICAgY29udGFjdC5tX2ZpeHR1cmVCLm1fYm9keS5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlMSA9IHBhcnNlSW50KGNvbnRhY3QubV9maXh0dXJlQS5HZXRUeXBlKCkpO1xuICAgICAgdmFyIHR5cGUyID0gcGFyc2VJbnQoY29udGFjdC5tX2ZpeHR1cmVCLkdldFR5cGUoKSk7XG4gICAgICB2YXIgcmVnID0gdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdO1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgIHJlZy5wb29sQ291bnQrKztcbiAgICAgICAgIGNvbnRhY3QubV9uZXh0ID0gcmVnLnBvb2w7XG4gICAgICAgICByZWcucG9vbCA9IGNvbnRhY3Q7XG4gICAgICB9XG4gICAgICB2YXIgZGVzdHJveUZjbiA9IHJlZy5kZXN0cm95RmNuO1xuICAgICAgZGVzdHJveUZjbihjb250YWN0LCB0aGlzLm1fYWxsb2NhdG9yKTtcbiAgIH1cbiAgIGIyQ29udGFjdFJlZ2lzdGVyLmIyQ29udGFjdFJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRhY3RSZXN1bHQuYjJDb250YWN0UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5pZCA9IG5ldyBiMkNvbnRhY3RJRCgpO1xuICAgfTtcbiAgIGIyQ29udGFjdFNvbHZlci5iMkNvbnRhY3RTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fc3RlcCA9IG5ldyBiMlRpbWVTdGVwKCk7XG4gICAgICB0aGlzLm1fY29uc3RyYWludHMgPSBuZXcgVmVjdG9yKCk7XG4gICB9O1xuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5iMkNvbnRhY3RTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKHN0ZXAsIGNvbnRhY3RzLCBjb250YWN0Q291bnQsIGFsbG9jYXRvcikge1xuICAgICAgaWYgKGNvbnRhY3RDb3VudCA9PT0gdW5kZWZpbmVkKSBjb250YWN0Q291bnQgPSAwO1xuICAgICAgdmFyIGNvbnRhY3Q7XG4gICAgICB0aGlzLm1fc3RlcC5TZXQoc3RlcCk7XG4gICAgICB0aGlzLm1fYWxsb2NhdG9yID0gYWxsb2NhdG9yO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHRWZWM7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHRoaXMubV9jb25zdHJhaW50Q291bnQgPSBjb250YWN0Q291bnQ7XG4gICAgICB3aGlsZSAodGhpcy5tX2NvbnN0cmFpbnRzLmxlbmd0aCA8IHRoaXMubV9jb25zdHJhaW50Q291bnQpIHtcbiAgICAgICAgIHRoaXMubV9jb25zdHJhaW50c1t0aGlzLm1fY29uc3RyYWludHMubGVuZ3RoXSA9IG5ldyBiMkNvbnRhY3RDb25zdHJhaW50KCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwO1xuICAgICAgaSA8IGNvbnRhY3RDb3VudDsgKytpKSB7XG4gICAgICAgICBjb250YWN0ID0gY29udGFjdHNbaV07XG4gICAgICAgICB2YXIgZml4dHVyZUEgPSBjb250YWN0Lm1fZml4dHVyZUE7XG4gICAgICAgICB2YXIgZml4dHVyZUIgPSBjb250YWN0Lm1fZml4dHVyZUI7XG4gICAgICAgICB2YXIgc2hhcGVBID0gZml4dHVyZUEubV9zaGFwZTtcbiAgICAgICAgIHZhciBzaGFwZUIgPSBmaXh0dXJlQi5tX3NoYXBlO1xuICAgICAgICAgdmFyIHJhZGl1c0EgPSBzaGFwZUEubV9yYWRpdXM7XG4gICAgICAgICB2YXIgcmFkaXVzQiA9IHNoYXBlQi5tX3JhZGl1cztcbiAgICAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLm1fYm9keTtcbiAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcbiAgICAgICAgIHZhciBtYW5pZm9sZCA9IGNvbnRhY3QuR2V0TWFuaWZvbGQoKTtcbiAgICAgICAgIHZhciBmcmljdGlvbiA9IGIyU2V0dGluZ3MuYjJNaXhGcmljdGlvbihmaXh0dXJlQS5HZXRGcmljdGlvbigpLCBmaXh0dXJlQi5HZXRGcmljdGlvbigpKTtcbiAgICAgICAgIHZhciByZXN0aXR1dGlvbiA9IGIyU2V0dGluZ3MuYjJNaXhSZXN0aXR1dGlvbihmaXh0dXJlQS5HZXRSZXN0aXR1dGlvbigpLCBmaXh0dXJlQi5HZXRSZXN0aXR1dGlvbigpKTtcbiAgICAgICAgIHZhciB2QVggPSBib2R5QS5tX2xpbmVhclZlbG9jaXR5Lng7XG4gICAgICAgICB2YXIgdkFZID0gYm9keUEubV9saW5lYXJWZWxvY2l0eS55O1xuICAgICAgICAgdmFyIHZCWCA9IGJvZHlCLm1fbGluZWFyVmVsb2NpdHkueDtcbiAgICAgICAgIHZhciB2QlkgPSBib2R5Qi5tX2xpbmVhclZlbG9jaXR5Lnk7XG4gICAgICAgICB2YXIgd0EgPSBib2R5QS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgIHZhciB3QiA9IGJvZHlCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChtYW5pZm9sZC5tX3BvaW50Q291bnQgPiAwKTtcbiAgICAgICAgIGIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQuSW5pdGlhbGl6ZShtYW5pZm9sZCwgYm9keUEubV94ZiwgcmFkaXVzQSwgYm9keUIubV94ZiwgcmFkaXVzQik7XG4gICAgICAgICB2YXIgbm9ybWFsWCA9IGIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQubV9ub3JtYWwueDtcbiAgICAgICAgIHZhciBub3JtYWxZID0gYjJDb250YWN0U29sdmVyLnNfd29ybGRNYW5pZm9sZC5tX25vcm1hbC55O1xuICAgICAgICAgdmFyIGNjID0gdGhpcy5tX2NvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgY2MuYm9keUEgPSBib2R5QTtcbiAgICAgICAgIGNjLmJvZHlCID0gYm9keUI7XG4gICAgICAgICBjYy5tYW5pZm9sZCA9IG1hbmlmb2xkO1xuICAgICAgICAgY2Mubm9ybWFsLnggPSBub3JtYWxYO1xuICAgICAgICAgY2Mubm9ybWFsLnkgPSBub3JtYWxZO1xuICAgICAgICAgY2MucG9pbnRDb3VudCA9IG1hbmlmb2xkLm1fcG9pbnRDb3VudDtcbiAgICAgICAgIGNjLmZyaWN0aW9uID0gZnJpY3Rpb247XG4gICAgICAgICBjYy5yZXN0aXR1dGlvbiA9IHJlc3RpdHV0aW9uO1xuICAgICAgICAgY2MubG9jYWxQbGFuZU5vcm1hbC54ID0gbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLng7XG4gICAgICAgICBjYy5sb2NhbFBsYW5lTm9ybWFsLnkgPSBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwueTtcbiAgICAgICAgIGNjLmxvY2FsUG9pbnQueCA9IG1hbmlmb2xkLm1fbG9jYWxQb2ludC54O1xuICAgICAgICAgY2MubG9jYWxQb2ludC55ID0gbWFuaWZvbGQubV9sb2NhbFBvaW50Lnk7XG4gICAgICAgICBjYy5yYWRpdXMgPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICAgICAgIGNjLnR5cGUgPSBtYW5pZm9sZC5tX3R5cGU7XG4gICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNjLnBvaW50Q291bnQ7ICsraykge1xuICAgICAgICAgICAgdmFyIGNwID0gbWFuaWZvbGQubV9wb2ludHNba107XG4gICAgICAgICAgICB2YXIgY2NwID0gY2MucG9pbnRzW2tdO1xuICAgICAgICAgICAgY2NwLm5vcm1hbEltcHVsc2UgPSBjcC5tX25vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICBjY3AudGFuZ2VudEltcHVsc2UgPSBjcC5tX3RhbmdlbnRJbXB1bHNlO1xuICAgICAgICAgICAgY2NwLmxvY2FsUG9pbnQuU2V0VihjcC5tX2xvY2FsUG9pbnQpO1xuICAgICAgICAgICAgdmFyIHJBWCA9IGNjcC5yQS54ID0gYjJDb250YWN0U29sdmVyLnNfd29ybGRNYW5pZm9sZC5tX3BvaW50c1trXS54IC0gYm9keUEubV9zd2VlcC5jLng7XG4gICAgICAgICAgICB2YXIgckFZID0gY2NwLnJBLnkgPSBiMkNvbnRhY3RTb2x2ZXIuc193b3JsZE1hbmlmb2xkLm1fcG9pbnRzW2tdLnkgLSBib2R5QS5tX3N3ZWVwLmMueTtcbiAgICAgICAgICAgIHZhciByQlggPSBjY3AuckIueCA9IGIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQubV9wb2ludHNba10ueCAtIGJvZHlCLm1fc3dlZXAuYy54O1xuICAgICAgICAgICAgdmFyIHJCWSA9IGNjcC5yQi55ID0gYjJDb250YWN0U29sdmVyLnNfd29ybGRNYW5pZm9sZC5tX3BvaW50c1trXS55IC0gYm9keUIubV9zd2VlcC5jLnk7XG4gICAgICAgICAgICB2YXIgcm5BID0gckFYICogbm9ybWFsWSAtIHJBWSAqIG5vcm1hbFg7XG4gICAgICAgICAgICB2YXIgcm5CID0gckJYICogbm9ybWFsWSAtIHJCWSAqIG5vcm1hbFg7XG4gICAgICAgICAgICBybkEgKj0gcm5BO1xuICAgICAgICAgICAgcm5CICo9IHJuQjtcbiAgICAgICAgICAgIHZhciBrTm9ybWFsID0gYm9keUEubV9pbnZNYXNzICsgYm9keUIubV9pbnZNYXNzICsgYm9keUEubV9pbnZJICogcm5BICsgYm9keUIubV9pbnZJICogcm5CO1xuICAgICAgICAgICAgY2NwLm5vcm1hbE1hc3MgPSAxLjAgLyBrTm9ybWFsO1xuICAgICAgICAgICAgdmFyIGtFcXVhbGl6ZWQgPSBib2R5QS5tX21hc3MgKiBib2R5QS5tX2ludk1hc3MgKyBib2R5Qi5tX21hc3MgKiBib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICAgICBrRXF1YWxpemVkICs9IGJvZHlBLm1fbWFzcyAqIGJvZHlBLm1faW52SSAqIHJuQSArIGJvZHlCLm1fbWFzcyAqIGJvZHlCLm1faW52SSAqIHJuQjtcbiAgICAgICAgICAgIGNjcC5lcXVhbGl6ZWRNYXNzID0gMS4wIC8ga0VxdWFsaXplZDtcbiAgICAgICAgICAgIHZhciB0YW5nZW50WCA9IG5vcm1hbFk7XG4gICAgICAgICAgICB2YXIgdGFuZ2VudFkgPSAoLW5vcm1hbFgpO1xuICAgICAgICAgICAgdmFyIHJ0QSA9IHJBWCAqIHRhbmdlbnRZIC0gckFZICogdGFuZ2VudFg7XG4gICAgICAgICAgICB2YXIgcnRCID0gckJYICogdGFuZ2VudFkgLSByQlkgKiB0YW5nZW50WDtcbiAgICAgICAgICAgIHJ0QSAqPSBydEE7XG4gICAgICAgICAgICBydEIgKj0gcnRCO1xuICAgICAgICAgICAgdmFyIGtUYW5nZW50ID0gYm9keUEubV9pbnZNYXNzICsgYm9keUIubV9pbnZNYXNzICsgYm9keUEubV9pbnZJICogcnRBICsgYm9keUIubV9pbnZJICogcnRCO1xuICAgICAgICAgICAgY2NwLnRhbmdlbnRNYXNzID0gMS4wIC8ga1RhbmdlbnQ7XG4gICAgICAgICAgICBjY3AudmVsb2NpdHlCaWFzID0gMC4wO1xuICAgICAgICAgICAgdmFyIHRYID0gdkJYICsgKCgtd0IgKiByQlkpKSAtIHZBWCAtICgoLXdBICogckFZKSk7XG4gICAgICAgICAgICB2YXIgdFkgPSB2QlkgKyAod0IgKiByQlgpIC0gdkFZIC0gKHdBICogckFYKTtcbiAgICAgICAgICAgIHZhciB2UmVsID0gY2Mubm9ybWFsLnggKiB0WCArIGNjLm5vcm1hbC55ICogdFk7XG4gICAgICAgICAgICBpZiAodlJlbCA8ICgtYjJTZXR0aW5ncy5iMl92ZWxvY2l0eVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgICAgIGNjcC52ZWxvY2l0eUJpYXMgKz0gKC1jYy5yZXN0aXR1dGlvbiAqIHZSZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKGNjLnBvaW50Q291bnQgPT0gMikge1xuICAgICAgICAgICAgdmFyIGNjcDEgPSBjYy5wb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgY2NwMiA9IGNjLnBvaW50c1sxXTtcbiAgICAgICAgICAgIHZhciBpbnZNYXNzQSA9IGJvZHlBLm1faW52TWFzcztcbiAgICAgICAgICAgIHZhciBpbnZJQSA9IGJvZHlBLm1faW52STtcbiAgICAgICAgICAgIHZhciBpbnZNYXNzQiA9IGJvZHlCLm1faW52TWFzcztcbiAgICAgICAgICAgIHZhciBpbnZJQiA9IGJvZHlCLm1faW52STtcbiAgICAgICAgICAgIHZhciBybjFBID0gY2NwMS5yQS54ICogbm9ybWFsWSAtIGNjcDEuckEueSAqIG5vcm1hbFg7XG4gICAgICAgICAgICB2YXIgcm4xQiA9IGNjcDEuckIueCAqIG5vcm1hbFkgLSBjY3AxLnJCLnkgKiBub3JtYWxYO1xuICAgICAgICAgICAgdmFyIHJuMkEgPSBjY3AyLnJBLnggKiBub3JtYWxZIC0gY2NwMi5yQS55ICogbm9ybWFsWDtcbiAgICAgICAgICAgIHZhciBybjJCID0gY2NwMi5yQi54ICogbm9ybWFsWSAtIGNjcDIuckIueSAqIG5vcm1hbFg7XG4gICAgICAgICAgICB2YXIgazExID0gaW52TWFzc0EgKyBpbnZNYXNzQiArIGludklBICogcm4xQSAqIHJuMUEgKyBpbnZJQiAqIHJuMUIgKiBybjFCO1xuICAgICAgICAgICAgdmFyIGsyMiA9IGludk1hc3NBICsgaW52TWFzc0IgKyBpbnZJQSAqIHJuMkEgKiBybjJBICsgaW52SUIgKiBybjJCICogcm4yQjtcbiAgICAgICAgICAgIHZhciBrMTIgPSBpbnZNYXNzQSArIGludk1hc3NCICsgaW52SUEgKiBybjFBICogcm4yQSArIGludklCICogcm4xQiAqIHJuMkI7XG4gICAgICAgICAgICB2YXIga19tYXhDb25kaXRpb25OdW1iZXIgPSAxMDAuMDtcbiAgICAgICAgICAgIGlmIChrMTEgKiBrMTEgPCBrX21heENvbmRpdGlvbk51bWJlciAqIChrMTEgKiBrMjIgLSBrMTIgKiBrMTIpKSB7XG4gICAgICAgICAgICAgICBjYy5LLmNvbDEuU2V0KGsxMSwgazEyKTtcbiAgICAgICAgICAgICAgIGNjLksuY29sMi5TZXQoazEyLCBrMjIpO1xuICAgICAgICAgICAgICAgY2MuSy5HZXRJbnZlcnNlKGNjLm5vcm1hbE1hc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICBjYy5wb2ludENvdW50ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIGIyQ29udGFjdFNvbHZlci5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIHRWZWM7XG4gICAgICB2YXIgdFZlYzI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnN0cmFpbnRDb3VudDsgKytpKSB7XG4gICAgICAgICB2YXIgYyA9IHRoaXMubV9jb25zdHJhaW50c1tpXTtcbiAgICAgICAgIHZhciBib2R5QSA9IGMuYm9keUE7XG4gICAgICAgICB2YXIgYm9keUIgPSBjLmJvZHlCO1xuICAgICAgICAgdmFyIGludk1hc3NBID0gYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgdmFyIGludklBID0gYm9keUEubV9pbnZJO1xuICAgICAgICAgdmFyIGludk1hc3NCID0gYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgdmFyIGludklCID0gYm9keUIubV9pbnZJO1xuICAgICAgICAgdmFyIG5vcm1hbFggPSBjLm5vcm1hbC54O1xuICAgICAgICAgdmFyIG5vcm1hbFkgPSBjLm5vcm1hbC55O1xuICAgICAgICAgdmFyIHRhbmdlbnRYID0gbm9ybWFsWTtcbiAgICAgICAgIHZhciB0YW5nZW50WSA9ICgtbm9ybWFsWCk7XG4gICAgICAgICB2YXIgdFggPSAwO1xuICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgdmFyIHRDb3VudCA9IDA7XG4gICAgICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgICAgIHRDb3VudCA9IGMucG9pbnRDb3VudDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7XG4gICAgICAgICAgICBqIDwgdENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgIHZhciBjY3AgPSBjLnBvaW50c1tqXTtcbiAgICAgICAgICAgICAgIGNjcC5ub3JtYWxJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgICAgICAgIGNjcC50YW5nZW50SW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICAgICAgICB2YXIgUFggPSBjY3Aubm9ybWFsSW1wdWxzZSAqIG5vcm1hbFggKyBjY3AudGFuZ2VudEltcHVsc2UgKiB0YW5nZW50WDtcbiAgICAgICAgICAgICAgIHZhciBQWSA9IGNjcC5ub3JtYWxJbXB1bHNlICogbm9ybWFsWSArIGNjcC50YW5nZW50SW1wdWxzZSAqIHRhbmdlbnRZO1xuICAgICAgICAgICAgICAgYm9keUEubV9hbmd1bGFyVmVsb2NpdHkgLT0gaW52SUEgKiAoY2NwLnJBLnggKiBQWSAtIGNjcC5yQS55ICogUFgpO1xuICAgICAgICAgICAgICAgYm9keUEubV9saW5lYXJWZWxvY2l0eS54IC09IGludk1hc3NBICogUFg7XG4gICAgICAgICAgICAgICBib2R5QS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gaW52TWFzc0EgKiBQWTtcbiAgICAgICAgICAgICAgIGJvZHlCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGludklCICogKGNjcC5yQi54ICogUFkgLSBjY3AuckIueSAqIFBYKTtcbiAgICAgICAgICAgICAgIGJvZHlCLm1fbGluZWFyVmVsb2NpdHkueCArPSBpbnZNYXNzQiAqIFBYO1xuICAgICAgICAgICAgICAgYm9keUIubV9saW5lYXJWZWxvY2l0eS55ICs9IGludk1hc3NCICogUFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRDb3VudCA9IGMucG9pbnRDb3VudDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7XG4gICAgICAgICAgICBqIDwgdENvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgIHZhciBjY3AyID0gYy5wb2ludHNbal07XG4gICAgICAgICAgICAgICBjY3AyLm5vcm1hbEltcHVsc2UgPSAwLjA7XG4gICAgICAgICAgICAgICBjY3AyLnRhbmdlbnRJbXB1bHNlID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICB2YXIgY2NwO1xuICAgICAgdmFyIHJBWCA9IDA7XG4gICAgICB2YXIgckFZID0gMDtcbiAgICAgIHZhciByQlggPSAwO1xuICAgICAgdmFyIHJCWSA9IDA7XG4gICAgICB2YXIgZHZYID0gMDtcbiAgICAgIHZhciBkdlkgPSAwO1xuICAgICAgdmFyIHZuID0gMDtcbiAgICAgIHZhciB2dCA9IDA7XG4gICAgICB2YXIgbGFtYmRhID0gMDtcbiAgICAgIHZhciBtYXhGcmljdGlvbiA9IDA7XG4gICAgICB2YXIgbmV3SW1wdWxzZSA9IDA7XG4gICAgICB2YXIgUFggPSAwO1xuICAgICAgdmFyIFBZID0gMDtcbiAgICAgIHZhciBkWCA9IDA7XG4gICAgICB2YXIgZFkgPSAwO1xuICAgICAgdmFyIFAxWCA9IDA7XG4gICAgICB2YXIgUDFZID0gMDtcbiAgICAgIHZhciBQMlggPSAwO1xuICAgICAgdmFyIFAyWSA9IDA7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29uc3RyYWludENvdW50OyArK2kpIHtcbiAgICAgICAgIHZhciBjID0gdGhpcy5tX2NvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgdmFyIGJvZHlBID0gYy5ib2R5QTtcbiAgICAgICAgIHZhciBib2R5QiA9IGMuYm9keUI7XG4gICAgICAgICB2YXIgd0EgPSBib2R5QS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgIHZhciB3QiA9IGJvZHlCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgdmFyIHZBID0gYm9keUEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgICAgIHZhciB2QiA9IGJvZHlCLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICAgICB2YXIgaW52TWFzc0EgPSBib2R5QS5tX2ludk1hc3M7XG4gICAgICAgICB2YXIgaW52SUEgPSBib2R5QS5tX2ludkk7XG4gICAgICAgICB2YXIgaW52TWFzc0IgPSBib2R5Qi5tX2ludk1hc3M7XG4gICAgICAgICB2YXIgaW52SUIgPSBib2R5Qi5tX2ludkk7XG4gICAgICAgICB2YXIgbm9ybWFsWCA9IGMubm9ybWFsLng7XG4gICAgICAgICB2YXIgbm9ybWFsWSA9IGMubm9ybWFsLnk7XG4gICAgICAgICB2YXIgdGFuZ2VudFggPSBub3JtYWxZO1xuICAgICAgICAgdmFyIHRhbmdlbnRZID0gKC1ub3JtYWxYKTtcbiAgICAgICAgIHZhciBmcmljdGlvbiA9IGMuZnJpY3Rpb247XG4gICAgICAgICB2YXIgdFggPSAwO1xuICAgICAgICAgZm9yIChqID0gMDtcbiAgICAgICAgIGogPCBjLnBvaW50Q291bnQ7IGorKykge1xuICAgICAgICAgICAgY2NwID0gYy5wb2ludHNbal07XG4gICAgICAgICAgICBkdlggPSB2Qi54IC0gd0IgKiBjY3AuckIueSAtIHZBLnggKyB3QSAqIGNjcC5yQS55O1xuICAgICAgICAgICAgZHZZID0gdkIueSArIHdCICogY2NwLnJCLnggLSB2QS55IC0gd0EgKiBjY3AuckEueDtcbiAgICAgICAgICAgIHZ0ID0gZHZYICogdGFuZ2VudFggKyBkdlkgKiB0YW5nZW50WTtcbiAgICAgICAgICAgIGxhbWJkYSA9IGNjcC50YW5nZW50TWFzcyAqICgtdnQpO1xuICAgICAgICAgICAgbWF4RnJpY3Rpb24gPSBmcmljdGlvbiAqIGNjcC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IGIyTWF0aC5DbGFtcChjY3AudGFuZ2VudEltcHVsc2UgKyBsYW1iZGEsICgtbWF4RnJpY3Rpb24pLCBtYXhGcmljdGlvbik7XG4gICAgICAgICAgICBsYW1iZGEgPSBuZXdJbXB1bHNlIC0gY2NwLnRhbmdlbnRJbXB1bHNlO1xuICAgICAgICAgICAgUFggPSBsYW1iZGEgKiB0YW5nZW50WDtcbiAgICAgICAgICAgIFBZID0gbGFtYmRhICogdGFuZ2VudFk7XG4gICAgICAgICAgICB2QS54IC09IGludk1hc3NBICogUFg7XG4gICAgICAgICAgICB2QS55IC09IGludk1hc3NBICogUFk7XG4gICAgICAgICAgICB3QSAtPSBpbnZJQSAqIChjY3AuckEueCAqIFBZIC0gY2NwLnJBLnkgKiBQWCk7XG4gICAgICAgICAgICB2Qi54ICs9IGludk1hc3NCICogUFg7XG4gICAgICAgICAgICB2Qi55ICs9IGludk1hc3NCICogUFk7XG4gICAgICAgICAgICB3QiArPSBpbnZJQiAqIChjY3AuckIueCAqIFBZIC0gY2NwLnJCLnkgKiBQWCk7XG4gICAgICAgICAgICBjY3AudGFuZ2VudEltcHVsc2UgPSBuZXdJbXB1bHNlO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIHRDb3VudCA9IHBhcnNlSW50KGMucG9pbnRDb3VudCk7XG4gICAgICAgICBpZiAoYy5wb2ludENvdW50ID09IDEpIHtcbiAgICAgICAgICAgIGNjcCA9IGMucG9pbnRzWzBdO1xuICAgICAgICAgICAgZHZYID0gdkIueCArICgoLXdCICogY2NwLnJCLnkpKSAtIHZBLnggLSAoKC13QSAqIGNjcC5yQS55KSk7XG4gICAgICAgICAgICBkdlkgPSB2Qi55ICsgKHdCICogY2NwLnJCLngpIC0gdkEueSAtICh3QSAqIGNjcC5yQS54KTtcbiAgICAgICAgICAgIHZuID0gZHZYICogbm9ybWFsWCArIGR2WSAqIG5vcm1hbFk7XG4gICAgICAgICAgICBsYW1iZGEgPSAoLWNjcC5ub3JtYWxNYXNzICogKHZuIC0gY2NwLnZlbG9jaXR5QmlhcykpO1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IGNjcC5ub3JtYWxJbXB1bHNlICsgbGFtYmRhO1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IG5ld0ltcHVsc2UgPiAwID8gbmV3SW1wdWxzZSA6IDAuMDtcbiAgICAgICAgICAgIGxhbWJkYSA9IG5ld0ltcHVsc2UgLSBjY3Aubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgIFBYID0gbGFtYmRhICogbm9ybWFsWDtcbiAgICAgICAgICAgIFBZID0gbGFtYmRhICogbm9ybWFsWTtcbiAgICAgICAgICAgIHZBLnggLT0gaW52TWFzc0EgKiBQWDtcbiAgICAgICAgICAgIHZBLnkgLT0gaW52TWFzc0EgKiBQWTtcbiAgICAgICAgICAgIHdBIC09IGludklBICogKGNjcC5yQS54ICogUFkgLSBjY3AuckEueSAqIFBYKTtcbiAgICAgICAgICAgIHZCLnggKz0gaW52TWFzc0IgKiBQWDtcbiAgICAgICAgICAgIHZCLnkgKz0gaW52TWFzc0IgKiBQWTtcbiAgICAgICAgICAgIHdCICs9IGludklCICogKGNjcC5yQi54ICogUFkgLSBjY3AuckIueSAqIFBYKTtcbiAgICAgICAgICAgIGNjcC5ub3JtYWxJbXB1bHNlID0gbmV3SW1wdWxzZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNwMSA9IGMucG9pbnRzWzBdO1xuICAgICAgICAgICAgdmFyIGNwMiA9IGMucG9pbnRzWzFdO1xuICAgICAgICAgICAgdmFyIGFYID0gY3AxLm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICB2YXIgYVkgPSBjcDIubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgIHZhciBkdjFYID0gdkIueCAtIHdCICogY3AxLnJCLnkgLSB2QS54ICsgd0EgKiBjcDEuckEueTtcbiAgICAgICAgICAgIHZhciBkdjFZID0gdkIueSArIHdCICogY3AxLnJCLnggLSB2QS55IC0gd0EgKiBjcDEuckEueDtcbiAgICAgICAgICAgIHZhciBkdjJYID0gdkIueCAtIHdCICogY3AyLnJCLnkgLSB2QS54ICsgd0EgKiBjcDIuckEueTtcbiAgICAgICAgICAgIHZhciBkdjJZID0gdkIueSArIHdCICogY3AyLnJCLnggLSB2QS55IC0gd0EgKiBjcDIuckEueDtcbiAgICAgICAgICAgIHZhciB2bjEgPSBkdjFYICogbm9ybWFsWCArIGR2MVkgKiBub3JtYWxZO1xuICAgICAgICAgICAgdmFyIHZuMiA9IGR2MlggKiBub3JtYWxYICsgZHYyWSAqIG5vcm1hbFk7XG4gICAgICAgICAgICB2YXIgYlggPSB2bjEgLSBjcDEudmVsb2NpdHlCaWFzO1xuICAgICAgICAgICAgdmFyIGJZID0gdm4yIC0gY3AyLnZlbG9jaXR5QmlhcztcbiAgICAgICAgICAgIHRNYXQgPSBjLks7XG4gICAgICAgICAgICBiWCAtPSB0TWF0LmNvbDEueCAqIGFYICsgdE1hdC5jb2wyLnggKiBhWTtcbiAgICAgICAgICAgIGJZIC09IHRNYXQuY29sMS55ICogYVggKyB0TWF0LmNvbDIueSAqIGFZO1xuICAgICAgICAgICAgdmFyIGtfZXJyb3JUb2wgPSAwLjAwMTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgIHRNYXQgPSBjLm5vcm1hbE1hc3M7XG4gICAgICAgICAgICAgICB2YXIgeFggPSAoLSh0TWF0LmNvbDEueCAqIGJYICsgdE1hdC5jb2wyLnggKiBiWSkpO1xuICAgICAgICAgICAgICAgdmFyIHhZID0gKC0odE1hdC5jb2wxLnkgKiBiWCArIHRNYXQuY29sMi55ICogYlkpKTtcbiAgICAgICAgICAgICAgIGlmICh4WCA+PSAwLjAgJiYgeFkgPj0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICBkWCA9IHhYIC0gYVg7XG4gICAgICAgICAgICAgICAgICBkWSA9IHhZIC0gYVk7XG4gICAgICAgICAgICAgICAgICBQMVggPSBkWCAqIG5vcm1hbFg7XG4gICAgICAgICAgICAgICAgICBQMVkgPSBkWCAqIG5vcm1hbFk7XG4gICAgICAgICAgICAgICAgICBQMlggPSBkWSAqIG5vcm1hbFg7XG4gICAgICAgICAgICAgICAgICBQMlkgPSBkWSAqIG5vcm1hbFk7XG4gICAgICAgICAgICAgICAgICB2QS54IC09IGludk1hc3NBICogKFAxWCArIFAyWCk7XG4gICAgICAgICAgICAgICAgICB2QS55IC09IGludk1hc3NBICogKFAxWSArIFAyWSk7XG4gICAgICAgICAgICAgICAgICB3QSAtPSBpbnZJQSAqIChjcDEuckEueCAqIFAxWSAtIGNwMS5yQS55ICogUDFYICsgY3AyLnJBLnggKiBQMlkgLSBjcDIuckEueSAqIFAyWCk7XG4gICAgICAgICAgICAgICAgICB2Qi54ICs9IGludk1hc3NCICogKFAxWCArIFAyWCk7XG4gICAgICAgICAgICAgICAgICB2Qi55ICs9IGludk1hc3NCICogKFAxWSArIFAyWSk7XG4gICAgICAgICAgICAgICAgICB3QiArPSBpbnZJQiAqIChjcDEuckIueCAqIFAxWSAtIGNwMS5yQi55ICogUDFYICsgY3AyLnJCLnggKiBQMlkgLSBjcDIuckIueSAqIFAyWCk7XG4gICAgICAgICAgICAgICAgICBjcDEubm9ybWFsSW1wdWxzZSA9IHhYO1xuICAgICAgICAgICAgICAgICAgY3AyLm5vcm1hbEltcHVsc2UgPSB4WTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgeFggPSAoLWNwMS5ub3JtYWxNYXNzICogYlgpO1xuICAgICAgICAgICAgICAgeFkgPSAwLjA7XG4gICAgICAgICAgICAgICB2bjEgPSAwLjA7XG4gICAgICAgICAgICAgICB2bjIgPSBjLksuY29sMS55ICogeFggKyBiWTtcbiAgICAgICAgICAgICAgIGlmICh4WCA+PSAwLjAgJiYgdm4yID49IDAuMCkge1xuICAgICAgICAgICAgICAgICAgZFggPSB4WCAtIGFYO1xuICAgICAgICAgICAgICAgICAgZFkgPSB4WSAtIGFZO1xuICAgICAgICAgICAgICAgICAgUDFYID0gZFggKiBub3JtYWxYO1xuICAgICAgICAgICAgICAgICAgUDFZID0gZFggKiBub3JtYWxZO1xuICAgICAgICAgICAgICAgICAgUDJYID0gZFkgKiBub3JtYWxYO1xuICAgICAgICAgICAgICAgICAgUDJZID0gZFkgKiBub3JtYWxZO1xuICAgICAgICAgICAgICAgICAgdkEueCAtPSBpbnZNYXNzQSAqIChQMVggKyBQMlgpO1xuICAgICAgICAgICAgICAgICAgdkEueSAtPSBpbnZNYXNzQSAqIChQMVkgKyBQMlkpO1xuICAgICAgICAgICAgICAgICAgd0EgLT0gaW52SUEgKiAoY3AxLnJBLnggKiBQMVkgLSBjcDEuckEueSAqIFAxWCArIGNwMi5yQS54ICogUDJZIC0gY3AyLnJBLnkgKiBQMlgpO1xuICAgICAgICAgICAgICAgICAgdkIueCArPSBpbnZNYXNzQiAqIChQMVggKyBQMlgpO1xuICAgICAgICAgICAgICAgICAgdkIueSArPSBpbnZNYXNzQiAqIChQMVkgKyBQMlkpO1xuICAgICAgICAgICAgICAgICAgd0IgKz0gaW52SUIgKiAoY3AxLnJCLnggKiBQMVkgLSBjcDEuckIueSAqIFAxWCArIGNwMi5yQi54ICogUDJZIC0gY3AyLnJCLnkgKiBQMlgpO1xuICAgICAgICAgICAgICAgICAgY3AxLm5vcm1hbEltcHVsc2UgPSB4WDtcbiAgICAgICAgICAgICAgICAgIGNwMi5ub3JtYWxJbXB1bHNlID0geFk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIHhYID0gMC4wO1xuICAgICAgICAgICAgICAgeFkgPSAoLWNwMi5ub3JtYWxNYXNzICogYlkpO1xuICAgICAgICAgICAgICAgdm4xID0gYy5LLmNvbDIueCAqIHhZICsgYlg7XG4gICAgICAgICAgICAgICB2bjIgPSAwLjA7XG4gICAgICAgICAgICAgICBpZiAoeFkgPj0gMC4wICYmIHZuMSA+PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgIGRYID0geFggLSBhWDtcbiAgICAgICAgICAgICAgICAgIGRZID0geFkgLSBhWTtcbiAgICAgICAgICAgICAgICAgIFAxWCA9IGRYICogbm9ybWFsWDtcbiAgICAgICAgICAgICAgICAgIFAxWSA9IGRYICogbm9ybWFsWTtcbiAgICAgICAgICAgICAgICAgIFAyWCA9IGRZICogbm9ybWFsWDtcbiAgICAgICAgICAgICAgICAgIFAyWSA9IGRZICogbm9ybWFsWTtcbiAgICAgICAgICAgICAgICAgIHZBLnggLT0gaW52TWFzc0EgKiAoUDFYICsgUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZBLnkgLT0gaW52TWFzc0EgKiAoUDFZICsgUDJZKTtcbiAgICAgICAgICAgICAgICAgIHdBIC09IGludklBICogKGNwMS5yQS54ICogUDFZIC0gY3AxLnJBLnkgKiBQMVggKyBjcDIuckEueCAqIFAyWSAtIGNwMi5yQS55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZCLnggKz0gaW52TWFzc0IgKiAoUDFYICsgUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZCLnkgKz0gaW52TWFzc0IgKiAoUDFZICsgUDJZKTtcbiAgICAgICAgICAgICAgICAgIHdCICs9IGludklCICogKGNwMS5yQi54ICogUDFZIC0gY3AxLnJCLnkgKiBQMVggKyBjcDIuckIueCAqIFAyWSAtIGNwMi5yQi55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAgIGNwMS5ub3JtYWxJbXB1bHNlID0geFg7XG4gICAgICAgICAgICAgICAgICBjcDIubm9ybWFsSW1wdWxzZSA9IHhZO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB4WCA9IDAuMDtcbiAgICAgICAgICAgICAgIHhZID0gMC4wO1xuICAgICAgICAgICAgICAgdm4xID0gYlg7XG4gICAgICAgICAgICAgICB2bjIgPSBiWTtcbiAgICAgICAgICAgICAgIGlmICh2bjEgPj0gMC4wICYmIHZuMiA+PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgIGRYID0geFggLSBhWDtcbiAgICAgICAgICAgICAgICAgIGRZID0geFkgLSBhWTtcbiAgICAgICAgICAgICAgICAgIFAxWCA9IGRYICogbm9ybWFsWDtcbiAgICAgICAgICAgICAgICAgIFAxWSA9IGRYICogbm9ybWFsWTtcbiAgICAgICAgICAgICAgICAgIFAyWCA9IGRZICogbm9ybWFsWDtcbiAgICAgICAgICAgICAgICAgIFAyWSA9IGRZICogbm9ybWFsWTtcbiAgICAgICAgICAgICAgICAgIHZBLnggLT0gaW52TWFzc0EgKiAoUDFYICsgUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZBLnkgLT0gaW52TWFzc0EgKiAoUDFZICsgUDJZKTtcbiAgICAgICAgICAgICAgICAgIHdBIC09IGludklBICogKGNwMS5yQS54ICogUDFZIC0gY3AxLnJBLnkgKiBQMVggKyBjcDIuckEueCAqIFAyWSAtIGNwMi5yQS55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZCLnggKz0gaW52TWFzc0IgKiAoUDFYICsgUDJYKTtcbiAgICAgICAgICAgICAgICAgIHZCLnkgKz0gaW52TWFzc0IgKiAoUDFZICsgUDJZKTtcbiAgICAgICAgICAgICAgICAgIHdCICs9IGludklCICogKGNwMS5yQi54ICogUDFZIC0gY3AxLnJCLnkgKiBQMVggKyBjcDIuckIueCAqIFAyWSAtIGNwMi5yQi55ICogUDJYKTtcbiAgICAgICAgICAgICAgICAgIGNwMS5ub3JtYWxJbXB1bHNlID0geFg7XG4gICAgICAgICAgICAgICAgICBjcDIubm9ybWFsSW1wdWxzZSA9IHhZO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGJvZHlBLm1fYW5ndWxhclZlbG9jaXR5ID0gd0E7XG4gICAgICAgICBib2R5Qi5tX2FuZ3VsYXJWZWxvY2l0eSA9IHdCO1xuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5GaW5hbGl6ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb25zdHJhaW50Q291bnQ7ICsraSkge1xuICAgICAgICAgdmFyIGMgPSB0aGlzLm1fY29uc3RyYWludHNbaV07XG4gICAgICAgICB2YXIgbSA9IGMubWFuaWZvbGQ7XG4gICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMucG9pbnRDb3VudDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQxID0gbS5tX3BvaW50c1tqXTtcbiAgICAgICAgICAgIHZhciBwb2ludDIgPSBjLnBvaW50c1tqXTtcbiAgICAgICAgICAgIHBvaW50MS5tX25vcm1hbEltcHVsc2UgPSBwb2ludDIubm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgIHBvaW50MS5tX3RhbmdlbnRJbXB1bHNlID0gcG9pbnQyLnRhbmdlbnRJbXB1bHNlO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICB2YXIgbWluU2VwYXJhdGlvbiA9IDAuMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnN0cmFpbnRDb3VudDsgaSsrKSB7XG4gICAgICAgICB2YXIgYyA9IHRoaXMubV9jb25zdHJhaW50c1tpXTtcbiAgICAgICAgIHZhciBib2R5QSA9IGMuYm9keUE7XG4gICAgICAgICB2YXIgYm9keUIgPSBjLmJvZHlCO1xuICAgICAgICAgdmFyIGludk1hc3NBID0gYm9keUEubV9tYXNzICogYm9keUEubV9pbnZNYXNzO1xuICAgICAgICAgdmFyIGludklBID0gYm9keUEubV9tYXNzICogYm9keUEubV9pbnZJO1xuICAgICAgICAgdmFyIGludk1hc3NCID0gYm9keUIubV9tYXNzICogYm9keUIubV9pbnZNYXNzO1xuICAgICAgICAgdmFyIGludklCID0gYm9keUIubV9tYXNzICogYm9keUIubV9pbnZJO1xuICAgICAgICAgYjJDb250YWN0U29sdmVyLnNfcHNtLkluaXRpYWxpemUoYyk7XG4gICAgICAgICB2YXIgbm9ybWFsID0gYjJDb250YWN0U29sdmVyLnNfcHNtLm1fbm9ybWFsO1xuICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLnBvaW50Q291bnQ7IGorKykge1xuICAgICAgICAgICAgdmFyIGNjcCA9IGMucG9pbnRzW2pdO1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gYjJDb250YWN0U29sdmVyLnNfcHNtLm1fcG9pbnRzW2pdO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBiMkNvbnRhY3RTb2x2ZXIuc19wc20ubV9zZXBhcmF0aW9uc1tqXTtcbiAgICAgICAgICAgIHZhciByQVggPSBwb2ludC54IC0gYm9keUEubV9zd2VlcC5jLng7XG4gICAgICAgICAgICB2YXIgckFZID0gcG9pbnQueSAtIGJvZHlBLm1fc3dlZXAuYy55O1xuICAgICAgICAgICAgdmFyIHJCWCA9IHBvaW50LnggLSBib2R5Qi5tX3N3ZWVwLmMueDtcbiAgICAgICAgICAgIHZhciByQlkgPSBwb2ludC55IC0gYm9keUIubV9zd2VlcC5jLnk7XG4gICAgICAgICAgICBtaW5TZXBhcmF0aW9uID0gbWluU2VwYXJhdGlvbiA8IHNlcGFyYXRpb24gPyBtaW5TZXBhcmF0aW9uIDogc2VwYXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBDID0gYjJNYXRoLkNsYW1wKGJhdW1nYXJ0ZSAqIChzZXBhcmF0aW9uICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSwgKC1iMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pLCAwLjApO1xuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSAoLWNjcC5lcXVhbGl6ZWRNYXNzICogQyk7XG4gICAgICAgICAgICB2YXIgUFggPSBpbXB1bHNlICogbm9ybWFsLng7XG4gICAgICAgICAgICB2YXIgUFkgPSBpbXB1bHNlICogbm9ybWFsLnk7Ym9keUEubV9zd2VlcC5jLnggLT0gaW52TWFzc0EgKiBQWDtcbiAgICAgICAgICAgIGJvZHlBLm1fc3dlZXAuYy55IC09IGludk1hc3NBICogUFk7XG4gICAgICAgICAgICBib2R5QS5tX3N3ZWVwLmEgLT0gaW52SUEgKiAockFYICogUFkgLSByQVkgKiBQWCk7XG4gICAgICAgICAgICBib2R5QS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgYm9keUIubV9zd2VlcC5jLnggKz0gaW52TWFzc0IgKiBQWDtcbiAgICAgICAgICAgIGJvZHlCLm1fc3dlZXAuYy55ICs9IGludk1hc3NCICogUFk7XG4gICAgICAgICAgICBib2R5Qi5tX3N3ZWVwLmEgKz0gaW52SUIgKiAockJYICogUFkgLSByQlkgKiBQWCk7XG4gICAgICAgICAgICBib2R5Qi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1pblNlcGFyYXRpb24gPiAoLTEuNSAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCk7XG4gICB9XG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQgPSBuZXcgYjJXb3JsZE1hbmlmb2xkKCk7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RTb2x2ZXIuc19wc20gPSBuZXcgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkKCk7XG4gICB9KTtcbiAgIEJveDJELmluaGVyaXQoYjJFZGdlQW5kQ2lyY2xlQ29udGFjdCwgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0KTtcbiAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QucHJvdG90eXBlO1xuICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5iMkVkZ2VBbmRDaXJjbGVDb250YWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QuQ3JlYXRlID0gZnVuY3Rpb24gKGFsbG9jYXRvcikge1xuICAgICAgcmV0dXJuIG5ldyBiMkVkZ2VBbmRDaXJjbGVDb250YWN0KCk7XG4gICB9XG4gICBiMkVkZ2VBbmRDaXJjbGVDb250YWN0LkRlc3Ryb3kgPSBmdW5jdGlvbiAoY29udGFjdCwgYWxsb2NhdG9yKSB7fVxuICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuUmVzZXQuY2FsbCh0aGlzLCBmaXh0dXJlQSwgZml4dHVyZUIpO1xuICAgfVxuICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuRXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fZml4dHVyZUEuR2V0Qm9keSgpO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2ZpeHR1cmVCLkdldEJvZHkoKTtcbiAgICAgIHRoaXMuYjJDb2xsaWRlRWRnZUFuZENpcmNsZSh0aGlzLm1fbWFuaWZvbGQsICh0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSBpbnN0YW5jZW9mIGIyRWRnZVNoYXBlID8gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgOiBudWxsKSwgYkEubV94ZiwgKHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJDaXJjbGVTaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xuICAgfVxuICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuYjJDb2xsaWRlRWRnZUFuZENpcmNsZSA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgZWRnZSwgeGYxLCBjaXJjbGUsIHhmMikge31cbiAgIEJveDJELmluaGVyaXQoYjJOdWxsQ29udGFjdCwgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0KTtcbiAgIGIyTnVsbENvbnRhY3QucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QucHJvdG90eXBlO1xuICAgYjJOdWxsQ29udGFjdC5iMk51bGxDb250YWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIGIyTnVsbENvbnRhY3QucHJvdG90eXBlLmIyTnVsbENvbnRhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJDb250YWN0LmNhbGwodGhpcyk7XG4gICB9XG4gICBiMk51bGxDb250YWN0LnByb3RvdHlwZS5FdmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHt9XG4gICBCb3gyRC5pbmhlcml0KGIyUG9seUFuZENpcmNsZUNvbnRhY3QsIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdCk7XG4gICBiMlBvbHlBbmRDaXJjbGVDb250YWN0LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LnByb3RvdHlwZTtcbiAgIGIyUG9seUFuZENpcmNsZUNvbnRhY3QuYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5iMkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH07XG4gICBiMlBvbHlBbmRDaXJjbGVDb250YWN0LkNyZWF0ZSA9IGZ1bmN0aW9uIChhbGxvY2F0b3IpIHtcbiAgICAgIHJldHVybiBuZXcgYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCgpO1xuICAgfVxuICAgYjJQb2x5QW5kQ2lyY2xlQ29udGFjdC5EZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRhY3QsIGFsbG9jYXRvcikge31cbiAgIGIyUG9seUFuZENpcmNsZUNvbnRhY3QucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xuICAgICAgdGhpcy5fX3N1cGVyLlJlc2V0LmNhbGwodGhpcywgZml4dHVyZUEsIGZpeHR1cmVCKTtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZml4dHVyZUEuR2V0VHlwZSgpID09IGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUpO1xuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmaXh0dXJlQi5HZXRUeXBlKCkgPT0gYjJTaGFwZS5lX2NpcmNsZVNoYXBlKTtcbiAgIH1cbiAgIGIyUG9seUFuZENpcmNsZUNvbnRhY3QucHJvdG90eXBlLkV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2ZpeHR1cmVBLm1fYm9keTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9maXh0dXJlQi5tX2JvZHk7XG4gICAgICBiMkNvbGxpc2lvbi5Db2xsaWRlUG9seWdvbkFuZENpcmNsZSh0aGlzLm1fbWFuaWZvbGQsICh0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSBpbnN0YW5jZW9mIGIyUG9seWdvblNoYXBlID8gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgOiBudWxsKSwgYkEubV94ZiwgKHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJDaXJjbGVTaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMlBvbHlBbmRFZGdlQ29udGFjdCwgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0KTtcbiAgIGIyUG9seUFuZEVkZ2VDb250YWN0LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LnByb3RvdHlwZTtcbiAgIGIyUG9seUFuZEVkZ2VDb250YWN0LmIyUG9seUFuZEVkZ2VDb250YWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfTtcbiAgIGIyUG9seUFuZEVkZ2VDb250YWN0LkNyZWF0ZSA9IGZ1bmN0aW9uIChhbGxvY2F0b3IpIHtcbiAgICAgIHJldHVybiBuZXcgYjJQb2x5QW5kRWRnZUNvbnRhY3QoKTtcbiAgIH1cbiAgIGIyUG9seUFuZEVkZ2VDb250YWN0LkRlc3Ryb3kgPSBmdW5jdGlvbiAoY29udGFjdCwgYWxsb2NhdG9yKSB7fVxuICAgYjJQb2x5QW5kRWRnZUNvbnRhY3QucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xuICAgICAgdGhpcy5fX3N1cGVyLlJlc2V0LmNhbGwodGhpcywgZml4dHVyZUEsIGZpeHR1cmVCKTtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZml4dHVyZUEuR2V0VHlwZSgpID09IGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUpO1xuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmaXh0dXJlQi5HZXRUeXBlKCkgPT0gYjJTaGFwZS5lX2VkZ2VTaGFwZSk7XG4gICB9XG4gICBiMlBvbHlBbmRFZGdlQ29udGFjdC5wcm90b3R5cGUuRXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fZml4dHVyZUEuR2V0Qm9keSgpO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2ZpeHR1cmVCLkdldEJvZHkoKTtcbiAgICAgIHRoaXMuYjJDb2xsaWRlUG9seUFuZEVkZ2UodGhpcy5tX21hbmlmb2xkLCAodGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMlBvbHlnb25TaGFwZSA/IHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpIDogbnVsbCksIGJBLm1feGYsICh0aGlzLm1fZml4dHVyZUIuR2V0U2hhcGUoKSBpbnN0YW5jZW9mIGIyRWRnZVNoYXBlID8gdGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCkgOiBudWxsKSwgYkIubV94Zik7XG4gICB9XG4gICBiMlBvbHlBbmRFZGdlQ29udGFjdC5wcm90b3R5cGUuYjJDb2xsaWRlUG9seUFuZEVkZ2UgPSBmdW5jdGlvbiAobWFuaWZvbGQsIHBvbHlnb24sIHhmMSwgZWRnZSwgeGYyKSB7fVxuICAgQm94MkQuaW5oZXJpdChiMlBvbHlnb25Db250YWN0LCBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QpO1xuICAgYjJQb2x5Z29uQ29udGFjdC5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5wcm90b3R5cGU7XG4gICBiMlBvbHlnb25Db250YWN0LmIyUG9seWdvbkNvbnRhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuYjJDb250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgYjJQb2x5Z29uQ29udGFjdC5DcmVhdGUgPSBmdW5jdGlvbiAoYWxsb2NhdG9yKSB7XG4gICAgICByZXR1cm4gbmV3IGIyUG9seWdvbkNvbnRhY3QoKTtcbiAgIH1cbiAgIGIyUG9seWdvbkNvbnRhY3QuRGVzdHJveSA9IGZ1bmN0aW9uIChjb250YWN0LCBhbGxvY2F0b3IpIHt9XG4gICBiMlBvbHlnb25Db250YWN0LnByb3RvdHlwZS5SZXNldCA9IGZ1bmN0aW9uIChmaXh0dXJlQSwgZml4dHVyZUIpIHtcbiAgICAgIHRoaXMuX19zdXBlci5SZXNldC5jYWxsKHRoaXMsIGZpeHR1cmVBLCBmaXh0dXJlQik7XG4gICB9XG4gICBiMlBvbHlnb25Db250YWN0LnByb3RvdHlwZS5FdmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9maXh0dXJlQS5HZXRCb2R5KCk7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fZml4dHVyZUIuR2V0Qm9keSgpO1xuICAgICAgYjJDb2xsaXNpb24uQ29sbGlkZVBvbHlnb25zKHRoaXMubV9tYW5pZm9sZCwgKHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJQb2x5Z29uU2hhcGUgPyB0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSA6IG51bGwpLCBiQS5tX3hmLCAodGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMlBvbHlnb25TaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xuICAgfVxuICAgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLnByb3RvdHlwZS5iMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fbm9ybWFsID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3NlcGFyYXRpb25zID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xuICAgICAgdGhpcy5tX3BvaW50cyA9IG5ldyBWZWN0b3IoYjJTZXR0aW5ncy5iMl9tYXhNYW5pZm9sZFBvaW50cyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xuICAgICAgICAgdGhpcy5tX3BvaW50c1tpXSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZC5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChjYykge1xuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChjYy5wb2ludENvdW50ID4gMCk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgY2xpcFBvaW50WCA9IDA7XG4gICAgICB2YXIgY2xpcFBvaW50WSA9IDA7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0VmVjO1xuICAgICAgdmFyIHBsYW5lUG9pbnRYID0gMDtcbiAgICAgIHZhciBwbGFuZVBvaW50WSA9IDA7XG4gICAgICBzd2l0Y2ggKGNjLnR5cGUpIHtcbiAgICAgIGNhc2UgYjJNYW5pZm9sZC5lX2NpcmNsZXM6XG4gICAgICAgICB7XG4gICAgICAgICAgICB0TWF0ID0gY2MuYm9keUEubV94Zi5SO1xuICAgICAgICAgICAgdFZlYyA9IGNjLmxvY2FsUG9pbnQ7XG4gICAgICAgICAgICB2YXIgcG9pbnRBWCA9IGNjLmJvZHlBLm1feGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgICAgIHZhciBwb2ludEFZID0gY2MuYm9keUEubV94Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgdE1hdCA9IGNjLmJvZHlCLm1feGYuUjtcbiAgICAgICAgICAgIHRWZWMgPSBjYy5wb2ludHNbMF0ubG9jYWxQb2ludDtcbiAgICAgICAgICAgIHZhciBwb2ludEJYID0gY2MuYm9keUIubV94Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgdmFyIHBvaW50QlkgPSBjYy5ib2R5Qi5tX3hmLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICAgICB2YXIgZFggPSBwb2ludEJYIC0gcG9pbnRBWDtcbiAgICAgICAgICAgIHZhciBkWSA9IHBvaW50QlkgLSBwb2ludEFZO1xuICAgICAgICAgICAgdmFyIGQyID0gZFggKiBkWCArIGRZICogZFk7XG4gICAgICAgICAgICBpZiAoZDIgPiBOdW1iZXIuTUlOX1ZBTFVFICogTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgICAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoZDIpO1xuICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ID0gZFggLyBkO1xuICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbC55ID0gZFkgLyBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnggPSAxLjA7XG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fcG9pbnRzWzBdLnggPSAwLjUgKiAocG9pbnRBWCArIHBvaW50QlgpO1xuICAgICAgICAgICAgdGhpcy5tX3BvaW50c1swXS55ID0gMC41ICogKHBvaW50QVkgKyBwb2ludEJZKTtcbiAgICAgICAgICAgIHRoaXMubV9zZXBhcmF0aW9uc1swXSA9IGRYICogdGhpcy5tX25vcm1hbC54ICsgZFkgKiB0aGlzLm1fbm9ybWFsLnkgLSBjYy5yYWRpdXM7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJNYW5pZm9sZC5lX2ZhY2VBOlxuICAgICAgICAge1xuICAgICAgICAgICAgdE1hdCA9IGNjLmJvZHlBLm1feGYuUjtcbiAgICAgICAgICAgIHRWZWMgPSBjYy5sb2NhbFBsYW5lTm9ybWFsO1xuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ID0gdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XG4gICAgICAgICAgICB0TWF0ID0gY2MuYm9keUEubV94Zi5SO1xuICAgICAgICAgICAgdFZlYyA9IGNjLmxvY2FsUG9pbnQ7XG4gICAgICAgICAgICBwbGFuZVBvaW50WCA9IGNjLmJvZHlBLm1feGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcbiAgICAgICAgICAgIHBsYW5lUG9pbnRZID0gY2MuYm9keUEubV94Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgdE1hdCA9IGNjLmJvZHlCLm1feGYuUjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7XG4gICAgICAgICAgICBpIDwgY2MucG9pbnRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICB0VmVjID0gY2MucG9pbnRzW2ldLmxvY2FsUG9pbnQ7XG4gICAgICAgICAgICAgICBjbGlwUG9pbnRYID0gY2MuYm9keUIubV94Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgICAgY2xpcFBvaW50WSA9IGNjLmJvZHlCLm1feGYucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcbiAgICAgICAgICAgICAgIHRoaXMubV9zZXBhcmF0aW9uc1tpXSA9IChjbGlwUG9pbnRYIC0gcGxhbmVQb2ludFgpICogdGhpcy5tX25vcm1hbC54ICsgKGNsaXBQb2ludFkgLSBwbGFuZVBvaW50WSkgKiB0aGlzLm1fbm9ybWFsLnkgLSBjYy5yYWRpdXM7XG4gICAgICAgICAgICAgICB0aGlzLm1fcG9pbnRzW2ldLnggPSBjbGlwUG9pbnRYO1xuICAgICAgICAgICAgICAgdGhpcy5tX3BvaW50c1tpXS55ID0gY2xpcFBvaW50WTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMk1hbmlmb2xkLmVfZmFjZUI6XG4gICAgICAgICB7XG4gICAgICAgICAgICB0TWF0ID0gY2MuYm9keUIubV94Zi5SO1xuICAgICAgICAgICAgdFZlYyA9IGNjLmxvY2FsUGxhbmVOb3JtYWw7XG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC55ID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgICAgIHRNYXQgPSBjYy5ib2R5Qi5tX3hmLlI7XG4gICAgICAgICAgICB0VmVjID0gY2MubG9jYWxQb2ludDtcbiAgICAgICAgICAgIHBsYW5lUG9pbnRYID0gY2MuYm9keUIubV94Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xuICAgICAgICAgICAgcGxhbmVQb2ludFkgPSBjYy5ib2R5Qi5tX3hmLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XG4gICAgICAgICAgICB0TWF0ID0gY2MuYm9keUEubV94Zi5SO1xuICAgICAgICAgICAgZm9yIChpID0gMDtcbiAgICAgICAgICAgIGkgPCBjYy5wb2ludENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgIHRWZWMgPSBjYy5wb2ludHNbaV0ubG9jYWxQb2ludDtcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFggPSBjYy5ib2R5QS5tX3hmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XG4gICAgICAgICAgICAgICBjbGlwUG9pbnRZID0gY2MuYm9keUEubV94Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xuICAgICAgICAgICAgICAgdGhpcy5tX3NlcGFyYXRpb25zW2ldID0gKGNsaXBQb2ludFggLSBwbGFuZVBvaW50WCkgKiB0aGlzLm1fbm9ybWFsLnggKyAoY2xpcFBvaW50WSAtIHBsYW5lUG9pbnRZKSAqIHRoaXMubV9ub3JtYWwueSAtIGNjLnJhZGl1cztcbiAgICAgICAgICAgICAgIHRoaXMubV9wb2ludHNbaV0uU2V0KGNsaXBQb2ludFgsIGNsaXBQb2ludFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ICo9ICgtMSk7XG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgKj0gKC0xKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQuY2lyY2xlUG9pbnRBID0gbmV3IGIyVmVjMigpO1xuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmNpcmNsZVBvaW50QiA9IG5ldyBiMlZlYzIoKTtcbiAgIH0pO1xufSkoKTtcbihmdW5jdGlvbiAoKSB7XG4gICB2YXIgYjJCb2R5ID0gQm94MkQuRHluYW1pY3MuYjJCb2R5LFxuICAgICAgYjJCb2R5RGVmID0gQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmLFxuICAgICAgYjJDb250YWN0RmlsdGVyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyLFxuICAgICAgYjJDb250YWN0SW1wdWxzZSA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEltcHVsc2UsXG4gICAgICBiMkNvbnRhY3RMaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyLFxuICAgICAgYjJDb250YWN0TWFuYWdlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIsXG4gICAgICBiMkRlYnVnRHJhdyA9IEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LFxuICAgICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gQm94MkQuRHluYW1pY3MuYjJEZXN0cnVjdGlvbkxpc3RlbmVyLFxuICAgICAgYjJGaWx0ZXJEYXRhID0gQm94MkQuRHluYW1pY3MuYjJGaWx0ZXJEYXRhLFxuICAgICAgYjJGaXh0dXJlID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlLFxuICAgICAgYjJGaXh0dXJlRGVmID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlRGVmLFxuICAgICAgYjJJc2xhbmQgPSBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCxcbiAgICAgIGIyVGltZVN0ZXAgPSBCb3gyRC5EeW5hbWljcy5iMlRpbWVTdGVwLFxuICAgICAgYjJXb3JsZCA9IEJveDJELkR5bmFtaWNzLmIyV29ybGQsXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcbiAgICAgIGIyTWF0MzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDMzLFxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXG4gICAgICBiMlRyYW5zZm9ybSA9IEJveDJELkNvbW1vbi5NYXRoLmIyVHJhbnNmb3JtLFxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzLFxuICAgICAgYjJDb2xvciA9IEJveDJELkNvbW1vbi5iMkNvbG9yLFxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxuICAgICAgYjJDaXJjbGVTaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJDaXJjbGVTaGFwZSxcbiAgICAgIGIyRWRnZUNoYWluRGVmID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VDaGFpbkRlZixcbiAgICAgIGIyRWRnZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VTaGFwZSxcbiAgICAgIGIyTWFzc0RhdGEgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyTWFzc0RhdGEsXG4gICAgICBiMlBvbHlnb25TaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJQb2x5Z29uU2hhcGUsXG4gICAgICBiMlNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLFxuICAgICAgYjJCdW95YW5jeUNvbnRyb2xsZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkJ1b3lhbmN5Q29udHJvbGxlcixcbiAgICAgIGIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnN0YW50QWNjZWxDb250cm9sbGVyLFxuICAgICAgYjJDb25zdGFudEZvcmNlQ29udHJvbGxlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIsXG4gICAgICBiMkNvbnRyb2xsZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXIsXG4gICAgICBiMkNvbnRyb2xsZXJFZGdlID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyRWRnZSxcbiAgICAgIGIyR3Jhdml0eUNvbnRyb2xsZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkdyYXZpdHlDb250cm9sbGVyLFxuICAgICAgYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXI7XG5cbiAgIEJveDJELmluaGVyaXQoYjJCdW95YW5jeUNvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMkJ1b3lhbmN5Q29udHJvbGxlci5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICBiMkJ1b3lhbmN5Q29udHJvbGxlci5iMkJ1b3lhbmN5Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubm9ybWFsID0gbmV3IGIyVmVjMigwLCAoLTEpKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuZGVuc2l0eSA9IDA7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IGIyVmVjMigwLCAwKTtcbiAgICAgIHRoaXMubGluZWFyRHJhZyA9IDI7XG4gICAgICB0aGlzLmFuZ3VsYXJEcmFnID0gMTtcbiAgICAgIHRoaXMudXNlRGVuc2l0eSA9IGZhbHNlO1xuICAgICAgdGhpcy51c2VXb3JsZEdyYXZpdHkgPSB0cnVlO1xuICAgICAgdGhpcy5ncmF2aXR5ID0gbnVsbDtcbiAgIH07XG4gICBiMkJ1b3lhbmN5Q29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICBpZiAoIXRoaXMubV9ib2R5TGlzdCkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMudXNlV29ybGRHcmF2aXR5KSB7XG4gICAgICAgICB0aGlzLmdyYXZpdHkgPSB0aGlzLkdldFdvcmxkKCkuR2V0R3Jhdml0eSgpLkNvcHkoKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLm1fYm9keUxpc3Q7IGk7IGkgPSBpLm5leHRCb2R5KSB7XG4gICAgICAgICB2YXIgYm9keSA9IGkuYm9keTtcbiAgICAgICAgIGlmIChib2R5LklzQXdha2UoKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICB9XG4gICAgICAgICB2YXIgYXJlYWMgPSBuZXcgYjJWZWMyKCk7XG4gICAgICAgICB2YXIgbWFzc2MgPSBuZXcgYjJWZWMyKCk7XG4gICAgICAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICAgICAgIHZhciBtYXNzID0gMC4wO1xuICAgICAgICAgZm9yICh2YXIgZml4dHVyZSA9IGJvZHkuR2V0Rml4dHVyZUxpc3QoKTsgZml4dHVyZTsgZml4dHVyZSA9IGZpeHR1cmUuR2V0TmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgc2MgPSBuZXcgYjJWZWMyKCk7XG4gICAgICAgICAgICB2YXIgc2FyZWEgPSBmaXh0dXJlLkdldFNoYXBlKCkuQ29tcHV0ZVN1Ym1lcmdlZEFyZWEodGhpcy5ub3JtYWwsIHRoaXMub2Zmc2V0LCBib2R5LkdldFRyYW5zZm9ybSgpLCBzYyk7XG4gICAgICAgICAgICBhcmVhICs9IHNhcmVhO1xuICAgICAgICAgICAgYXJlYWMueCArPSBzYXJlYSAqIHNjLng7XG4gICAgICAgICAgICBhcmVhYy55ICs9IHNhcmVhICogc2MueTtcbiAgICAgICAgICAgIHZhciBzaGFwZURlbnNpdHkgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlRGVuc2l0eSkge1xuICAgICAgICAgICAgICAgc2hhcGVEZW5zaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgc2hhcGVEZW5zaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hc3MgKz0gc2FyZWEgKiBzaGFwZURlbnNpdHk7XG4gICAgICAgICAgICBtYXNzYy54ICs9IHNhcmVhICogc2MueCAqIHNoYXBlRGVuc2l0eTtcbiAgICAgICAgICAgIG1hc3NjLnkgKz0gc2FyZWEgKiBzYy55ICogc2hhcGVEZW5zaXR5O1xuICAgICAgICAgfVxuICAgICAgICAgYXJlYWMueCAvPSBhcmVhO1xuICAgICAgICAgYXJlYWMueSAvPSBhcmVhO1xuICAgICAgICAgbWFzc2MueCAvPSBtYXNzO1xuICAgICAgICAgbWFzc2MueSAvPSBtYXNzO1xuICAgICAgICAgaWYgKGFyZWEgPCBOdW1iZXIuTUlOX1ZBTFVFKSBjb250aW51ZTtcbiAgICAgICAgIHZhciBidW95YW5jeUZvcmNlID0gdGhpcy5ncmF2aXR5LkdldE5lZ2F0aXZlKCk7XG4gICAgICAgICBidW95YW5jeUZvcmNlLk11bHRpcGx5KHRoaXMuZGVuc2l0eSAqIGFyZWEpO1xuICAgICAgICAgYm9keS5BcHBseUZvcmNlKGJ1b3lhbmN5Rm9yY2UsIG1hc3NjKTtcbiAgICAgICAgIHZhciBkcmFnRm9yY2UgPSBib2R5LkdldExpbmVhclZlbG9jaXR5RnJvbVdvcmxkUG9pbnQoYXJlYWMpO1xuICAgICAgICAgZHJhZ0ZvcmNlLlN1YnRyYWN0KHRoaXMudmVsb2NpdHkpO1xuICAgICAgICAgZHJhZ0ZvcmNlLk11bHRpcGx5KCgtdGhpcy5saW5lYXJEcmFnICogYXJlYSkpO1xuICAgICAgICAgYm9keS5BcHBseUZvcmNlKGRyYWdGb3JjZSwgYXJlYWMpO1xuICAgICAgICAgYm9keS5BcHBseVRvcnF1ZSgoLWJvZHkuR2V0SW5lcnRpYSgpIC8gYm9keS5HZXRNYXNzKCkgKiBhcmVhICogYm9keS5HZXRBbmd1bGFyVmVsb2NpdHkoKSAqIHRoaXMuYW5ndWxhckRyYWcpKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyQnVveWFuY3lDb250cm9sbGVyLnByb3RvdHlwZS5EcmF3ID0gZnVuY3Rpb24gKGRlYnVnRHJhdykge1xuICAgICAgdmFyIHIgPSAxMDAwO1xuICAgICAgdmFyIHAxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdmFyIHAyID0gbmV3IGIyVmVjMigpO1xuICAgICAgcDEueCA9IHRoaXMubm9ybWFsLnggKiB0aGlzLm9mZnNldCArIHRoaXMubm9ybWFsLnkgKiByO1xuICAgICAgcDEueSA9IHRoaXMubm9ybWFsLnkgKiB0aGlzLm9mZnNldCAtIHRoaXMubm9ybWFsLnggKiByO1xuICAgICAgcDIueCA9IHRoaXMubm9ybWFsLnggKiB0aGlzLm9mZnNldCAtIHRoaXMubm9ybWFsLnkgKiByO1xuICAgICAgcDIueSA9IHRoaXMubm9ybWFsLnkgKiB0aGlzLm9mZnNldCArIHRoaXMubm9ybWFsLnggKiByO1xuICAgICAgdmFyIGNvbG9yID0gbmV3IGIyQ29sb3IoMCwgMCwgMSk7XG4gICAgICBkZWJ1Z0RyYXcuRHJhd1NlZ21lbnQocDEsIHAyLCBjb2xvcik7XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMkNvbnN0YW50QWNjZWxDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgIGIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIuYjJDb25zdGFudEFjY2VsQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuQSA9IG5ldyBiMlZlYzIoMCwgMCk7XG4gICB9O1xuICAgYjJDb25zdGFudEFjY2VsQ29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgc21hbGxBID0gbmV3IGIyVmVjMih0aGlzLkEueCAqIHN0ZXAuZHQsIHRoaXMuQS55ICogc3RlcC5kdCk7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5tX2JvZHlMaXN0OyBpOyBpID0gaS5uZXh0Qm9keSkge1xuICAgICAgICAgdmFyIGJvZHkgPSBpLmJvZHk7XG4gICAgICAgICBpZiAoIWJvZHkuSXNBd2FrZSgpKSBjb250aW51ZTtcbiAgICAgICAgIGJvZHkuU2V0TGluZWFyVmVsb2NpdHkobmV3IGIyVmVjMihib2R5LkdldExpbmVhclZlbG9jaXR5KCkueCArIHNtYWxsQS54LCBib2R5LkdldExpbmVhclZlbG9jaXR5KCkueSArIHNtYWxsQS55KSk7XG4gICAgICB9XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMkNvbnN0YW50Rm9yY2VDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgIGIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIuYjJDb25zdGFudEZvcmNlQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuRiA9IG5ldyBiMlZlYzIoMCwgMCk7XG4gICB9O1xuICAgYjJDb25zdGFudEZvcmNlQ29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5tX2JvZHlMaXN0OyBpOyBpID0gaS5uZXh0Qm9keSkge1xuICAgICAgICAgdmFyIGJvZHkgPSBpLmJvZHk7XG4gICAgICAgICBpZiAoIWJvZHkuSXNBd2FrZSgpKSBjb250aW51ZTtcbiAgICAgICAgIGJvZHkuQXBwbHlGb3JjZSh0aGlzLkYsIGJvZHkuR2V0V29ybGRDZW50ZXIoKSk7XG4gICAgICB9XG4gICB9XG4gICBiMkNvbnRyb2xsZXIuYjJDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge307XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLlN0ZXAgPSBmdW5jdGlvbiAoc3RlcCkge31cbiAgIGIyQ29udHJvbGxlci5wcm90b3R5cGUuRHJhdyA9IGZ1bmN0aW9uIChkZWJ1Z0RyYXcpIHt9XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLkFkZEJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgdmFyIGVkZ2UgPSBuZXcgYjJDb250cm9sbGVyRWRnZSgpO1xuICAgICAgZWRnZS5jb250cm9sbGVyID0gdGhpcztcbiAgICAgIGVkZ2UuYm9keSA9IGJvZHk7XG4gICAgICBlZGdlLm5leHRCb2R5ID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgZWRnZS5wcmV2Qm9keSA9IG51bGw7XG4gICAgICB0aGlzLm1fYm9keUxpc3QgPSBlZGdlO1xuICAgICAgaWYgKGVkZ2UubmV4dEJvZHkpIGVkZ2UubmV4dEJvZHkucHJldkJvZHkgPSBlZGdlO1xuICAgICAgdGhpcy5tX2JvZHlDb3VudCsrO1xuICAgICAgZWRnZS5uZXh0Q29udHJvbGxlciA9IGJvZHkubV9jb250cm9sbGVyTGlzdDtcbiAgICAgIGVkZ2UucHJldkNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgYm9keS5tX2NvbnRyb2xsZXJMaXN0ID0gZWRnZTtcbiAgICAgIGlmIChlZGdlLm5leHRDb250cm9sbGVyKSBlZGdlLm5leHRDb250cm9sbGVyLnByZXZDb250cm9sbGVyID0gZWRnZTtcbiAgICAgIGJvZHkubV9jb250cm9sbGVyQ291bnQrKztcbiAgIH1cbiAgIGIyQ29udHJvbGxlci5wcm90b3R5cGUuUmVtb3ZlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICB2YXIgZWRnZSA9IGJvZHkubV9jb250cm9sbGVyTGlzdDtcbiAgICAgIHdoaWxlIChlZGdlICYmIGVkZ2UuY29udHJvbGxlciAhPSB0aGlzKVxuICAgICAgZWRnZSA9IGVkZ2UubmV4dENvbnRyb2xsZXI7XG4gICAgICBpZiAoZWRnZS5wcmV2Qm9keSkgZWRnZS5wcmV2Qm9keS5uZXh0Qm9keSA9IGVkZ2UubmV4dEJvZHk7XG4gICAgICBpZiAoZWRnZS5uZXh0Qm9keSkgZWRnZS5uZXh0Qm9keS5wcmV2Qm9keSA9IGVkZ2UucHJldkJvZHk7XG4gICAgICBpZiAoZWRnZS5uZXh0Q29udHJvbGxlcikgZWRnZS5uZXh0Q29udHJvbGxlci5wcmV2Q29udHJvbGxlciA9IGVkZ2UucHJldkNvbnRyb2xsZXI7XG4gICAgICBpZiAoZWRnZS5wcmV2Q29udHJvbGxlcikgZWRnZS5wcmV2Q29udHJvbGxlci5uZXh0Q29udHJvbGxlciA9IGVkZ2UubmV4dENvbnRyb2xsZXI7XG4gICAgICBpZiAodGhpcy5tX2JvZHlMaXN0ID09IGVkZ2UpIHRoaXMubV9ib2R5TGlzdCA9IGVkZ2UubmV4dEJvZHk7XG4gICAgICBpZiAoYm9keS5tX2NvbnRyb2xsZXJMaXN0ID09IGVkZ2UpIGJvZHkubV9jb250cm9sbGVyTGlzdCA9IGVkZ2UubmV4dENvbnRyb2xsZXI7XG4gICAgICBib2R5Lm1fY29udHJvbGxlckNvdW50LS07XG4gICAgICB0aGlzLm1fYm9keUNvdW50LS07XG4gICB9XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLkNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRoaXMubV9ib2R5TGlzdClcbiAgICAgIHRoaXMuUmVtb3ZlQm9keSh0aGlzLm1fYm9keUxpc3QuYm9keSk7XG4gICB9XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLkdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX25leHQ7XG4gICB9XG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLkdldFdvcmxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV93b3JsZDtcbiAgIH1cbiAgIGIyQ29udHJvbGxlci5wcm90b3R5cGUuR2V0Qm9keUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlMaXN0O1xuICAgfVxuICAgYjJDb250cm9sbGVyRWRnZS5iMkNvbnRyb2xsZXJFZGdlID0gZnVuY3Rpb24gKCkge307XG4gICBCb3gyRC5pbmhlcml0KGIyR3Jhdml0eUNvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMkdyYXZpdHlDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgIGIyR3Jhdml0eUNvbnRyb2xsZXIuYjJHcmF2aXR5Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuRyA9IDE7XG4gICAgICB0aGlzLmludlNxciA9IHRydWU7XG4gICB9O1xuICAgYjJHcmF2aXR5Q29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgaSA9IG51bGw7XG4gICAgICB2YXIgYm9keTEgPSBudWxsO1xuICAgICAgdmFyIHAxID0gbnVsbDtcbiAgICAgIHZhciBtYXNzMSA9IDA7XG4gICAgICB2YXIgaiA9IG51bGw7XG4gICAgICB2YXIgYm9keTIgPSBudWxsO1xuICAgICAgdmFyIHAyID0gbnVsbDtcbiAgICAgIHZhciBkeCA9IDA7XG4gICAgICB2YXIgZHkgPSAwO1xuICAgICAgdmFyIHIyID0gMDtcbiAgICAgIHZhciBmID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmludlNxcikge1xuICAgICAgICAgZm9yIChpID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgICAgaTsgaSA9IGkubmV4dEJvZHkpIHtcbiAgICAgICAgICAgIGJvZHkxID0gaS5ib2R5O1xuICAgICAgICAgICAgcDEgPSBib2R5MS5HZXRXb3JsZENlbnRlcigpO1xuICAgICAgICAgICAgbWFzczEgPSBib2R5MS5HZXRNYXNzKCk7XG4gICAgICAgICAgICBmb3IgKGogPSB0aGlzLm1fYm9keUxpc3Q7XG4gICAgICAgICAgICBqICE9IGk7IGogPSBqLm5leHRCb2R5KSB7XG4gICAgICAgICAgICAgICBib2R5MiA9IGouYm9keTtcbiAgICAgICAgICAgICAgIHAyID0gYm9keTIuR2V0V29ybGRDZW50ZXIoKTtcbiAgICAgICAgICAgICAgIGR4ID0gcDIueCAtIHAxLng7XG4gICAgICAgICAgICAgICBkeSA9IHAyLnkgLSBwMS55O1xuICAgICAgICAgICAgICAgcjIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICAgICAgIGlmIChyMiA8IE51bWJlci5NSU5fVkFMVUUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgZiA9IG5ldyBiMlZlYzIoZHgsIGR5KTtcbiAgICAgICAgICAgICAgIGYuTXVsdGlwbHkodGhpcy5HIC8gcjIgLyBNYXRoLnNxcnQocjIpICogbWFzczEgKiBib2R5Mi5HZXRNYXNzKCkpO1xuICAgICAgICAgICAgICAgaWYgKGJvZHkxLklzQXdha2UoKSkgYm9keTEuQXBwbHlGb3JjZShmLCBwMSk7XG4gICAgICAgICAgICAgICBmLk11bHRpcGx5KCgtMSkpO1xuICAgICAgICAgICAgICAgaWYgKGJvZHkyLklzQXdha2UoKSkgYm9keTIuQXBwbHlGb3JjZShmLCBwMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIGZvciAoaSA9IHRoaXMubV9ib2R5TGlzdDtcbiAgICAgICAgIGk7IGkgPSBpLm5leHRCb2R5KSB7XG4gICAgICAgICAgICBib2R5MSA9IGkuYm9keTtcbiAgICAgICAgICAgIHAxID0gYm9keTEuR2V0V29ybGRDZW50ZXIoKTtcbiAgICAgICAgICAgIG1hc3MxID0gYm9keTEuR2V0TWFzcygpO1xuICAgICAgICAgICAgZm9yIChqID0gdGhpcy5tX2JvZHlMaXN0O1xuICAgICAgICAgICAgaiAhPSBpOyBqID0gai5uZXh0Qm9keSkge1xuICAgICAgICAgICAgICAgYm9keTIgPSBqLmJvZHk7XG4gICAgICAgICAgICAgICBwMiA9IGJvZHkyLkdldFdvcmxkQ2VudGVyKCk7XG4gICAgICAgICAgICAgICBkeCA9IHAyLnggLSBwMS54O1xuICAgICAgICAgICAgICAgZHkgPSBwMi55IC0gcDEueTtcbiAgICAgICAgICAgICAgIHIyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgICAgICAgICBpZiAocjIgPCBOdW1iZXIuTUlOX1ZBTFVFKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgIGYgPSBuZXcgYjJWZWMyKGR4LCBkeSk7XG4gICAgICAgICAgICAgICBmLk11bHRpcGx5KHRoaXMuRyAvIHIyICogbWFzczEgKiBib2R5Mi5HZXRNYXNzKCkpO1xuICAgICAgICAgICAgICAgaWYgKGJvZHkxLklzQXdha2UoKSkgYm9keTEuQXBwbHlGb3JjZShmLCBwMSk7XG4gICAgICAgICAgICAgICBmLk11bHRpcGx5KCgtMSkpO1xuICAgICAgICAgICAgICAgaWYgKGJvZHkyLklzQXdha2UoKSkgYm9keTIuQXBwbHlGb3JjZShmLCBwMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XG4gICBiMlRlbnNvckRhbXBpbmdDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgIGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIuYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuVCA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1heFRpbWVzdGVwID0gMDtcbiAgIH07XG4gICBiMlRlbnNvckRhbXBpbmdDb250cm9sbGVyLnByb3RvdHlwZS5TZXRBeGlzQWxpZ25lZCA9IGZ1bmN0aW9uICh4RGFtcGluZywgeURhbXBpbmcpIHtcbiAgICAgIGlmICh4RGFtcGluZyA9PT0gdW5kZWZpbmVkKSB4RGFtcGluZyA9IDA7XG4gICAgICBpZiAoeURhbXBpbmcgPT09IHVuZGVmaW5lZCkgeURhbXBpbmcgPSAwO1xuICAgICAgdGhpcy5ULmNvbDEueCA9ICgteERhbXBpbmcpO1xuICAgICAgdGhpcy5ULmNvbDEueSA9IDA7XG4gICAgICB0aGlzLlQuY29sMi54ID0gMDtcbiAgICAgIHRoaXMuVC5jb2wyLnkgPSAoLXlEYW1waW5nKTtcbiAgICAgIGlmICh4RGFtcGluZyA+IDAgfHwgeURhbXBpbmcgPiAwKSB7XG4gICAgICAgICB0aGlzLm1heFRpbWVzdGVwID0gMSAvIE1hdGgubWF4KHhEYW1waW5nLCB5RGFtcGluZyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubWF4VGltZXN0ZXAgPSAwO1xuICAgICAgfVxuICAgfVxuICAgYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgdGltZXN0ZXAgPSBzdGVwLmR0O1xuICAgICAgaWYgKHRpbWVzdGVwIDw9IE51bWJlci5NSU5fVkFMVUUpIHJldHVybjtcbiAgICAgIGlmICh0aW1lc3RlcCA+IHRoaXMubWF4VGltZXN0ZXAgJiYgdGhpcy5tYXhUaW1lc3RlcCA+IDApIHRpbWVzdGVwID0gdGhpcy5tYXhUaW1lc3RlcDtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLm1fYm9keUxpc3Q7IGk7IGkgPSBpLm5leHRCb2R5KSB7XG4gICAgICAgICB2YXIgYm9keSA9IGkuYm9keTtcbiAgICAgICAgIGlmICghYm9keS5Jc0F3YWtlKCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIGRhbXBpbmcgPSBib2R5LkdldFdvcmxkVmVjdG9yKGIyTWF0aC5NdWxNVih0aGlzLlQsIGJvZHkuR2V0TG9jYWxWZWN0b3IoYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpKSkpO1xuICAgICAgICAgYm9keS5TZXRMaW5lYXJWZWxvY2l0eShuZXcgYjJWZWMyKGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKS54ICsgZGFtcGluZy54ICogdGltZXN0ZXAsIGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKS55ICsgZGFtcGluZy55ICogdGltZXN0ZXApKTtcbiAgICAgIH1cbiAgIH1cbn0pKCk7XG4oZnVuY3Rpb24gKCkge1xuICAgdmFyIGIyQ29sb3IgPSBCb3gyRC5Db21tb24uYjJDb2xvcixcbiAgICAgIGIyaW50ZXJuYWwgPSBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCxcbiAgICAgIGIyU2V0dGluZ3MgPSBCb3gyRC5Db21tb24uYjJTZXR0aW5ncyxcbiAgICAgIGIyTWF0MjIgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDIyLFxuICAgICAgYjJNYXQzMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MzMsXG4gICAgICBiMk1hdGggPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGgsXG4gICAgICBiMlN3ZWVwID0gQm94MkQuQ29tbW9uLk1hdGguYjJTd2VlcCxcbiAgICAgIGIyVHJhbnNmb3JtID0gQm94MkQuQ29tbW9uLk1hdGguYjJUcmFuc2Zvcm0sXG4gICAgICBiMlZlYzIgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzIsXG4gICAgICBiMlZlYzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzMsXG4gICAgICBiMkRpc3RhbmNlSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJEaXN0YW5jZUpvaW50LFxuICAgICAgYjJEaXN0YW5jZUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyRGlzdGFuY2VKb2ludERlZixcbiAgICAgIGIyRnJpY3Rpb25Kb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkZyaWN0aW9uSm9pbnQsXG4gICAgICBiMkZyaWN0aW9uSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJGcmljdGlvbkpvaW50RGVmLFxuICAgICAgYjJHZWFySm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJHZWFySm9pbnQsXG4gICAgICBiMkdlYXJKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkdlYXJKb2ludERlZixcbiAgICAgIGIySmFjb2JpYW4gPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKYWNvYmlhbixcbiAgICAgIGIySm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCxcbiAgICAgIGIySm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZixcbiAgICAgIGIySm9pbnRFZGdlID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnRFZGdlLFxuICAgICAgYjJMaW5lSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJMaW5lSm9pbnQsXG4gICAgICBiMkxpbmVKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkxpbmVKb2ludERlZixcbiAgICAgIGIyTW91c2VKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMk1vdXNlSm9pbnQsXG4gICAgICBiMk1vdXNlSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJNb3VzZUpvaW50RGVmLFxuICAgICAgYjJQcmlzbWF0aWNKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlByaXNtYXRpY0pvaW50LFxuICAgICAgYjJQcmlzbWF0aWNKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlByaXNtYXRpY0pvaW50RGVmLFxuICAgICAgYjJQdWxsZXlKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlB1bGxleUpvaW50LFxuICAgICAgYjJQdWxsZXlKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlB1bGxleUpvaW50RGVmLFxuICAgICAgYjJSZXZvbHV0ZUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludCxcbiAgICAgIGIyUmV2b2x1dGVKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlJldm9sdXRlSm9pbnREZWYsXG4gICAgICBiMldlbGRKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMldlbGRKb2ludCxcbiAgICAgIGIyV2VsZEpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyV2VsZEpvaW50RGVmLFxuICAgICAgYjJCb2R5ID0gQm94MkQuRHluYW1pY3MuYjJCb2R5LFxuICAgICAgYjJCb2R5RGVmID0gQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmLFxuICAgICAgYjJDb250YWN0RmlsdGVyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyLFxuICAgICAgYjJDb250YWN0SW1wdWxzZSA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEltcHVsc2UsXG4gICAgICBiMkNvbnRhY3RMaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyLFxuICAgICAgYjJDb250YWN0TWFuYWdlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIsXG4gICAgICBiMkRlYnVnRHJhdyA9IEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LFxuICAgICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gQm94MkQuRHluYW1pY3MuYjJEZXN0cnVjdGlvbkxpc3RlbmVyLFxuICAgICAgYjJGaWx0ZXJEYXRhID0gQm94MkQuRHluYW1pY3MuYjJGaWx0ZXJEYXRhLFxuICAgICAgYjJGaXh0dXJlID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlLFxuICAgICAgYjJGaXh0dXJlRGVmID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlRGVmLFxuICAgICAgYjJJc2xhbmQgPSBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCxcbiAgICAgIGIyVGltZVN0ZXAgPSBCb3gyRC5EeW5hbWljcy5iMlRpbWVTdGVwLFxuICAgICAgYjJXb3JsZCA9IEJveDJELkR5bmFtaWNzLmIyV29ybGQ7XG5cbiAgIEJveDJELmluaGVyaXQoYjJEaXN0YW5jZUpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMkRpc3RhbmNlSm9pbnQuYjJEaXN0YW5jZUpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fdSA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMik7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV91LngsIGludl9kdCAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX3UueSk7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIDAuMDtcbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuR2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9sZW5ndGg7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLlNldExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgbGVuZ3RoID0gMDtcbiAgICAgIHRoaXMubV9sZW5ndGggPSBsZW5ndGg7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkdldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLlNldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChoeikge1xuICAgICAgaWYgKGh6ID09PSB1bmRlZmluZWQpIGh6ID0gMDtcbiAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xuICAgfVxuICAgYjJEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5HZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RhbXBpbmdSYXRpbztcbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuU2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICBpZiAocmF0aW8gPT09IHVuZGVmaW5lZCkgcmF0aW8gPSAwO1xuICAgICAgdGhpcy5tX2RhbXBpbmdSYXRpbyA9IHJhdGlvO1xuICAgfVxuICAgYjJEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5iMkRpc3RhbmNlSm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludC5jYWxsKHRoaXMsIGRlZik7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgdFkgPSAwO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMS5TZXRWKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMi5TZXRWKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgdGhpcy5tX2xlbmd0aCA9IGRlZi5sZW5ndGg7XG4gICAgICB0aGlzLm1fZnJlcXVlbmN5SHogPSBkZWYuZnJlcXVlbmN5SHo7XG4gICAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gZGVmLmRhbXBpbmdSYXRpbztcbiAgICAgIHRoaXMubV9pbXB1bHNlID0gMC4wO1xuICAgICAgdGhpcy5tX2dhbW1hID0gMC4wO1xuICAgICAgdGhpcy5tX2JpYXMgPSAwLjA7XG4gICB9XG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLkluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xuICAgICAgcjFYID0gdFg7XG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgIHIyWCA9IHRYO1xuICAgICAgdGhpcy5tX3UueCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XG4gICAgICB0aGlzLm1fdS55ID0gYkIubV9zd2VlcC5jLnkgKyByMlkgLSBiQS5tX3N3ZWVwLmMueSAtIHIxWTtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodGhpcy5tX3UueCAqIHRoaXMubV91LnggKyB0aGlzLm1fdS55ICogdGhpcy5tX3UueSk7XG4gICAgICBpZiAobGVuZ3RoID4gYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XG4gICAgICAgICB0aGlzLm1fdS5NdWx0aXBseSgxLjAgLyBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fdS5TZXRaZXJvKCk7XG4gICAgICB9XG4gICAgICB2YXIgY3IxdSA9IChyMVggKiB0aGlzLm1fdS55IC0gcjFZICogdGhpcy5tX3UueCk7XG4gICAgICB2YXIgY3IydSA9IChyMlggKiB0aGlzLm1fdS55IC0gcjJZICogdGhpcy5tX3UueCk7XG4gICAgICB2YXIgaW52TWFzcyA9IGJBLm1faW52TWFzcyArIGJBLm1faW52SSAqIGNyMXUgKiBjcjF1ICsgYkIubV9pbnZNYXNzICsgYkIubV9pbnZJICogY3IydSAqIGNyMnU7XG4gICAgICB0aGlzLm1fbWFzcyA9IGludk1hc3MgIT0gMC4wID8gMS4wIC8gaW52TWFzcyA6IDAuMDtcbiAgICAgIGlmICh0aGlzLm1fZnJlcXVlbmN5SHogPiAwLjApIHtcbiAgICAgICAgIHZhciBDID0gbGVuZ3RoIC0gdGhpcy5tX2xlbmd0aDtcbiAgICAgICAgIHZhciBvbWVnYSA9IDIuMCAqIE1hdGguUEkgKiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICAgICB2YXIgZCA9IDIuMCAqIHRoaXMubV9tYXNzICogdGhpcy5tX2RhbXBpbmdSYXRpbyAqIG9tZWdhO1xuICAgICAgICAgdmFyIGsgPSB0aGlzLm1fbWFzcyAqIG9tZWdhICogb21lZ2E7XG4gICAgICAgICB0aGlzLm1fZ2FtbWEgPSBzdGVwLmR0ICogKGQgKyBzdGVwLmR0ICogayk7XG4gICAgICAgICB0aGlzLm1fZ2FtbWEgPSB0aGlzLm1fZ2FtbWEgIT0gMC4wID8gMSAvIHRoaXMubV9nYW1tYSA6IDAuMDtcbiAgICAgICAgIHRoaXMubV9iaWFzID0gQyAqIHN0ZXAuZHQgKiBrICogdGhpcy5tX2dhbW1hO1xuICAgICAgICAgdGhpcy5tX21hc3MgPSBpbnZNYXNzICsgdGhpcy5tX2dhbW1hO1xuICAgICAgICAgdGhpcy5tX21hc3MgPSB0aGlzLm1fbWFzcyAhPSAwLjAgPyAxLjAgLyB0aGlzLm1fbWFzcyA6IDAuMDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdmFyIFBYID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fdS54O1xuICAgICAgICAgdmFyIFBZID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fdS55O1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54IC09IGJBLm1faW52TWFzcyAqIFBYO1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55IC09IGJBLm1faW52TWFzcyAqIFBZO1xuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgLT0gYkEubV9pbnZJICogKHIxWCAqIFBZIC0gcjFZICogUFgpO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS54ICs9IGJCLm1faW52TWFzcyAqIFBYO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IGJCLm1faW52TWFzcyAqIFBZO1xuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogKHIyWCAqIFBZIC0gcjJZICogUFgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdmFyIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xuICAgICAgcjFYID0gdFg7XG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgIHIyWCA9IHRYO1xuICAgICAgdmFyIHYxWCA9IGJBLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFZKSk7XG4gICAgICB2YXIgdjFZID0gYkEubV9saW5lYXJWZWxvY2l0eS55ICsgKGJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFYKTtcbiAgICAgIHZhciB2MlggPSBiQi5tX2xpbmVhclZlbG9jaXR5LnggKyAoKC1iQi5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIyWSkpO1xuICAgICAgdmFyIHYyWSA9IGJCLm1fbGluZWFyVmVsb2NpdHkueSArIChiQi5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIyWCk7XG4gICAgICB2YXIgQ2RvdCA9ICh0aGlzLm1fdS54ICogKHYyWCAtIHYxWCkgKyB0aGlzLm1fdS55ICogKHYyWSAtIHYxWSkpO1xuICAgICAgdmFyIGltcHVsc2UgPSAoLXRoaXMubV9tYXNzICogKENkb3QgKyB0aGlzLm1fYmlhcyArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlKSk7XG4gICAgICB0aGlzLm1faW1wdWxzZSArPSBpbXB1bHNlO1xuICAgICAgdmFyIFBYID0gaW1wdWxzZSAqIHRoaXMubV91Lng7XG4gICAgICB2YXIgUFkgPSBpbXB1bHNlICogdGhpcy5tX3UueTtcbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCAtPSBiQS5tX2ludk1hc3MgKiBQWDtcbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSAtPSBiQS5tX2ludk1hc3MgKiBQWTtcbiAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5IC09IGJBLm1faW52SSAqIChyMVggKiBQWSAtIHIxWSAqIFBYKTtcbiAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQi5tX2ludk1hc3MgKiBQWDtcbiAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQi5tX2ludk1hc3MgKiBQWTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJCLm1faW52SSAqIChyMlggKiBQWSAtIHIyWSAqIFBYKTtcbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHZhciB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICByMlggPSB0WDtcbiAgICAgIHZhciBkWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XG4gICAgICB2YXIgZFkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWSAtIGJBLm1fc3dlZXAuYy55IC0gcjFZO1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG4gICAgICBkWCAvPSBsZW5ndGg7XG4gICAgICBkWSAvPSBsZW5ndGg7XG4gICAgICB2YXIgQyA9IGxlbmd0aCAtIHRoaXMubV9sZW5ndGg7XG4gICAgICBDID0gYjJNYXRoLkNsYW1wKEMsICgtYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKSwgYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICAgIHZhciBpbXB1bHNlID0gKC10aGlzLm1fbWFzcyAqIEMpO1xuICAgICAgdGhpcy5tX3UuU2V0KGRYLCBkWSk7XG4gICAgICB2YXIgUFggPSBpbXB1bHNlICogdGhpcy5tX3UueDtcbiAgICAgIHZhciBQWSA9IGltcHVsc2UgKiB0aGlzLm1fdS55O1xuICAgICAgYkEubV9zd2VlcC5jLnggLT0gYkEubV9pbnZNYXNzICogUFg7XG4gICAgICBiQS5tX3N3ZWVwLmMueSAtPSBiQS5tX2ludk1hc3MgKiBQWTtcbiAgICAgIGJBLm1fc3dlZXAuYSAtPSBiQS5tX2ludkkgKiAocjFYICogUFkgLSByMVkgKiBQWCk7XG4gICAgICBiQi5tX3N3ZWVwLmMueCArPSBiQi5tX2ludk1hc3MgKiBQWDtcbiAgICAgIGJCLm1fc3dlZXAuYy55ICs9IGJCLm1faW52TWFzcyAqIFBZO1xuICAgICAgYkIubV9zd2VlcC5hICs9IGJCLm1faW52SSAqIChyMlggKiBQWSAtIHIyWSAqIFBYKTtcbiAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuIGIyTWF0aC5BYnMoQykgPCBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyRGlzdGFuY2VKb2ludERlZiwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYpO1xuICAgYjJEaXN0YW5jZUpvaW50RGVmLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYucHJvdG90eXBlO1xuICAgYjJEaXN0YW5jZUpvaW50RGVmLmIyRGlzdGFuY2VKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJEaXN0YW5jZUpvaW50RGVmLnByb3RvdHlwZS5iMkRpc3RhbmNlSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQ7XG4gICAgICB0aGlzLmxlbmd0aCA9IDEuMDtcbiAgICAgIHRoaXMuZnJlcXVlbmN5SHogPSAwLjA7XG4gICAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IDAuMDtcbiAgIH1cbiAgIGIyRGlzdGFuY2VKb2ludERlZi5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChiQSwgYkIsIGFuY2hvckEsIGFuY2hvckIpIHtcbiAgICAgIHRoaXMuYm9keUEgPSBiQTtcbiAgICAgIHRoaXMuYm9keUIgPSBiQjtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBLlNldFYodGhpcy5ib2R5QS5HZXRMb2NhbFBvaW50KGFuY2hvckEpKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldFYodGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvckIpKTtcbiAgICAgIHZhciBkWCA9IGFuY2hvckIueCAtIGFuY2hvckEueDtcbiAgICAgIHZhciBkWSA9IGFuY2hvckIueSAtIGFuY2hvckEueTtcbiAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcbiAgICAgIHRoaXMuZnJlcXVlbmN5SHogPSAwLjA7XG4gICAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IDAuMDtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJGcmljdGlvbkpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMkZyaWN0aW9uSm9pbnQuYjJGcmljdGlvbkpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbGluZWFyTWFzcyA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1fbGluZWFySW1wdWxzZSA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1fbGluZWFySW1wdWxzZS54LCBpbnZfZHQgKiB0aGlzLm1fbGluZWFySW1wdWxzZS55KTtcbiAgIH1cbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2FuZ3VsYXJJbXB1bHNlO1xuICAgfVxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5TZXRNYXhGb3JjZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgaWYgKGZvcmNlID09PSB1bmRlZmluZWQpIGZvcmNlID0gMDtcbiAgICAgIHRoaXMubV9tYXhGb3JjZSA9IGZvcmNlO1xuICAgfVxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5HZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbWF4Rm9yY2U7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLlNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcbiAgICAgIGlmICh0b3JxdWUgPT09IHVuZGVmaW5lZCkgdG9ycXVlID0gMDtcbiAgICAgIHRoaXMubV9tYXhUb3JxdWUgPSB0b3JxdWU7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbWF4VG9ycXVlO1xuICAgfVxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5iMkZyaWN0aW9uSm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludC5jYWxsKHRoaXMsIGRlZik7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JCLlNldFYoZGVmLmxvY2FsQW5jaG9yQik7XG4gICAgICB0aGlzLm1fbGluZWFyTWFzcy5TZXRaZXJvKCk7XG4gICAgICB0aGlzLm1fYW5ndWxhck1hc3MgPSAwLjA7XG4gICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5TZXRaZXJvKCk7XG4gICAgICB0aGlzLm1fYW5ndWxhckltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1fbWF4Rm9yY2UgPSBkZWYubWF4Rm9yY2U7XG4gICAgICB0aGlzLm1fbWF4VG9ycXVlID0gZGVmLm1heFRvcnF1ZTtcbiAgIH1cbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByQVggPSB0aGlzLm1fbG9jYWxBbmNob3JBLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgckFZID0gdGhpcy5tX2xvY2FsQW5jaG9yQS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQVggKyB0TWF0LmNvbDIueCAqIHJBWSk7XG4gICAgICByQVkgPSAodE1hdC5jb2wxLnkgKiByQVggKyB0TWF0LmNvbDIueSAqIHJBWSk7XG4gICAgICByQVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgckJYID0gdGhpcy5tX2xvY2FsQW5jaG9yQi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHJCWSA9IHRoaXMubV9sb2NhbEFuY2hvckIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckJYICsgdE1hdC5jb2wyLnggKiByQlkpO1xuICAgICAgckJZID0gKHRNYXQuY29sMS55ICogckJYICsgdE1hdC5jb2wyLnkgKiByQlkpO1xuICAgICAgckJYID0gdFg7XG4gICAgICB2YXIgbUEgPSBiQS5tX2ludk1hc3M7XG4gICAgICB2YXIgbUIgPSBiQi5tX2ludk1hc3M7XG4gICAgICB2YXIgaUEgPSBiQS5tX2ludkk7XG4gICAgICB2YXIgaUIgPSBiQi5tX2ludkk7XG4gICAgICB2YXIgSyA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICBLLmNvbDEueCA9IG1BICsgbUI7XG4gICAgICBLLmNvbDIueCA9IDAuMDtcbiAgICAgIEsuY29sMS55ID0gMC4wO1xuICAgICAgSy5jb2wyLnkgPSBtQSArIG1CO1xuICAgICAgSy5jb2wxLnggKz0gaUEgKiByQVkgKiByQVk7XG4gICAgICBLLmNvbDIueCArPSAoLWlBICogckFYICogckFZKTtcbiAgICAgIEsuY29sMS55ICs9ICgtaUEgKiByQVggKiByQVkpO1xuICAgICAgSy5jb2wyLnkgKz0gaUEgKiByQVggKiByQVg7XG4gICAgICBLLmNvbDEueCArPSBpQiAqIHJCWSAqIHJCWTtcbiAgICAgIEsuY29sMi54ICs9ICgtaUIgKiByQlggKiByQlkpO1xuICAgICAgSy5jb2wxLnkgKz0gKC1pQiAqIHJCWCAqIHJCWSk7XG4gICAgICBLLmNvbDIueSArPSBpQiAqIHJCWCAqIHJCWDtcbiAgICAgIEsuR2V0SW52ZXJzZSh0aGlzLm1fbGluZWFyTWFzcyk7XG4gICAgICB0aGlzLm1fYW5ndWxhck1hc3MgPSBpQSArIGlCO1xuICAgICAgaWYgKHRoaXMubV9hbmd1bGFyTWFzcyA+IDAuMCkge1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJNYXNzID0gMS4wIC8gdGhpcy5tX2FuZ3VsYXJNYXNzO1xuICAgICAgfVxuICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS54ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLnkgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHZhciBQID0gdGhpcy5tX2xpbmVhckltcHVsc2U7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggLT0gbUEgKiBQLng7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gbUEgKiBQLnk7XG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSAtPSBpQSAqIChyQVggKiBQLnkgLSByQVkgKiBQLnggKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS54ICs9IG1CICogUC54O1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IG1CICogUC55O1xuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gaUIgKiAockJYICogUC55IC0gckJZICogUC54ICsgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2UuU2V0WmVybygpO1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMC4wO1xuICAgICAgfVxuICAgfVxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHZBID0gYkEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3QSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIHZCID0gYkIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3QiA9IGJCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIG1BID0gYkEubV9pbnZNYXNzO1xuICAgICAgdmFyIG1CID0gYkIubV9pbnZNYXNzO1xuICAgICAgdmFyIGlBID0gYkEubV9pbnZJO1xuICAgICAgdmFyIGlCID0gYkIubV9pbnZJO1xuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByQVggPSB0aGlzLm1fbG9jYWxBbmNob3JBLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgckFZID0gdGhpcy5tX2xvY2FsQW5jaG9yQS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQVggKyB0TWF0LmNvbDIueCAqIHJBWSk7XG4gICAgICByQVkgPSAodE1hdC5jb2wxLnkgKiByQVggKyB0TWF0LmNvbDIueSAqIHJBWSk7XG4gICAgICByQVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgckJYID0gdGhpcy5tX2xvY2FsQW5jaG9yQi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHJCWSA9IHRoaXMubV9sb2NhbEFuY2hvckIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckJYICsgdE1hdC5jb2wyLnggKiByQlkpO1xuICAgICAgckJZID0gKHRNYXQuY29sMS55ICogckJYICsgdE1hdC5jb2wyLnkgKiByQlkpO1xuICAgICAgckJYID0gdFg7XG4gICAgICB2YXIgbWF4SW1wdWxzZSA9IDA7IHtcbiAgICAgICAgIHZhciBDZG90ID0gd0IgLSB3QTtcbiAgICAgICAgIHZhciBpbXB1bHNlID0gKC10aGlzLm1fYW5ndWxhck1hc3MgKiBDZG90KTtcbiAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2FuZ3VsYXJJbXB1bHNlO1xuICAgICAgICAgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiB0aGlzLm1fbWF4VG9ycXVlO1xuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gYjJNYXRoLkNsYW1wKHRoaXMubV9hbmd1bGFySW1wdWxzZSArIGltcHVsc2UsICgtbWF4SW1wdWxzZSksIG1heEltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9hbmd1bGFySW1wdWxzZSAtIG9sZEltcHVsc2U7XG4gICAgICAgICB3QSAtPSBpQSAqIGltcHVsc2U7XG4gICAgICAgICB3QiArPSBpQiAqIGltcHVsc2U7XG4gICAgICB9IHtcbiAgICAgICAgIHZhciBDZG90WCA9IHZCLnggLSB3QiAqIHJCWSAtIHZBLnggKyB3QSAqIHJBWTtcbiAgICAgICAgIHZhciBDZG90WSA9IHZCLnkgKyB3QiAqIHJCWCAtIHZBLnkgLSB3QSAqIHJBWDtcbiAgICAgICAgIHZhciBpbXB1bHNlViA9IGIyTWF0aC5NdWxNVih0aGlzLm1fbGluZWFyTWFzcywgbmV3IGIyVmVjMigoLUNkb3RYKSwgKC1DZG90WSkpKTtcbiAgICAgICAgIHZhciBvbGRJbXB1bHNlViA9IHRoaXMubV9saW5lYXJJbXB1bHNlLkNvcHkoKTtcbiAgICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLkFkZChpbXB1bHNlVik7XG4gICAgICAgICBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhGb3JjZTtcbiAgICAgICAgIGlmICh0aGlzLm1fbGluZWFySW1wdWxzZS5MZW5ndGhTcXVhcmVkKCkgPiBtYXhJbXB1bHNlICogbWF4SW1wdWxzZSkge1xuICAgICAgICAgICAgdGhpcy5tX2xpbmVhckltcHVsc2UuTm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5NdWx0aXBseShtYXhJbXB1bHNlKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGltcHVsc2VWID0gYjJNYXRoLlN1YnRyYWN0VlYodGhpcy5tX2xpbmVhckltcHVsc2UsIG9sZEltcHVsc2VWKTtcbiAgICAgICAgIHZBLnggLT0gbUEgKiBpbXB1bHNlVi54O1xuICAgICAgICAgdkEueSAtPSBtQSAqIGltcHVsc2VWLnk7XG4gICAgICAgICB3QSAtPSBpQSAqIChyQVggKiBpbXB1bHNlVi55IC0gckFZICogaW1wdWxzZVYueCk7XG4gICAgICAgICB2Qi54ICs9IG1CICogaW1wdWxzZVYueDtcbiAgICAgICAgIHZCLnkgKz0gbUIgKiBpbXB1bHNlVi55O1xuICAgICAgICAgd0IgKz0gaUIgKiAockJYICogaW1wdWxzZVYueSAtIHJCWSAqIGltcHVsc2VWLngpO1xuICAgICAgfVxuICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgPSB3QTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ID0gd0I7XG4gICB9XG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChiYXVtZ2FydGUpIHtcbiAgICAgIGlmIChiYXVtZ2FydGUgPT09IHVuZGVmaW5lZCkgYmF1bWdhcnRlID0gMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMkZyaWN0aW9uSm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyRnJpY3Rpb25Kb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcbiAgIGIyRnJpY3Rpb25Kb2ludERlZi5iMkZyaWN0aW9uSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyRnJpY3Rpb25Kb2ludERlZi5wcm90b3R5cGUuYjJGcmljdGlvbkpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnREZWYuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudHlwZSA9IGIySm9pbnQuZV9mcmljdGlvbkpvaW50O1xuICAgICAgdGhpcy5tYXhGb3JjZSA9IDAuMDtcbiAgICAgIHRoaXMubWF4VG9ycXVlID0gMC4wO1xuICAgfVxuICAgYjJGcmljdGlvbkpvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgYW5jaG9yKSB7XG4gICAgICB0aGlzLmJvZHlBID0gYkE7XG4gICAgICB0aGlzLmJvZHlCID0gYkI7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQS5TZXRWKHRoaXMuYm9keUEuR2V0TG9jYWxQb2ludChhbmNob3IpKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldFYodGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvcikpO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMkdlYXJKb2ludCwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQpO1xuICAgYjJHZWFySm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMkdlYXJKb2ludC5iMkdlYXJKb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9KID0gbmV3IGIySmFjb2JpYW4oKTtcbiAgIH07XG4gICBiMkdlYXJKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IxKTtcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xuICAgfVxuICAgYjJHZWFySm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLnkpO1xuICAgfVxuICAgYjJHZWFySm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgdmFyIHRNYXQgPSB0aGlzLm1fYm9keUIubV94Zi5SO1xuICAgICAgdmFyIHJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gdGhpcy5tX2JvZHlCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB2YXIgdFggPSB0TWF0LmNvbDEueCAqIHJYICsgdE1hdC5jb2wyLnggKiByWTtcbiAgICAgIHJZID0gdE1hdC5jb2wxLnkgKiByWCArIHRNYXQuY29sMi55ICogclk7XG4gICAgICByWCA9IHRYO1xuICAgICAgdmFyIFBYID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLng7XG4gICAgICB2YXIgUFkgPSB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueTtcbiAgICAgIHJldHVybiBpbnZfZHQgKiAodGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5hbmd1bGFyQiAtIHJYICogUFkgKyByWSAqIFBYKTtcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5HZXRSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fcmF0aW87XG4gICB9XG4gICBiMkdlYXJKb2ludC5wcm90b3R5cGUuU2V0UmF0aW8gPSBmdW5jdGlvbiAocmF0aW8pIHtcbiAgICAgIGlmIChyYXRpbyA9PT0gdW5kZWZpbmVkKSByYXRpbyA9IDA7XG4gICAgICB0aGlzLm1fcmF0aW8gPSByYXRpbztcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5iMkdlYXJKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50LmNhbGwodGhpcywgZGVmKTtcbiAgICAgIHZhciB0eXBlMSA9IHBhcnNlSW50KGRlZi5qb2ludDEubV90eXBlKTtcbiAgICAgIHZhciB0eXBlMiA9IHBhcnNlSW50KGRlZi5qb2ludDIubV90eXBlKTtcbiAgICAgIHRoaXMubV9yZXZvbHV0ZTEgPSBudWxsO1xuICAgICAgdGhpcy5tX3ByaXNtYXRpYzEgPSBudWxsO1xuICAgICAgdGhpcy5tX3Jldm9sdXRlMiA9IG51bGw7XG4gICAgICB0aGlzLm1fcHJpc21hdGljMiA9IG51bGw7XG4gICAgICB2YXIgY29vcmRpbmF0ZTEgPSAwO1xuICAgICAgdmFyIGNvb3JkaW5hdGUyID0gMDtcbiAgICAgIHRoaXMubV9ncm91bmQxID0gZGVmLmpvaW50MS5HZXRCb2R5QSgpO1xuICAgICAgdGhpcy5tX2JvZHlBID0gZGVmLmpvaW50MS5HZXRCb2R5QigpO1xuICAgICAgaWYgKHR5cGUxID09IGIySm9pbnQuZV9yZXZvbHV0ZUpvaW50KSB7XG4gICAgICAgICB0aGlzLm1fcmV2b2x1dGUxID0gKGRlZi5qb2ludDEgaW5zdGFuY2VvZiBiMlJldm9sdXRlSm9pbnQgPyBkZWYuam9pbnQxIDogbnVsbCk7XG4gICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMS5TZXRWKHRoaXMubV9yZXZvbHV0ZTEubV9sb2NhbEFuY2hvcjEpO1xuICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMS5TZXRWKHRoaXMubV9yZXZvbHV0ZTEubV9sb2NhbEFuY2hvcjIpO1xuICAgICAgICAgY29vcmRpbmF0ZTEgPSB0aGlzLm1fcmV2b2x1dGUxLkdldEpvaW50QW5nbGUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX3ByaXNtYXRpYzEgPSAoZGVmLmpvaW50MSBpbnN0YW5jZW9mIGIyUHJpc21hdGljSm9pbnQgPyBkZWYuam9pbnQxIDogbnVsbCk7XG4gICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMS5TZXRWKHRoaXMubV9wcmlzbWF0aWMxLm1fbG9jYWxBbmNob3IxKTtcbiAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEuU2V0Vih0aGlzLm1fcHJpc21hdGljMS5tX2xvY2FsQW5jaG9yMik7XG4gICAgICAgICBjb29yZGluYXRlMSA9IHRoaXMubV9wcmlzbWF0aWMxLkdldEpvaW50VHJhbnNsYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9ncm91bmQyID0gZGVmLmpvaW50Mi5HZXRCb2R5QSgpO1xuICAgICAgdGhpcy5tX2JvZHlCID0gZGVmLmpvaW50Mi5HZXRCb2R5QigpO1xuICAgICAgaWYgKHR5cGUyID09IGIySm9pbnQuZV9yZXZvbHV0ZUpvaW50KSB7XG4gICAgICAgICB0aGlzLm1fcmV2b2x1dGUyID0gKGRlZi5qb2ludDIgaW5zdGFuY2VvZiBiMlJldm9sdXRlSm9pbnQgPyBkZWYuam9pbnQyIDogbnVsbCk7XG4gICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMi5TZXRWKHRoaXMubV9yZXZvbHV0ZTIubV9sb2NhbEFuY2hvcjEpO1xuICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMi5TZXRWKHRoaXMubV9yZXZvbHV0ZTIubV9sb2NhbEFuY2hvcjIpO1xuICAgICAgICAgY29vcmRpbmF0ZTIgPSB0aGlzLm1fcmV2b2x1dGUyLkdldEpvaW50QW5nbGUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX3ByaXNtYXRpYzIgPSAoZGVmLmpvaW50MiBpbnN0YW5jZW9mIGIyUHJpc21hdGljSm9pbnQgPyBkZWYuam9pbnQyIDogbnVsbCk7XG4gICAgICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMi5TZXRWKHRoaXMubV9wcmlzbWF0aWMyLm1fbG9jYWxBbmNob3IxKTtcbiAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIuU2V0Vih0aGlzLm1fcHJpc21hdGljMi5tX2xvY2FsQW5jaG9yMik7XG4gICAgICAgICBjb29yZGluYXRlMiA9IHRoaXMubV9wcmlzbWF0aWMyLkdldEpvaW50VHJhbnNsYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9yYXRpbyA9IGRlZi5yYXRpbztcbiAgICAgIHRoaXMubV9jb25zdGFudCA9IGNvb3JkaW5hdGUxICsgdGhpcy5tX3JhdGlvICogY29vcmRpbmF0ZTI7XG4gICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgZzEgPSB0aGlzLm1fZ3JvdW5kMTtcbiAgICAgIHZhciBnMiA9IHRoaXMubV9ncm91bmQyO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHVnWCA9IDA7XG4gICAgICB2YXIgdWdZID0gMDtcbiAgICAgIHZhciByWCA9IDA7XG4gICAgICB2YXIgclkgPSAwO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFZlYztcbiAgICAgIHZhciBjcnVnID0gMDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgSyA9IDAuMDtcbiAgICAgIHRoaXMubV9KLlNldFplcm8oKTtcbiAgICAgIGlmICh0aGlzLm1fcmV2b2x1dGUxKSB7XG4gICAgICAgICB0aGlzLm1fSi5hbmd1bGFyQSA9ICgtMS4wKTtcbiAgICAgICAgIEsgKz0gYkEubV9pbnZJO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0TWF0ID0gZzEubV94Zi5SO1xuICAgICAgICAgdFZlYyA9IHRoaXMubV9wcmlzbWF0aWMxLm1fbG9jYWxYQXhpczE7XG4gICAgICAgICB1Z1ggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xuICAgICAgICAgdWdZID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcbiAgICAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICAgICByWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgICAgIHJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSB0TWF0LmNvbDEueCAqIHJYICsgdE1hdC5jb2wyLnggKiByWTtcbiAgICAgICAgIHJZID0gdE1hdC5jb2wxLnkgKiByWCArIHRNYXQuY29sMi55ICogclk7XG4gICAgICAgICByWCA9IHRYO1xuICAgICAgICAgY3J1ZyA9IHJYICogdWdZIC0gclkgKiB1Z1g7XG4gICAgICAgICB0aGlzLm1fSi5saW5lYXJBLlNldCgoLXVnWCksICgtdWdZKSk7XG4gICAgICAgICB0aGlzLm1fSi5hbmd1bGFyQSA9ICgtY3J1Zyk7XG4gICAgICAgICBLICs9IGJBLm1faW52TWFzcyArIGJBLm1faW52SSAqIGNydWcgKiBjcnVnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9yZXZvbHV0ZTIpIHtcbiAgICAgICAgIHRoaXMubV9KLmFuZ3VsYXJCID0gKC10aGlzLm1fcmF0aW8pO1xuICAgICAgICAgSyArPSB0aGlzLm1fcmF0aW8gKiB0aGlzLm1fcmF0aW8gKiBiQi5tX2ludkk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRNYXQgPSBnMi5tX3hmLlI7XG4gICAgICAgICB0VmVjID0gdGhpcy5tX3ByaXNtYXRpYzIubV9sb2NhbFhBeGlzMTtcbiAgICAgICAgIHVnWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XG4gICAgICAgICB1Z1kgPSB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xuICAgICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgICAgIHJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgclkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICAgICB0WCA9IHRNYXQuY29sMS54ICogclggKyB0TWF0LmNvbDIueCAqIHJZO1xuICAgICAgICAgclkgPSB0TWF0LmNvbDEueSAqIHJYICsgdE1hdC5jb2wyLnkgKiByWTtcbiAgICAgICAgIHJYID0gdFg7XG4gICAgICAgICBjcnVnID0gclggKiB1Z1kgLSByWSAqIHVnWDtcbiAgICAgICAgIHRoaXMubV9KLmxpbmVhckIuU2V0KCgtdGhpcy5tX3JhdGlvICogdWdYKSwgKC10aGlzLm1fcmF0aW8gKiB1Z1kpKTtcbiAgICAgICAgIHRoaXMubV9KLmFuZ3VsYXJCID0gKC10aGlzLm1fcmF0aW8gKiBjcnVnKTtcbiAgICAgICAgIEsgKz0gdGhpcy5tX3JhdGlvICogdGhpcy5tX3JhdGlvICogKGJCLm1faW52TWFzcyArIGJCLm1faW52SSAqIGNydWcgKiBjcnVnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9tYXNzID0gSyA+IDAuMCA/IDEuMCAvIEsgOiAwLjA7XG4gICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQS5tX2ludk1hc3MgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckEueDtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQS5tX2ludk1hc3MgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckEueTtcbiAgICAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJBLm1faW52SSAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX0ouYW5ndWxhckE7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkIubV9pbnZNYXNzICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLng7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLnk7XG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBiQi5tX2ludkkgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmFuZ3VsYXJCO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIENkb3QgPSB0aGlzLm1fSi5Db21wdXRlKGJBLm1fbGluZWFyVmVsb2NpdHksIGJBLm1fYW5ndWxhclZlbG9jaXR5LCBiQi5tX2xpbmVhclZlbG9jaXR5LCBiQi5tX2FuZ3VsYXJWZWxvY2l0eSk7XG4gICAgICB2YXIgaW1wdWxzZSA9ICgtdGhpcy5tX21hc3MgKiBDZG90KTtcbiAgICAgIHRoaXMubV9pbXB1bHNlICs9IGltcHVsc2U7XG4gICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkEubV9pbnZNYXNzICogaW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckEueDtcbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQS5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQS55O1xuICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkEubV9pbnZJICogaW1wdWxzZSAqIHRoaXMubV9KLmFuZ3VsYXJBO1xuICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS54ICs9IGJCLm1faW52TWFzcyAqIGltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLng7XG4gICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogaW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJCLm1faW52SSAqIGltcHVsc2UgKiB0aGlzLm1fSi5hbmd1bGFyQjtcbiAgIH1cbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICB2YXIgbGluZWFyRXJyb3IgPSAwLjA7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgY29vcmRpbmF0ZTEgPSAwO1xuICAgICAgdmFyIGNvb3JkaW5hdGUyID0gMDtcbiAgICAgIGlmICh0aGlzLm1fcmV2b2x1dGUxKSB7XG4gICAgICAgICBjb29yZGluYXRlMSA9IHRoaXMubV9yZXZvbHV0ZTEuR2V0Sm9pbnRBbmdsZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBjb29yZGluYXRlMSA9IHRoaXMubV9wcmlzbWF0aWMxLkdldEpvaW50VHJhbnNsYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1fcmV2b2x1dGUyKSB7XG4gICAgICAgICBjb29yZGluYXRlMiA9IHRoaXMubV9yZXZvbHV0ZTIuR2V0Sm9pbnRBbmdsZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBjb29yZGluYXRlMiA9IHRoaXMubV9wcmlzbWF0aWMyLkdldEpvaW50VHJhbnNsYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHZhciBDID0gdGhpcy5tX2NvbnN0YW50IC0gKGNvb3JkaW5hdGUxICsgdGhpcy5tX3JhdGlvICogY29vcmRpbmF0ZTIpO1xuICAgICAgdmFyIGltcHVsc2UgPSAoLXRoaXMubV9tYXNzICogQyk7XG4gICAgICBiQS5tX3N3ZWVwLmMueCArPSBiQS5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQS54O1xuICAgICAgYkEubV9zd2VlcC5jLnkgKz0gYkEubV9pbnZNYXNzICogaW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckEueTtcbiAgICAgIGJBLm1fc3dlZXAuYSArPSBiQS5tX2ludkkgKiBpbXB1bHNlICogdGhpcy5tX0ouYW5ndWxhckE7XG4gICAgICBiQi5tX3N3ZWVwLmMueCArPSBiQi5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQi54O1xuICAgICAgYkIubV9zd2VlcC5jLnkgKz0gYkIubV9pbnZNYXNzICogaW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueTtcbiAgICAgIGJCLm1fc3dlZXAuYSArPSBiQi5tX2ludkkgKiBpbXB1bHNlICogdGhpcy5tX0ouYW5ndWxhckI7XG4gICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJHZWFySm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyR2VhckpvaW50RGVmLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYucHJvdG90eXBlO1xuICAgYjJHZWFySm9pbnREZWYuYjJHZWFySm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICB9O1xuICAgYjJHZWFySm9pbnREZWYucHJvdG90eXBlLmIyR2VhckpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnREZWYuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudHlwZSA9IGIySm9pbnQuZV9nZWFySm9pbnQ7XG4gICAgICB0aGlzLmpvaW50MSA9IG51bGw7XG4gICAgICB0aGlzLmpvaW50MiA9IG51bGw7XG4gICAgICB0aGlzLnJhdGlvID0gMS4wO1xuICAgfVxuICAgYjJKYWNvYmlhbi5iMkphY29iaWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5saW5lYXJBID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5saW5lYXJCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIySmFjb2JpYW4ucHJvdG90eXBlLlNldFplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxpbmVhckEuU2V0WmVybygpO1xuICAgICAgdGhpcy5hbmd1bGFyQSA9IDAuMDtcbiAgICAgIHRoaXMubGluZWFyQi5TZXRaZXJvKCk7XG4gICAgICB0aGlzLmFuZ3VsYXJCID0gMC4wO1xuICAgfVxuICAgYjJKYWNvYmlhbi5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKHgxLCBhMSwgeDIsIGEyKSB7XG4gICAgICBpZiAoYTEgPT09IHVuZGVmaW5lZCkgYTEgPSAwO1xuICAgICAgaWYgKGEyID09PSB1bmRlZmluZWQpIGEyID0gMDtcbiAgICAgIHRoaXMubGluZWFyQS5TZXRWKHgxKTtcbiAgICAgIHRoaXMuYW5ndWxhckEgPSBhMTtcbiAgICAgIHRoaXMubGluZWFyQi5TZXRWKHgyKTtcbiAgICAgIHRoaXMuYW5ndWxhckIgPSBhMjtcbiAgIH1cbiAgIGIySmFjb2JpYW4ucHJvdG90eXBlLkNvbXB1dGUgPSBmdW5jdGlvbiAoeDEsIGExLCB4MiwgYTIpIHtcbiAgICAgIGlmIChhMSA9PT0gdW5kZWZpbmVkKSBhMSA9IDA7XG4gICAgICBpZiAoYTIgPT09IHVuZGVmaW5lZCkgYTIgPSAwO1xuICAgICAgcmV0dXJuICh0aGlzLmxpbmVhckEueCAqIHgxLnggKyB0aGlzLmxpbmVhckEueSAqIHgxLnkpICsgdGhpcy5hbmd1bGFyQSAqIGExICsgKHRoaXMubGluZWFyQi54ICogeDIueCArIHRoaXMubGluZWFyQi55ICogeDIueSkgKyB0aGlzLmFuZ3VsYXJCICogYTI7XG4gICB9XG4gICBiMkpvaW50LmIySm9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fZWRnZUEgPSBuZXcgYjJKb2ludEVkZ2UoKTtcbiAgICAgIHRoaXMubV9lZGdlQiA9IG5ldyBiMkpvaW50RWRnZSgpO1xuICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbENlbnRlckIgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJKb2ludC5wcm90b3R5cGUuR2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIDAuMDtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEJvZHlBID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QTtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEJvZHlCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QjtcbiAgIH1cbiAgIGIySm9pbnQucHJvdG90eXBlLkdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX25leHQ7XG4gICB9XG4gICBiMkpvaW50LnByb3RvdHlwZS5HZXRVc2VyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdXNlckRhdGE7XG4gICB9XG4gICBiMkpvaW50LnByb3RvdHlwZS5TZXRVc2VyRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB0aGlzLm1fdXNlckRhdGEgPSBkYXRhO1xuICAgfVxuICAgYjJKb2ludC5wcm90b3R5cGUuSXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLklzQWN0aXZlKCkgJiYgdGhpcy5tX2JvZHlCLklzQWN0aXZlKCk7XG4gICB9XG4gICBiMkpvaW50LkNyZWF0ZSA9IGZ1bmN0aW9uIChkZWYsIGFsbG9jYXRvcikge1xuICAgICAgdmFyIGpvaW50ID0gbnVsbDtcbiAgICAgIHN3aXRjaCAoZGVmLnR5cGUpIHtcbiAgICAgIGNhc2UgYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQ6XG4gICAgICAgICB7XG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMkRpc3RhbmNlSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyRGlzdGFuY2VKb2ludERlZiA/IGRlZiA6IG51bGwpKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMkpvaW50LmVfbW91c2VKb2ludDpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyTW91c2VKb2ludCgoZGVmIGluc3RhbmNlb2YgYjJNb3VzZUpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIySm9pbnQuZV9wcmlzbWF0aWNKb2ludDpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyUHJpc21hdGljSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyUHJpc21hdGljSm9pbnREZWYgPyBkZWYgOiBudWxsKSk7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJKb2ludC5lX3Jldm9sdXRlSm9pbnQ6XG4gICAgICAgICB7XG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMlJldm9sdXRlSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyUmV2b2x1dGVKb2ludERlZiA/IGRlZiA6IG51bGwpKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMkpvaW50LmVfcHVsbGV5Sm9pbnQ6XG4gICAgICAgICB7XG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMlB1bGxleUpvaW50KChkZWYgaW5zdGFuY2VvZiBiMlB1bGxleUpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIySm9pbnQuZV9nZWFySm9pbnQ6XG4gICAgICAgICB7XG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMkdlYXJKb2ludCgoZGVmIGluc3RhbmNlb2YgYjJHZWFySm9pbnREZWYgPyBkZWYgOiBudWxsKSk7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjJKb2ludC5lX2xpbmVKb2ludDpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyTGluZUpvaW50KChkZWYgaW5zdGFuY2VvZiBiMkxpbmVKb2ludERlZiA/IGRlZiA6IG51bGwpKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMkpvaW50LmVfd2VsZEpvaW50OlxuICAgICAgICAge1xuICAgICAgICAgICAgam9pbnQgPSBuZXcgYjJXZWxkSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyV2VsZEpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xuICAgICAgICAgfVxuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGIySm9pbnQuZV9mcmljdGlvbkpvaW50OlxuICAgICAgICAge1xuICAgICAgICAgICAgam9pbnQgPSBuZXcgYjJGcmljdGlvbkpvaW50KChkZWYgaW5zdGFuY2VvZiBiMkZyaWN0aW9uSm9pbnREZWYgPyBkZWYgOiBudWxsKSk7XG4gICAgICAgICB9XG4gICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBqb2ludDtcbiAgIH1cbiAgIGIySm9pbnQuRGVzdHJveSA9IGZ1bmN0aW9uIChqb2ludCwgYWxsb2NhdG9yKSB7fVxuICAgYjJKb2ludC5wcm90b3R5cGUuYjJKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZGVmLmJvZHlBICE9IGRlZi5ib2R5Qik7XG4gICAgICB0aGlzLm1fdHlwZSA9IGRlZi50eXBlO1xuICAgICAgdGhpcy5tX3ByZXYgPSBudWxsO1xuICAgICAgdGhpcy5tX25leHQgPSBudWxsO1xuICAgICAgdGhpcy5tX2JvZHlBID0gZGVmLmJvZHlBO1xuICAgICAgdGhpcy5tX2JvZHlCID0gZGVmLmJvZHlCO1xuICAgICAgdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQgPSBkZWYuY29sbGlkZUNvbm5lY3RlZDtcbiAgICAgIHRoaXMubV9pc2xhbmRGbGFnID0gZmFsc2U7XG4gICAgICB0aGlzLm1fdXNlckRhdGEgPSBkZWYudXNlckRhdGE7XG4gICB9XG4gICBiMkpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7fVxuICAgYjJKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHt9XG4gICBiMkpvaW50LnByb3RvdHlwZS5GaW5hbGl6ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7fVxuICAgYjJKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX3Vua25vd25Kb2ludCA9IDA7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX3Jldm9sdXRlSm9pbnQgPSAxO1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9wcmlzbWF0aWNKb2ludCA9IDI7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQgPSAzO1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9wdWxsZXlKb2ludCA9IDQ7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX21vdXNlSm9pbnQgPSA1O1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9nZWFySm9pbnQgPSA2O1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9saW5lSm9pbnQgPSA3O1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV93ZWxkSm9pbnQgPSA4O1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9mcmljdGlvbkpvaW50ID0gOTtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmVfaW5hY3RpdmVMaW1pdCA9IDA7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2F0TG93ZXJMaW1pdCA9IDE7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2F0VXBwZXJMaW1pdCA9IDI7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2VxdWFsTGltaXRzID0gMztcbiAgIH0pO1xuICAgYjJKb2ludERlZi5iMkpvaW50RGVmID0gZnVuY3Rpb24gKCkge307XG4gICBiMkpvaW50RGVmLnByb3RvdHlwZS5iMkpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX3Vua25vd25Kb2ludDtcbiAgICAgIHRoaXMudXNlckRhdGEgPSBudWxsO1xuICAgICAgdGhpcy5ib2R5QSA9IG51bGw7XG4gICAgICB0aGlzLmJvZHlCID0gbnVsbDtcbiAgICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IGZhbHNlO1xuICAgfVxuICAgYjJKb2ludEVkZ2UuYjJKb2ludEVkZ2UgPSBmdW5jdGlvbiAoKSB7fTtcbiAgIEJveDJELmluaGVyaXQoYjJMaW5lSm9pbnQsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50KTtcbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQucHJvdG90eXBlO1xuICAgYjJMaW5lSm9pbnQuYjJMaW5lSm9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5iMkpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbFhBeGlzMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbFlBeGlzMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9heGlzID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3BlcnAgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fSyA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1faW1wdWxzZSA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IxKTtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiAodGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnggKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnkpICogdGhpcy5tX2F4aXMueCksIGludl9kdCAqICh0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3BlcnAueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueSkgKiB0aGlzLm1fYXhpcy55KSk7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueTtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRKb2ludFRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgcDEgPSBiQS5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjEpO1xuICAgICAgdmFyIHAyID0gYkIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IyKTtcbiAgICAgIHZhciBkWCA9IHAyLnggLSBwMS54O1xuICAgICAgdmFyIGRZID0gcDIueSAtIHAxLnk7XG4gICAgICB2YXIgYXhpcyA9IGJBLkdldFdvcmxkVmVjdG9yKHRoaXMubV9sb2NhbFhBeGlzMSk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSBheGlzLnggKiBkWCArIGF4aXMueSAqIGRZO1xuICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldEpvaW50U3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHZhciB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICByMlggPSB0WDtcbiAgICAgIHZhciBwMVggPSBiQS5tX3N3ZWVwLmMueCArIHIxWDtcbiAgICAgIHZhciBwMVkgPSBiQS5tX3N3ZWVwLmMueSArIHIxWTtcbiAgICAgIHZhciBwMlggPSBiQi5tX3N3ZWVwLmMueCArIHIyWDtcbiAgICAgIHZhciBwMlkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWTtcbiAgICAgIHZhciBkWCA9IHAyWCAtIHAxWDtcbiAgICAgIHZhciBkWSA9IHAyWSAtIHAxWTtcbiAgICAgIHZhciBheGlzID0gYkEuR2V0V29ybGRWZWN0b3IodGhpcy5tX2xvY2FsWEF4aXMxKTtcbiAgICAgIHZhciB2MSA9IGJBLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdjIgPSBiQi5tX2xpbmVhclZlbG9jaXR5O1xuICAgICAgdmFyIHcxID0gYkEubV9hbmd1bGFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzIgPSBiQi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciBzcGVlZCA9IChkWCAqICgoLXcxICogYXhpcy55KSkgKyBkWSAqICh3MSAqIGF4aXMueCkpICsgKGF4aXMueCAqICgoKHYyLnggKyAoKC13MiAqIHIyWSkpKSAtIHYxLngpIC0gKCgtdzEgKiByMVkpKSkgKyBheGlzLnkgKiAoKCh2Mi55ICsgKHcyICogcjJYKSkgLSB2MS55KSAtICh3MSAqIHIxWCkpKTtcbiAgICAgIHJldHVybiBzcGVlZDtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5Jc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTGltaXQ7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuRW5hYmxlTGltaXQgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZmxhZztcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRMb3dlckxpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldFVwcGVyTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb247XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuU2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQpIGxvd2VyID0gMDtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB1cHBlciA9IDA7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiA9IGxvd2VyO1xuICAgICAgdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gPSB1cHBlcjtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5Jc01vdG9yRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTW90b3I7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuRW5hYmxlTW90b3IgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZmxhZztcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5TZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKHNwZWVkKSB7XG4gICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkgc3BlZWQgPSAwO1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBzcGVlZDtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9tb3RvclNwZWVkO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLlNldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSA9PT0gdW5kZWZpbmVkKSBmb3JjZSA9IDA7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fbWF4TW90b3JGb3JjZSA9IGZvcmNlO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX21heE1vdG9yRm9yY2U7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuR2V0TW90b3JGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgfVxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLmIyTGluZUpvaW50ID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIHRZID0gMDtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEuU2V0VihkZWYubG9jYWxBbmNob3JBKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIuU2V0VihkZWYubG9jYWxBbmNob3JCKTtcbiAgICAgIHRoaXMubV9sb2NhbFhBeGlzMS5TZXRWKGRlZi5sb2NhbEF4aXNBKTtcbiAgICAgIHRoaXMubV9sb2NhbFlBeGlzMS54ID0gKC10aGlzLm1fbG9jYWxYQXhpczEueSk7XG4gICAgICB0aGlzLm1fbG9jYWxZQXhpczEueSA9IHRoaXMubV9sb2NhbFhBeGlzMS54O1xuICAgICAgdGhpcy5tX2ltcHVsc2UuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IDAuMDtcbiAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiA9IGRlZi5sb3dlclRyYW5zbGF0aW9uO1xuICAgICAgdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gPSBkZWYudXBwZXJUcmFuc2xhdGlvbjtcbiAgICAgIHRoaXMubV9tYXhNb3RvckZvcmNlID0gZGVmLm1heE1vdG9yRm9yY2U7XG4gICAgICB0aGlzLm1fbW90b3JTcGVlZCA9IGRlZi5tb3RvclNwZWVkO1xuICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZGVmLmVuYWJsZUxpbWl0O1xuICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZGVmLmVuYWJsZU1vdG9yO1xuICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdDtcbiAgICAgIHRoaXMubV9heGlzLlNldFplcm8oKTtcbiAgICAgIHRoaXMubV9wZXJwLlNldFplcm8oKTtcbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBLlNldFYoYkEuR2V0TG9jYWxDZW50ZXIoKSk7XG4gICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCLlNldFYoYkIuR2V0TG9jYWxDZW50ZXIoKSk7XG4gICAgICB2YXIgeGYxID0gYkEuR2V0VHJhbnNmb3JtKCk7XG4gICAgICB2YXIgeGYyID0gYkIuR2V0VHJhbnNmb3JtKCk7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIHRoaXMubV9sb2NhbENlbnRlckEueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJBLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSB0aGlzLm1fbG9jYWxDZW50ZXJCLng7XG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gdGhpcy5tX2xvY2FsQ2VudGVyQi55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICByMlggPSB0WDtcbiAgICAgIHZhciBkWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XG4gICAgICB2YXIgZFkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWSAtIGJBLm1fc3dlZXAuYy55IC0gcjFZO1xuICAgICAgdGhpcy5tX2ludk1hc3NBID0gYkEubV9pbnZNYXNzO1xuICAgICAgdGhpcy5tX2ludk1hc3NCID0gYkIubV9pbnZNYXNzO1xuICAgICAgdGhpcy5tX2ludklBID0gYkEubV9pbnZJO1xuICAgICAgdGhpcy5tX2ludklCID0gYkIubV9pbnZJOyB7XG4gICAgICAgICB0aGlzLm1fYXhpcy5TZXRWKGIyTWF0aC5NdWxNVih4ZjEuUiwgdGhpcy5tX2xvY2FsWEF4aXMxKSk7XG4gICAgICAgICB0aGlzLm1fYTEgPSAoZFggKyByMVgpICogdGhpcy5tX2F4aXMueSAtIChkWSArIHIxWSkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgICAgdGhpcy5tX2EyID0gcjJYICogdGhpcy5tX2F4aXMueSAtIHIyWSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gdGhpcy5tX2ludk1hc3NBICsgdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklBICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgdGhpcy5tX2ludklCICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IHRoaXMubV9tb3Rvck1hc3MgPiBOdW1iZXIuTUlOX1ZBTFVFID8gMS4wIC8gdGhpcy5tX21vdG9yTWFzcyA6IDAuMDtcbiAgICAgIH0ge1xuICAgICAgICAgdGhpcy5tX3BlcnAuU2V0VihiMk1hdGguTXVsTVYoeGYxLlIsIHRoaXMubV9sb2NhbFlBeGlzMSkpO1xuICAgICAgICAgdGhpcy5tX3MxID0gKGRYICsgcjFYKSAqIHRoaXMubV9wZXJwLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX3BlcnAueDtcbiAgICAgICAgIHRoaXMubV9zMiA9IHIyWCAqIHRoaXMubV9wZXJwLnkgLSByMlkgKiB0aGlzLm1fcGVycC54O1xuICAgICAgICAgdmFyIG0xID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgdmFyIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgdmFyIGkxID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgdmFyIGkyID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgdGhpcy5tX0suY29sMS54ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX3MxICogdGhpcy5tX3MxICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fczI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wxLnkgPSBpMSAqIHRoaXMubV9zMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX3MyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX0suY29sMi54ID0gdGhpcy5tX0suY29sMS55O1xuICAgICAgICAgdGhpcy5tX0suY29sMi55ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fYTIgKiB0aGlzLm1fYTI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0KSB7XG4gICAgICAgICB2YXIgam9pbnRUcmFuc2l0aW9uID0gdGhpcy5tX2F4aXMueCAqIGRYICsgdGhpcy5tX2F4aXMueSAqIGRZO1xuICAgICAgICAgaWYgKGIyTWF0aC5BYnModGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikgPCAyLjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2VxdWFsTGltaXRzO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2l0aW9uIDw9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfYXRMb3dlckxpbWl0O1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKGpvaW50VHJhbnNpdGlvbiA+PSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gMC4wO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSkge1xuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS55ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdmFyIFBYID0gdGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnggKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnkpICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIHZhciBQWSA9IHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fcGVycC55ICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS55KSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICB2YXIgTDEgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MxICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS55KSAqIHRoaXMubV9hMTtcbiAgICAgICAgIHZhciBMMiA9IHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fczIgKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnkpICogdGhpcy5tX2EyO1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgLT0gdGhpcy5tX2ludklBICogTDE7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gdGhpcy5tX2ludk1hc3NCICogUFg7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UuU2V0WmVybygpO1xuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgIH1cbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHYxID0gYkEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3MSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIHYyID0gYkIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3MiA9IGJCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIFBYID0gMDtcbiAgICAgIHZhciBQWSA9IDA7XG4gICAgICB2YXIgTDEgPSAwO1xuICAgICAgdmFyIEwyID0gMDtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2VxdWFsTGltaXRzKSB7XG4gICAgICAgICB2YXIgQ2RvdCA9IHRoaXMubV9heGlzLnggKiAodjIueCAtIHYxLngpICsgdGhpcy5tX2F4aXMueSAqICh2Mi55IC0gdjEueSkgKyB0aGlzLm1fYTIgKiB3MiAtIHRoaXMubV9hMSAqIHcxO1xuICAgICAgICAgdmFyIGltcHVsc2UgPSB0aGlzLm1fbW90b3JNYXNzICogKHRoaXMubV9tb3RvclNwZWVkIC0gQ2RvdCk7XG4gICAgICAgICB2YXIgb2xkSW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2U7XG4gICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiB0aGlzLm1fbWF4TW90b3JGb3JjZTtcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSBiMk1hdGguQ2xhbXAodGhpcy5tX21vdG9ySW1wdWxzZSArIGltcHVsc2UsICgtbWF4SW1wdWxzZSksIG1heEltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgUFggPSBpbXB1bHNlICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIFBZID0gaW1wdWxzZSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICBMMSA9IGltcHVsc2UgKiB0aGlzLm1fYTE7XG4gICAgICAgICBMMiA9IGltcHVsc2UgKiB0aGlzLm1fYTI7XG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIHZhciBDZG90MSA9IHRoaXMubV9wZXJwLnggKiAodjIueCAtIHYxLngpICsgdGhpcy5tX3BlcnAueSAqICh2Mi55IC0gdjEueSkgKyB0aGlzLm1fczIgKiB3MiAtIHRoaXMubV9zMSAqIHcxO1xuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdCkge1xuICAgICAgICAgdmFyIENkb3QyID0gdGhpcy5tX2F4aXMueCAqICh2Mi54IC0gdjEueCkgKyB0aGlzLm1fYXhpcy55ICogKHYyLnkgLSB2MS55KSArIHRoaXMubV9hMiAqIHcyIC0gdGhpcy5tX2ExICogdzE7XG4gICAgICAgICB2YXIgZjEgPSB0aGlzLm1faW1wdWxzZS5Db3B5KCk7XG4gICAgICAgICB2YXIgZGYgPSB0aGlzLm1fSy5Tb2x2ZShuZXcgYjJWZWMyKCksICgtQ2RvdDEpLCAoLUNkb3QyKSk7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS5BZGQoZGYpO1xuICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgPSBiMk1hdGguTWF4KHRoaXMubV9pbXB1bHNlLnksIDAuMCk7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gYjJNYXRoLk1pbih0aGlzLm1faW1wdWxzZS55LCAwLjApO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIGIgPSAoLUNkb3QxKSAtICh0aGlzLm1faW1wdWxzZS55IC0gZjEueSkgKiB0aGlzLm1fSy5jb2wyLng7XG4gICAgICAgICB2YXIgZjJyID0gMDtcbiAgICAgICAgIGlmICh0aGlzLm1fSy5jb2wxLnggIT0gMC4wKSB7XG4gICAgICAgICAgICBmMnIgPSBiIC8gdGhpcy5tX0suY29sMS54ICsgZjEueDtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZjJyID0gZjEueDtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggPSBmMnI7XG4gICAgICAgICBkZi54ID0gdGhpcy5tX2ltcHVsc2UueCAtIGYxLng7XG4gICAgICAgICBkZi55ID0gdGhpcy5tX2ltcHVsc2UueSAtIGYxLnk7XG4gICAgICAgICBQWCA9IGRmLnggKiB0aGlzLm1fcGVycC54ICsgZGYueSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICBQWSA9IGRmLnggKiB0aGlzLm1fcGVycC55ICsgZGYueSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICBMMSA9IGRmLnggKiB0aGlzLm1fczEgKyBkZi55ICogdGhpcy5tX2ExO1xuICAgICAgICAgTDIgPSBkZi54ICogdGhpcy5tX3MyICsgZGYueSAqIHRoaXMubV9hMjtcbiAgICAgICAgIHYxLnggLT0gdGhpcy5tX2ludk1hc3NBICogUFg7XG4gICAgICAgICB2MS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xuICAgICAgICAgdzEgLT0gdGhpcy5tX2ludklBICogTDE7XG4gICAgICAgICB2Mi54ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBYO1xuICAgICAgICAgdjIueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcbiAgICAgICAgIHcyICs9IHRoaXMubV9pbnZJQiAqIEwyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB2YXIgZGYyID0gMDtcbiAgICAgICAgIGlmICh0aGlzLm1fSy5jb2wxLnggIT0gMC4wKSB7XG4gICAgICAgICAgICBkZjIgPSAoKC1DZG90MSkpIC8gdGhpcy5tX0suY29sMS54O1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZjIgPSAwLjA7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICs9IGRmMjtcbiAgICAgICAgIFBYID0gZGYyICogdGhpcy5tX3BlcnAueDtcbiAgICAgICAgIFBZID0gZGYyICogdGhpcy5tX3BlcnAueTtcbiAgICAgICAgIEwxID0gZGYyICogdGhpcy5tX3MxO1xuICAgICAgICAgTDIgPSBkZjIgKiB0aGlzLm1fczI7XG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkuU2V0Vih2MSk7XG4gICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSA9IHcxO1xuICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS5TZXRWKHYyKTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ID0gdzI7XG4gICB9XG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xuICAgICAgdmFyIGxpbWl0QyA9IDA7XG4gICAgICB2YXIgb2xkTGltaXRJbXB1bHNlID0gMDtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHZhciBjMSA9IGJBLm1fc3dlZXAuYztcbiAgICAgIHZhciBhMSA9IGJBLm1fc3dlZXAuYTtcbiAgICAgIHZhciBjMiA9IGJCLm1fc3dlZXAuYztcbiAgICAgIHZhciBhMiA9IGJCLm1fc3dlZXAuYTtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIHZhciBtMSA9IDA7XG4gICAgICB2YXIgbTIgPSAwO1xuICAgICAgdmFyIGkxID0gMDtcbiAgICAgIHZhciBpMiA9IDA7XG4gICAgICB2YXIgbGluZWFyRXJyb3IgPSAwLjA7XG4gICAgICB2YXIgYW5ndWxhckVycm9yID0gMC4wO1xuICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdmFyIEMyID0gMC4wO1xuICAgICAgdmFyIFIxID0gYjJNYXQyMi5Gcm9tQW5nbGUoYTEpO1xuICAgICAgdmFyIFIyID0gYjJNYXQyMi5Gcm9tQW5nbGUoYTIpO1xuICAgICAgdE1hdCA9IFIxO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIHRoaXMubV9sb2NhbENlbnRlckEueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJBLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IFIyO1xuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIHRoaXMubV9sb2NhbENlbnRlckIueDtcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJCLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgIHIyWCA9IHRYO1xuICAgICAgdmFyIGRYID0gYzIueCArIHIyWCAtIGMxLnggLSByMVg7XG4gICAgICB2YXIgZFkgPSBjMi55ICsgcjJZIC0gYzEueSAtIHIxWTtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQpIHtcbiAgICAgICAgIHRoaXMubV9heGlzID0gYjJNYXRoLk11bE1WKFIxLCB0aGlzLm1fbG9jYWxYQXhpczEpO1xuICAgICAgICAgdGhpcy5tX2ExID0gKGRYICsgcjFYKSAqIHRoaXMubV9heGlzLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIHRoaXMubV9hMiA9IHIyWCAqIHRoaXMubV9heGlzLnkgLSByMlkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5tX2F4aXMueCAqIGRYICsgdGhpcy5tX2F4aXMueSAqIGRZO1xuICAgICAgICAgaWYgKGIyTWF0aC5BYnModGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikgPCAyLjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcbiAgICAgICAgICAgIEMyID0gYjJNYXRoLkNsYW1wKHRyYW5zbGF0aW9uLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIGIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbik7XG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IGIyTWF0aC5BYnModHJhbnNsYXRpb24pO1xuICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKHRyYW5zbGF0aW9uIDw9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICBDMiA9IGIyTWF0aC5DbGFtcCh0cmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIDAuMCk7XG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uIC0gdHJhbnNsYXRpb247XG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPj0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgIEMyID0gYjJNYXRoLkNsYW1wKHRyYW5zbGF0aW9uIC0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gKyBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsIDAuMCwgYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGxpbmVhckVycm9yID0gdHJhbnNsYXRpb24gLSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbjtcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm1fcGVycCA9IGIyTWF0aC5NdWxNVihSMSwgdGhpcy5tX2xvY2FsWUF4aXMxKTtcbiAgICAgIHRoaXMubV9zMSA9IChkWCArIHIxWCkgKiB0aGlzLm1fcGVycC55IC0gKGRZICsgcjFZKSAqIHRoaXMubV9wZXJwLng7XG4gICAgICB0aGlzLm1fczIgPSByMlggKiB0aGlzLm1fcGVycC55IC0gcjJZICogdGhpcy5tX3BlcnAueDtcbiAgICAgIHZhciBpbXB1bHNlID0gbmV3IGIyVmVjMigpO1xuICAgICAgdmFyIEMxID0gdGhpcy5tX3BlcnAueCAqIGRYICsgdGhpcy5tX3BlcnAueSAqIGRZO1xuICAgICAgbGluZWFyRXJyb3IgPSBiMk1hdGguTWF4KGxpbmVhckVycm9yLCBiMk1hdGguQWJzKEMxKSk7XG4gICAgICBhbmd1bGFyRXJyb3IgPSAwLjA7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICBtMSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgaTEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICBpMiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDEueCA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9zMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyICogdGhpcy5tX3MyO1xuICAgICAgICAgdGhpcy5tX0suY29sMS55ID0gaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fYTEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9hMjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueCA9IHRoaXMubV9LLmNvbDEueTtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueSA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9hMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX0suU29sdmUoaW1wdWxzZSwgKC1DMSksICgtQzIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgbTEgPSB0aGlzLm1faW52TWFzc0E7XG4gICAgICAgICBtMiA9IHRoaXMubV9pbnZNYXNzQjtcbiAgICAgICAgIGkxID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgaTIgPSB0aGlzLm1faW52SUI7XG4gICAgICAgICB2YXIgazExID0gbTEgKyBtMiArIGkxICogdGhpcy5tX3MxICogdGhpcy5tX3MxICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fczI7XG4gICAgICAgICB2YXIgaW1wdWxzZTEgPSAwO1xuICAgICAgICAgaWYgKGsxMSAhPSAwLjApIHtcbiAgICAgICAgICAgIGltcHVsc2UxID0gKCgtQzEpKSAvIGsxMTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW1wdWxzZTEgPSAwLjA7XG4gICAgICAgICB9XG4gICAgICAgICBpbXB1bHNlLnggPSBpbXB1bHNlMTtcbiAgICAgICAgIGltcHVsc2UueSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIHZhciBQWCA9IGltcHVsc2UueCAqIHRoaXMubV9wZXJwLnggKyBpbXB1bHNlLnkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgdmFyIFBZID0gaW1wdWxzZS54ICogdGhpcy5tX3BlcnAueSArIGltcHVsc2UueSAqIHRoaXMubV9heGlzLnk7XG4gICAgICB2YXIgTDEgPSBpbXB1bHNlLnggKiB0aGlzLm1fczEgKyBpbXB1bHNlLnkgKiB0aGlzLm1fYTE7XG4gICAgICB2YXIgTDIgPSBpbXB1bHNlLnggKiB0aGlzLm1fczIgKyBpbXB1bHNlLnkgKiB0aGlzLm1fYTI7XG4gICAgICBjMS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgYzEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgIGExIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgYzIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgIGMyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICBhMiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIGJBLm1fc3dlZXAuYSA9IGExO1xuICAgICAgYkIubV9zd2VlcC5hID0gYTI7XG4gICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8PSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3A7XG4gICB9XG4gICBCb3gyRC5pbmhlcml0KGIyTGluZUpvaW50RGVmLCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZik7XG4gICBiMkxpbmVKb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcbiAgIGIyTGluZUpvaW50RGVmLmIyTGluZUpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYuYjJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBeGlzQSA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMkxpbmVKb2ludERlZi5wcm90b3R5cGUuYjJMaW5lSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX2xpbmVKb2ludDtcbiAgICAgIHRoaXMubG9jYWxBeGlzQS5TZXQoMS4wLCAwLjApO1xuICAgICAgdGhpcy5lbmFibGVMaW1pdCA9IGZhbHNlO1xuICAgICAgdGhpcy5sb3dlclRyYW5zbGF0aW9uID0gMC4wO1xuICAgICAgdGhpcy51cHBlclRyYW5zbGF0aW9uID0gMC4wO1xuICAgICAgdGhpcy5lbmFibGVNb3RvciA9IGZhbHNlO1xuICAgICAgdGhpcy5tYXhNb3RvckZvcmNlID0gMC4wO1xuICAgICAgdGhpcy5tb3RvclNwZWVkID0gMC4wO1xuICAgfVxuICAgYjJMaW5lSm9pbnREZWYucHJvdG90eXBlLkluaXRpYWxpemUgPSBmdW5jdGlvbiAoYkEsIGJCLCBhbmNob3IsIGF4aXMpIHtcbiAgICAgIHRoaXMuYm9keUEgPSBiQTtcbiAgICAgIHRoaXMuYm9keUIgPSBiQjtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gdGhpcy5ib2R5QS5HZXRMb2NhbFBvaW50KGFuY2hvcik7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IHRoaXMuYm9keUIuR2V0TG9jYWxQb2ludChhbmNob3IpO1xuICAgICAgdGhpcy5sb2NhbEF4aXNBID0gdGhpcy5ib2R5QS5HZXRMb2NhbFZlY3RvcihheGlzKTtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJNb3VzZUpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMk1vdXNlSm9pbnQuYjJNb3VzZUpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5LID0gbmV3IGIyTWF0MjIoKTtcbiAgICAgIHRoaXMuSzEgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgdGhpcy5LMiA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fdGFyZ2V0ID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2ltcHVsc2UgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbWFzcyA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLm1fQyA9IG5ldyBiMlZlYzIoKTtcbiAgIH07XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3RhcmdldDtcbiAgIH1cbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IpO1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueSk7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIDAuMDtcbiAgIH1cbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuR2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV90YXJnZXQ7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLlNldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLm1fYm9keUIuSXNBd2FrZSgpID09IGZhbHNlKSB7XG4gICAgICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbWF4Rm9yY2U7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLlNldE1heEZvcmNlID0gZnVuY3Rpb24gKG1heEZvcmNlKSB7XG4gICAgICBpZiAobWF4Rm9yY2UgPT09IHVuZGVmaW5lZCkgbWF4Rm9yY2UgPSAwO1xuICAgICAgdGhpcy5tX21heEZvcmNlID0gbWF4Rm9yY2U7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkdldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLlNldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChoeikge1xuICAgICAgaWYgKGh6ID09PSB1bmRlZmluZWQpIGh6ID0gMDtcbiAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RhbXBpbmdSYXRpbztcbiAgIH1cbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuU2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICBpZiAocmF0aW8gPT09IHVuZGVmaW5lZCkgcmF0aW8gPSAwO1xuICAgICAgdGhpcy5tX2RhbXBpbmdSYXRpbyA9IHJhdGlvO1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5iMk1vdXNlSm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludC5jYWxsKHRoaXMsIGRlZik7XG4gICAgICB0aGlzLm1fdGFyZ2V0LlNldFYoZGVmLnRhcmdldCk7XG4gICAgICB2YXIgdFggPSB0aGlzLm1fdGFyZ2V0LnggLSB0aGlzLm1fYm9keUIubV94Zi5wb3NpdGlvbi54O1xuICAgICAgdmFyIHRZID0gdGhpcy5tX3RhcmdldC55IC0gdGhpcy5tX2JvZHlCLm1feGYucG9zaXRpb24ueTtcbiAgICAgIHZhciB0TWF0ID0gdGhpcy5tX2JvZHlCLm1feGYuUjtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvci54ID0gKHRYICogdE1hdC5jb2wxLnggKyB0WSAqIHRNYXQuY29sMS55KTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvci55ID0gKHRYICogdE1hdC5jb2wyLnggKyB0WSAqIHRNYXQuY29sMi55KTtcbiAgICAgIHRoaXMubV9tYXhGb3JjZSA9IGRlZi5tYXhGb3JjZTtcbiAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGRlZi5mcmVxdWVuY3lIejtcbiAgICAgIHRoaXMubV9kYW1waW5nUmF0aW8gPSBkZWYuZGFtcGluZ1JhdGlvO1xuICAgICAgdGhpcy5tX2JldGEgPSAwLjA7XG4gICAgICB0aGlzLm1fZ2FtbWEgPSAwLjA7XG4gICB9XG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciBiID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIG1hc3MgPSBiLkdldE1hc3MoKTtcbiAgICAgIHZhciBvbWVnYSA9IDIuMCAqIE1hdGguUEkgKiB0aGlzLm1fZnJlcXVlbmN5SHo7XG4gICAgICB2YXIgZCA9IDIuMCAqIG1hc3MgKiB0aGlzLm1fZGFtcGluZ1JhdGlvICogb21lZ2E7XG4gICAgICB2YXIgayA9IG1hc3MgKiBvbWVnYSAqIG9tZWdhO1xuICAgICAgdGhpcy5tX2dhbW1hID0gc3RlcC5kdCAqIChkICsgc3RlcC5kdCAqIGspO1xuICAgICAgdGhpcy5tX2dhbW1hID0gdGhpcy5tX2dhbW1hICE9IDAgPyAxIC8gdGhpcy5tX2dhbW1hIDogMC4wO1xuICAgICAgdGhpcy5tX2JldGEgPSBzdGVwLmR0ICogayAqIHRoaXMubV9nYW1tYTtcbiAgICAgIHZhciB0TWF0O3RNYXQgPSBiLm1feGYuUjtcbiAgICAgIHZhciByWCA9IHRoaXMubV9sb2NhbEFuY2hvci54IC0gYi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgclkgPSB0aGlzLm1fbG9jYWxBbmNob3IueSAtIGIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdmFyIHRYID0gKHRNYXQuY29sMS54ICogclggKyB0TWF0LmNvbDIueCAqIHJZKTtyWSA9ICh0TWF0LmNvbDEueSAqIHJYICsgdE1hdC5jb2wyLnkgKiByWSk7XG4gICAgICByWCA9IHRYO1xuICAgICAgdmFyIGludk1hc3MgPSBiLm1faW52TWFzcztcbiAgICAgIHZhciBpbnZJID0gYi5tX2ludkk7dGhpcy5LMS5jb2wxLnggPSBpbnZNYXNzO1xuICAgICAgdGhpcy5LMS5jb2wyLnggPSAwLjA7XG4gICAgICB0aGlzLksxLmNvbDEueSA9IDAuMDtcbiAgICAgIHRoaXMuSzEuY29sMi55ID0gaW52TWFzcztcbiAgICAgIHRoaXMuSzIuY29sMS54ID0gaW52SSAqIHJZICogclk7XG4gICAgICB0aGlzLksyLmNvbDIueCA9ICgtaW52SSAqIHJYICogclkpO1xuICAgICAgdGhpcy5LMi5jb2wxLnkgPSAoLWludkkgKiByWCAqIHJZKTtcbiAgICAgIHRoaXMuSzIuY29sMi55ID0gaW52SSAqIHJYICogclg7XG4gICAgICB0aGlzLksuU2V0TSh0aGlzLksxKTtcbiAgICAgIHRoaXMuSy5BZGRNKHRoaXMuSzIpO1xuICAgICAgdGhpcy5LLmNvbDEueCArPSB0aGlzLm1fZ2FtbWE7XG4gICAgICB0aGlzLksuY29sMi55ICs9IHRoaXMubV9nYW1tYTtcbiAgICAgIHRoaXMuSy5HZXRJbnZlcnNlKHRoaXMubV9tYXNzKTtcbiAgICAgIHRoaXMubV9DLnggPSBiLm1fc3dlZXAuYy54ICsgclggLSB0aGlzLm1fdGFyZ2V0Lng7XG4gICAgICB0aGlzLm1fQy55ID0gYi5tX3N3ZWVwLmMueSArIHJZIC0gdGhpcy5tX3RhcmdldC55O1xuICAgICAgYi5tX2FuZ3VsYXJWZWxvY2l0eSAqPSAwLjk4O1xuICAgICAgdGhpcy5tX2ltcHVsc2UueCAqPSBzdGVwLmR0UmF0aW87XG4gICAgICB0aGlzLm1faW1wdWxzZS55ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgIGIubV9saW5lYXJWZWxvY2l0eS54ICs9IGludk1hc3MgKiB0aGlzLm1faW1wdWxzZS54O1xuICAgICAgYi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gaW52TWFzcyAqIHRoaXMubV9pbXB1bHNlLnk7XG4gICAgICBiLm1fYW5ndWxhclZlbG9jaXR5ICs9IGludkkgKiAoclggKiB0aGlzLm1faW1wdWxzZS55IC0gclkgKiB0aGlzLm1faW1wdWxzZS54KTtcbiAgIH1cbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciBiID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIHRZID0gMDtcbiAgICAgIHRNYXQgPSBiLm1feGYuUjtcbiAgICAgIHZhciByWCA9IHRoaXMubV9sb2NhbEFuY2hvci54IC0gYi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgclkgPSB0aGlzLm1fbG9jYWxBbmNob3IueSAtIGIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByWCArIHRNYXQuY29sMi54ICogclkpO1xuICAgICAgclkgPSAodE1hdC5jb2wxLnkgKiByWCArIHRNYXQuY29sMi55ICogclkpO1xuICAgICAgclggPSB0WDtcbiAgICAgIHZhciBDZG90WCA9IGIubV9saW5lYXJWZWxvY2l0eS54ICsgKCgtYi5tX2FuZ3VsYXJWZWxvY2l0eSAqIHJZKSk7XG4gICAgICB2YXIgQ2RvdFkgPSBiLm1fbGluZWFyVmVsb2NpdHkueSArIChiLm1fYW5ndWxhclZlbG9jaXR5ICogclgpO1xuICAgICAgdE1hdCA9IHRoaXMubV9tYXNzO1xuICAgICAgdFggPSBDZG90WCArIHRoaXMubV9iZXRhICogdGhpcy5tX0MueCArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlLng7XG4gICAgICB0WSA9IENkb3RZICsgdGhpcy5tX2JldGEgKiB0aGlzLm1fQy55ICsgdGhpcy5tX2dhbW1hICogdGhpcy5tX2ltcHVsc2UueTtcbiAgICAgIHZhciBpbXB1bHNlWCA9ICgtKHRNYXQuY29sMS54ICogdFggKyB0TWF0LmNvbDIueCAqIHRZKSk7XG4gICAgICB2YXIgaW1wdWxzZVkgPSAoLSh0TWF0LmNvbDEueSAqIHRYICsgdE1hdC5jb2wyLnkgKiB0WSkpO1xuICAgICAgdmFyIG9sZEltcHVsc2VYID0gdGhpcy5tX2ltcHVsc2UueDtcbiAgICAgIHZhciBvbGRJbXB1bHNlWSA9IHRoaXMubV9pbXB1bHNlLnk7XG4gICAgICB0aGlzLm1faW1wdWxzZS54ICs9IGltcHVsc2VYO1xuICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSBpbXB1bHNlWTtcbiAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhGb3JjZTtcbiAgICAgIGlmICh0aGlzLm1faW1wdWxzZS5MZW5ndGhTcXVhcmVkKCkgPiBtYXhJbXB1bHNlICogbWF4SW1wdWxzZSkge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UuTXVsdGlwbHkobWF4SW1wdWxzZSAvIHRoaXMubV9pbXB1bHNlLkxlbmd0aCgpKTtcbiAgICAgIH1cbiAgICAgIGltcHVsc2VYID0gdGhpcy5tX2ltcHVsc2UueCAtIG9sZEltcHVsc2VYO1xuICAgICAgaW1wdWxzZVkgPSB0aGlzLm1faW1wdWxzZS55IC0gb2xkSW1wdWxzZVk7XG4gICAgICBiLm1fbGluZWFyVmVsb2NpdHkueCArPSBiLm1faW52TWFzcyAqIGltcHVsc2VYO1xuICAgICAgYi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYi5tX2ludk1hc3MgKiBpbXB1bHNlWTtcbiAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYi5tX2ludkkgKiAoclggKiBpbXB1bHNlWSAtIHJZICogaW1wdWxzZVgpO1xuICAgfVxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJNb3VzZUpvaW50RGVmLCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZik7XG4gICBiMk1vdXNlSm9pbnREZWYucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5wcm90b3R5cGU7XG4gICBiMk1vdXNlSm9pbnREZWYuYjJNb3VzZUpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYuYjJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy50YXJnZXQgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJNb3VzZUpvaW50RGVmLnByb3RvdHlwZS5iMk1vdXNlSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX21vdXNlSm9pbnQ7XG4gICAgICB0aGlzLm1heEZvcmNlID0gMC4wO1xuICAgICAgdGhpcy5mcmVxdWVuY3lIeiA9IDUuMDtcbiAgICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gMC43O1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMlByaXNtYXRpY0pvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQucHJvdG90eXBlO1xuICAgYjJQcmlzbWF0aWNKb2ludC5iMlByaXNtYXRpY0pvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxYQXhpczEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxZQXhpczEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fYXhpcyA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9wZXJwID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX0sgPSBuZXcgYjJNYXQzMygpO1xuICAgICAgdGhpcy5tX2ltcHVsc2UgPSBuZXcgYjJWZWMzKCk7XG4gICB9O1xuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IxKTtcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMik7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogKHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fcGVycC54ICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KSAqIHRoaXMubV9heGlzLngpLCBpbnZfZHQgKiAodGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnkgKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopICogdGhpcy5tX2F4aXMueSkpO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueTtcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldEpvaW50VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciBwMSA9IGJBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICAgICB2YXIgcDIgPSBiQi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xuICAgICAgdmFyIGRYID0gcDIueCAtIHAxLng7XG4gICAgICB2YXIgZFkgPSBwMi55IC0gcDEueTtcbiAgICAgIHZhciBheGlzID0gYkEuR2V0V29ybGRWZWN0b3IodGhpcy5tX2xvY2FsWEF4aXMxKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IGF4aXMueCAqIGRYICsgYXhpcy55ICogZFk7XG4gICAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5HZXRKb2ludFNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICByMVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgcDFYID0gYkEubV9zd2VlcC5jLnggKyByMVg7XG4gICAgICB2YXIgcDFZID0gYkEubV9zd2VlcC5jLnkgKyByMVk7XG4gICAgICB2YXIgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XG4gICAgICB2YXIgcDJZID0gYkIubV9zd2VlcC5jLnkgKyByMlk7XG4gICAgICB2YXIgZFggPSBwMlggLSBwMVg7XG4gICAgICB2YXIgZFkgPSBwMlkgLSBwMVk7XG4gICAgICB2YXIgYXhpcyA9IGJBLkdldFdvcmxkVmVjdG9yKHRoaXMubV9sb2NhbFhBeGlzMSk7XG4gICAgICB2YXIgdjEgPSBiQS5tX2xpbmVhclZlbG9jaXR5O1xuICAgICAgdmFyIHYyID0gYkIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3MSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIHcyID0gYkIubV9hbmd1bGFyVmVsb2NpdHk7XG4gICAgICB2YXIgc3BlZWQgPSAoZFggKiAoKC13MSAqIGF4aXMueSkpICsgZFkgKiAodzEgKiBheGlzLngpKSArIChheGlzLnggKiAoKCh2Mi54ICsgKCgtdzIgKiByMlkpKSkgLSB2MS54KSAtICgoLXcxICogcjFZKSkpICsgYXhpcy55ICogKCgodjIueSArICh3MiAqIHIyWCkpIC0gdjEueSkgLSAodzEgKiByMVgpKSk7XG4gICAgICByZXR1cm4gc3BlZWQ7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5Jc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fZW5hYmxlTGltaXQ7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5FbmFibGVMaW1pdCA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fZW5hYmxlTGltaXQgPSBmbGFnO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0TG93ZXJMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbjtcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldFVwcGVyTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb247XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5TZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCkgbG93ZXIgPSAwO1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHVwcGVyID0gMDtcbiAgICAgIHRoaXMubV9ib2R5QS5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIHRoaXMubV9ib2R5Qi5TZXRBd2FrZSh0cnVlKTtcbiAgICAgIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uID0gbG93ZXI7XG4gICAgICB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiA9IHVwcGVyO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuSXNNb3RvckVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2VuYWJsZU1vdG9yO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuRW5hYmxlTW90b3IgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZmxhZztcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLlNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcbiAgICAgIGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSBzcGVlZCA9IDA7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fbW90b3JTcGVlZCA9IHNwZWVkO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbW90b3JTcGVlZDtcbiAgIH1cbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLlNldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSA9PT0gdW5kZWZpbmVkKSBmb3JjZSA9IDA7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fbWF4TW90b3JGb3JjZSA9IGZvcmNlO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0TW90b3JGb3JjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuYjJQcmlzbWF0aWNKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50LmNhbGwodGhpcywgZGVmKTtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIHZhciB0WSA9IDA7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyLlNldFYoZGVmLmxvY2FsQW5jaG9yQik7XG4gICAgICB0aGlzLm1fbG9jYWxYQXhpczEuU2V0VihkZWYubG9jYWxBeGlzQSk7XG4gICAgICB0aGlzLm1fbG9jYWxZQXhpczEueCA9ICgtdGhpcy5tX2xvY2FsWEF4aXMxLnkpO1xuICAgICAgdGhpcy5tX2xvY2FsWUF4aXMxLnkgPSB0aGlzLm1fbG9jYWxYQXhpczEueDtcbiAgICAgIHRoaXMubV9yZWZBbmdsZSA9IGRlZi5yZWZlcmVuY2VBbmdsZTtcbiAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAwLjA7XG4gICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xuICAgICAgdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gPSBkZWYubG93ZXJUcmFuc2xhdGlvbjtcbiAgICAgIHRoaXMubV91cHBlclRyYW5zbGF0aW9uID0gZGVmLnVwcGVyVHJhbnNsYXRpb247XG4gICAgICB0aGlzLm1fbWF4TW90b3JGb3JjZSA9IGRlZi5tYXhNb3RvckZvcmNlO1xuICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBkZWYubW90b3JTcGVlZDtcbiAgICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGRlZi5lbmFibGVMaW1pdDtcbiAgICAgIHRoaXMubV9lbmFibGVNb3RvciA9IGRlZi5lbmFibGVNb3RvcjtcbiAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICB0aGlzLm1fYXhpcy5TZXRaZXJvKCk7XG4gICAgICB0aGlzLm1fcGVycC5TZXRaZXJvKCk7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB0aGlzLm1fbG9jYWxDZW50ZXJBLlNldFYoYkEuR2V0TG9jYWxDZW50ZXIoKSk7XG4gICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCLlNldFYoYkIuR2V0TG9jYWxDZW50ZXIoKSk7XG4gICAgICB2YXIgeGYxID0gYkEuR2V0VHJhbnNmb3JtKCk7XG4gICAgICB2YXIgeGYyID0gYkIuR2V0VHJhbnNmb3JtKCk7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIHRoaXMubV9sb2NhbENlbnRlckEueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJBLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgIHIxWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSB0aGlzLm1fbG9jYWxDZW50ZXJCLng7XG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gdGhpcy5tX2xvY2FsQ2VudGVyQi55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICByMlggPSB0WDtcbiAgICAgIHZhciBkWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XG4gICAgICB2YXIgZFkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWSAtIGJBLm1fc3dlZXAuYy55IC0gcjFZO1xuICAgICAgdGhpcy5tX2ludk1hc3NBID0gYkEubV9pbnZNYXNzO1xuICAgICAgdGhpcy5tX2ludk1hc3NCID0gYkIubV9pbnZNYXNzO1xuICAgICAgdGhpcy5tX2ludklBID0gYkEubV9pbnZJO1xuICAgICAgdGhpcy5tX2ludklCID0gYkIubV9pbnZJOyB7XG4gICAgICAgICB0aGlzLm1fYXhpcy5TZXRWKGIyTWF0aC5NdWxNVih4ZjEuUiwgdGhpcy5tX2xvY2FsWEF4aXMxKSk7XG4gICAgICAgICB0aGlzLm1fYTEgPSAoZFggKyByMVgpICogdGhpcy5tX2F4aXMueSAtIChkWSArIHIxWSkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgICAgdGhpcy5tX2EyID0gcjJYICogdGhpcy5tX2F4aXMueSAtIHIyWSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gdGhpcy5tX2ludk1hc3NBICsgdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklBICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgdGhpcy5tX2ludklCICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICAgaWYgKHRoaXMubV9tb3Rvck1hc3MgPiBOdW1iZXIuTUlOX1ZBTFVFKSB0aGlzLm1fbW90b3JNYXNzID0gMS4wIC8gdGhpcy5tX21vdG9yTWFzcztcbiAgICAgIH0ge1xuICAgICAgICAgdGhpcy5tX3BlcnAuU2V0VihiMk1hdGguTXVsTVYoeGYxLlIsIHRoaXMubV9sb2NhbFlBeGlzMSkpO1xuICAgICAgICAgdGhpcy5tX3MxID0gKGRYICsgcjFYKSAqIHRoaXMubV9wZXJwLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX3BlcnAueDtcbiAgICAgICAgIHRoaXMubV9zMiA9IHIyWCAqIHRoaXMubV9wZXJwLnkgLSByMlkgKiB0aGlzLm1fcGVycC54O1xuICAgICAgICAgdmFyIG0xID0gdGhpcy5tX2ludk1hc3NBO1xuICAgICAgICAgdmFyIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgdmFyIGkxID0gdGhpcy5tX2ludklBO1xuICAgICAgICAgdmFyIGkyID0gdGhpcy5tX2ludklCO1xuICAgICAgICAgdGhpcy5tX0suY29sMS54ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX3MxICogdGhpcy5tX3MxICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fczI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wxLnkgPSBpMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyO1xuICAgICAgICAgdGhpcy5tX0suY29sMS56ID0gaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fYTEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9hMjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueCA9IHRoaXMubV9LLmNvbDEueTtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueSA9IGkxICsgaTI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnogPSBpMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX0suY29sMy54ID0gdGhpcy5tX0suY29sMS56O1xuICAgICAgICAgdGhpcy5tX0suY29sMy55ID0gdGhpcy5tX0suY29sMi56O1xuICAgICAgICAgdGhpcy5tX0suY29sMy56ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fYTIgKiB0aGlzLm1fYTI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0KSB7XG4gICAgICAgICB2YXIgam9pbnRUcmFuc2l0aW9uID0gdGhpcy5tX2F4aXMueCAqIGRYICsgdGhpcy5tX2F4aXMueSAqIGRZO1xuICAgICAgICAgaWYgKGIyTWF0aC5BYnModGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbikgPCAyLjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2VxdWFsTGltaXRzO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2l0aW9uIDw9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfYXRMb3dlckxpbWl0O1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKGpvaW50VHJhbnNpdGlvbiA+PSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSkge1xuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS55ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdmFyIFBYID0gdGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnggKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIHZhciBQWSA9IHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fcGVycC55ICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KSAqIHRoaXMubV9heGlzLnk7XG4gICAgICAgICB2YXIgTDEgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MxICsgdGhpcy5tX2ltcHVsc2UueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueikgKiB0aGlzLm1fYTE7XG4gICAgICAgICB2YXIgTDIgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MyICsgdGhpcy5tX2ltcHVsc2UueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueikgKiB0aGlzLm1fYTI7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggLT0gdGhpcy5tX2ludk1hc3NBICogUFg7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gdGhpcy5tX2ludk1hc3NBICogUFk7XG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSAtPSB0aGlzLm1faW52SUEgKiBMMTtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcbiAgICAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMubV9pbnZJQiAqIEwyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS5TZXRaZXJvKCk7XG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xuICAgICAgfVxuICAgfVxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHZhciB2MSA9IGJBLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzEgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciB2MiA9IGJCLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzIgPSBiQi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciBQWCA9IDA7XG4gICAgICB2YXIgUFkgPSAwO1xuICAgICAgdmFyIEwxID0gMDtcbiAgICAgIHZhciBMMiA9IDA7XG4gICAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yICYmIHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9lcXVhbExpbWl0cykge1xuICAgICAgICAgdmFyIENkb3QgPSB0aGlzLm1fYXhpcy54ICogKHYyLnggLSB2MS54KSArIHRoaXMubV9heGlzLnkgKiAodjIueSAtIHYxLnkpICsgdGhpcy5tX2EyICogdzIgLSB0aGlzLm1fYTEgKiB3MTtcbiAgICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5tX21vdG9yTWFzcyAqICh0aGlzLm1fbW90b3JTcGVlZCAtIENkb3QpO1xuICAgICAgICAgdmFyIG9sZEltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlO1xuICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBzdGVwLmR0ICogdGhpcy5tX21heE1vdG9yRm9yY2U7XG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gYjJNYXRoLkNsYW1wKHRoaXMubV9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAoLW1heEltcHVsc2UpLCBtYXhJbXB1bHNlKTtcbiAgICAgICAgIGltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgIFBYID0gaW1wdWxzZSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICBQWSA9IGltcHVsc2UgKiB0aGlzLm1fYXhpcy55O1xuICAgICAgICAgTDEgPSBpbXB1bHNlICogdGhpcy5tX2ExO1xuICAgICAgICAgTDIgPSBpbXB1bHNlICogdGhpcy5tX2EyO1xuICAgICAgICAgdjEueCAtPSB0aGlzLm1faW52TWFzc0EgKiBQWDtcbiAgICAgICAgIHYxLnkgLT0gdGhpcy5tX2ludk1hc3NBICogUFk7XG4gICAgICAgICB3MSAtPSB0aGlzLm1faW52SUEgKiBMMTtcbiAgICAgICAgIHYyLnggKz0gdGhpcy5tX2ludk1hc3NCICogUFg7XG4gICAgICAgICB2Mi55ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBZO1xuICAgICAgICAgdzIgKz0gdGhpcy5tX2ludklCICogTDI7XG4gICAgICB9XG4gICAgICB2YXIgQ2RvdDFYID0gdGhpcy5tX3BlcnAueCAqICh2Mi54IC0gdjEueCkgKyB0aGlzLm1fcGVycC55ICogKHYyLnkgLSB2MS55KSArIHRoaXMubV9zMiAqIHcyIC0gdGhpcy5tX3MxICogdzE7XG4gICAgICB2YXIgQ2RvdDFZID0gdzIgLSB3MTtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQpIHtcbiAgICAgICAgIHZhciBDZG90MiA9IHRoaXMubV9heGlzLnggKiAodjIueCAtIHYxLngpICsgdGhpcy5tX2F4aXMueSAqICh2Mi55IC0gdjEueSkgKyB0aGlzLm1fYTIgKiB3MiAtIHRoaXMubV9hMSAqIHcxO1xuICAgICAgICAgdmFyIGYxID0gdGhpcy5tX2ltcHVsc2UuQ29weSgpO1xuICAgICAgICAgdmFyIGRmID0gdGhpcy5tX0suU29sdmUzMyhuZXcgYjJWZWMzKCksICgtQ2RvdDFYKSwgKC1DZG90MVkpLCAoLUNkb3QyKSk7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS5BZGQoZGYpO1xuICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSBiMk1hdGguTWF4KHRoaXMubV9pbXB1bHNlLnosIDAuMCk7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gYjJNYXRoLk1pbih0aGlzLm1faW1wdWxzZS56LCAwLjApO1xuICAgICAgICAgfVxuICAgICAgICAgdmFyIGJYID0gKC1DZG90MVgpIC0gKHRoaXMubV9pbXB1bHNlLnogLSBmMS56KSAqIHRoaXMubV9LLmNvbDMueDtcbiAgICAgICAgIHZhciBiWSA9ICgtQ2RvdDFZKSAtICh0aGlzLm1faW1wdWxzZS56IC0gZjEueikgKiB0aGlzLm1fSy5jb2wzLnk7XG4gICAgICAgICB2YXIgZjJyID0gdGhpcy5tX0suU29sdmUyMihuZXcgYjJWZWMyKCksIGJYLCBiWSk7XG4gICAgICAgICBmMnIueCArPSBmMS54O1xuICAgICAgICAgZjJyLnkgKz0gZjEueTtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggPSBmMnIueDtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgPSBmMnIueTtcbiAgICAgICAgIGRmLnggPSB0aGlzLm1faW1wdWxzZS54IC0gZjEueDtcbiAgICAgICAgIGRmLnkgPSB0aGlzLm1faW1wdWxzZS55IC0gZjEueTtcbiAgICAgICAgIGRmLnogPSB0aGlzLm1faW1wdWxzZS56IC0gZjEuejtcbiAgICAgICAgIFBYID0gZGYueCAqIHRoaXMubV9wZXJwLnggKyBkZi56ICogdGhpcy5tX2F4aXMueDtcbiAgICAgICAgIFBZID0gZGYueCAqIHRoaXMubV9wZXJwLnkgKyBkZi56ICogdGhpcy5tX2F4aXMueTtcbiAgICAgICAgIEwxID0gZGYueCAqIHRoaXMubV9zMSArIGRmLnkgKyBkZi56ICogdGhpcy5tX2ExO1xuICAgICAgICAgTDIgPSBkZi54ICogdGhpcy5tX3MyICsgZGYueSArIGRmLnogKiB0aGlzLm1fYTI7XG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdmFyIGRmMiA9IHRoaXMubV9LLlNvbHZlMjIobmV3IGIyVmVjMigpLCAoLUNkb3QxWCksICgtQ2RvdDFZKSk7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICs9IGRmMi54O1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSBkZjIueTtcbiAgICAgICAgIFBYID0gZGYyLnggKiB0aGlzLm1fcGVycC54O1xuICAgICAgICAgUFkgPSBkZjIueCAqIHRoaXMubV9wZXJwLnk7XG4gICAgICAgICBMMSA9IGRmMi54ICogdGhpcy5tX3MxICsgZGYyLnk7XG4gICAgICAgICBMMiA9IGRmMi54ICogdGhpcy5tX3MyICsgZGYyLnk7XG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcbiAgICAgIH1cbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkuU2V0Vih2MSk7XG4gICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSA9IHcxO1xuICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS5TZXRWKHYyKTtcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ID0gdzI7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICB2YXIgbGltaXRDID0gMDtcbiAgICAgIHZhciBvbGRMaW1pdEltcHVsc2UgPSAwO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIGMxID0gYkEubV9zd2VlcC5jO1xuICAgICAgdmFyIGExID0gYkEubV9zd2VlcC5hO1xuICAgICAgdmFyIGMyID0gYkIubV9zd2VlcC5jO1xuICAgICAgdmFyIGEyID0gYkIubV9zd2VlcC5hO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIG0xID0gMDtcbiAgICAgIHZhciBtMiA9IDA7XG4gICAgICB2YXIgaTEgPSAwO1xuICAgICAgdmFyIGkyID0gMDtcbiAgICAgIHZhciBsaW5lYXJFcnJvciA9IDAuMDtcbiAgICAgIHZhciBhbmd1bGFyRXJyb3IgPSAwLjA7XG4gICAgICB2YXIgYWN0aXZlID0gZmFsc2U7XG4gICAgICB2YXIgQzIgPSAwLjA7XG4gICAgICB2YXIgUjEgPSBiMk1hdDIyLkZyb21BbmdsZShhMSk7XG4gICAgICB2YXIgUjIgPSBiMk1hdDIyLkZyb21BbmdsZShhMik7XG4gICAgICB0TWF0ID0gUjE7XG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gdGhpcy5tX2xvY2FsQ2VudGVyQS54O1xuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIHRoaXMubV9sb2NhbENlbnRlckEueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xuICAgICAgcjFYID0gdFg7XG4gICAgICB0TWF0ID0gUjI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gdGhpcy5tX2xvY2FsQ2VudGVyQi54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIHRoaXMubV9sb2NhbENlbnRlckIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgZFggPSBjMi54ICsgcjJYIC0gYzEueCAtIHIxWDtcbiAgICAgIHZhciBkWSA9IGMyLnkgKyByMlkgLSBjMS55IC0gcjFZO1xuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCkge1xuICAgICAgICAgdGhpcy5tX2F4aXMgPSBiMk1hdGguTXVsTVYoUjEsIHRoaXMubV9sb2NhbFhBeGlzMSk7XG4gICAgICAgICB0aGlzLm1fYTEgPSAoZFggKyByMVgpICogdGhpcy5tX2F4aXMueSAtIChkWSArIHIxWSkgKiB0aGlzLm1fYXhpcy54O1xuICAgICAgICAgdGhpcy5tX2EyID0gcjJYICogdGhpcy5tX2F4aXMueSAtIHIyWSAqIHRoaXMubV9heGlzLng7XG4gICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLm1fYXhpcy54ICogZFggKyB0aGlzLm1fYXhpcy55ICogZFk7XG4gICAgICAgICBpZiAoYjJNYXRoLkFicyh0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSA8IDIuMCAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xuICAgICAgICAgICAgQzIgPSBiMk1hdGguQ2xhbXAodHJhbnNsYXRpb24sICgtYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKSwgYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGxpbmVhckVycm9yID0gYjJNYXRoLkFicyh0cmFuc2xhdGlvbik7XG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPD0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgIEMyID0gYjJNYXRoLkNsYW1wKHRyYW5zbGF0aW9uIC0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gKyBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsICgtYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKSwgMC4wKTtcbiAgICAgICAgICAgIGxpbmVhckVycm9yID0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gLSB0cmFuc2xhdGlvbjtcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0cmFuc2xhdGlvbiA+PSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgQzIgPSBiMk1hdGguQ2xhbXAodHJhbnNsYXRpb24gLSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgMC4wLCBiMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgbGluZWFyRXJyb3IgPSB0cmFuc2xhdGlvbiAtIHRoaXMubV91cHBlclRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubV9wZXJwID0gYjJNYXRoLk11bE1WKFIxLCB0aGlzLm1fbG9jYWxZQXhpczEpO1xuICAgICAgdGhpcy5tX3MxID0gKGRYICsgcjFYKSAqIHRoaXMubV9wZXJwLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX3BlcnAueDtcbiAgICAgIHRoaXMubV9zMiA9IHIyWCAqIHRoaXMubV9wZXJwLnkgLSByMlkgKiB0aGlzLm1fcGVycC54O1xuICAgICAgdmFyIGltcHVsc2UgPSBuZXcgYjJWZWMzKCk7XG4gICAgICB2YXIgQzFYID0gdGhpcy5tX3BlcnAueCAqIGRYICsgdGhpcy5tX3BlcnAueSAqIGRZO1xuICAgICAgdmFyIEMxWSA9IGEyIC0gYTEgLSB0aGlzLm1fcmVmQW5nbGU7XG4gICAgICBsaW5lYXJFcnJvciA9IGIyTWF0aC5NYXgobGluZWFyRXJyb3IsIGIyTWF0aC5BYnMoQzFYKSk7XG4gICAgICBhbmd1bGFyRXJyb3IgPSBiMk1hdGguQWJzKEMxWSk7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICBtMSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgaTEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICBpMiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDEueCA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9zMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyICogdGhpcy5tX3MyO1xuICAgICAgICAgdGhpcy5tX0suY29sMS55ID0gaTEgKiB0aGlzLm1fczEgKyBpMiAqIHRoaXMubV9zMjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDEueiA9IGkxICogdGhpcy5tX3MxICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fYTI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnggPSB0aGlzLm1fSy5jb2wxLnk7XG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnkgPSBpMSArIGkyO1xuICAgICAgICAgdGhpcy5tX0suY29sMi56ID0gaTEgKiB0aGlzLm1fYTEgKyBpMiAqIHRoaXMubV9hMjtcbiAgICAgICAgIHRoaXMubV9LLmNvbDMueCA9IHRoaXMubV9LLmNvbDEuejtcbiAgICAgICAgIHRoaXMubV9LLmNvbDMueSA9IHRoaXMubV9LLmNvbDIuejtcbiAgICAgICAgIHRoaXMubV9LLmNvbDMueiA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9hMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xuICAgICAgICAgdGhpcy5tX0suU29sdmUzMyhpbXB1bHNlLCAoLUMxWCksICgtQzFZKSwgKC1DMikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICBtMSA9IHRoaXMubV9pbnZNYXNzQTtcbiAgICAgICAgIG0yID0gdGhpcy5tX2ludk1hc3NCO1xuICAgICAgICAgaTEgPSB0aGlzLm1faW52SUE7XG4gICAgICAgICBpMiA9IHRoaXMubV9pbnZJQjtcbiAgICAgICAgIHZhciBrMTEgPSBtMSArIG0yICsgaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fczEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9zMjtcbiAgICAgICAgIHZhciBrMTIgPSBpMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyO1xuICAgICAgICAgdmFyIGsyMiA9IGkxICsgaTI7XG4gICAgICAgICB0aGlzLm1fSy5jb2wxLlNldChrMTEsIGsxMiwgMC4wKTtcbiAgICAgICAgIHRoaXMubV9LLmNvbDIuU2V0KGsxMiwgazIyLCAwLjApO1xuICAgICAgICAgdmFyIGltcHVsc2UxID0gdGhpcy5tX0suU29sdmUyMihuZXcgYjJWZWMyKCksICgtQzFYKSwgKC1DMVkpKTtcbiAgICAgICAgIGltcHVsc2UueCA9IGltcHVsc2UxLng7XG4gICAgICAgICBpbXB1bHNlLnkgPSBpbXB1bHNlMS55O1xuICAgICAgICAgaW1wdWxzZS56ID0gMC4wO1xuICAgICAgfVxuICAgICAgdmFyIFBYID0gaW1wdWxzZS54ICogdGhpcy5tX3BlcnAueCArIGltcHVsc2UueiAqIHRoaXMubV9heGlzLng7XG4gICAgICB2YXIgUFkgPSBpbXB1bHNlLnggKiB0aGlzLm1fcGVycC55ICsgaW1wdWxzZS56ICogdGhpcy5tX2F4aXMueTtcbiAgICAgIHZhciBMMSA9IGltcHVsc2UueCAqIHRoaXMubV9zMSArIGltcHVsc2UueSArIGltcHVsc2UueiAqIHRoaXMubV9hMTtcbiAgICAgIHZhciBMMiA9IGltcHVsc2UueCAqIHRoaXMubV9zMiArIGltcHVsc2UueSArIGltcHVsc2UueiAqIHRoaXMubV9hMjtcbiAgICAgIGMxLnggLT0gdGhpcy5tX2ludk1hc3NBICogUFg7XG4gICAgICBjMS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xuICAgICAgYTEgLT0gdGhpcy5tX2ludklBICogTDE7XG4gICAgICBjMi54ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBYO1xuICAgICAgYzIueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcbiAgICAgIGEyICs9IHRoaXMubV9pbnZJQiAqIEwyO1xuICAgICAgYkEubV9zd2VlcC5hID0gYTE7XG4gICAgICBiQi5tX3N3ZWVwLmEgPSBhMjtcbiAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuIGxpbmVhckVycm9yIDw9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcDtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJQcmlzbWF0aWNKb2ludERlZiwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYpO1xuICAgYjJQcmlzbWF0aWNKb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcbiAgIGIyUHJpc21hdGljSm9pbnREZWYuYjJQcmlzbWF0aWNKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmxvY2FsQXhpc0EgPSBuZXcgYjJWZWMyKCk7XG4gICB9O1xuICAgYjJQcmlzbWF0aWNKb2ludERlZi5wcm90b3R5cGUuYjJQcmlzbWF0aWNKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50RGVmLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnR5cGUgPSBiMkpvaW50LmVfcHJpc21hdGljSm9pbnQ7XG4gICAgICB0aGlzLmxvY2FsQXhpc0EuU2V0KDEuMCwgMC4wKTtcbiAgICAgIHRoaXMucmVmZXJlbmNlQW5nbGUgPSAwLjA7XG4gICAgICB0aGlzLmVuYWJsZUxpbWl0ID0gZmFsc2U7XG4gICAgICB0aGlzLmxvd2VyVHJhbnNsYXRpb24gPSAwLjA7XG4gICAgICB0aGlzLnVwcGVyVHJhbnNsYXRpb24gPSAwLjA7XG4gICAgICB0aGlzLmVuYWJsZU1vdG9yID0gZmFsc2U7XG4gICAgICB0aGlzLm1heE1vdG9yRm9yY2UgPSAwLjA7XG4gICAgICB0aGlzLm1vdG9yU3BlZWQgPSAwLjA7XG4gICB9XG4gICBiMlByaXNtYXRpY0pvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgYW5jaG9yLCBheGlzKSB7XG4gICAgICB0aGlzLmJvZHlBID0gYkE7XG4gICAgICB0aGlzLmJvZHlCID0gYkI7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IHRoaXMuYm9keUEuR2V0TG9jYWxQb2ludChhbmNob3IpO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSB0aGlzLmJvZHlCLkdldExvY2FsUG9pbnQoYW5jaG9yKTtcbiAgICAgIHRoaXMubG9jYWxBeGlzQSA9IHRoaXMuYm9keUEuR2V0TG9jYWxWZWN0b3IoYXhpcyk7XG4gICAgICB0aGlzLnJlZmVyZW5jZUFuZ2xlID0gdGhpcy5ib2R5Qi5HZXRBbmdsZSgpIC0gdGhpcy5ib2R5QS5HZXRBbmdsZSgpO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMlB1bGxleUpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQucHJvdG90eXBlO1xuICAgYjJQdWxsZXlKb2ludC5iMlB1bGxleUpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMiA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3UxID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX3UyID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICB9XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcbiAgICAgIHJldHVybiBuZXcgYjJWZWMyKGludl9kdCAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX3UyLngsIGludl9kdCAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX3UyLnkpO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gMC4wO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0R3JvdW5kQW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLkNvcHkoKTtcbiAgICAgIGEuQWRkKHRoaXMubV9ncm91bmRBbmNob3IxKTtcbiAgICAgIHJldHVybiBhO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0R3JvdW5kQW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLkNvcHkoKTtcbiAgICAgIGEuQWRkKHRoaXMubV9ncm91bmRBbmNob3IyKTtcbiAgICAgIHJldHVybiBhO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0TGVuZ3RoMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwID0gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICAgICB2YXIgc1ggPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueCArIHRoaXMubV9ncm91bmRBbmNob3IxLng7XG4gICAgICB2YXIgc1kgPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueSArIHRoaXMubV9ncm91bmRBbmNob3IxLnk7XG4gICAgICB2YXIgZFggPSBwLnggLSBzWDtcbiAgICAgIHZhciBkWSA9IHAueSAtIHNZO1xuICAgICAgcmV0dXJuIE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG4gICB9XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5HZXRMZW5ndGgyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHAgPSB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IyKTtcbiAgICAgIHZhciBzWCA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi54ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjIueDtcbiAgICAgIHZhciBzWSA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi55ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjIueTtcbiAgICAgIHZhciBkWCA9IHAueCAtIHNYO1xuICAgICAgdmFyIGRZID0gcC55IC0gc1k7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcbiAgIH1cbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLkdldFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9yYXRpbztcbiAgIH1cbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLmIyUHVsbGV5Sm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludC5jYWxsKHRoaXMsIGRlZik7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgdFkgPSAwO1xuICAgICAgdGhpcy5tX2dyb3VuZCA9IHRoaXMubV9ib2R5QS5tX3dvcmxkLm1fZ3JvdW5kQm9keTtcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IxLnggPSBkZWYuZ3JvdW5kQW5jaG9yQS54IC0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLng7XG4gICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMS55ID0gZGVmLmdyb3VuZEFuY2hvckEueSAtIHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi55O1xuICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjIueCA9IGRlZi5ncm91bmRBbmNob3JCLnggLSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueDtcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IyLnkgPSBkZWYuZ3JvdW5kQW5jaG9yQi55IC0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyLlNldFYoZGVmLmxvY2FsQW5jaG9yQik7XG4gICAgICB0aGlzLm1fcmF0aW8gPSBkZWYucmF0aW87XG4gICAgICB0aGlzLm1fY29uc3RhbnQgPSBkZWYubGVuZ3RoQSArIHRoaXMubV9yYXRpbyAqIGRlZi5sZW5ndGhCO1xuICAgICAgdGhpcy5tX21heExlbmd0aDEgPSBiMk1hdGguTWluKGRlZi5tYXhMZW5ndGhBLCB0aGlzLm1fY29uc3RhbnQgLSB0aGlzLm1fcmF0aW8gKiBiMlB1bGxleUpvaW50LmIyX21pblB1bGxleUxlbmd0aCk7XG4gICAgICB0aGlzLm1fbWF4TGVuZ3RoMiA9IGIyTWF0aC5NaW4oZGVmLm1heExlbmd0aEIsICh0aGlzLm1fY29uc3RhbnQgLSBiMlB1bGxleUpvaW50LmIyX21pblB1bGxleUxlbmd0aCkgLyB0aGlzLm1fcmF0aW8pO1xuICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwLjA7XG4gICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMSA9IDAuMDtcbiAgICAgIHRoaXMubV9saW1pdEltcHVsc2UyID0gMC4wO1xuICAgfVxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICByMVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgcDFYID0gYkEubV9zd2VlcC5jLnggKyByMVg7XG4gICAgICB2YXIgcDFZID0gYkEubV9zd2VlcC5jLnkgKyByMVk7XG4gICAgICB2YXIgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XG4gICAgICB2YXIgcDJZID0gYkIubV9zd2VlcC5jLnkgKyByMlk7XG4gICAgICB2YXIgczFYID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnggKyB0aGlzLm1fZ3JvdW5kQW5jaG9yMS54O1xuICAgICAgdmFyIHMxWSA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi55ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjEueTtcbiAgICAgIHZhciBzMlggPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueCArIHRoaXMubV9ncm91bmRBbmNob3IyLng7XG4gICAgICB2YXIgczJZID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnkgKyB0aGlzLm1fZ3JvdW5kQW5jaG9yMi55O1xuICAgICAgdGhpcy5tX3UxLlNldChwMVggLSBzMVgsIHAxWSAtIHMxWSk7XG4gICAgICB0aGlzLm1fdTIuU2V0KHAyWCAtIHMyWCwgcDJZIC0gczJZKTtcbiAgICAgIHZhciBsZW5ndGgxID0gdGhpcy5tX3UxLkxlbmd0aCgpO1xuICAgICAgdmFyIGxlbmd0aDIgPSB0aGlzLm1fdTIuTGVuZ3RoKCk7XG4gICAgICBpZiAobGVuZ3RoMSA+IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xuICAgICAgICAgdGhpcy5tX3UxLk11bHRpcGx5KDEuMCAvIGxlbmd0aDEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fdTEuU2V0WmVybygpO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aDIgPiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcbiAgICAgICAgIHRoaXMubV91Mi5NdWx0aXBseSgxLjAgLyBsZW5ndGgyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX3UyLlNldFplcm8oKTtcbiAgICAgIH1cbiAgICAgIHZhciBDID0gdGhpcy5tX2NvbnN0YW50IC0gbGVuZ3RoMSAtIHRoaXMubV9yYXRpbyAqIGxlbmd0aDI7XG4gICAgICBpZiAoQyA+IDAuMCkge1xuICAgICAgICAgdGhpcy5tX3N0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy5tX3N0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGgxIDwgdGhpcy5tX21heExlbmd0aDEpIHtcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlMSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xuICAgICAgICAgdGhpcy5tX2xpbWl0SW1wdWxzZTEgPSAwLjA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlMSA9IGIySm9pbnQuZV9hdFVwcGVyTGltaXQ7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoMiA8IHRoaXMubV9tYXhMZW5ndGgyKSB7XG4gICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZTIgPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdDtcbiAgICAgICAgIHRoaXMubV9saW1pdEltcHVsc2UyID0gMC4wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZTIgPSBiMkpvaW50LmVfYXRVcHBlckxpbWl0O1xuICAgICAgfVxuICAgICAgdmFyIGNyMXUxID0gcjFYICogdGhpcy5tX3UxLnkgLSByMVkgKiB0aGlzLm1fdTEueDtcbiAgICAgIHZhciBjcjJ1MiA9IHIyWCAqIHRoaXMubV91Mi55IC0gcjJZICogdGhpcy5tX3UyLng7XG4gICAgICB0aGlzLm1fbGltaXRNYXNzMSA9IGJBLm1faW52TWFzcyArIGJBLm1faW52SSAqIGNyMXUxICogY3IxdTE7XG4gICAgICB0aGlzLm1fbGltaXRNYXNzMiA9IGJCLm1faW52TWFzcyArIGJCLm1faW52SSAqIGNyMnUyICogY3IydTI7XG4gICAgICB0aGlzLm1fcHVsbGV5TWFzcyA9IHRoaXMubV9saW1pdE1hc3MxICsgdGhpcy5tX3JhdGlvICogdGhpcy5tX3JhdGlvICogdGhpcy5tX2xpbWl0TWFzczI7XG4gICAgICB0aGlzLm1fbGltaXRNYXNzMSA9IDEuMCAvIHRoaXMubV9saW1pdE1hc3MxO1xuICAgICAgdGhpcy5tX2xpbWl0TWFzczIgPSAxLjAgLyB0aGlzLm1fbGltaXRNYXNzMjtcbiAgICAgIHRoaXMubV9wdWxsZXlNYXNzID0gMS4wIC8gdGhpcy5tX3B1bGxleU1hc3M7XG4gICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9saW1pdEltcHVsc2UxICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9saW1pdEltcHVsc2UyICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHZhciBQMVggPSAoKC10aGlzLm1faW1wdWxzZSkgLSB0aGlzLm1fbGltaXRJbXB1bHNlMSkgKiB0aGlzLm1fdTEueDtcbiAgICAgICAgIHZhciBQMVkgPSAoKC10aGlzLm1faW1wdWxzZSkgLSB0aGlzLm1fbGltaXRJbXB1bHNlMSkgKiB0aGlzLm1fdTEueTtcbiAgICAgICAgIHZhciBQMlggPSAoKC10aGlzLm1fcmF0aW8gKiB0aGlzLm1faW1wdWxzZSkgLSB0aGlzLm1fbGltaXRJbXB1bHNlMikgKiB0aGlzLm1fdTIueDtcbiAgICAgICAgIHZhciBQMlkgPSAoKC10aGlzLm1fcmF0aW8gKiB0aGlzLm1faW1wdWxzZSkgLSB0aGlzLm1fbGltaXRJbXB1bHNlMikgKiB0aGlzLm1fdTIueTtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQS5tX2ludk1hc3MgKiBQMVg7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkEubV9pbnZNYXNzICogUDFZO1xuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkEubV9pbnZJICogKHIxWCAqIFAxWSAtIHIxWSAqIFAxWCk7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkIubV9pbnZNYXNzICogUDJYO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IGJCLm1faW52TWFzcyAqIFAyWTtcbiAgICAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJCLm1faW52SSAqIChyMlggKiBQMlkgLSByMlkgKiBQMlgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcbiAgICAgICAgIHRoaXMubV9saW1pdEltcHVsc2UxID0gMC4wO1xuICAgICAgICAgdGhpcy5tX2xpbWl0SW1wdWxzZTIgPSAwLjA7XG4gICAgICB9XG4gICB9XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICByMVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgdjFYID0gMDtcbiAgICAgIHZhciB2MVkgPSAwO1xuICAgICAgdmFyIHYyWCA9IDA7XG4gICAgICB2YXIgdjJZID0gMDtcbiAgICAgIHZhciBQMVggPSAwO1xuICAgICAgdmFyIFAxWSA9IDA7XG4gICAgICB2YXIgUDJYID0gMDtcbiAgICAgIHZhciBQMlkgPSAwO1xuICAgICAgdmFyIENkb3QgPSAwO1xuICAgICAgdmFyIGltcHVsc2UgPSAwO1xuICAgICAgdmFyIG9sZEltcHVsc2UgPSAwO1xuICAgICAgaWYgKHRoaXMubV9zdGF0ZSA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XG4gICAgICAgICB2MVggPSBiQS5tX2xpbmVhclZlbG9jaXR5LnggKyAoKC1iQS5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIxWSkpO1xuICAgICAgICAgdjFZID0gYkEubV9saW5lYXJWZWxvY2l0eS55ICsgKGJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFYKTtcbiAgICAgICAgIHYyWCA9IGJCLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJCLm1fYW5ndWxhclZlbG9jaXR5ICogcjJZKSk7XG4gICAgICAgICB2MlkgPSBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKyAoYkIubV9hbmd1bGFyVmVsb2NpdHkgKiByMlgpO1xuICAgICAgICAgQ2RvdCA9ICgtKHRoaXMubV91MS54ICogdjFYICsgdGhpcy5tX3UxLnkgKiB2MVkpKSAtIHRoaXMubV9yYXRpbyAqICh0aGlzLm1fdTIueCAqIHYyWCArIHRoaXMubV91Mi55ICogdjJZKTtcbiAgICAgICAgIGltcHVsc2UgPSB0aGlzLm1fcHVsbGV5TWFzcyAqICgoLUNkb3QpKTtcbiAgICAgICAgIG9sZEltcHVsc2UgPSB0aGlzLm1faW1wdWxzZTtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlID0gYjJNYXRoLk1heCgwLjAsIHRoaXMubV9pbXB1bHNlICsgaW1wdWxzZSk7XG4gICAgICAgICBpbXB1bHNlID0gdGhpcy5tX2ltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgUDFYID0gKC1pbXB1bHNlICogdGhpcy5tX3UxLngpO1xuICAgICAgICAgUDFZID0gKC1pbXB1bHNlICogdGhpcy5tX3UxLnkpO1xuICAgICAgICAgUDJYID0gKC10aGlzLm1fcmF0aW8gKiBpbXB1bHNlICogdGhpcy5tX3UyLngpO1xuICAgICAgICAgUDJZID0gKC10aGlzLm1fcmF0aW8gKiBpbXB1bHNlICogdGhpcy5tX3UyLnkpO1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54ICs9IGJBLm1faW52TWFzcyAqIFAxWDtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQS5tX2ludk1hc3MgKiBQMVk7XG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSArPSBiQS5tX2ludkkgKiAocjFYICogUDFZIC0gcjFZICogUDFYKTtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQi5tX2ludk1hc3MgKiBQMlg7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogUDJZO1xuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogKHIyWCAqIFAyWSAtIHIyWSAqIFAyWCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUxID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgIHYxWCA9IGJBLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFZKSk7XG4gICAgICAgICB2MVkgPSBiQS5tX2xpbmVhclZlbG9jaXR5LnkgKyAoYkEubV9hbmd1bGFyVmVsb2NpdHkgKiByMVgpO1xuICAgICAgICAgQ2RvdCA9ICgtKHRoaXMubV91MS54ICogdjFYICsgdGhpcy5tX3UxLnkgKiB2MVkpKTtcbiAgICAgICAgIGltcHVsc2UgPSAoLXRoaXMubV9saW1pdE1hc3MxICogQ2RvdCk7XG4gICAgICAgICBvbGRJbXB1bHNlID0gdGhpcy5tX2xpbWl0SW1wdWxzZTE7XG4gICAgICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMSA9IGIyTWF0aC5NYXgoMC4wLCB0aGlzLm1fbGltaXRJbXB1bHNlMSArIGltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9saW1pdEltcHVsc2UxIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgIFAxWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS54KTtcbiAgICAgICAgIFAxWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS55KTtcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQS5tX2ludk1hc3MgKiBQMVg7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkEubV9pbnZNYXNzICogUDFZO1xuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkEubV9pbnZJICogKHIxWCAqIFAxWSAtIHIxWSAqIFAxWCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUyID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgIHYyWCA9IGJCLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJCLm1fYW5ndWxhclZlbG9jaXR5ICogcjJZKSk7XG4gICAgICAgICB2MlkgPSBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKyAoYkIubV9hbmd1bGFyVmVsb2NpdHkgKiByMlgpO1xuICAgICAgICAgQ2RvdCA9ICgtKHRoaXMubV91Mi54ICogdjJYICsgdGhpcy5tX3UyLnkgKiB2MlkpKTtcbiAgICAgICAgIGltcHVsc2UgPSAoLXRoaXMubV9saW1pdE1hc3MyICogQ2RvdCk7XG4gICAgICAgICBvbGRJbXB1bHNlID0gdGhpcy5tX2xpbWl0SW1wdWxzZTI7XG4gICAgICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMiA9IGIyTWF0aC5NYXgoMC4wLCB0aGlzLm1fbGltaXRJbXB1bHNlMiArIGltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9saW1pdEltcHVsc2UyIC0gb2xkSW1wdWxzZTtcbiAgICAgICAgIFAyWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91Mi54KTtcbiAgICAgICAgIFAyWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91Mi55KTtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQi5tX2ludk1hc3MgKiBQMlg7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogUDJZO1xuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogKHIyWCAqIFAyWSAtIHIyWSAqIFAyWCk7XG4gICAgICB9XG4gICB9XG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciBzMVggPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueCArIHRoaXMubV9ncm91bmRBbmNob3IxLng7XG4gICAgICB2YXIgczFZID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnkgKyB0aGlzLm1fZ3JvdW5kQW5jaG9yMS55O1xuICAgICAgdmFyIHMyWCA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi54ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjIueDtcbiAgICAgIHZhciBzMlkgPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueSArIHRoaXMubV9ncm91bmRBbmNob3IyLnk7XG4gICAgICB2YXIgcjFYID0gMDtcbiAgICAgIHZhciByMVkgPSAwO1xuICAgICAgdmFyIHIyWCA9IDA7XG4gICAgICB2YXIgcjJZID0gMDtcbiAgICAgIHZhciBwMVggPSAwO1xuICAgICAgdmFyIHAxWSA9IDA7XG4gICAgICB2YXIgcDJYID0gMDtcbiAgICAgIHZhciBwMlkgPSAwO1xuICAgICAgdmFyIGxlbmd0aDEgPSAwO1xuICAgICAgdmFyIGxlbmd0aDIgPSAwO1xuICAgICAgdmFyIEMgPSAwO1xuICAgICAgdmFyIGltcHVsc2UgPSAwO1xuICAgICAgdmFyIG9sZEltcHVsc2UgPSAwO1xuICAgICAgdmFyIG9sZExpbWl0UG9zaXRpb25JbXB1bHNlID0gMDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgbGluZWFyRXJyb3IgPSAwLjA7XG4gICAgICBpZiAodGhpcy5tX3N0YXRlID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICAgICByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICAgICByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcbiAgICAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcbiAgICAgICAgIHIxWCA9IHRYO1xuICAgICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgICAgIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgICAgIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgICAgcjJYID0gdFg7XG4gICAgICAgICBwMVggPSBiQS5tX3N3ZWVwLmMueCArIHIxWDtcbiAgICAgICAgIHAxWSA9IGJBLm1fc3dlZXAuYy55ICsgcjFZO1xuICAgICAgICAgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XG4gICAgICAgICBwMlkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWTtcbiAgICAgICAgIHRoaXMubV91MS5TZXQocDFYIC0gczFYLCBwMVkgLSBzMVkpO1xuICAgICAgICAgdGhpcy5tX3UyLlNldChwMlggLSBzMlgsIHAyWSAtIHMyWSk7XG4gICAgICAgICBsZW5ndGgxID0gdGhpcy5tX3UxLkxlbmd0aCgpO1xuICAgICAgICAgbGVuZ3RoMiA9IHRoaXMubV91Mi5MZW5ndGgoKTtcbiAgICAgICAgIGlmIChsZW5ndGgxID4gYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XG4gICAgICAgICAgICB0aGlzLm1fdTEuTXVsdGlwbHkoMS4wIC8gbGVuZ3RoMSk7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV91MS5TZXRaZXJvKCk7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAobGVuZ3RoMiA+IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xuICAgICAgICAgICAgdGhpcy5tX3UyLk11bHRpcGx5KDEuMCAvIGxlbmd0aDIpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1fdTIuU2V0WmVybygpO1xuICAgICAgICAgfVxuICAgICAgICAgQyA9IHRoaXMubV9jb25zdGFudCAtIGxlbmd0aDEgLSB0aGlzLm1fcmF0aW8gKiBsZW5ndGgyO1xuICAgICAgICAgbGluZWFyRXJyb3IgPSBiMk1hdGguTWF4KGxpbmVhckVycm9yLCAoLUMpKTtcbiAgICAgICAgIEMgPSBiMk1hdGguQ2xhbXAoQyArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgKC1iMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pLCAwLjApO1xuICAgICAgICAgaW1wdWxzZSA9ICgtdGhpcy5tX3B1bGxleU1hc3MgKiBDKTtcbiAgICAgICAgIHAxWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS54KTtcbiAgICAgICAgIHAxWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS55KTtcbiAgICAgICAgIHAyWCA9ICgtdGhpcy5tX3JhdGlvICogaW1wdWxzZSAqIHRoaXMubV91Mi54KTtcbiAgICAgICAgIHAyWSA9ICgtdGhpcy5tX3JhdGlvICogaW1wdWxzZSAqIHRoaXMubV91Mi55KTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy54ICs9IGJBLm1faW52TWFzcyAqIHAxWDtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy55ICs9IGJBLm1faW52TWFzcyAqIHAxWTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYSArPSBiQS5tX2ludkkgKiAocjFYICogcDFZIC0gcjFZICogcDFYKTtcbiAgICAgICAgIGJCLm1fc3dlZXAuYy54ICs9IGJCLm1faW52TWFzcyAqIHAyWDtcbiAgICAgICAgIGJCLm1fc3dlZXAuYy55ICs9IGJCLm1faW52TWFzcyAqIHAyWTtcbiAgICAgICAgIGJCLm1fc3dlZXAuYSArPSBiQi5tX2ludkkgKiAocjJYICogcDJZIC0gcjJZICogcDJYKTtcbiAgICAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlMSA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XG4gICAgICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgICAgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICAgICByMVggPSB0WDtcbiAgICAgICAgIHAxWCA9IGJBLm1fc3dlZXAuYy54ICsgcjFYO1xuICAgICAgICAgcDFZID0gYkEubV9zd2VlcC5jLnkgKyByMVk7XG4gICAgICAgICB0aGlzLm1fdTEuU2V0KHAxWCAtIHMxWCwgcDFZIC0gczFZKTtcbiAgICAgICAgIGxlbmd0aDEgPSB0aGlzLm1fdTEuTGVuZ3RoKCk7XG4gICAgICAgICBpZiAobGVuZ3RoMSA+IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xuICAgICAgICAgICAgdGhpcy5tX3UxLnggKj0gMS4wIC8gbGVuZ3RoMTtcbiAgICAgICAgICAgIHRoaXMubV91MS55ICo9IDEuMCAvIGxlbmd0aDE7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV91MS5TZXRaZXJvKCk7XG4gICAgICAgICB9XG4gICAgICAgICBDID0gdGhpcy5tX21heExlbmd0aDEgLSBsZW5ndGgxO1xuICAgICAgICAgbGluZWFyRXJyb3IgPSBiMk1hdGguTWF4KGxpbmVhckVycm9yLCAoLUMpKTtcbiAgICAgICAgIEMgPSBiMk1hdGguQ2xhbXAoQyArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgKC1iMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pLCAwLjApO1xuICAgICAgICAgaW1wdWxzZSA9ICgtdGhpcy5tX2xpbWl0TWFzczEgKiBDKTtcbiAgICAgICAgIHAxWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS54KTtcbiAgICAgICAgIHAxWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS55KTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy54ICs9IGJBLm1faW52TWFzcyAqIHAxWDtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy55ICs9IGJBLm1faW52TWFzcyAqIHAxWTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYSArPSBiQS5tX2ludkkgKiAocjFYICogcDFZIC0gcjFZICogcDFYKTtcbiAgICAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUyID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcbiAgICAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICAgICByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICAgICByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgICAgIHIyWCA9IHRYO1xuICAgICAgICAgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XG4gICAgICAgICBwMlkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWTtcbiAgICAgICAgIHRoaXMubV91Mi5TZXQocDJYIC0gczJYLCBwMlkgLSBzMlkpO1xuICAgICAgICAgbGVuZ3RoMiA9IHRoaXMubV91Mi5MZW5ndGgoKTtcbiAgICAgICAgIGlmIChsZW5ndGgyID4gYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XG4gICAgICAgICAgICB0aGlzLm1fdTIueCAqPSAxLjAgLyBsZW5ndGgyO1xuICAgICAgICAgICAgdGhpcy5tX3UyLnkgKj0gMS4wIC8gbGVuZ3RoMjtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tX3UyLlNldFplcm8oKTtcbiAgICAgICAgIH1cbiAgICAgICAgIEMgPSB0aGlzLm1fbWF4TGVuZ3RoMiAtIGxlbmd0aDI7XG4gICAgICAgICBsaW5lYXJFcnJvciA9IGIyTWF0aC5NYXgobGluZWFyRXJyb3IsICgtQykpO1xuICAgICAgICAgQyA9IGIyTWF0aC5DbGFtcChDICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIDAuMCk7XG4gICAgICAgICBpbXB1bHNlID0gKC10aGlzLm1fbGltaXRNYXNzMiAqIEMpO1xuICAgICAgICAgcDJYID0gKC1pbXB1bHNlICogdGhpcy5tX3UyLngpO1xuICAgICAgICAgcDJZID0gKC1pbXB1bHNlICogdGhpcy5tX3UyLnkpO1xuICAgICAgICAgYkIubV9zd2VlcC5jLnggKz0gYkIubV9pbnZNYXNzICogcDJYO1xuICAgICAgICAgYkIubV9zd2VlcC5jLnkgKz0gYkIubV9pbnZNYXNzICogcDJZO1xuICAgICAgICAgYkIubV9zd2VlcC5hICs9IGJCLm1faW52SSAqIChyMlggKiBwMlkgLSByMlkgKiBwMlgpO1xuICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnQuYjJfbWluUHVsbGV5TGVuZ3RoID0gMi4wO1xuICAgfSk7XG4gICBCb3gyRC5pbmhlcml0KGIyUHVsbGV5Sm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyUHVsbGV5Sm9pbnREZWYucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5wcm90b3R5cGU7XG4gICBiMlB1bGxleUpvaW50RGVmLmIyUHVsbGV5Sm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmdyb3VuZEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmdyb3VuZEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyUHVsbGV5Sm9pbnREZWYucHJvdG90eXBlLmIyUHVsbGV5Sm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX3B1bGxleUpvaW50O1xuICAgICAgdGhpcy5ncm91bmRBbmNob3JBLlNldCgoLTEuMCksIDEuMCk7XG4gICAgICB0aGlzLmdyb3VuZEFuY2hvckIuU2V0KDEuMCwgMS4wKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBLlNldCgoLTEuMCksIDAuMCk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQi5TZXQoMS4wLCAwLjApO1xuICAgICAgdGhpcy5sZW5ndGhBID0gMC4wO1xuICAgICAgdGhpcy5tYXhMZW5ndGhBID0gMC4wO1xuICAgICAgdGhpcy5sZW5ndGhCID0gMC4wO1xuICAgICAgdGhpcy5tYXhMZW5ndGhCID0gMC4wO1xuICAgICAgdGhpcy5yYXRpbyA9IDEuMDtcbiAgICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IHRydWU7XG4gICB9XG4gICBiMlB1bGxleUpvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgZ2FBLCBnYUIsIGFuY2hvckEsIGFuY2hvckIsIHIpIHtcbiAgICAgIGlmIChyID09PSB1bmRlZmluZWQpIHIgPSAwO1xuICAgICAgdGhpcy5ib2R5QSA9IGJBO1xuICAgICAgdGhpcy5ib2R5QiA9IGJCO1xuICAgICAgdGhpcy5ncm91bmRBbmNob3JBLlNldFYoZ2FBKTtcbiAgICAgIHRoaXMuZ3JvdW5kQW5jaG9yQi5TZXRWKGdhQik7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IHRoaXMuYm9keUEuR2V0TG9jYWxQb2ludChhbmNob3JBKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gdGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvckIpO1xuICAgICAgdmFyIGQxWCA9IGFuY2hvckEueCAtIGdhQS54O1xuICAgICAgdmFyIGQxWSA9IGFuY2hvckEueSAtIGdhQS55O1xuICAgICAgdGhpcy5sZW5ndGhBID0gTWF0aC5zcXJ0KGQxWCAqIGQxWCArIGQxWSAqIGQxWSk7XG4gICAgICB2YXIgZDJYID0gYW5jaG9yQi54IC0gZ2FCLng7XG4gICAgICB2YXIgZDJZID0gYW5jaG9yQi55IC0gZ2FCLnk7XG4gICAgICB0aGlzLmxlbmd0aEIgPSBNYXRoLnNxcnQoZDJYICogZDJYICsgZDJZICogZDJZKTtcbiAgICAgIHRoaXMucmF0aW8gPSByO1xuICAgICAgdmFyIEMgPSB0aGlzLmxlbmd0aEEgKyB0aGlzLnJhdGlvICogdGhpcy5sZW5ndGhCO1xuICAgICAgdGhpcy5tYXhMZW5ndGhBID0gQyAtIHRoaXMucmF0aW8gKiBiMlB1bGxleUpvaW50LmIyX21pblB1bGxleUxlbmd0aDtcbiAgICAgIHRoaXMubWF4TGVuZ3RoQiA9IChDIC0gYjJQdWxsZXlKb2ludC5iMl9taW5QdWxsZXlMZW5ndGgpIC8gdGhpcy5yYXRpbztcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJSZXZvbHV0ZUpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMlJldm9sdXRlSm9pbnQuYjJSZXZvbHV0ZUpvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5LID0gbmV3IGIyTWF0MjIoKTtcbiAgICAgIHRoaXMuSzEgPSBuZXcgYjJNYXQyMigpO1xuICAgICAgdGhpcy5LMiA9IG5ldyBiMk1hdDIyKCk7XG4gICAgICB0aGlzLkszID0gbmV3IGIyTWF0MjIoKTtcbiAgICAgIHRoaXMuaW1wdWxzZTMgPSBuZXcgYjJWZWMzKCk7XG4gICAgICB0aGlzLmltcHVsc2UyID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5yZWR1Y2VkID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1faW1wdWxzZSA9IG5ldyBiMlZlYzMoKTtcbiAgICAgIHRoaXMubV9tYXNzID0gbmV3IGIyTWF0MzMoKTtcbiAgIH07XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMik7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS54LCBpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS55KTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UuejtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0Sm9pbnRBbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIubV9zd2VlcC5hIC0gdGhpcy5tX2JvZHlBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0Sm9pbnRTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIubV9hbmd1bGFyVmVsb2NpdHkgLSB0aGlzLm1fYm9keUEubV9hbmd1bGFyVmVsb2NpdHk7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLklzTGltaXRFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVMaW1pdDtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuRW5hYmxlTGltaXQgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZmxhZztcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0TG93ZXJMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbG93ZXJBbmdsZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0VXBwZXJMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fdXBwZXJBbmdsZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuU2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQpIGxvd2VyID0gMDtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB1cHBlciA9IDA7XG4gICAgICB0aGlzLm1fbG93ZXJBbmdsZSA9IGxvd2VyO1xuICAgICAgdGhpcy5tX3VwcGVyQW5nbGUgPSB1cHBlcjtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuSXNNb3RvckVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5tX2VuYWJsZU1vdG9yO1xuICAgfVxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5FbmFibGVNb3RvciA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICB0aGlzLm1fZW5hYmxlTW90b3IgPSBmbGFnO1xuICAgfVxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5TZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKHNwZWVkKSB7XG4gICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkgc3BlZWQgPSAwO1xuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBzcGVlZDtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuR2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fbW90b3JTcGVlZDtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuU2V0TWF4TW90b3JUb3JxdWUgPSBmdW5jdGlvbiAodG9ycXVlKSB7XG4gICAgICBpZiAodG9ycXVlID09PSB1bmRlZmluZWQpIHRvcnF1ZSA9IDA7XG4gICAgICB0aGlzLm1fbWF4TW90b3JUb3JxdWUgPSB0b3JxdWU7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldE1vdG9yVG9ycXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuYjJSZXZvbHV0ZUpvaW50ID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMS5TZXRWKGRlZi5sb2NhbEFuY2hvckEpO1xuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMi5TZXRWKGRlZi5sb2NhbEFuY2hvckIpO1xuICAgICAgdGhpcy5tX3JlZmVyZW5jZUFuZ2xlID0gZGVmLnJlZmVyZW5jZUFuZ2xlO1xuICAgICAgdGhpcy5tX2ltcHVsc2UuU2V0WmVybygpO1xuICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcbiAgICAgIHRoaXMubV9sb3dlckFuZ2xlID0gZGVmLmxvd2VyQW5nbGU7XG4gICAgICB0aGlzLm1fdXBwZXJBbmdsZSA9IGRlZi51cHBlckFuZ2xlO1xuICAgICAgdGhpcy5tX21heE1vdG9yVG9ycXVlID0gZGVmLm1heE1vdG9yVG9ycXVlO1xuICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBkZWYubW90b3JTcGVlZDtcbiAgICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGRlZi5lbmFibGVMaW1pdDtcbiAgICAgIHRoaXMubV9lbmFibGVNb3RvciA9IGRlZi5lbmFibGVNb3RvcjtcbiAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgfHwgdGhpcy5tX2VuYWJsZUxpbWl0KSB7fVxuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICByMVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgcjJYID0gdFg7XG4gICAgICB2YXIgbTEgPSBiQS5tX2ludk1hc3M7XG4gICAgICB2YXIgbTIgPSBiQi5tX2ludk1hc3M7XG4gICAgICB2YXIgaTEgPSBiQS5tX2ludkk7XG4gICAgICB2YXIgaTIgPSBiQi5tX2ludkk7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnggPSBtMSArIG0yICsgcjFZICogcjFZICogaTEgKyByMlkgKiByMlkgKiBpMjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDIueCA9ICgtcjFZICogcjFYICogaTEpIC0gcjJZICogcjJYICogaTI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wzLnggPSAoLXIxWSAqIGkxKSAtIHIyWSAqIGkyO1xuICAgICAgdGhpcy5tX21hc3MuY29sMS55ID0gdGhpcy5tX21hc3MuY29sMi54O1xuICAgICAgdGhpcy5tX21hc3MuY29sMi55ID0gbTEgKyBtMiArIHIxWCAqIHIxWCAqIGkxICsgcjJYICogcjJYICogaTI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wzLnkgPSByMVggKiBpMSArIHIyWCAqIGkyO1xuICAgICAgdGhpcy5tX21hc3MuY29sMS56ID0gdGhpcy5tX21hc3MuY29sMy54O1xuICAgICAgdGhpcy5tX21hc3MuY29sMi56ID0gdGhpcy5tX21hc3MuY29sMy55O1xuICAgICAgdGhpcy5tX21hc3MuY29sMy56ID0gaTEgKyBpMjtcbiAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAxLjAgLyAoaTEgKyBpMik7XG4gICAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yID09IGZhbHNlKSB7XG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCkge1xuICAgICAgICAgdmFyIGpvaW50QW5nbGUgPSBiQi5tX3N3ZWVwLmEgLSBiQS5tX3N3ZWVwLmEgLSB0aGlzLm1fcmVmZXJlbmNlQW5nbGU7XG4gICAgICAgICBpZiAoYjJNYXRoLkFicyh0aGlzLm1fdXBwZXJBbmdsZSAtIHRoaXMubV9sb3dlckFuZ2xlKSA8IDIuMCAqIGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3ApIHtcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2VxdWFsTGltaXRzO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAoam9pbnRBbmdsZSA8PSB0aGlzLm1fbG93ZXJBbmdsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9hdExvd2VyTGltaXQ7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmIChqb2ludEFuZ2xlID49IHRoaXMubV91cHBlckFuZ2xlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdDtcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHZhciBQWCA9IHRoaXMubV9pbXB1bHNlLng7XG4gICAgICAgICB2YXIgUFkgPSB0aGlzLm1faW1wdWxzZS55O1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54IC09IG0xICogUFg7XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gbTEgKiBQWTtcbiAgICAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5IC09IGkxICogKChyMVggKiBQWSAtIHIxWSAqIFBYKSArIHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KTtcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBtMiAqIFBYO1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IG0yICogUFk7XG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBpMiAqICgocjJYICogUFkgLSByMlkgKiBQWCkgKyB0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XG4gICAgICB9XG4gICB9XG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLlNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgbmV3SW1wdWxzZSA9IDA7XG4gICAgICB2YXIgcjFYID0gMDtcbiAgICAgIHZhciByMVkgPSAwO1xuICAgICAgdmFyIHIyWCA9IDA7XG4gICAgICB2YXIgcjJZID0gMDtcbiAgICAgIHZhciB2MSA9IGJBLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzEgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciB2MiA9IGJCLm1fbGluZWFyVmVsb2NpdHk7XG4gICAgICB2YXIgdzIgPSBiQi5tX2FuZ3VsYXJWZWxvY2l0eTtcbiAgICAgIHZhciBtMSA9IGJBLm1faW52TWFzcztcbiAgICAgIHZhciBtMiA9IGJCLm1faW52TWFzcztcbiAgICAgIHZhciBpMSA9IGJBLm1faW52STtcbiAgICAgIHZhciBpMiA9IGJCLm1faW52STtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2VxdWFsTGltaXRzKSB7XG4gICAgICAgICB2YXIgQ2RvdCA9IHcyIC0gdzEgLSB0aGlzLm1fbW90b3JTcGVlZDtcbiAgICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5tX21vdG9yTWFzcyAqICgoLUNkb3QpKTtcbiAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZTtcbiAgICAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSBiMk1hdGguQ2xhbXAodGhpcy5tX21vdG9ySW1wdWxzZSArIGltcHVsc2UsICgtbWF4SW1wdWxzZSksIG1heEltcHVsc2UpO1xuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xuICAgICAgICAgdzEgLT0gaTEgKiBpbXB1bHNlO1xuICAgICAgICAgdzIgKz0gaTIgKiBpbXB1bHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdCkge1xuICAgICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgICAgIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgICAgIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xuICAgICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xuICAgICAgICAgcjFYID0gdFg7XG4gICAgICAgICB0TWF0ID0gYkIubV94Zi5SO1xuICAgICAgICAgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XG4gICAgICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XG4gICAgICAgICByMlggPSB0WDtcbiAgICAgICAgIHZhciBDZG90MVggPSB2Mi54ICsgKCgtdzIgKiByMlkpKSAtIHYxLnggLSAoKC13MSAqIHIxWSkpO1xuICAgICAgICAgdmFyIENkb3QxWSA9IHYyLnkgKyAodzIgKiByMlgpIC0gdjEueSAtICh3MSAqIHIxWCk7XG4gICAgICAgICB2YXIgQ2RvdDIgPSB3MiAtIHcxO1xuICAgICAgICAgdGhpcy5tX21hc3MuU29sdmUzMyh0aGlzLmltcHVsc2UzLCAoLUNkb3QxWCksICgtQ2RvdDFZKSwgKC1DZG90MikpO1xuICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9lcXVhbExpbWl0cykge1xuICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuQWRkKHRoaXMuaW1wdWxzZTMpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlLnogKyB0aGlzLmltcHVsc2UzLno7XG4gICAgICAgICAgICBpZiAobmV3SW1wdWxzZSA8IDAuMCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX21hc3MuU29sdmUyMih0aGlzLnJlZHVjZWQsICgtQ2RvdDFYKSwgKC1DZG90MVkpKTtcbiAgICAgICAgICAgICAgIHRoaXMuaW1wdWxzZTMueCA9IHRoaXMucmVkdWNlZC54O1xuICAgICAgICAgICAgICAgdGhpcy5pbXB1bHNlMy55ID0gdGhpcy5yZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICB0aGlzLmltcHVsc2UzLnogPSAoLXRoaXMubV9pbXB1bHNlLnopO1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSB0aGlzLnJlZHVjZWQueDtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gdGhpcy5yZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlLnogKyB0aGlzLmltcHVsc2UzLno7XG4gICAgICAgICAgICBpZiAobmV3SW1wdWxzZSA+IDAuMCkge1xuICAgICAgICAgICAgICAgdGhpcy5tX21hc3MuU29sdmUyMih0aGlzLnJlZHVjZWQsICgtQ2RvdDFYKSwgKC1DZG90MVkpKTtcbiAgICAgICAgICAgICAgIHRoaXMuaW1wdWxzZTMueCA9IHRoaXMucmVkdWNlZC54O1xuICAgICAgICAgICAgICAgdGhpcy5pbXB1bHNlMy55ID0gdGhpcy5yZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICB0aGlzLmltcHVsc2UzLnogPSAoLXRoaXMubV9pbXB1bHNlLnopO1xuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSB0aGlzLnJlZHVjZWQueDtcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gdGhpcy5yZWR1Y2VkLnk7XG4gICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgdjEueCAtPSBtMSAqIHRoaXMuaW1wdWxzZTMueDtcbiAgICAgICAgIHYxLnkgLT0gbTEgKiB0aGlzLmltcHVsc2UzLnk7XG4gICAgICAgICB3MSAtPSBpMSAqIChyMVggKiB0aGlzLmltcHVsc2UzLnkgLSByMVkgKiB0aGlzLmltcHVsc2UzLnggKyB0aGlzLmltcHVsc2UzLnopO1xuICAgICAgICAgdjIueCArPSBtMiAqIHRoaXMuaW1wdWxzZTMueDtcbiAgICAgICAgIHYyLnkgKz0gbTIgKiB0aGlzLmltcHVsc2UzLnk7XG4gICAgICAgICB3MiArPSBpMiAqIChyMlggKiB0aGlzLmltcHVsc2UzLnkgLSByMlkgKiB0aGlzLmltcHVsc2UzLnggKyB0aGlzLmltcHVsc2UzLnopO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgICAgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICAgICByMVggPSB0WDtcbiAgICAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICAgICByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICAgICByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcbiAgICAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcbiAgICAgICAgIHIyWCA9IHRYO1xuICAgICAgICAgdmFyIENkb3RYID0gdjIueCArICgoLXcyICogcjJZKSkgLSB2MS54IC0gKCgtdzEgKiByMVkpKTtcbiAgICAgICAgIHZhciBDZG90WSA9IHYyLnkgKyAodzIgKiByMlgpIC0gdjEueSAtICh3MSAqIHIxWCk7XG4gICAgICAgICB0aGlzLm1fbWFzcy5Tb2x2ZTIyKHRoaXMuaW1wdWxzZTIsICgtQ2RvdFgpLCAoLUNkb3RZKSk7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICs9IHRoaXMuaW1wdWxzZTIueDtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gdGhpcy5pbXB1bHNlMi55O1xuICAgICAgICAgdjEueCAtPSBtMSAqIHRoaXMuaW1wdWxzZTIueDtcbiAgICAgICAgIHYxLnkgLT0gbTEgKiB0aGlzLmltcHVsc2UyLnk7XG4gICAgICAgICB3MSAtPSBpMSAqIChyMVggKiB0aGlzLmltcHVsc2UyLnkgLSByMVkgKiB0aGlzLmltcHVsc2UyLngpO1xuICAgICAgICAgdjIueCArPSBtMiAqIHRoaXMuaW1wdWxzZTIueDtcbiAgICAgICAgIHYyLnkgKz0gbTIgKiB0aGlzLmltcHVsc2UyLnk7XG4gICAgICAgICB3MiArPSBpMiAqIChyMlggKiB0aGlzLmltcHVsc2UyLnkgLSByMlkgKiB0aGlzLmltcHVsc2UyLngpO1xuICAgICAgfVxuICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS5TZXRWKHYxKTtcbiAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5ID0gdzE7XG4gICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LlNldFYodjIpO1xuICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgPSB3MjtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xuICAgICAgdmFyIG9sZExpbWl0SW1wdWxzZSA9IDA7XG4gICAgICB2YXIgQyA9IDA7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHZhciBhbmd1bGFyRXJyb3IgPSAwLjA7XG4gICAgICB2YXIgcG9zaXRpb25FcnJvciA9IDAuMDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgaW1wdWxzZVggPSAwO1xuICAgICAgdmFyIGltcHVsc2VZID0gMDtcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQpIHtcbiAgICAgICAgIHZhciBhbmdsZSA9IGJCLm1fc3dlZXAuYSAtIGJBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgICAgIHZhciBsaW1pdEltcHVsc2UgPSAwLjA7XG4gICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2VxdWFsTGltaXRzKSB7XG4gICAgICAgICAgICBDID0gYjJNYXRoLkNsYW1wKGFuZ2xlIC0gdGhpcy5tX2xvd2VyQW5nbGUsICgtYjJTZXR0aW5ncy5iMl9tYXhBbmd1bGFyQ29ycmVjdGlvbiksIGIyU2V0dGluZ3MuYjJfbWF4QW5ndWxhckNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gKC10aGlzLm1fbW90b3JNYXNzICogQyk7XG4gICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBiMk1hdGguQWJzKEMpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xuICAgICAgICAgICAgQyA9IGFuZ2xlIC0gdGhpcy5tX2xvd2VyQW5nbGU7XG4gICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSAoLUMpO1xuICAgICAgICAgICAgQyA9IGIyTWF0aC5DbGFtcChDICsgYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcCwgKC1iMlNldHRpbmdzLmIyX21heEFuZ3VsYXJDb3JyZWN0aW9uKSwgMC4wKTtcbiAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9ICgtdGhpcy5tX21vdG9yTWFzcyAqIEMpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdCkge1xuICAgICAgICAgICAgQyA9IGFuZ2xlIC0gdGhpcy5tX3VwcGVyQW5nbGU7XG4gICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBDO1xuICAgICAgICAgICAgQyA9IGIyTWF0aC5DbGFtcChDIC0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcCwgMC4wLCBiMlNldHRpbmdzLmIyX21heEFuZ3VsYXJDb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9ICgtdGhpcy5tX21vdG9yTWFzcyAqIEMpO1xuICAgICAgICAgfVxuICAgICAgICAgYkEubV9zd2VlcC5hIC09IGJBLm1faW52SSAqIGxpbWl0SW1wdWxzZTtcbiAgICAgICAgIGJCLm1fc3dlZXAuYSArPSBiQi5tX2ludkkgKiBsaW1pdEltcHVsc2U7XG4gICAgICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH0ge1xuICAgICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XG4gICAgICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XG4gICAgICAgICByMVggPSB0WDtcbiAgICAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xuICAgICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xuICAgICAgICAgcjJYID0gdFg7XG4gICAgICAgICB2YXIgQ1ggPSBiQi5tX3N3ZWVwLmMueCArIHIyWCAtIGJBLm1fc3dlZXAuYy54IC0gcjFYO1xuICAgICAgICAgdmFyIENZID0gYkIubV9zd2VlcC5jLnkgKyByMlkgLSBiQS5tX3N3ZWVwLmMueSAtIHIxWTtcbiAgICAgICAgIHZhciBDTGVuZ3RoU3F1YXJlZCA9IENYICogQ1ggKyBDWSAqIENZO1xuICAgICAgICAgdmFyIENMZW5ndGggPSBNYXRoLnNxcnQoQ0xlbmd0aFNxdWFyZWQpO1xuICAgICAgICAgcG9zaXRpb25FcnJvciA9IENMZW5ndGg7XG4gICAgICAgICB2YXIgaW52TWFzczEgPSBiQS5tX2ludk1hc3M7XG4gICAgICAgICB2YXIgaW52TWFzczIgPSBiQi5tX2ludk1hc3M7XG4gICAgICAgICB2YXIgaW52STEgPSBiQS5tX2ludkk7XG4gICAgICAgICB2YXIgaW52STIgPSBiQi5tX2ludkk7XG4gICAgICAgICB2YXIga19hbGxvd2VkU3RyZXRjaCA9IDEwLjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XG4gICAgICAgICBpZiAoQ0xlbmd0aFNxdWFyZWQgPiBrX2FsbG93ZWRTdHJldGNoICoga19hbGxvd2VkU3RyZXRjaCkge1xuICAgICAgICAgICAgdmFyIHVYID0gQ1ggLyBDTGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHVZID0gQ1kgLyBDTGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGsgPSBpbnZNYXNzMSArIGludk1hc3MyO1xuICAgICAgICAgICAgdmFyIG0gPSAxLjAgLyBrO1xuICAgICAgICAgICAgaW1wdWxzZVggPSBtICogKCgtQ1gpKTtcbiAgICAgICAgICAgIGltcHVsc2VZID0gbSAqICgoLUNZKSk7XG4gICAgICAgICAgICB2YXIga19iZXRhID0gMC41O1xuICAgICAgICAgICAgYkEubV9zd2VlcC5jLnggLT0ga19iZXRhICogaW52TWFzczEgKiBpbXB1bHNlWDtcbiAgICAgICAgICAgIGJBLm1fc3dlZXAuYy55IC09IGtfYmV0YSAqIGludk1hc3MxICogaW1wdWxzZVk7XG4gICAgICAgICAgICBiQi5tX3N3ZWVwLmMueCArPSBrX2JldGEgKiBpbnZNYXNzMiAqIGltcHVsc2VYO1xuICAgICAgICAgICAgYkIubV9zd2VlcC5jLnkgKz0ga19iZXRhICogaW52TWFzczIgKiBpbXB1bHNlWTtcbiAgICAgICAgICAgIENYID0gYkIubV9zd2VlcC5jLnggKyByMlggLSBiQS5tX3N3ZWVwLmMueCAtIHIxWDtcbiAgICAgICAgICAgIENZID0gYkIubV9zd2VlcC5jLnkgKyByMlkgLSBiQS5tX3N3ZWVwLmMueSAtIHIxWTtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMuSzEuY29sMS54ID0gaW52TWFzczEgKyBpbnZNYXNzMjtcbiAgICAgICAgIHRoaXMuSzEuY29sMi54ID0gMC4wO1xuICAgICAgICAgdGhpcy5LMS5jb2wxLnkgPSAwLjA7XG4gICAgICAgICB0aGlzLksxLmNvbDIueSA9IGludk1hc3MxICsgaW52TWFzczI7XG4gICAgICAgICB0aGlzLksyLmNvbDEueCA9IGludkkxICogcjFZICogcjFZO1xuICAgICAgICAgdGhpcy5LMi5jb2wyLnggPSAoLWludkkxICogcjFYICogcjFZKTtcbiAgICAgICAgIHRoaXMuSzIuY29sMS55ID0gKC1pbnZJMSAqIHIxWCAqIHIxWSk7XG4gICAgICAgICB0aGlzLksyLmNvbDIueSA9IGludkkxICogcjFYICogcjFYO1xuICAgICAgICAgdGhpcy5LMy5jb2wxLnggPSBpbnZJMiAqIHIyWSAqIHIyWTtcbiAgICAgICAgIHRoaXMuSzMuY29sMi54ID0gKC1pbnZJMiAqIHIyWCAqIHIyWSk7XG4gICAgICAgICB0aGlzLkszLmNvbDEueSA9ICgtaW52STIgKiByMlggKiByMlkpO1xuICAgICAgICAgdGhpcy5LMy5jb2wyLnkgPSBpbnZJMiAqIHIyWCAqIHIyWDtcbiAgICAgICAgIHRoaXMuSy5TZXRNKHRoaXMuSzEpO1xuICAgICAgICAgdGhpcy5LLkFkZE0odGhpcy5LMik7XG4gICAgICAgICB0aGlzLksuQWRkTSh0aGlzLkszKTtcbiAgICAgICAgIHRoaXMuSy5Tb2x2ZShiMlJldm9sdXRlSm9pbnQudEltcHVsc2UsICgtQ1gpLCAoLUNZKSk7XG4gICAgICAgICBpbXB1bHNlWCA9IGIyUmV2b2x1dGVKb2ludC50SW1wdWxzZS54O1xuICAgICAgICAgaW1wdWxzZVkgPSBiMlJldm9sdXRlSm9pbnQudEltcHVsc2UueTtcbiAgICAgICAgIGJBLm1fc3dlZXAuYy54IC09IGJBLm1faW52TWFzcyAqIGltcHVsc2VYO1xuICAgICAgICAgYkEubV9zd2VlcC5jLnkgLT0gYkEubV9pbnZNYXNzICogaW1wdWxzZVk7XG4gICAgICAgICBiQS5tX3N3ZWVwLmEgLT0gYkEubV9pbnZJICogKHIxWCAqIGltcHVsc2VZIC0gcjFZICogaW1wdWxzZVgpO1xuICAgICAgICAgYkIubV9zd2VlcC5jLnggKz0gYkIubV9pbnZNYXNzICogaW1wdWxzZVg7XG4gICAgICAgICBiQi5tX3N3ZWVwLmMueSArPSBiQi5tX2ludk1hc3MgKiBpbXB1bHNlWTtcbiAgICAgICAgIGJCLm1fc3dlZXAuYSArPSBiQi5tX2ludkkgKiAocjJYICogaW1wdWxzZVkgLSByMlkgKiBpbXB1bHNlWCk7XG4gICAgICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcDtcbiAgIH1cbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludC50SW1wdWxzZSA9IG5ldyBiMlZlYzIoKTtcbiAgIH0pO1xuICAgQm94MkQuaW5oZXJpdChiMlJldm9sdXRlSm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyUmV2b2x1dGVKb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcbiAgIGIyUmV2b2x1dGVKb2ludERlZi5iMlJldm9sdXRlSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyUmV2b2x1dGVKb2ludERlZi5wcm90b3R5cGUuYjJSZXZvbHV0ZUpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnREZWYuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudHlwZSA9IGIySm9pbnQuZV9yZXZvbHV0ZUpvaW50O1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckEuU2V0KDAuMCwgMC4wKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldCgwLjAsIDAuMCk7XG4gICAgICB0aGlzLnJlZmVyZW5jZUFuZ2xlID0gMC4wO1xuICAgICAgdGhpcy5sb3dlckFuZ2xlID0gMC4wO1xuICAgICAgdGhpcy51cHBlckFuZ2xlID0gMC4wO1xuICAgICAgdGhpcy5tYXhNb3RvclRvcnF1ZSA9IDAuMDtcbiAgICAgIHRoaXMubW90b3JTcGVlZCA9IDAuMDtcbiAgICAgIHRoaXMuZW5hYmxlTGltaXQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW5hYmxlTW90b3IgPSBmYWxzZTtcbiAgIH1cbiAgIGIyUmV2b2x1dGVKb2ludERlZi5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChiQSwgYkIsIGFuY2hvcikge1xuICAgICAgdGhpcy5ib2R5QSA9IGJBO1xuICAgICAgdGhpcy5ib2R5QiA9IGJCO1xuICAgICAgdGhpcy5sb2NhbEFuY2hvckEgPSB0aGlzLmJvZHlBLkdldExvY2FsUG9pbnQoYW5jaG9yKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gdGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvcik7XG4gICAgICB0aGlzLnJlZmVyZW5jZUFuZ2xlID0gdGhpcy5ib2R5Qi5HZXRBbmdsZSgpIC0gdGhpcy5ib2R5QS5HZXRBbmdsZSgpO1xuICAgfVxuICAgQm94MkQuaW5oZXJpdChiMldlbGRKb2ludCwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQpO1xuICAgYjJXZWxkSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XG4gICBiMldlbGRKb2ludC5iMldlbGRKb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgICAgdGhpcy5tX2ltcHVsc2UgPSBuZXcgYjJWZWMzKCk7XG4gICAgICB0aGlzLm1fbWFzcyA9IG5ldyBiMk1hdDMzKCk7XG4gICB9O1xuICAgYjJXZWxkSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQSk7XG4gICB9XG4gICBiMldlbGRKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcbiAgIH1cbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvbkZvcmNlID0gZnVuY3Rpb24gKGludl9kdCkge1xuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueSk7XG4gICB9XG4gICBiMldlbGRKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UuejtcbiAgIH1cbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5iMldlbGRKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50LmNhbGwodGhpcywgZGVmKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckEuU2V0VihkZWYubG9jYWxBbmNob3JBKTtcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuU2V0VihkZWYubG9jYWxBbmNob3JCKTtcbiAgICAgIHRoaXMubV9yZWZlcmVuY2VBbmdsZSA9IGRlZi5yZWZlcmVuY2VBbmdsZTtcbiAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgIHRoaXMubV9tYXNzID0gbmV3IGIyTWF0MzMoKTtcbiAgIH1cbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICB2YXIgdE1hdDtcbiAgICAgIHZhciB0WCA9IDA7XG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xuICAgICAgdmFyIHJBWCA9IHRoaXMubV9sb2NhbEFuY2hvckEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByQVkgPSB0aGlzLm1fbG9jYWxBbmNob3JBLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHJBWCArIHRNYXQuY29sMi54ICogckFZKTtcbiAgICAgIHJBWSA9ICh0TWF0LmNvbDEueSAqIHJBWCArIHRNYXQuY29sMi55ICogckFZKTtcbiAgICAgIHJBWCA9IHRYO1xuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcbiAgICAgIHZhciByQlggPSB0aGlzLm1fbG9jYWxBbmNob3JCLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgckJZID0gdGhpcy5tX2xvY2FsQW5jaG9yQi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQlggKyB0TWF0LmNvbDIueCAqIHJCWSk7XG4gICAgICByQlkgPSAodE1hdC5jb2wxLnkgKiByQlggKyB0TWF0LmNvbDIueSAqIHJCWSk7XG4gICAgICByQlggPSB0WDtcbiAgICAgIHZhciBtQSA9IGJBLm1faW52TWFzcztcbiAgICAgIHZhciBtQiA9IGJCLm1faW52TWFzcztcbiAgICAgIHZhciBpQSA9IGJBLm1faW52STtcbiAgICAgIHZhciBpQiA9IGJCLm1faW52STtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDEueCA9IG1BICsgbUIgKyByQVkgKiByQVkgKiBpQSArIHJCWSAqIHJCWSAqIGlCO1xuICAgICAgdGhpcy5tX21hc3MuY29sMi54ID0gKC1yQVkgKiByQVggKiBpQSkgLSByQlkgKiByQlggKiBpQjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueCA9ICgtckFZICogaUEpIC0gckJZICogaUI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnkgPSB0aGlzLm1fbWFzcy5jb2wyLng7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnkgPSBtQSArIG1CICsgckFYICogckFYICogaUEgKyByQlggKiByQlggKiBpQjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueSA9IHJBWCAqIGlBICsgckJYICogaUI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnogPSB0aGlzLm1fbWFzcy5jb2wzLng7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnogPSB0aGlzLm1fbWFzcy5jb2wzLnk7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wzLnogPSBpQSArIGlCO1xuICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICo9IHN0ZXAuZHRSYXRpbztcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKj0gc3RlcC5kdFJhdGlvO1xuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiAqPSBzdGVwLmR0UmF0aW87XG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggLT0gbUEgKiB0aGlzLm1faW1wdWxzZS54O1xuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55IC09IG1BICogdGhpcy5tX2ltcHVsc2UueTtcbiAgICAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5IC09IGlBICogKHJBWCAqIHRoaXMubV9pbXB1bHNlLnkgLSByQVkgKiB0aGlzLm1faW1wdWxzZS54ICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gbUIgKiB0aGlzLm1faW1wdWxzZS54O1xuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IG1CICogdGhpcy5tX2ltcHVsc2UueTtcbiAgICAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGlCICogKHJCWCAqIHRoaXMubV9pbXB1bHNlLnkgLSByQlkgKiB0aGlzLm1faW1wdWxzZS54ICsgdGhpcy5tX2ltcHVsc2Uueik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcbiAgICAgIH1cbiAgIH1cbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgdmFyIHRNYXQ7XG4gICAgICB2YXIgdFggPSAwO1xuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xuICAgICAgdmFyIHZBID0gYkEubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3QSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIHZCID0gYkIubV9saW5lYXJWZWxvY2l0eTtcbiAgICAgIHZhciB3QiA9IGJCLm1fYW5ndWxhclZlbG9jaXR5O1xuICAgICAgdmFyIG1BID0gYkEubV9pbnZNYXNzO1xuICAgICAgdmFyIG1CID0gYkIubV9pbnZNYXNzO1xuICAgICAgdmFyIGlBID0gYkEubV9pbnZJO1xuICAgICAgdmFyIGlCID0gYkIubV9pbnZJO1xuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcbiAgICAgIHZhciByQVggPSB0aGlzLm1fbG9jYWxBbmNob3JBLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XG4gICAgICB2YXIgckFZID0gdGhpcy5tX2xvY2FsQW5jaG9yQS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQVggKyB0TWF0LmNvbDIueCAqIHJBWSk7XG4gICAgICByQVkgPSAodE1hdC5jb2wxLnkgKiByQVggKyB0TWF0LmNvbDIueSAqIHJBWSk7XG4gICAgICByQVggPSB0WDtcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XG4gICAgICB2YXIgckJYID0gdGhpcy5tX2xvY2FsQW5jaG9yQi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHJCWSA9IHRoaXMubV9sb2NhbEFuY2hvckIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckJYICsgdE1hdC5jb2wyLnggKiByQlkpO1xuICAgICAgckJZID0gKHRNYXQuY29sMS55ICogckJYICsgdE1hdC5jb2wyLnkgKiByQlkpO1xuICAgICAgckJYID0gdFg7XG4gICAgICB2YXIgQ2RvdDFYID0gdkIueCAtIHdCICogckJZIC0gdkEueCArIHdBICogckFZO1xuICAgICAgdmFyIENkb3QxWSA9IHZCLnkgKyB3QiAqIHJCWCAtIHZBLnkgLSB3QSAqIHJBWDtcbiAgICAgIHZhciBDZG90MiA9IHdCIC0gd0E7XG4gICAgICB2YXIgaW1wdWxzZSA9IG5ldyBiMlZlYzMoKTtcbiAgICAgIHRoaXMubV9tYXNzLlNvbHZlMzMoaW1wdWxzZSwgKC1DZG90MVgpLCAoLUNkb3QxWSksICgtQ2RvdDIpKTtcbiAgICAgIHRoaXMubV9pbXB1bHNlLkFkZChpbXB1bHNlKTtcbiAgICAgIHZBLnggLT0gbUEgKiBpbXB1bHNlLng7XG4gICAgICB2QS55IC09IG1BICogaW1wdWxzZS55O1xuICAgICAgd0EgLT0gaUEgKiAockFYICogaW1wdWxzZS55IC0gckFZICogaW1wdWxzZS54ICsgaW1wdWxzZS56KTtcbiAgICAgIHZCLnggKz0gbUIgKiBpbXB1bHNlLng7XG4gICAgICB2Qi55ICs9IG1CICogaW1wdWxzZS55O1xuICAgICAgd0IgKz0gaUIgKiAockJYICogaW1wdWxzZS55IC0gckJZICogaW1wdWxzZS54ICsgaW1wdWxzZS56KTtcbiAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5ID0gd0E7XG4gICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSA9IHdCO1xuICAgfVxuICAgYjJXZWxkSm9pbnQucHJvdG90eXBlLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChiYXVtZ2FydGUpIHtcbiAgICAgIGlmIChiYXVtZ2FydGUgPT09IHVuZGVmaW5lZCkgYmF1bWdhcnRlID0gMDtcbiAgICAgIHZhciB0TWF0O1xuICAgICAgdmFyIHRYID0gMDtcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XG4gICAgICB2YXIgckFYID0gdGhpcy5tX2xvY2FsQW5jaG9yQS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xuICAgICAgdmFyIHJBWSA9IHRoaXMubV9sb2NhbEFuY2hvckEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckFYICsgdE1hdC5jb2wyLnggKiByQVkpO1xuICAgICAgckFZID0gKHRNYXQuY29sMS55ICogckFYICsgdE1hdC5jb2wyLnkgKiByQVkpO1xuICAgICAgckFYID0gdFg7XG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xuICAgICAgdmFyIHJCWCA9IHRoaXMubV9sb2NhbEFuY2hvckIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcbiAgICAgIHZhciByQlkgPSB0aGlzLm1fbG9jYWxBbmNob3JCLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHJCWCArIHRNYXQuY29sMi54ICogckJZKTtcbiAgICAgIHJCWSA9ICh0TWF0LmNvbDEueSAqIHJCWCArIHRNYXQuY29sMi55ICogckJZKTtcbiAgICAgIHJCWCA9IHRYO1xuICAgICAgdmFyIG1BID0gYkEubV9pbnZNYXNzO1xuICAgICAgdmFyIG1CID0gYkIubV9pbnZNYXNzO1xuICAgICAgdmFyIGlBID0gYkEubV9pbnZJO1xuICAgICAgdmFyIGlCID0gYkIubV9pbnZJO1xuICAgICAgdmFyIEMxWCA9IGJCLm1fc3dlZXAuYy54ICsgckJYIC0gYkEubV9zd2VlcC5jLnggLSByQVg7XG4gICAgICB2YXIgQzFZID0gYkIubV9zd2VlcC5jLnkgKyByQlkgLSBiQS5tX3N3ZWVwLmMueSAtIHJBWTtcbiAgICAgIHZhciBDMiA9IGJCLm1fc3dlZXAuYSAtIGJBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcbiAgICAgIHZhciBrX2FsbG93ZWRTdHJldGNoID0gMTAuMCAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcbiAgICAgIHZhciBwb3NpdGlvbkVycm9yID0gTWF0aC5zcXJ0KEMxWCAqIEMxWCArIEMxWSAqIEMxWSk7XG4gICAgICB2YXIgYW5ndWxhckVycm9yID0gYjJNYXRoLkFicyhDMik7XG4gICAgICBpZiAocG9zaXRpb25FcnJvciA+IGtfYWxsb3dlZFN0cmV0Y2gpIHtcbiAgICAgICAgIGlBICo9IDEuMDtcbiAgICAgICAgIGlCICo9IDEuMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubV9tYXNzLmNvbDEueCA9IG1BICsgbUIgKyByQVkgKiByQVkgKiBpQSArIHJCWSAqIHJCWSAqIGlCO1xuICAgICAgdGhpcy5tX21hc3MuY29sMi54ID0gKC1yQVkgKiByQVggKiBpQSkgLSByQlkgKiByQlggKiBpQjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueCA9ICgtckFZICogaUEpIC0gckJZICogaUI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnkgPSB0aGlzLm1fbWFzcy5jb2wyLng7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnkgPSBtQSArIG1CICsgckFYICogckFYICogaUEgKyByQlggKiByQlggKiBpQjtcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueSA9IHJBWCAqIGlBICsgckJYICogaUI7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnogPSB0aGlzLm1fbWFzcy5jb2wzLng7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnogPSB0aGlzLm1fbWFzcy5jb2wzLnk7XG4gICAgICB0aGlzLm1fbWFzcy5jb2wzLnogPSBpQSArIGlCO1xuICAgICAgdmFyIGltcHVsc2UgPSBuZXcgYjJWZWMzKCk7XG4gICAgICB0aGlzLm1fbWFzcy5Tb2x2ZTMzKGltcHVsc2UsICgtQzFYKSwgKC1DMVkpLCAoLUMyKSk7XG4gICAgICBiQS5tX3N3ZWVwLmMueCAtPSBtQSAqIGltcHVsc2UueDtcbiAgICAgIGJBLm1fc3dlZXAuYy55IC09IG1BICogaW1wdWxzZS55O1xuICAgICAgYkEubV9zd2VlcC5hIC09IGlBICogKHJBWCAqIGltcHVsc2UueSAtIHJBWSAqIGltcHVsc2UueCArIGltcHVsc2Uueik7XG4gICAgICBiQi5tX3N3ZWVwLmMueCArPSBtQiAqIGltcHVsc2UueDtcbiAgICAgIGJCLm1fc3dlZXAuYy55ICs9IG1CICogaW1wdWxzZS55O1xuICAgICAgYkIubV9zd2VlcC5hICs9IGlCICogKHJCWCAqIGltcHVsc2UueSAtIHJCWSAqIGltcHVsc2UueCArIGltcHVsc2Uueik7XG4gICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xuICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcDtcbiAgIH1cbiAgIEJveDJELmluaGVyaXQoYjJXZWxkSm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcbiAgIGIyV2VsZEpvaW50RGVmLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYucHJvdG90eXBlO1xuICAgYjJXZWxkSm9pbnREZWYuYjJXZWxkSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xuICAgfTtcbiAgIGIyV2VsZEpvaW50RGVmLnByb3RvdHlwZS5iMldlbGRKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50RGVmLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnR5cGUgPSBiMkpvaW50LmVfd2VsZEpvaW50O1xuICAgICAgdGhpcy5yZWZlcmVuY2VBbmdsZSA9IDAuMDtcbiAgIH1cbiAgIGIyV2VsZEpvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgYW5jaG9yKSB7XG4gICAgICB0aGlzLmJvZHlBID0gYkE7XG4gICAgICB0aGlzLmJvZHlCID0gYkI7XG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQS5TZXRWKHRoaXMuYm9keUEuR2V0TG9jYWxQb2ludChhbmNob3IpKTtcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldFYodGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvcikpO1xuICAgICAgdGhpcy5yZWZlcmVuY2VBbmdsZSA9IHRoaXMuYm9keUIuR2V0QW5nbGUoKSAtIHRoaXMuYm9keUEuR2V0QW5nbGUoKTtcbiAgIH1cbn0pKCk7XG4oZnVuY3Rpb24gKCkge1xuICAgdmFyIGIyRGVidWdEcmF3ID0gQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXc7XG4gICBiMkRlYnVnRHJhdy5iMkRlYnVnRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9kcmF3U2NhbGUgPSAxLjA7XG4gICAgICB0aGlzLm1fbGluZVRoaWNrbmVzcyA9IDEuMDtcbiAgICAgIHRoaXMubV9hbHBoYSA9IDEuMDtcbiAgICAgIHRoaXMubV9maWxsQWxwaGEgPSAxLjA7XG4gICAgICB0aGlzLm1feGZvcm1TY2FsZSA9IDEuMDtcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xuICAgICAgLy8jV09SS0FST1VORFxuICAgICAgdGhpcy5tX3Nwcml0ZSA9IHtcbiAgICAgICAgIGdyYXBoaWNzOiB7XG4gICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgX190aGlzLm1fY3R4LmNsZWFyUmVjdCgwLCAwLCBfX3RoaXMubV9jdHguY2FudmFzLndpZHRoLCBfX3RoaXMubV9jdHguY2FudmFzLmhlaWdodClcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH07XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLl9jb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgYWxwaGEpIHtcbiAgICAgIHJldHVybiBcInJnYmEoXCIgKyAoKGNvbG9yICYgMHhGRjAwMDApID4+IDE2KSArIFwiLFwiICsgKChjb2xvciAmIDB4RkYwMCkgPj4gOCkgKyBcIixcIiArIChjb2xvciAmIDB4RkYpICsgXCIsXCIgKyBhbHBoYSArIFwiKVwiO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5iMkRlYnVnRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubV9kcmF3RmxhZ3MgPSAwO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXRGbGFncyA9IGZ1bmN0aW9uIChmbGFncykge1xuICAgICAgaWYgKGZsYWdzID09PSB1bmRlZmluZWQpIGZsYWdzID0gMDtcbiAgICAgIHRoaXMubV9kcmF3RmxhZ3MgPSBmbGFncztcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RmxhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RyYXdGbGFncztcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuQXBwZW5kRmxhZ3MgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XG4gICAgICB0aGlzLm1fZHJhd0ZsYWdzIHw9IGZsYWdzO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5DbGVhckZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XG4gICAgICBpZiAoZmxhZ3MgPT09IHVuZGVmaW5lZCkgZmxhZ3MgPSAwO1xuICAgICAgdGhpcy5tX2RyYXdGbGFncyAmPSB+ZmxhZ3M7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldFNwcml0ZSA9IGZ1bmN0aW9uIChzcHJpdGUpIHtcbiAgICAgIHRoaXMubV9jdHggPSBzcHJpdGU7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkdldFNwcml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fY3R4O1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXREcmF3U2NhbGUgPSBmdW5jdGlvbiAoZHJhd1NjYWxlKSB7XG4gICAgICBpZiAoZHJhd1NjYWxlID09PSB1bmRlZmluZWQpIGRyYXdTY2FsZSA9IDA7XG4gICAgICB0aGlzLm1fZHJhd1NjYWxlID0gZHJhd1NjYWxlO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXREcmF3U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX2RyYXdTY2FsZTtcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0TGluZVRoaWNrbmVzcyA9IGZ1bmN0aW9uIChsaW5lVGhpY2tuZXNzKSB7XG4gICAgICBpZiAobGluZVRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkKSBsaW5lVGhpY2tuZXNzID0gMDtcbiAgICAgIHRoaXMubV9saW5lVGhpY2tuZXNzID0gbGluZVRoaWNrbmVzcztcbiAgICAgIHRoaXMubV9jdHguc3Ryb2tlV2lkdGggPSBsaW5lVGhpY2tuZXNzO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXRMaW5lVGhpY2tuZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9saW5lVGhpY2tuZXNzO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXRBbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIGFscGhhID0gMDtcbiAgICAgIHRoaXMubV9hbHBoYSA9IGFscGhhO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXRBbHBoYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1fYWxwaGE7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldEZpbGxBbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIGFscGhhID0gMDtcbiAgICAgIHRoaXMubV9maWxsQWxwaGEgPSBhbHBoYTtcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RmlsbEFscGhhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubV9maWxsQWxwaGE7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldFhGb3JtU2NhbGUgPSBmdW5jdGlvbiAoeGZvcm1TY2FsZSkge1xuICAgICAgaWYgKHhmb3JtU2NhbGUgPT09IHVuZGVmaW5lZCkgeGZvcm1TY2FsZSA9IDA7XG4gICAgICB0aGlzLm1feGZvcm1TY2FsZSA9IHhmb3JtU2NhbGU7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkdldFhGb3JtU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tX3hmb3JtU2NhbGU7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdQb2x5Z29uID0gZnVuY3Rpb24gKHZlcnRpY2VzLCB2ZXJ0ZXhDb3VudCwgY29sb3IpIHtcbiAgICAgIGlmICghdmVydGV4Q291bnQpIHJldHVybjtcbiAgICAgIHZhciBzID0gdGhpcy5tX2N0eDtcbiAgICAgIHZhciBkcmF3U2NhbGUgPSB0aGlzLm1fZHJhd1NjYWxlO1xuICAgICAgcy5iZWdpblBhdGgoKTtcbiAgICAgIHMuc3Ryb2tlU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2FscGhhKTtcbiAgICAgIHMubW92ZVRvKHZlcnRpY2VzWzBdLnggKiBkcmF3U2NhbGUsIHZlcnRpY2VzWzBdLnkgKiBkcmF3U2NhbGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XG4gICAgICAgICBzLmxpbmVUbyh2ZXJ0aWNlc1tpXS54ICogZHJhd1NjYWxlLCB2ZXJ0aWNlc1tpXS55ICogZHJhd1NjYWxlKTtcbiAgICAgIH1cbiAgICAgIHMubGluZVRvKHZlcnRpY2VzWzBdLnggKiBkcmF3U2NhbGUsIHZlcnRpY2VzWzBdLnkgKiBkcmF3U2NhbGUpO1xuICAgICAgcy5jbG9zZVBhdGgoKTtcbiAgICAgIHMuc3Ryb2tlKCk7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdTb2xpZFBvbHlnb24gPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50LCBjb2xvcikge1xuICAgICAgaWYgKCF2ZXJ0ZXhDb3VudCkgcmV0dXJuO1xuICAgICAgdmFyIHMgPSB0aGlzLm1fY3R4O1xuICAgICAgdmFyIGRyYXdTY2FsZSA9IHRoaXMubV9kcmF3U2NhbGU7XG4gICAgICBzLmJlZ2luUGF0aCgpO1xuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKGNvbG9yLmNvbG9yLCB0aGlzLm1fYWxwaGEpO1xuICAgICAgcy5maWxsU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2ZpbGxBbHBoYSk7XG4gICAgICBzLm1vdmVUbyh2ZXJ0aWNlc1swXS54ICogZHJhd1NjYWxlLCB2ZXJ0aWNlc1swXS55ICogZHJhd1NjYWxlKTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgICAgICAgcy5saW5lVG8odmVydGljZXNbaV0ueCAqIGRyYXdTY2FsZSwgdmVydGljZXNbaV0ueSAqIGRyYXdTY2FsZSk7XG4gICAgICB9XG4gICAgICBzLmxpbmVUbyh2ZXJ0aWNlc1swXS54ICogZHJhd1NjYWxlLCB2ZXJ0aWNlc1swXS55ICogZHJhd1NjYWxlKTtcbiAgICAgIHMuY2xvc2VQYXRoKCk7XG4gICAgICBzLmZpbGwoKTtcbiAgICAgIHMuc3Ryb2tlKCk7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdDaXJjbGUgPSBmdW5jdGlvbiAoY2VudGVyLCByYWRpdXMsIGNvbG9yKSB7XG4gICAgICBpZiAoIXJhZGl1cykgcmV0dXJuO1xuICAgICAgdmFyIHMgPSB0aGlzLm1fY3R4O1xuICAgICAgdmFyIGRyYXdTY2FsZSA9IHRoaXMubV9kcmF3U2NhbGU7XG4gICAgICBzLmJlZ2luUGF0aCgpO1xuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKGNvbG9yLmNvbG9yLCB0aGlzLm1fYWxwaGEpO1xuICAgICAgcy5hcmMoY2VudGVyLnggKiBkcmF3U2NhbGUsIGNlbnRlci55ICogZHJhd1NjYWxlLCByYWRpdXMgKiBkcmF3U2NhbGUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgIHMuY2xvc2VQYXRoKCk7XG4gICAgICBzLnN0cm9rZSgpO1xuICAgfTtcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3U29saWRDaXJjbGUgPSBmdW5jdGlvbiAoY2VudGVyLCByYWRpdXMsIGF4aXMsIGNvbG9yKSB7XG4gICAgICBpZiAoIXJhZGl1cykgcmV0dXJuO1xuICAgICAgdmFyIHMgPSB0aGlzLm1fY3R4LFxuICAgICAgICAgZHJhd1NjYWxlID0gdGhpcy5tX2RyYXdTY2FsZSxcbiAgICAgICAgIGN4ID0gY2VudGVyLnggKiBkcmF3U2NhbGUsXG4gICAgICAgICBjeSA9IGNlbnRlci55ICogZHJhd1NjYWxlO1xuICAgICAgcy5tb3ZlVG8oMCwgMCk7XG4gICAgICBzLmJlZ2luUGF0aCgpO1xuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKGNvbG9yLmNvbG9yLCB0aGlzLm1fYWxwaGEpO1xuICAgICAgcy5maWxsU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2ZpbGxBbHBoYSk7XG4gICAgICBzLmFyYyhjeCwgY3ksIHJhZGl1cyAqIGRyYXdTY2FsZSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgcy5tb3ZlVG8oY3gsIGN5KTtcbiAgICAgIHMubGluZVRvKChjZW50ZXIueCArIGF4aXMueCAqIHJhZGl1cykgKiBkcmF3U2NhbGUsIChjZW50ZXIueSArIGF4aXMueSAqIHJhZGl1cykgKiBkcmF3U2NhbGUpO1xuICAgICAgcy5jbG9zZVBhdGgoKTtcbiAgICAgIHMuZmlsbCgpO1xuICAgICAgcy5zdHJva2UoKTtcbiAgIH07XG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd1NlZ21lbnQgPSBmdW5jdGlvbiAocDEsIHAyLCBjb2xvcikge1xuICAgICAgdmFyIHMgPSB0aGlzLm1fY3R4LFxuICAgICAgICAgZHJhd1NjYWxlID0gdGhpcy5tX2RyYXdTY2FsZTtcbiAgICAgIHMuc3Ryb2tlU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2FscGhhKTtcbiAgICAgIHMuYmVnaW5QYXRoKCk7XG4gICAgICBzLm1vdmVUbyhwMS54ICogZHJhd1NjYWxlLCBwMS55ICogZHJhd1NjYWxlKTtcbiAgICAgIHMubGluZVRvKHAyLnggKiBkcmF3U2NhbGUsIHAyLnkgKiBkcmF3U2NhbGUpO1xuICAgICAgcy5jbG9zZVBhdGgoKTtcbiAgICAgIHMuc3Ryb2tlKCk7XG4gICB9O1xuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoeGYpIHtcbiAgICAgIHZhciBzID0gdGhpcy5tX2N0eCxcbiAgICAgICAgIGRyYXdTY2FsZSA9IHRoaXMubV9kcmF3U2NhbGU7XG4gICAgICBzLmJlZ2luUGF0aCgpO1xuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKDB4ZmYwMDAwLCB0aGlzLm1fYWxwaGEpO1xuICAgICAgcy5tb3ZlVG8oeGYucG9zaXRpb24ueCAqIGRyYXdTY2FsZSwgeGYucG9zaXRpb24ueSAqIGRyYXdTY2FsZSk7XG4gICAgICBzLmxpbmVUbygoeGYucG9zaXRpb24ueCArIHRoaXMubV94Zm9ybVNjYWxlICogeGYuUi5jb2wxLngpICogZHJhd1NjYWxlLCAoeGYucG9zaXRpb24ueSArIHRoaXMubV94Zm9ybVNjYWxlICogeGYuUi5jb2wxLnkpICogZHJhd1NjYWxlKTtcblxuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKDB4ZmYwMCwgdGhpcy5tX2FscGhhKTtcbiAgICAgIHMubW92ZVRvKHhmLnBvc2l0aW9uLnggKiBkcmF3U2NhbGUsIHhmLnBvc2l0aW9uLnkgKiBkcmF3U2NhbGUpO1xuICAgICAgcy5saW5lVG8oKHhmLnBvc2l0aW9uLnggKyB0aGlzLm1feGZvcm1TY2FsZSAqIHhmLlIuY29sMi54KSAqIGRyYXdTY2FsZSwgKHhmLnBvc2l0aW9uLnkgKyB0aGlzLm1feGZvcm1TY2FsZSAqIHhmLlIuY29sMi55KSAqIGRyYXdTY2FsZSk7XG4gICAgICBzLmNsb3NlUGF0aCgpO1xuICAgICAgcy5zdHJva2UoKTtcbiAgIH07XG59KSgpO1xudmFyIGk7XG5mb3IgKGkgPSAwOyBpIDwgQm94MkQucG9zdERlZnMubGVuZ3RoOyArK2kpIEJveDJELnBvc3REZWZzW2ldKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm94MkQiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBSZWZsZWN0QXBwbHkodGhpcy5saXN0ZW5lciwgdGhpcy50YXJnZXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBYbWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIveG1sLWVudGl0aWVzLmpzJyksXG4gIEh0bWw0RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw0LWVudGl0aWVzLmpzJyksXG4gIEh0bWw1RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJyksXG4gIEFsbEh0bWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKVxufTtcbiIsInZhciBIVE1MX0FMUEhBID0gWydhcG9zJywgJ25ic3AnLCAnaWV4Y2wnLCAnY2VudCcsICdwb3VuZCcsICdjdXJyZW4nLCAneWVuJywgJ2JydmJhcicsICdzZWN0JywgJ3VtbCcsICdjb3B5JywgJ29yZGYnLCAnbGFxdW8nLCAnbm90JywgJ3NoeScsICdyZWcnLCAnbWFjcicsICdkZWcnLCAncGx1c21uJywgJ3N1cDInLCAnc3VwMycsICdhY3V0ZScsICdtaWNybycsICdwYXJhJywgJ21pZGRvdCcsICdjZWRpbCcsICdzdXAxJywgJ29yZG0nLCAncmFxdW8nLCAnZnJhYzE0JywgJ2ZyYWMxMicsICdmcmFjMzQnLCAnaXF1ZXN0JywgJ0FncmF2ZScsICdBYWN1dGUnLCAnQWNpcmMnLCAnQXRpbGRlJywgJ0F1bWwnLCAnQXJpbmcnLCAnQWVsaWcnLCAnQ2NlZGlsJywgJ0VncmF2ZScsICdFYWN1dGUnLCAnRWNpcmMnLCAnRXVtbCcsICdJZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjJywgJ0l1bWwnLCAnRVRIJywgJ050aWxkZScsICdPZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjJywgJ090aWxkZScsICdPdW1sJywgJ3RpbWVzJywgJ09zbGFzaCcsICdVZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjJywgJ1V1bWwnLCAnWWFjdXRlJywgJ1RIT1JOJywgJ3N6bGlnJywgJ2FncmF2ZScsICdhYWN1dGUnLCAnYWNpcmMnLCAnYXRpbGRlJywgJ2F1bWwnLCAnYXJpbmcnLCAnYWVsaWcnLCAnY2NlZGlsJywgJ2VncmF2ZScsICdlYWN1dGUnLCAnZWNpcmMnLCAnZXVtbCcsICdpZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjJywgJ2l1bWwnLCAnZXRoJywgJ250aWxkZScsICdvZ3JhdmUnLCAnb2FjdXRlJywgJ29jaXJjJywgJ290aWxkZScsICdvdW1sJywgJ2RpdmlkZScsICdvc2xhc2gnLCAndWdyYXZlJywgJ3VhY3V0ZScsICd1Y2lyYycsICd1dW1sJywgJ3lhY3V0ZScsICd0aG9ybicsICd5dW1sJywgJ3F1b3QnLCAnYW1wJywgJ2x0JywgJ2d0JywgJ09FbGlnJywgJ29lbGlnJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWXVtbCcsICdjaXJjJywgJ3RpbGRlJywgJ2Vuc3AnLCAnZW1zcCcsICd0aGluc3AnLCAnenduaicsICd6d2onLCAnbHJtJywgJ3JsbScsICduZGFzaCcsICdtZGFzaCcsICdsc3F1bycsICdyc3F1bycsICdzYnF1bycsICdsZHF1bycsICdyZHF1bycsICdiZHF1bycsICdkYWdnZXInLCAnRGFnZ2VyJywgJ3Blcm1pbCcsICdsc2FxdW8nLCAncnNhcXVvJywgJ2V1cm8nLCAnZm5vZicsICdBbHBoYScsICdCZXRhJywgJ0dhbW1hJywgJ0RlbHRhJywgJ0Vwc2lsb24nLCAnWmV0YScsICdFdGEnLCAnVGhldGEnLCAnSW90YScsICdLYXBwYScsICdMYW1iZGEnLCAnTXUnLCAnTnUnLCAnWGknLCAnT21pY3JvbicsICdQaScsICdSaG8nLCAnU2lnbWEnLCAnVGF1JywgJ1Vwc2lsb24nLCAnUGhpJywgJ0NoaScsICdQc2knLCAnT21lZ2EnLCAnYWxwaGEnLCAnYmV0YScsICdnYW1tYScsICdkZWx0YScsICdlcHNpbG9uJywgJ3pldGEnLCAnZXRhJywgJ3RoZXRhJywgJ2lvdGEnLCAna2FwcGEnLCAnbGFtYmRhJywgJ211JywgJ251JywgJ3hpJywgJ29taWNyb24nLCAncGknLCAncmhvJywgJ3NpZ21hZicsICdzaWdtYScsICd0YXUnLCAndXBzaWxvbicsICdwaGknLCAnY2hpJywgJ3BzaScsICdvbWVnYScsICd0aGV0YXN5bScsICd1cHNpaCcsICdwaXYnLCAnYnVsbCcsICdoZWxsaXAnLCAncHJpbWUnLCAnUHJpbWUnLCAnb2xpbmUnLCAnZnJhc2wnLCAnd2VpZXJwJywgJ2ltYWdlJywgJ3JlYWwnLCAndHJhZGUnLCAnYWxlZnN5bScsICdsYXJyJywgJ3VhcnInLCAncmFycicsICdkYXJyJywgJ2hhcnInLCAnY3JhcnInLCAnbEFycicsICd1QXJyJywgJ3JBcnInLCAnZEFycicsICdoQXJyJywgJ2ZvcmFsbCcsICdwYXJ0JywgJ2V4aXN0JywgJ2VtcHR5JywgJ25hYmxhJywgJ2lzaW4nLCAnbm90aW4nLCAnbmknLCAncHJvZCcsICdzdW0nLCAnbWludXMnLCAnbG93YXN0JywgJ3JhZGljJywgJ3Byb3AnLCAnaW5maW4nLCAnYW5nJywgJ2FuZCcsICdvcicsICdjYXAnLCAnY3VwJywgJ2ludCcsICd0aGVyZTQnLCAnc2ltJywgJ2NvbmcnLCAnYXN5bXAnLCAnbmUnLCAnZXF1aXYnLCAnbGUnLCAnZ2UnLCAnc3ViJywgJ3N1cCcsICduc3ViJywgJ3N1YmUnLCAnc3VwZScsICdvcGx1cycsICdvdGltZXMnLCAncGVycCcsICdzZG90JywgJ2xjZWlsJywgJ3JjZWlsJywgJ2xmbG9vcicsICdyZmxvb3InLCAnbGFuZycsICdyYW5nJywgJ2xveicsICdzcGFkZXMnLCAnY2x1YnMnLCAnaGVhcnRzJywgJ2RpYW1zJ107XG52YXIgSFRNTF9DT0RFUyA9IFszOSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSwgMTcyLCAxNzMsIDE3NCwgMTc1LCAxNzYsIDE3NywgMTc4LCAxNzksIDE4MCwgMTgxLCAxODIsIDE4MywgMTg0LCAxODUsIDE4NiwgMTg3LCAxODgsIDE4OSwgMTkwLCAxOTEsIDE5MiwgMTkzLCAxOTQsIDE5NSwgMTk2LCAxOTcsIDE5OCwgMTk5LCAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCwgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxMCwgMjExLCAyMTIsIDIxMywgMjE0LCAyMTUsIDIxNiwgMjE3LCAyMTgsIDIxOSwgMjIwLCAyMjEsIDIyMiwgMjIzLCAyMjQsIDIyNSwgMjI2LCAyMjcsIDIyOCwgMjI5LCAyMzAsIDIzMSwgMjMyLCAyMzMsIDIzNCwgMjM1LCAyMzYsIDIzNywgMjM4LCAyMzksIDI0MCwgMjQxLCAyNDIsIDI0MywgMjQ0LCAyNDUsIDI0NiwgMjQ3LCAyNDgsIDI0OSwgMjUwLCAyNTEsIDI1MiwgMjUzLCAyNTQsIDI1NSwgMzQsIDM4LCA2MCwgNjIsIDMzOCwgMzM5LCAzNTIsIDM1MywgMzc2LCA3MTAsIDczMiwgODE5NCwgODE5NSwgODIwMSwgODIwNCwgODIwNSwgODIwNiwgODIwNywgODIxMSwgODIxMiwgODIxNiwgODIxNywgODIxOCwgODIyMCwgODIyMSwgODIyMiwgODIyNCwgODIyNSwgODI0MCwgODI0OSwgODI1MCwgODM2NCwgNDAyLCA5MTMsIDkxNCwgOTE1LCA5MTYsIDkxNywgOTE4LCA5MTksIDkyMCwgOTIxLCA5MjIsIDkyMywgOTI0LCA5MjUsIDkyNiwgOTI3LCA5MjgsIDkyOSwgOTMxLCA5MzIsIDkzMywgOTM0LCA5MzUsIDkzNiwgOTM3LCA5NDUsIDk0NiwgOTQ3LCA5NDgsIDk0OSwgOTUwLCA5NTEsIDk1MiwgOTUzLCA5NTQsIDk1NSwgOTU2LCA5NTcsIDk1OCwgOTU5LCA5NjAsIDk2MSwgOTYyLCA5NjMsIDk2NCwgOTY1LCA5NjYsIDk2NywgOTY4LCA5NjksIDk3NywgOTc4LCA5ODIsIDgyMjYsIDgyMzAsIDgyNDIsIDgyNDMsIDgyNTQsIDgyNjAsIDg0NzIsIDg0NjUsIDg0NzYsIDg0ODIsIDg1MDEsIDg1OTIsIDg1OTMsIDg1OTQsIDg1OTUsIDg1OTYsIDg2MjksIDg2NTYsIDg2NTcsIDg2NTgsIDg2NTksIDg2NjAsIDg3MDQsIDg3MDYsIDg3MDcsIDg3MDksIDg3MTEsIDg3MTIsIDg3MTMsIDg3MTUsIDg3MTksIDg3MjEsIDg3MjIsIDg3MjcsIDg3MzAsIDg3MzMsIDg3MzQsIDg3MzYsIDg3NDMsIDg3NDQsIDg3NDUsIDg3NDYsIDg3NDcsIDg3NTYsIDg3NjQsIDg3NzMsIDg3NzYsIDg4MDAsIDg4MDEsIDg4MDQsIDg4MDUsIDg4MzQsIDg4MzUsIDg4MzYsIDg4MzgsIDg4MzksIDg4NTMsIDg4NTUsIDg4NjksIDg5MDEsIDg5NjgsIDg5NjksIDg5NzAsIDg5NzEsIDkwMDEsIDkwMDIsIDk2NzQsIDk4MjQsIDk4MjcsIDk4MjksIDk4MzBdO1xuXG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIG51bUluZGV4ID0ge307XG5cbnZhciBpID0gMDtcbnZhciBsZW5ndGggPSBIVE1MX0FMUEhBLmxlbmd0aDtcbndoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGEgPSBIVE1MX0FMUEhBW2ldO1xuICAgIHZhciBjID0gSFRNTF9DT0RFU1tpXTtcbiAgICBhbHBoYUluZGV4W2FdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICBudW1JbmRleFtjXSA9IGE7XG4gICAgaSsrO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgcmVzdWx0ICs9IGFscGhhID8gXCImXCIgKyBhbHBoYSArIFwiO1wiIDogc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W2NjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGNjIDwgMzIgfHwgY2MgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiYjXCIgKyBjYyArIFwiO1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDRFbnRpdGllcztcbiIsInZhciBFTlRJVElFUyA9IFtbJ0FhY3V0ZScsIFsxOTNdXSwgWydhYWN1dGUnLCBbMjI1XV0sIFsnQWJyZXZlJywgWzI1OF1dLCBbJ2FicmV2ZScsIFsyNTldXSwgWydhYycsIFs4NzY2XV0sIFsnYWNkJywgWzg3NjddXSwgWydhY0UnLCBbODc2NiwgODE5XV0sIFsnQWNpcmMnLCBbMTk0XV0sIFsnYWNpcmMnLCBbMjI2XV0sIFsnYWN1dGUnLCBbMTgwXV0sIFsnQWN5JywgWzEwNDBdXSwgWydhY3knLCBbMTA3Ml1dLCBbJ0FFbGlnJywgWzE5OF1dLCBbJ2FlbGlnJywgWzIzMF1dLCBbJ2FmJywgWzgyODldXSwgWydBZnInLCBbMTIwMDY4XV0sIFsnYWZyJywgWzEyMDA5NF1dLCBbJ0FncmF2ZScsIFsxOTJdXSwgWydhZ3JhdmUnLCBbMjI0XV0sIFsnYWxlZnN5bScsIFs4NTAxXV0sIFsnYWxlcGgnLCBbODUwMV1dLCBbJ0FscGhhJywgWzkxM11dLCBbJ2FscGhhJywgWzk0NV1dLCBbJ0FtYWNyJywgWzI1Nl1dLCBbJ2FtYWNyJywgWzI1N11dLCBbJ2FtYWxnJywgWzEwODE1XV0sIFsnYW1wJywgWzM4XV0sIFsnQU1QJywgWzM4XV0sIFsnYW5kYW5kJywgWzEwODM3XV0sIFsnQW5kJywgWzEwODM1XV0sIFsnYW5kJywgWzg3NDNdXSwgWydhbmRkJywgWzEwODQ0XV0sIFsnYW5kc2xvcGUnLCBbMTA4NDBdXSwgWydhbmR2JywgWzEwODQyXV0sIFsnYW5nJywgWzg3MzZdXSwgWydhbmdlJywgWzEwNjYwXV0sIFsnYW5nbGUnLCBbODczNl1dLCBbJ2FuZ21zZGFhJywgWzEwNjY0XV0sIFsnYW5nbXNkYWInLCBbMTA2NjVdXSwgWydhbmdtc2RhYycsIFsxMDY2Nl1dLCBbJ2FuZ21zZGFkJywgWzEwNjY3XV0sIFsnYW5nbXNkYWUnLCBbMTA2NjhdXSwgWydhbmdtc2RhZicsIFsxMDY2OV1dLCBbJ2FuZ21zZGFnJywgWzEwNjcwXV0sIFsnYW5nbXNkYWgnLCBbMTA2NzFdXSwgWydhbmdtc2QnLCBbODczN11dLCBbJ2FuZ3J0JywgWzg3MzVdXSwgWydhbmdydHZiJywgWzg4OTRdXSwgWydhbmdydHZiZCcsIFsxMDY1M11dLCBbJ2FuZ3NwaCcsIFs4NzM4XV0sIFsnYW5nc3QnLCBbMTk3XV0sIFsnYW5nemFycicsIFs5MDg0XV0sIFsnQW9nb24nLCBbMjYwXV0sIFsnYW9nb24nLCBbMjYxXV0sIFsnQW9wZicsIFsxMjAxMjBdXSwgWydhb3BmJywgWzEyMDE0Nl1dLCBbJ2FwYWNpcicsIFsxMDg2M11dLCBbJ2FwJywgWzg3NzZdXSwgWydhcEUnLCBbMTA4NjRdXSwgWydhcGUnLCBbODc3OF1dLCBbJ2FwaWQnLCBbODc3OV1dLCBbJ2Fwb3MnLCBbMzldXSwgWydBcHBseUZ1bmN0aW9uJywgWzgyODldXSwgWydhcHByb3gnLCBbODc3Nl1dLCBbJ2FwcHJveGVxJywgWzg3NzhdXSwgWydBcmluZycsIFsxOTddXSwgWydhcmluZycsIFsyMjldXSwgWydBc2NyJywgWzExOTk2NF1dLCBbJ2FzY3InLCBbMTE5OTkwXV0sIFsnQXNzaWduJywgWzg3ODhdXSwgWydhc3QnLCBbNDJdXSwgWydhc3ltcCcsIFs4Nzc2XV0sIFsnYXN5bXBlcScsIFs4NzgxXV0sIFsnQXRpbGRlJywgWzE5NV1dLCBbJ2F0aWxkZScsIFsyMjddXSwgWydBdW1sJywgWzE5Nl1dLCBbJ2F1bWwnLCBbMjI4XV0sIFsnYXdjb25pbnQnLCBbODc1NV1dLCBbJ2F3aW50JywgWzEwNzY5XV0sIFsnYmFja2NvbmcnLCBbODc4MF1dLCBbJ2JhY2tlcHNpbG9uJywgWzEwMTRdXSwgWydiYWNrcHJpbWUnLCBbODI0NV1dLCBbJ2JhY2tzaW0nLCBbODc2NV1dLCBbJ2JhY2tzaW1lcScsIFs4OTA5XV0sIFsnQmFja3NsYXNoJywgWzg3MjZdXSwgWydCYXJ2JywgWzEwOTgzXV0sIFsnYmFydmVlJywgWzg4OTNdXSwgWydiYXJ3ZWQnLCBbODk2NV1dLCBbJ0JhcndlZCcsIFs4OTY2XV0sIFsnYmFyd2VkZ2UnLCBbODk2NV1dLCBbJ2JicmsnLCBbOTE0MV1dLCBbJ2Jicmt0YnJrJywgWzkxNDJdXSwgWydiY29uZycsIFs4NzgwXV0sIFsnQmN5JywgWzEwNDFdXSwgWydiY3knLCBbMTA3M11dLCBbJ2JkcXVvJywgWzgyMjJdXSwgWydiZWNhdXMnLCBbODc1N11dLCBbJ2JlY2F1c2UnLCBbODc1N11dLCBbJ0JlY2F1c2UnLCBbODc1N11dLCBbJ2JlbXB0eXYnLCBbMTA2NzJdXSwgWydiZXBzaScsIFsxMDE0XV0sIFsnYmVybm91JywgWzg0OTJdXSwgWydCZXJub3VsbGlzJywgWzg0OTJdXSwgWydCZXRhJywgWzkxNF1dLCBbJ2JldGEnLCBbOTQ2XV0sIFsnYmV0aCcsIFs4NTAyXV0sIFsnYmV0d2VlbicsIFs4ODEyXV0sIFsnQmZyJywgWzEyMDA2OV1dLCBbJ2JmcicsIFsxMjAwOTVdXSwgWydiaWdjYXAnLCBbODg5OF1dLCBbJ2JpZ2NpcmMnLCBbOTcxMV1dLCBbJ2JpZ2N1cCcsIFs4ODk5XV0sIFsnYmlnb2RvdCcsIFsxMDc1Ml1dLCBbJ2JpZ29wbHVzJywgWzEwNzUzXV0sIFsnYmlnb3RpbWVzJywgWzEwNzU0XV0sIFsnYmlnc3FjdXAnLCBbMTA3NThdXSwgWydiaWdzdGFyJywgWzk3MzNdXSwgWydiaWd0cmlhbmdsZWRvd24nLCBbOTY2MV1dLCBbJ2JpZ3RyaWFuZ2xldXAnLCBbOTY1MV1dLCBbJ2JpZ3VwbHVzJywgWzEwNzU2XV0sIFsnYmlndmVlJywgWzg4OTddXSwgWydiaWd3ZWRnZScsIFs4ODk2XV0sIFsnYmthcm93JywgWzEwNTA5XV0sIFsnYmxhY2tsb3plbmdlJywgWzEwNzMxXV0sIFsnYmxhY2tzcXVhcmUnLCBbOTY0Ml1dLCBbJ2JsYWNrdHJpYW5nbGUnLCBbOTY1Ml1dLCBbJ2JsYWNrdHJpYW5nbGVkb3duJywgWzk2NjJdXSwgWydibGFja3RyaWFuZ2xlbGVmdCcsIFs5NjY2XV0sIFsnYmxhY2t0cmlhbmdsZXJpZ2h0JywgWzk2NTZdXSwgWydibGFuaycsIFs5MjUxXV0sIFsnYmxrMTInLCBbOTYxOF1dLCBbJ2JsazE0JywgWzk2MTddXSwgWydibGszNCcsIFs5NjE5XV0sIFsnYmxvY2snLCBbOTYwOF1dLCBbJ2JuZScsIFs2MSwgODQyMV1dLCBbJ2JuZXF1aXYnLCBbODgwMSwgODQyMV1dLCBbJ2JOb3QnLCBbMTA5ODldXSwgWydibm90JywgWzg5NzZdXSwgWydCb3BmJywgWzEyMDEyMV1dLCBbJ2JvcGYnLCBbMTIwMTQ3XV0sIFsnYm90JywgWzg4NjldXSwgWydib3R0b20nLCBbODg2OV1dLCBbJ2Jvd3RpZScsIFs4OTA0XV0sIFsnYm94Ym94JywgWzEwNjk3XV0sIFsnYm94ZGwnLCBbOTQ4OF1dLCBbJ2JveGRMJywgWzk1NTddXSwgWydib3hEbCcsIFs5NTU4XV0sIFsnYm94REwnLCBbOTU1OV1dLCBbJ2JveGRyJywgWzk0ODRdXSwgWydib3hkUicsIFs5NTU0XV0sIFsnYm94RHInLCBbOTU1NV1dLCBbJ2JveERSJywgWzk1NTZdXSwgWydib3hoJywgWzk0NzJdXSwgWydib3hIJywgWzk1NTJdXSwgWydib3hoZCcsIFs5NTE2XV0sIFsnYm94SGQnLCBbOTU3Ml1dLCBbJ2JveGhEJywgWzk1NzNdXSwgWydib3hIRCcsIFs5NTc0XV0sIFsnYm94aHUnLCBbOTUyNF1dLCBbJ2JveEh1JywgWzk1NzVdXSwgWydib3hoVScsIFs5NTc2XV0sIFsnYm94SFUnLCBbOTU3N11dLCBbJ2JveG1pbnVzJywgWzg4NjNdXSwgWydib3hwbHVzJywgWzg4NjJdXSwgWydib3h0aW1lcycsIFs4ODY0XV0sIFsnYm94dWwnLCBbOTQ5Nl1dLCBbJ2JveHVMJywgWzk1NjNdXSwgWydib3hVbCcsIFs5NTY0XV0sIFsnYm94VUwnLCBbOTU2NV1dLCBbJ2JveHVyJywgWzk0OTJdXSwgWydib3h1UicsIFs5NTYwXV0sIFsnYm94VXInLCBbOTU2MV1dLCBbJ2JveFVSJywgWzk1NjJdXSwgWydib3h2JywgWzk0NzRdXSwgWydib3hWJywgWzk1NTNdXSwgWydib3h2aCcsIFs5NTMyXV0sIFsnYm94dkgnLCBbOTU3OF1dLCBbJ2JveFZoJywgWzk1NzldXSwgWydib3hWSCcsIFs5NTgwXV0sIFsnYm94dmwnLCBbOTUwOF1dLCBbJ2JveHZMJywgWzk1NjldXSwgWydib3hWbCcsIFs5NTcwXV0sIFsnYm94VkwnLCBbOTU3MV1dLCBbJ2JveHZyJywgWzk1MDBdXSwgWydib3h2UicsIFs5NTY2XV0sIFsnYm94VnInLCBbOTU2N11dLCBbJ2JveFZSJywgWzk1NjhdXSwgWydicHJpbWUnLCBbODI0NV1dLCBbJ2JyZXZlJywgWzcyOF1dLCBbJ0JyZXZlJywgWzcyOF1dLCBbJ2JydmJhcicsIFsxNjZdXSwgWydic2NyJywgWzExOTk5MV1dLCBbJ0JzY3InLCBbODQ5Ml1dLCBbJ2JzZW1pJywgWzgyNzFdXSwgWydic2ltJywgWzg3NjVdXSwgWydic2ltZScsIFs4OTA5XV0sIFsnYnNvbGInLCBbMTA2OTNdXSwgWydic29sJywgWzkyXV0sIFsnYnNvbGhzdWInLCBbMTAxODRdXSwgWydidWxsJywgWzgyMjZdXSwgWydidWxsZXQnLCBbODIyNl1dLCBbJ2J1bXAnLCBbODc4Ml1dLCBbJ2J1bXBFJywgWzEwOTI2XV0sIFsnYnVtcGUnLCBbODc4M11dLCBbJ0J1bXBlcScsIFs4NzgyXV0sIFsnYnVtcGVxJywgWzg3ODNdXSwgWydDYWN1dGUnLCBbMjYyXV0sIFsnY2FjdXRlJywgWzI2M11dLCBbJ2NhcGFuZCcsIFsxMDgyMF1dLCBbJ2NhcGJyY3VwJywgWzEwODI1XV0sIFsnY2FwY2FwJywgWzEwODI3XV0sIFsnY2FwJywgWzg3NDVdXSwgWydDYXAnLCBbODkxNF1dLCBbJ2NhcGN1cCcsIFsxMDgyM11dLCBbJ2NhcGRvdCcsIFsxMDgxNl1dLCBbJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJywgWzg1MTddXSwgWydjYXBzJywgWzg3NDUsIDY1MDI0XV0sIFsnY2FyZXQnLCBbODI1N11dLCBbJ2Nhcm9uJywgWzcxMV1dLCBbJ0NheWxleXMnLCBbODQ5M11dLCBbJ2NjYXBzJywgWzEwODI5XV0sIFsnQ2Nhcm9uJywgWzI2OF1dLCBbJ2NjYXJvbicsIFsyNjldXSwgWydDY2VkaWwnLCBbMTk5XV0sIFsnY2NlZGlsJywgWzIzMV1dLCBbJ0NjaXJjJywgWzI2NF1dLCBbJ2NjaXJjJywgWzI2NV1dLCBbJ0Njb25pbnQnLCBbODc1Ml1dLCBbJ2NjdXBzJywgWzEwODI4XV0sIFsnY2N1cHNzbScsIFsxMDgzMl1dLCBbJ0Nkb3QnLCBbMjY2XV0sIFsnY2RvdCcsIFsyNjddXSwgWydjZWRpbCcsIFsxODRdXSwgWydDZWRpbGxhJywgWzE4NF1dLCBbJ2NlbXB0eXYnLCBbMTA2NzRdXSwgWydjZW50JywgWzE2Ml1dLCBbJ2NlbnRlcmRvdCcsIFsxODNdXSwgWydDZW50ZXJEb3QnLCBbMTgzXV0sIFsnY2ZyJywgWzEyMDA5Nl1dLCBbJ0NmcicsIFs4NDkzXV0sIFsnQ0hjeScsIFsxMDYzXV0sIFsnY2hjeScsIFsxMDk1XV0sIFsnY2hlY2snLCBbMTAwMDNdXSwgWydjaGVja21hcmsnLCBbMTAwMDNdXSwgWydDaGknLCBbOTM1XV0sIFsnY2hpJywgWzk2N11dLCBbJ2NpcmMnLCBbNzEwXV0sIFsnY2lyY2VxJywgWzg3OTFdXSwgWydjaXJjbGVhcnJvd2xlZnQnLCBbODYzNF1dLCBbJ2NpcmNsZWFycm93cmlnaHQnLCBbODYzNV1dLCBbJ2NpcmNsZWRhc3QnLCBbODg1OV1dLCBbJ2NpcmNsZWRjaXJjJywgWzg4NThdXSwgWydjaXJjbGVkZGFzaCcsIFs4ODYxXV0sIFsnQ2lyY2xlRG90JywgWzg4NTddXSwgWydjaXJjbGVkUicsIFsxNzRdXSwgWydjaXJjbGVkUycsIFs5NDE2XV0sIFsnQ2lyY2xlTWludXMnLCBbODg1NF1dLCBbJ0NpcmNsZVBsdXMnLCBbODg1M11dLCBbJ0NpcmNsZVRpbWVzJywgWzg4NTVdXSwgWydjaXInLCBbOTY3NV1dLCBbJ2NpckUnLCBbMTA2OTFdXSwgWydjaXJlJywgWzg3OTFdXSwgWydjaXJmbmludCcsIFsxMDc2OF1dLCBbJ2Npcm1pZCcsIFsxMDk5MV1dLCBbJ2NpcnNjaXInLCBbMTA2OTBdXSwgWydDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NF1dLCBbJ2NsdWJzJywgWzk4MjddXSwgWydjbHVic3VpdCcsIFs5ODI3XV0sIFsnY29sb24nLCBbNThdXSwgWydDb2xvbicsIFs4NzU5XV0sIFsnQ29sb25lJywgWzEwODY4XV0sIFsnY29sb25lJywgWzg3ODhdXSwgWydjb2xvbmVxJywgWzg3ODhdXSwgWydjb21tYScsIFs0NF1dLCBbJ2NvbW1hdCcsIFs2NF1dLCBbJ2NvbXAnLCBbODcwNV1dLCBbJ2NvbXBmbicsIFs4NzI4XV0sIFsnY29tcGxlbWVudCcsIFs4NzA1XV0sIFsnY29tcGxleGVzJywgWzg0NTBdXSwgWydjb25nJywgWzg3NzNdXSwgWydjb25nZG90JywgWzEwODYxXV0sIFsnQ29uZ3J1ZW50JywgWzg4MDFdXSwgWydjb25pbnQnLCBbODc1MF1dLCBbJ0NvbmludCcsIFs4NzUxXV0sIFsnQ29udG91ckludGVncmFsJywgWzg3NTBdXSwgWydjb3BmJywgWzEyMDE0OF1dLCBbJ0NvcGYnLCBbODQ1MF1dLCBbJ2NvcHJvZCcsIFs4NzIwXV0sIFsnQ29wcm9kdWN0JywgWzg3MjBdXSwgWydjb3B5JywgWzE2OV1dLCBbJ0NPUFknLCBbMTY5XV0sIFsnY29weXNyJywgWzg0NzFdXSwgWydDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTVdXSwgWydjcmFycicsIFs4NjI5XV0sIFsnY3Jvc3MnLCBbMTAwMDddXSwgWydDcm9zcycsIFsxMDc5OV1dLCBbJ0NzY3InLCBbMTE5OTY2XV0sIFsnY3NjcicsIFsxMTk5OTJdXSwgWydjc3ViJywgWzEwOTU5XV0sIFsnY3N1YmUnLCBbMTA5NjFdXSwgWydjc3VwJywgWzEwOTYwXV0sIFsnY3N1cGUnLCBbMTA5NjJdXSwgWydjdGRvdCcsIFs4OTQzXV0sIFsnY3VkYXJybCcsIFsxMDU1Ml1dLCBbJ2N1ZGFycnInLCBbMTA1NDldXSwgWydjdWVwcicsIFs4OTI2XV0sIFsnY3Vlc2MnLCBbODkyN11dLCBbJ2N1bGFycicsIFs4NjMwXV0sIFsnY3VsYXJycCcsIFsxMDU1N11dLCBbJ2N1cGJyY2FwJywgWzEwODI0XV0sIFsnY3VwY2FwJywgWzEwODIyXV0sIFsnQ3VwQ2FwJywgWzg3ODFdXSwgWydjdXAnLCBbODc0Nl1dLCBbJ0N1cCcsIFs4OTE1XV0sIFsnY3VwY3VwJywgWzEwODI2XV0sIFsnY3VwZG90JywgWzg4NDVdXSwgWydjdXBvcicsIFsxMDgyMV1dLCBbJ2N1cHMnLCBbODc0NiwgNjUwMjRdXSwgWydjdXJhcnInLCBbODYzMV1dLCBbJ2N1cmFycm0nLCBbMTA1NTZdXSwgWydjdXJseWVxcHJlYycsIFs4OTI2XV0sIFsnY3VybHllcXN1Y2MnLCBbODkyN11dLCBbJ2N1cmx5dmVlJywgWzg5MTBdXSwgWydjdXJseXdlZGdlJywgWzg5MTFdXSwgWydjdXJyZW4nLCBbMTY0XV0sIFsnY3VydmVhcnJvd2xlZnQnLCBbODYzMF1dLCBbJ2N1cnZlYXJyb3dyaWdodCcsIFs4NjMxXV0sIFsnY3V2ZWUnLCBbODkxMF1dLCBbJ2N1d2VkJywgWzg5MTFdXSwgWydjd2NvbmludCcsIFs4NzU0XV0sIFsnY3dpbnQnLCBbODc1M11dLCBbJ2N5bGN0eScsIFs5MDA1XV0sIFsnZGFnZ2VyJywgWzgyMjRdXSwgWydEYWdnZXInLCBbODIyNV1dLCBbJ2RhbGV0aCcsIFs4NTA0XV0sIFsnZGFycicsIFs4NTk1XV0sIFsnRGFycicsIFs4NjA5XV0sIFsnZEFycicsIFs4NjU5XV0sIFsnZGFzaCcsIFs4MjA4XV0sIFsnRGFzaHYnLCBbMTA5ODBdXSwgWydkYXNodicsIFs4ODY3XV0sIFsnZGJrYXJvdycsIFsxMDUxMV1dLCBbJ2RibGFjJywgWzczM11dLCBbJ0RjYXJvbicsIFsyNzBdXSwgWydkY2Fyb24nLCBbMjcxXV0sIFsnRGN5JywgWzEwNDRdXSwgWydkY3knLCBbMTA3Nl1dLCBbJ2RkYWdnZXInLCBbODIyNV1dLCBbJ2RkYXJyJywgWzg2NTBdXSwgWydERCcsIFs4NTE3XV0sIFsnZGQnLCBbODUxOF1dLCBbJ0REb3RyYWhkJywgWzEwNTEzXV0sIFsnZGRvdHNlcScsIFsxMDg3MV1dLCBbJ2RlZycsIFsxNzZdXSwgWydEZWwnLCBbODcxMV1dLCBbJ0RlbHRhJywgWzkxNl1dLCBbJ2RlbHRhJywgWzk0OF1dLCBbJ2RlbXB0eXYnLCBbMTA2NzNdXSwgWydkZmlzaHQnLCBbMTA2MjNdXSwgWydEZnInLCBbMTIwMDcxXV0sIFsnZGZyJywgWzEyMDA5N11dLCBbJ2RIYXInLCBbMTA1OTddXSwgWydkaGFybCcsIFs4NjQzXV0sIFsnZGhhcnInLCBbODY0Ml1dLCBbJ0RpYWNyaXRpY2FsQWN1dGUnLCBbMTgwXV0sIFsnRGlhY3JpdGljYWxEb3QnLCBbNzI5XV0sIFsnRGlhY3JpdGljYWxEb3VibGVBY3V0ZScsIFs3MzNdXSwgWydEaWFjcml0aWNhbEdyYXZlJywgWzk2XV0sIFsnRGlhY3JpdGljYWxUaWxkZScsIFs3MzJdXSwgWydkaWFtJywgWzg5MDBdXSwgWydkaWFtb25kJywgWzg5MDBdXSwgWydEaWFtb25kJywgWzg5MDBdXSwgWydkaWFtb25kc3VpdCcsIFs5ODMwXV0sIFsnZGlhbXMnLCBbOTgzMF1dLCBbJ2RpZScsIFsxNjhdXSwgWydEaWZmZXJlbnRpYWxEJywgWzg1MThdXSwgWydkaWdhbW1hJywgWzk4OV1dLCBbJ2Rpc2luJywgWzg5NDZdXSwgWydkaXYnLCBbMjQ3XV0sIFsnZGl2aWRlJywgWzI0N11dLCBbJ2RpdmlkZW9udGltZXMnLCBbODkwM11dLCBbJ2Rpdm9ueCcsIFs4OTAzXV0sIFsnREpjeScsIFsxMDI2XV0sIFsnZGpjeScsIFsxMTA2XV0sIFsnZGxjb3JuJywgWzg5OTBdXSwgWydkbGNyb3AnLCBbODk3M11dLCBbJ2RvbGxhcicsIFszNl1dLCBbJ0RvcGYnLCBbMTIwMTIzXV0sIFsnZG9wZicsIFsxMjAxNDldXSwgWydEb3QnLCBbMTY4XV0sIFsnZG90JywgWzcyOV1dLCBbJ0RvdERvdCcsIFs4NDEyXV0sIFsnZG90ZXEnLCBbODc4NF1dLCBbJ2RvdGVxZG90JywgWzg3ODVdXSwgWydEb3RFcXVhbCcsIFs4Nzg0XV0sIFsnZG90bWludXMnLCBbODc2MF1dLCBbJ2RvdHBsdXMnLCBbODcyNF1dLCBbJ2RvdHNxdWFyZScsIFs4ODY1XV0sIFsnZG91YmxlYmFyd2VkZ2UnLCBbODk2Nl1dLCBbJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzUxXV0sIFsnRG91YmxlRG90JywgWzE2OF1dLCBbJ0RvdWJsZURvd25BcnJvdycsIFs4NjU5XV0sIFsnRG91YmxlTGVmdEFycm93JywgWzg2NTZdXSwgWydEb3VibGVMZWZ0UmlnaHRBcnJvdycsIFs4NjYwXV0sIFsnRG91YmxlTGVmdFRlZScsIFsxMDk4MF1dLCBbJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnLCBbMTAyMzJdXSwgWydEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzRdXSwgWydEb3VibGVMb25nUmlnaHRBcnJvdycsIFsxMDIzM11dLCBbJ0RvdWJsZVJpZ2h0QXJyb3cnLCBbODY1OF1dLCBbJ0RvdWJsZVJpZ2h0VGVlJywgWzg4NzJdXSwgWydEb3VibGVVcEFycm93JywgWzg2NTddXSwgWydEb3VibGVVcERvd25BcnJvdycsIFs4NjYxXV0sIFsnRG91YmxlVmVydGljYWxCYXInLCBbODc0MV1dLCBbJ0Rvd25BcnJvd0JhcicsIFsxMDUxNV1dLCBbJ2Rvd25hcnJvdycsIFs4NTk1XV0sIFsnRG93bkFycm93JywgWzg1OTVdXSwgWydEb3duYXJyb3cnLCBbODY1OV1dLCBbJ0Rvd25BcnJvd1VwQXJyb3cnLCBbODY5M11dLCBbJ0Rvd25CcmV2ZScsIFs3ODVdXSwgWydkb3duZG93bmFycm93cycsIFs4NjUwXV0sIFsnZG93bmhhcnBvb25sZWZ0JywgWzg2NDNdXSwgWydkb3duaGFycG9vbnJpZ2h0JywgWzg2NDJdXSwgWydEb3duTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc2XV0sIFsnRG93bkxlZnRUZWVWZWN0b3InLCBbMTA1OTBdXSwgWydEb3duTGVmdFZlY3RvckJhcicsIFsxMDU4Ml1dLCBbJ0Rvd25MZWZ0VmVjdG9yJywgWzg2MzddXSwgWydEb3duUmlnaHRUZWVWZWN0b3InLCBbMTA1OTFdXSwgWydEb3duUmlnaHRWZWN0b3JCYXInLCBbMTA1ODNdXSwgWydEb3duUmlnaHRWZWN0b3InLCBbODY0MV1dLCBbJ0Rvd25UZWVBcnJvdycsIFs4NjE1XV0sIFsnRG93blRlZScsIFs4ODY4XV0sIFsnZHJia2Fyb3cnLCBbMTA1MTJdXSwgWydkcmNvcm4nLCBbODk5MV1dLCBbJ2RyY3JvcCcsIFs4OTcyXV0sIFsnRHNjcicsIFsxMTk5NjddXSwgWydkc2NyJywgWzExOTk5M11dLCBbJ0RTY3knLCBbMTAyOV1dLCBbJ2RzY3knLCBbMTEwOV1dLCBbJ2Rzb2wnLCBbMTA3NDJdXSwgWydEc3Ryb2snLCBbMjcyXV0sIFsnZHN0cm9rJywgWzI3M11dLCBbJ2R0ZG90JywgWzg5NDVdXSwgWydkdHJpJywgWzk2NjNdXSwgWydkdHJpZicsIFs5NjYyXV0sIFsnZHVhcnInLCBbODY5M11dLCBbJ2R1aGFyJywgWzEwNjA3XV0sIFsnZHdhbmdsZScsIFsxMDY2Ml1dLCBbJ0RaY3knLCBbMTAzOV1dLCBbJ2R6Y3knLCBbMTExOV1dLCBbJ2R6aWdyYXJyJywgWzEwMjM5XV0sIFsnRWFjdXRlJywgWzIwMV1dLCBbJ2VhY3V0ZScsIFsyMzNdXSwgWydlYXN0ZXInLCBbMTA4NjJdXSwgWydFY2Fyb24nLCBbMjgyXV0sIFsnZWNhcm9uJywgWzI4M11dLCBbJ0VjaXJjJywgWzIwMl1dLCBbJ2VjaXJjJywgWzIzNF1dLCBbJ2VjaXInLCBbODc5MF1dLCBbJ2Vjb2xvbicsIFs4Nzg5XV0sIFsnRWN5JywgWzEwNjldXSwgWydlY3knLCBbMTEwMV1dLCBbJ2VERG90JywgWzEwODcxXV0sIFsnRWRvdCcsIFsyNzhdXSwgWydlZG90JywgWzI3OV1dLCBbJ2VEb3QnLCBbODc4NV1dLCBbJ2VlJywgWzg1MTldXSwgWydlZkRvdCcsIFs4Nzg2XV0sIFsnRWZyJywgWzEyMDA3Ml1dLCBbJ2VmcicsIFsxMjAwOThdXSwgWydlZycsIFsxMDkwNl1dLCBbJ0VncmF2ZScsIFsyMDBdXSwgWydlZ3JhdmUnLCBbMjMyXV0sIFsnZWdzJywgWzEwOTAyXV0sIFsnZWdzZG90JywgWzEwOTA0XV0sIFsnZWwnLCBbMTA5MDVdXSwgWydFbGVtZW50JywgWzg3MTJdXSwgWydlbGludGVycycsIFs5MTkxXV0sIFsnZWxsJywgWzg0NjddXSwgWydlbHMnLCBbMTA5MDFdXSwgWydlbHNkb3QnLCBbMTA5MDNdXSwgWydFbWFjcicsIFsyNzRdXSwgWydlbWFjcicsIFsyNzVdXSwgWydlbXB0eScsIFs4NzA5XV0sIFsnZW1wdHlzZXQnLCBbODcwOV1dLCBbJ0VtcHR5U21hbGxTcXVhcmUnLCBbOTcyM11dLCBbJ2VtcHR5dicsIFs4NzA5XV0sIFsnRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCBbOTY0M11dLCBbJ2Vtc3AxMycsIFs4MTk2XV0sIFsnZW1zcDE0JywgWzgxOTddXSwgWydlbXNwJywgWzgxOTVdXSwgWydFTkcnLCBbMzMwXV0sIFsnZW5nJywgWzMzMV1dLCBbJ2Vuc3AnLCBbODE5NF1dLCBbJ0VvZ29uJywgWzI4MF1dLCBbJ2VvZ29uJywgWzI4MV1dLCBbJ0VvcGYnLCBbMTIwMTI0XV0sIFsnZW9wZicsIFsxMjAxNTBdXSwgWydlcGFyJywgWzg5MTddXSwgWydlcGFyc2wnLCBbMTA3MjNdXSwgWydlcGx1cycsIFsxMDg2NV1dLCBbJ2Vwc2knLCBbOTQ5XV0sIFsnRXBzaWxvbicsIFs5MTddXSwgWydlcHNpbG9uJywgWzk0OV1dLCBbJ2Vwc2l2JywgWzEwMTNdXSwgWydlcWNpcmMnLCBbODc5MF1dLCBbJ2VxY29sb24nLCBbODc4OV1dLCBbJ2Vxc2ltJywgWzg3NzBdXSwgWydlcXNsYW50Z3RyJywgWzEwOTAyXV0sIFsnZXFzbGFudGxlc3MnLCBbMTA5MDFdXSwgWydFcXVhbCcsIFsxMDg2OV1dLCBbJ2VxdWFscycsIFs2MV1dLCBbJ0VxdWFsVGlsZGUnLCBbODc3MF1dLCBbJ2VxdWVzdCcsIFs4Nzk5XV0sIFsnRXF1aWxpYnJpdW0nLCBbODY1Ml1dLCBbJ2VxdWl2JywgWzg4MDFdXSwgWydlcXVpdkREJywgWzEwODcyXV0sIFsnZXF2cGFyc2wnLCBbMTA3MjVdXSwgWydlcmFycicsIFsxMDYwOV1dLCBbJ2VyRG90JywgWzg3ODddXSwgWydlc2NyJywgWzg0OTVdXSwgWydFc2NyJywgWzg0OTZdXSwgWydlc2RvdCcsIFs4Nzg0XV0sIFsnRXNpbScsIFsxMDg2N11dLCBbJ2VzaW0nLCBbODc3MF1dLCBbJ0V0YScsIFs5MTldXSwgWydldGEnLCBbOTUxXV0sIFsnRVRIJywgWzIwOF1dLCBbJ2V0aCcsIFsyNDBdXSwgWydFdW1sJywgWzIwM11dLCBbJ2V1bWwnLCBbMjM1XV0sIFsnZXVybycsIFs4MzY0XV0sIFsnZXhjbCcsIFszM11dLCBbJ2V4aXN0JywgWzg3MDddXSwgWydFeGlzdHMnLCBbODcwN11dLCBbJ2V4cGVjdGF0aW9uJywgWzg0OTZdXSwgWydleHBvbmVudGlhbGUnLCBbODUxOV1dLCBbJ0V4cG9uZW50aWFsRScsIFs4NTE5XV0sIFsnZmFsbGluZ2RvdHNlcScsIFs4Nzg2XV0sIFsnRmN5JywgWzEwNjBdXSwgWydmY3knLCBbMTA5Ml1dLCBbJ2ZlbWFsZScsIFs5NzkyXV0sIFsnZmZpbGlnJywgWzY0MjU5XV0sIFsnZmZsaWcnLCBbNjQyNTZdXSwgWydmZmxsaWcnLCBbNjQyNjBdXSwgWydGZnInLCBbMTIwMDczXV0sIFsnZmZyJywgWzEyMDA5OV1dLCBbJ2ZpbGlnJywgWzY0MjU3XV0sIFsnRmlsbGVkU21hbGxTcXVhcmUnLCBbOTcyNF1dLCBbJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZScsIFs5NjQyXV0sIFsnZmpsaWcnLCBbMTAyLCAxMDZdXSwgWydmbGF0JywgWzk4MzddXSwgWydmbGxpZycsIFs2NDI1OF1dLCBbJ2ZsdG5zJywgWzk2NDldXSwgWydmbm9mJywgWzQwMl1dLCBbJ0ZvcGYnLCBbMTIwMTI1XV0sIFsnZm9wZicsIFsxMjAxNTFdXSwgWydmb3JhbGwnLCBbODcwNF1dLCBbJ0ZvckFsbCcsIFs4NzA0XV0sIFsnZm9yaycsIFs4OTE2XV0sIFsnZm9ya3YnLCBbMTA5NjldXSwgWydGb3VyaWVydHJmJywgWzg0OTddXSwgWydmcGFydGludCcsIFsxMDc2NV1dLCBbJ2ZyYWMxMicsIFsxODldXSwgWydmcmFjMTMnLCBbODUzMV1dLCBbJ2ZyYWMxNCcsIFsxODhdXSwgWydmcmFjMTUnLCBbODUzM11dLCBbJ2ZyYWMxNicsIFs4NTM3XV0sIFsnZnJhYzE4JywgWzg1MzldXSwgWydmcmFjMjMnLCBbODUzMl1dLCBbJ2ZyYWMyNScsIFs4NTM0XV0sIFsnZnJhYzM0JywgWzE5MF1dLCBbJ2ZyYWMzNScsIFs4NTM1XV0sIFsnZnJhYzM4JywgWzg1NDBdXSwgWydmcmFjNDUnLCBbODUzNl1dLCBbJ2ZyYWM1NicsIFs4NTM4XV0sIFsnZnJhYzU4JywgWzg1NDFdXSwgWydmcmFjNzgnLCBbODU0Ml1dLCBbJ2ZyYXNsJywgWzgyNjBdXSwgWydmcm93bicsIFs4OTk0XV0sIFsnZnNjcicsIFsxMTk5OTVdXSwgWydGc2NyJywgWzg0OTddXSwgWydnYWN1dGUnLCBbNTAxXV0sIFsnR2FtbWEnLCBbOTE1XV0sIFsnZ2FtbWEnLCBbOTQ3XV0sIFsnR2FtbWFkJywgWzk4OF1dLCBbJ2dhbW1hZCcsIFs5ODldXSwgWydnYXAnLCBbMTA4ODZdXSwgWydHYnJldmUnLCBbMjg2XV0sIFsnZ2JyZXZlJywgWzI4N11dLCBbJ0djZWRpbCcsIFsyOTBdXSwgWydHY2lyYycsIFsyODRdXSwgWydnY2lyYycsIFsyODVdXSwgWydHY3knLCBbMTA0M11dLCBbJ2djeScsIFsxMDc1XV0sIFsnR2RvdCcsIFsyODhdXSwgWydnZG90JywgWzI4OV1dLCBbJ2dlJywgWzg4MDVdXSwgWydnRScsIFs4ODA3XV0sIFsnZ0VsJywgWzEwODkyXV0sIFsnZ2VsJywgWzg5MjNdXSwgWydnZXEnLCBbODgwNV1dLCBbJ2dlcXEnLCBbODgwN11dLCBbJ2dlcXNsYW50JywgWzEwODc4XV0sIFsnZ2VzY2MnLCBbMTA5MjFdXSwgWydnZXMnLCBbMTA4NzhdXSwgWydnZXNkb3QnLCBbMTA4ODBdXSwgWydnZXNkb3RvJywgWzEwODgyXV0sIFsnZ2VzZG90b2wnLCBbMTA4ODRdXSwgWydnZXNsJywgWzg5MjMsIDY1MDI0XV0sIFsnZ2VzbGVzJywgWzEwOTAwXV0sIFsnR2ZyJywgWzEyMDA3NF1dLCBbJ2dmcicsIFsxMjAxMDBdXSwgWydnZycsIFs4ODExXV0sIFsnR2cnLCBbODkyMV1dLCBbJ2dnZycsIFs4OTIxXV0sIFsnZ2ltZWwnLCBbODUwM11dLCBbJ0dKY3knLCBbMTAyN11dLCBbJ2dqY3knLCBbMTEwN11dLCBbJ2dsYScsIFsxMDkxN11dLCBbJ2dsJywgWzg4MjNdXSwgWydnbEUnLCBbMTA4OThdXSwgWydnbGonLCBbMTA5MTZdXSwgWydnbmFwJywgWzEwODkwXV0sIFsnZ25hcHByb3gnLCBbMTA4OTBdXSwgWydnbmUnLCBbMTA4ODhdXSwgWydnbkUnLCBbODgwOV1dLCBbJ2duZXEnLCBbMTA4ODhdXSwgWydnbmVxcScsIFs4ODA5XV0sIFsnZ25zaW0nLCBbODkzNV1dLCBbJ0dvcGYnLCBbMTIwMTI2XV0sIFsnZ29wZicsIFsxMjAxNTJdXSwgWydncmF2ZScsIFs5Nl1dLCBbJ0dyZWF0ZXJFcXVhbCcsIFs4ODA1XV0sIFsnR3JlYXRlckVxdWFsTGVzcycsIFs4OTIzXV0sIFsnR3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3XV0sIFsnR3JlYXRlckdyZWF0ZXInLCBbMTA5MTRdXSwgWydHcmVhdGVyTGVzcycsIFs4ODIzXV0sIFsnR3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzhdXSwgWydHcmVhdGVyVGlsZGUnLCBbODgxOV1dLCBbJ0dzY3InLCBbMTE5OTcwXV0sIFsnZ3NjcicsIFs4NDU4XV0sIFsnZ3NpbScsIFs4ODE5XV0sIFsnZ3NpbWUnLCBbMTA4OTRdXSwgWydnc2ltbCcsIFsxMDg5Nl1dLCBbJ2d0Y2MnLCBbMTA5MTldXSwgWydndGNpcicsIFsxMDg3NF1dLCBbJ2d0JywgWzYyXV0sIFsnR1QnLCBbNjJdXSwgWydHdCcsIFs4ODExXV0sIFsnZ3Rkb3QnLCBbODkxOV1dLCBbJ2d0bFBhcicsIFsxMDY0NV1dLCBbJ2d0cXVlc3QnLCBbMTA4NzZdXSwgWydndHJhcHByb3gnLCBbMTA4ODZdXSwgWydndHJhcnInLCBbMTA2MTZdXSwgWydndHJkb3QnLCBbODkxOV1dLCBbJ2d0cmVxbGVzcycsIFs4OTIzXV0sIFsnZ3RyZXFxbGVzcycsIFsxMDg5Ml1dLCBbJ2d0cmxlc3MnLCBbODgyM11dLCBbJ2d0cnNpbScsIFs4ODE5XV0sIFsnZ3ZlcnRuZXFxJywgWzg4MDksIDY1MDI0XV0sIFsnZ3ZuRScsIFs4ODA5LCA2NTAyNF1dLCBbJ0hhY2VrJywgWzcxMV1dLCBbJ2hhaXJzcCcsIFs4MjAyXV0sIFsnaGFsZicsIFsxODldXSwgWydoYW1pbHQnLCBbODQ1OV1dLCBbJ0hBUkRjeScsIFsxMDY2XV0sIFsnaGFyZGN5JywgWzEwOThdXSwgWydoYXJyY2lyJywgWzEwNTY4XV0sIFsnaGFycicsIFs4NTk2XV0sIFsnaEFycicsIFs4NjYwXV0sIFsnaGFycncnLCBbODYyMV1dLCBbJ0hhdCcsIFs5NF1dLCBbJ2hiYXInLCBbODQ2M11dLCBbJ0hjaXJjJywgWzI5Ml1dLCBbJ2hjaXJjJywgWzI5M11dLCBbJ2hlYXJ0cycsIFs5ODI5XV0sIFsnaGVhcnRzdWl0JywgWzk4MjldXSwgWydoZWxsaXAnLCBbODIzMF1dLCBbJ2hlcmNvbicsIFs4ODg5XV0sIFsnaGZyJywgWzEyMDEwMV1dLCBbJ0hmcicsIFs4NDYwXV0sIFsnSGlsYmVydFNwYWNlJywgWzg0NTldXSwgWydoa3NlYXJvdycsIFsxMDUzM11dLCBbJ2hrc3dhcm93JywgWzEwNTM0XV0sIFsnaG9hcnInLCBbODcwM11dLCBbJ2hvbXRodCcsIFs4NzYzXV0sIFsnaG9va2xlZnRhcnJvdycsIFs4NjE3XV0sIFsnaG9va3JpZ2h0YXJyb3cnLCBbODYxOF1dLCBbJ2hvcGYnLCBbMTIwMTUzXV0sIFsnSG9wZicsIFs4NDYxXV0sIFsnaG9yYmFyJywgWzgyMTNdXSwgWydIb3Jpem9udGFsTGluZScsIFs5NDcyXV0sIFsnaHNjcicsIFsxMTk5OTddXSwgWydIc2NyJywgWzg0NTldXSwgWydoc2xhc2gnLCBbODQ2M11dLCBbJ0hzdHJvaycsIFsyOTRdXSwgWydoc3Ryb2snLCBbMjk1XV0sIFsnSHVtcERvd25IdW1wJywgWzg3ODJdXSwgWydIdW1wRXF1YWwnLCBbODc4M11dLCBbJ2h5YnVsbCcsIFs4MjU5XV0sIFsnaHlwaGVuJywgWzgyMDhdXSwgWydJYWN1dGUnLCBbMjA1XV0sIFsnaWFjdXRlJywgWzIzN11dLCBbJ2ljJywgWzgyOTFdXSwgWydJY2lyYycsIFsyMDZdXSwgWydpY2lyYycsIFsyMzhdXSwgWydJY3knLCBbMTA0OF1dLCBbJ2ljeScsIFsxMDgwXV0sIFsnSWRvdCcsIFszMDRdXSwgWydJRWN5JywgWzEwNDVdXSwgWydpZWN5JywgWzEwNzddXSwgWydpZXhjbCcsIFsxNjFdXSwgWydpZmYnLCBbODY2MF1dLCBbJ2lmcicsIFsxMjAxMDJdXSwgWydJZnInLCBbODQ2NV1dLCBbJ0lncmF2ZScsIFsyMDRdXSwgWydpZ3JhdmUnLCBbMjM2XV0sIFsnaWknLCBbODUyMF1dLCBbJ2lpaWludCcsIFsxMDc2NF1dLCBbJ2lpaW50JywgWzg3NDldXSwgWydpaW5maW4nLCBbMTA3MTZdXSwgWydpaW90YScsIFs4NDg5XV0sIFsnSUpsaWcnLCBbMzA2XV0sIFsnaWpsaWcnLCBbMzA3XV0sIFsnSW1hY3InLCBbMjk4XV0sIFsnaW1hY3InLCBbMjk5XV0sIFsnaW1hZ2UnLCBbODQ2NV1dLCBbJ0ltYWdpbmFyeUknLCBbODUyMF1dLCBbJ2ltYWdsaW5lJywgWzg0NjRdXSwgWydpbWFncGFydCcsIFs4NDY1XV0sIFsnaW1hdGgnLCBbMzA1XV0sIFsnSW0nLCBbODQ2NV1dLCBbJ2ltb2YnLCBbODg4N11dLCBbJ2ltcGVkJywgWzQzN11dLCBbJ0ltcGxpZXMnLCBbODY1OF1dLCBbJ2luY2FyZScsIFs4NDUzXV0sIFsnaW4nLCBbODcxMl1dLCBbJ2luZmluJywgWzg3MzRdXSwgWydpbmZpbnRpZScsIFsxMDcxN11dLCBbJ2lub2RvdCcsIFszMDVdXSwgWydpbnRjYWwnLCBbODg5MF1dLCBbJ2ludCcsIFs4NzQ3XV0sIFsnSW50JywgWzg3NDhdXSwgWydpbnRlZ2VycycsIFs4NDg0XV0sIFsnSW50ZWdyYWwnLCBbODc0N11dLCBbJ2ludGVyY2FsJywgWzg4OTBdXSwgWydJbnRlcnNlY3Rpb24nLCBbODg5OF1dLCBbJ2ludGxhcmhrJywgWzEwNzc1XV0sIFsnaW50cHJvZCcsIFsxMDgxMl1dLCBbJ0ludmlzaWJsZUNvbW1hJywgWzgyOTFdXSwgWydJbnZpc2libGVUaW1lcycsIFs4MjkwXV0sIFsnSU9jeScsIFsxMDI1XV0sIFsnaW9jeScsIFsxMTA1XV0sIFsnSW9nb24nLCBbMzAyXV0sIFsnaW9nb24nLCBbMzAzXV0sIFsnSW9wZicsIFsxMjAxMjhdXSwgWydpb3BmJywgWzEyMDE1NF1dLCBbJ0lvdGEnLCBbOTIxXV0sIFsnaW90YScsIFs5NTNdXSwgWydpcHJvZCcsIFsxMDgxMl1dLCBbJ2lxdWVzdCcsIFsxOTFdXSwgWydpc2NyJywgWzExOTk5OF1dLCBbJ0lzY3InLCBbODQ2NF1dLCBbJ2lzaW4nLCBbODcxMl1dLCBbJ2lzaW5kb3QnLCBbODk0OV1dLCBbJ2lzaW5FJywgWzg5NTNdXSwgWydpc2lucycsIFs4OTQ4XV0sIFsnaXNpbnN2JywgWzg5NDddXSwgWydpc2ludicsIFs4NzEyXV0sIFsnaXQnLCBbODI5MF1dLCBbJ0l0aWxkZScsIFsyOTZdXSwgWydpdGlsZGUnLCBbMjk3XV0sIFsnSXVrY3knLCBbMTAzMF1dLCBbJ2l1a2N5JywgWzExMTBdXSwgWydJdW1sJywgWzIwN11dLCBbJ2l1bWwnLCBbMjM5XV0sIFsnSmNpcmMnLCBbMzA4XV0sIFsnamNpcmMnLCBbMzA5XV0sIFsnSmN5JywgWzEwNDldXSwgWydqY3knLCBbMTA4MV1dLCBbJ0pmcicsIFsxMjAwNzddXSwgWydqZnInLCBbMTIwMTAzXV0sIFsnam1hdGgnLCBbNTY3XV0sIFsnSm9wZicsIFsxMjAxMjldXSwgWydqb3BmJywgWzEyMDE1NV1dLCBbJ0pzY3InLCBbMTE5OTczXV0sIFsnanNjcicsIFsxMTk5OTldXSwgWydKc2VyY3knLCBbMTAzMl1dLCBbJ2pzZXJjeScsIFsxMTEyXV0sIFsnSnVrY3knLCBbMTAyOF1dLCBbJ2p1a2N5JywgWzExMDhdXSwgWydLYXBwYScsIFs5MjJdXSwgWydrYXBwYScsIFs5NTRdXSwgWydrYXBwYXYnLCBbMTAwOF1dLCBbJ0tjZWRpbCcsIFszMTBdXSwgWydrY2VkaWwnLCBbMzExXV0sIFsnS2N5JywgWzEwNTBdXSwgWydrY3knLCBbMTA4Ml1dLCBbJ0tmcicsIFsxMjAwNzhdXSwgWydrZnInLCBbMTIwMTA0XV0sIFsna2dyZWVuJywgWzMxMl1dLCBbJ0tIY3knLCBbMTA2MV1dLCBbJ2toY3knLCBbMTA5M11dLCBbJ0tKY3knLCBbMTAzNl1dLCBbJ2tqY3knLCBbMTExNl1dLCBbJ0tvcGYnLCBbMTIwMTMwXV0sIFsna29wZicsIFsxMjAxNTZdXSwgWydLc2NyJywgWzExOTk3NF1dLCBbJ2tzY3InLCBbMTIwMDAwXV0sIFsnbEFhcnInLCBbODY2Nl1dLCBbJ0xhY3V0ZScsIFszMTNdXSwgWydsYWN1dGUnLCBbMzE0XV0sIFsnbGFlbXB0eXYnLCBbMTA2NzZdXSwgWydsYWdyYW4nLCBbODQ2Nl1dLCBbJ0xhbWJkYScsIFs5MjNdXSwgWydsYW1iZGEnLCBbOTU1XV0sIFsnbGFuZycsIFsxMDIxNl1dLCBbJ0xhbmcnLCBbMTAyMThdXSwgWydsYW5nZCcsIFsxMDY0MV1dLCBbJ2xhbmdsZScsIFsxMDIxNl1dLCBbJ2xhcCcsIFsxMDg4NV1dLCBbJ0xhcGxhY2V0cmYnLCBbODQ2Nl1dLCBbJ2xhcXVvJywgWzE3MV1dLCBbJ2xhcnJiJywgWzg2NzZdXSwgWydsYXJyYmZzJywgWzEwNTI3XV0sIFsnbGFycicsIFs4NTkyXV0sIFsnTGFycicsIFs4NjA2XV0sIFsnbEFycicsIFs4NjU2XV0sIFsnbGFycmZzJywgWzEwNTI1XV0sIFsnbGFycmhrJywgWzg2MTddXSwgWydsYXJybHAnLCBbODYxOV1dLCBbJ2xhcnJwbCcsIFsxMDU1M11dLCBbJ2xhcnJzaW0nLCBbMTA2MTFdXSwgWydsYXJydGwnLCBbODYxMF1dLCBbJ2xhdGFpbCcsIFsxMDUyMV1dLCBbJ2xBdGFpbCcsIFsxMDUyM11dLCBbJ2xhdCcsIFsxMDkyM11dLCBbJ2xhdGUnLCBbMTA5MjVdXSwgWydsYXRlcycsIFsxMDkyNSwgNjUwMjRdXSwgWydsYmFycicsIFsxMDUwOF1dLCBbJ2xCYXJyJywgWzEwNTEwXV0sIFsnbGJicmsnLCBbMTAwOThdXSwgWydsYnJhY2UnLCBbMTIzXV0sIFsnbGJyYWNrJywgWzkxXV0sIFsnbGJya2UnLCBbMTA2MzVdXSwgWydsYnJrc2xkJywgWzEwNjM5XV0sIFsnbGJya3NsdScsIFsxMDYzN11dLCBbJ0xjYXJvbicsIFszMTddXSwgWydsY2Fyb24nLCBbMzE4XV0sIFsnTGNlZGlsJywgWzMxNV1dLCBbJ2xjZWRpbCcsIFszMTZdXSwgWydsY2VpbCcsIFs4OTY4XV0sIFsnbGN1YicsIFsxMjNdXSwgWydMY3knLCBbMTA1MV1dLCBbJ2xjeScsIFsxMDgzXV0sIFsnbGRjYScsIFsxMDU1MF1dLCBbJ2xkcXVvJywgWzgyMjBdXSwgWydsZHF1b3InLCBbODIyMl1dLCBbJ2xkcmRoYXInLCBbMTA1OTldXSwgWydsZHJ1c2hhcicsIFsxMDU3MV1dLCBbJ2xkc2gnLCBbODYyNl1dLCBbJ2xlJywgWzg4MDRdXSwgWydsRScsIFs4ODA2XV0sIFsnTGVmdEFuZ2xlQnJhY2tldCcsIFsxMDIxNl1dLCBbJ0xlZnRBcnJvd0JhcicsIFs4Njc2XV0sIFsnbGVmdGFycm93JywgWzg1OTJdXSwgWydMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRhcnJvdycsIFs4NjU2XV0sIFsnTGVmdEFycm93UmlnaHRBcnJvdycsIFs4NjQ2XV0sIFsnbGVmdGFycm93dGFpbCcsIFs4NjEwXV0sIFsnTGVmdENlaWxpbmcnLCBbODk2OF1dLCBbJ0xlZnREb3VibGVCcmFja2V0JywgWzEwMjE0XV0sIFsnTGVmdERvd25UZWVWZWN0b3InLCBbMTA1OTNdXSwgWydMZWZ0RG93blZlY3RvckJhcicsIFsxMDU4NV1dLCBbJ0xlZnREb3duVmVjdG9yJywgWzg2NDNdXSwgWydMZWZ0Rmxvb3InLCBbODk3MF1dLCBbJ2xlZnRoYXJwb29uZG93bicsIFs4NjM3XV0sIFsnbGVmdGhhcnBvb251cCcsIFs4NjM2XV0sIFsnbGVmdGxlZnRhcnJvd3MnLCBbODY0N11dLCBbJ2xlZnRyaWdodGFycm93JywgWzg1OTZdXSwgWydMZWZ0UmlnaHRBcnJvdycsIFs4NTk2XV0sIFsnTGVmdHJpZ2h0YXJyb3cnLCBbODY2MF1dLCBbJ2xlZnRyaWdodGFycm93cycsIFs4NjQ2XV0sIFsnbGVmdHJpZ2h0aGFycG9vbnMnLCBbODY1MV1dLCBbJ2xlZnRyaWdodHNxdWlnYXJyb3cnLCBbODYyMV1dLCBbJ0xlZnRSaWdodFZlY3RvcicsIFsxMDU3NF1dLCBbJ0xlZnRUZWVBcnJvdycsIFs4NjEyXV0sIFsnTGVmdFRlZScsIFs4ODY3XV0sIFsnTGVmdFRlZVZlY3RvcicsIFsxMDU4Nl1dLCBbJ2xlZnR0aHJlZXRpbWVzJywgWzg5MDddXSwgWydMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDNdXSwgWydMZWZ0VHJpYW5nbGUnLCBbODg4Ml1dLCBbJ0xlZnRUcmlhbmdsZUVxdWFsJywgWzg4ODRdXSwgWydMZWZ0VXBEb3duVmVjdG9yJywgWzEwNTc3XV0sIFsnTGVmdFVwVGVlVmVjdG9yJywgWzEwNTkyXV0sIFsnTGVmdFVwVmVjdG9yQmFyJywgWzEwNTg0XV0sIFsnTGVmdFVwVmVjdG9yJywgWzg2MzldXSwgWydMZWZ0VmVjdG9yQmFyJywgWzEwNTc4XV0sIFsnTGVmdFZlY3RvcicsIFs4NjM2XV0sIFsnbEVnJywgWzEwODkxXV0sIFsnbGVnJywgWzg5MjJdXSwgWydsZXEnLCBbODgwNF1dLCBbJ2xlcXEnLCBbODgwNl1dLCBbJ2xlcXNsYW50JywgWzEwODc3XV0sIFsnbGVzY2MnLCBbMTA5MjBdXSwgWydsZXMnLCBbMTA4NzddXSwgWydsZXNkb3QnLCBbMTA4NzldXSwgWydsZXNkb3RvJywgWzEwODgxXV0sIFsnbGVzZG90b3InLCBbMTA4ODNdXSwgWydsZXNnJywgWzg5MjIsIDY1MDI0XV0sIFsnbGVzZ2VzJywgWzEwODk5XV0sIFsnbGVzc2FwcHJveCcsIFsxMDg4NV1dLCBbJ2xlc3Nkb3QnLCBbODkxOF1dLCBbJ2xlc3NlcWd0cicsIFs4OTIyXV0sIFsnbGVzc2VxcWd0cicsIFsxMDg5MV1dLCBbJ0xlc3NFcXVhbEdyZWF0ZXInLCBbODkyMl1dLCBbJ0xlc3NGdWxsRXF1YWwnLCBbODgwNl1dLCBbJ0xlc3NHcmVhdGVyJywgWzg4MjJdXSwgWydsZXNzZ3RyJywgWzg4MjJdXSwgWydMZXNzTGVzcycsIFsxMDkxM11dLCBbJ2xlc3NzaW0nLCBbODgxOF1dLCBbJ0xlc3NTbGFudEVxdWFsJywgWzEwODc3XV0sIFsnTGVzc1RpbGRlJywgWzg4MThdXSwgWydsZmlzaHQnLCBbMTA2MjBdXSwgWydsZmxvb3InLCBbODk3MF1dLCBbJ0xmcicsIFsxMjAwNzldXSwgWydsZnInLCBbMTIwMTA1XV0sIFsnbGcnLCBbODgyMl1dLCBbJ2xnRScsIFsxMDg5N11dLCBbJ2xIYXInLCBbMTA1OTRdXSwgWydsaGFyZCcsIFs4NjM3XV0sIFsnbGhhcnUnLCBbODYzNl1dLCBbJ2xoYXJ1bCcsIFsxMDYwMl1dLCBbJ2xoYmxrJywgWzk2MDRdXSwgWydMSmN5JywgWzEwMzNdXSwgWydsamN5JywgWzExMTNdXSwgWydsbGFycicsIFs4NjQ3XV0sIFsnbGwnLCBbODgxMF1dLCBbJ0xsJywgWzg5MjBdXSwgWydsbGNvcm5lcicsIFs4OTkwXV0sIFsnTGxlZnRhcnJvdycsIFs4NjY2XV0sIFsnbGxoYXJkJywgWzEwNjAzXV0sIFsnbGx0cmknLCBbOTcyMl1dLCBbJ0xtaWRvdCcsIFszMTldXSwgWydsbWlkb3QnLCBbMzIwXV0sIFsnbG1vdXN0YWNoZScsIFs5MTM2XV0sIFsnbG1vdXN0JywgWzkxMzZdXSwgWydsbmFwJywgWzEwODg5XV0sIFsnbG5hcHByb3gnLCBbMTA4ODldXSwgWydsbmUnLCBbMTA4ODddXSwgWydsbkUnLCBbODgwOF1dLCBbJ2xuZXEnLCBbMTA4ODddXSwgWydsbmVxcScsIFs4ODA4XV0sIFsnbG5zaW0nLCBbODkzNF1dLCBbJ2xvYW5nJywgWzEwMjIwXV0sIFsnbG9hcnInLCBbODcwMV1dLCBbJ2xvYnJrJywgWzEwMjE0XV0sIFsnbG9uZ2xlZnRhcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdMZWZ0QXJyb3cnLCBbMTAyMjldXSwgWydMb25nbGVmdGFycm93JywgWzEwMjMyXV0sIFsnbG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjMxXV0sIFsnTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjMxXV0sIFsnTG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjM0XV0sIFsnbG9uZ21hcHN0bycsIFsxMDIzNl1dLCBbJ2xvbmdyaWdodGFycm93JywgWzEwMjMwXV0sIFsnTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzBdXSwgWydMb25ncmlnaHRhcnJvdycsIFsxMDIzM11dLCBbJ2xvb3BhcnJvd2xlZnQnLCBbODYxOV1dLCBbJ2xvb3BhcnJvd3JpZ2h0JywgWzg2MjBdXSwgWydsb3BhcicsIFsxMDYyOV1dLCBbJ0xvcGYnLCBbMTIwMTMxXV0sIFsnbG9wZicsIFsxMjAxNTddXSwgWydsb3BsdXMnLCBbMTA3OTddXSwgWydsb3RpbWVzJywgWzEwODA0XV0sIFsnbG93YXN0JywgWzg3MjddXSwgWydsb3diYXInLCBbOTVdXSwgWydMb3dlckxlZnRBcnJvdycsIFs4NjAxXV0sIFsnTG93ZXJSaWdodEFycm93JywgWzg2MDBdXSwgWydsb3onLCBbOTY3NF1dLCBbJ2xvemVuZ2UnLCBbOTY3NF1dLCBbJ2xvemYnLCBbMTA3MzFdXSwgWydscGFyJywgWzQwXV0sIFsnbHBhcmx0JywgWzEwNjQzXV0sIFsnbHJhcnInLCBbODY0Nl1dLCBbJ2xyY29ybmVyJywgWzg5OTFdXSwgWydscmhhcicsIFs4NjUxXV0sIFsnbHJoYXJkJywgWzEwNjA1XV0sIFsnbHJtJywgWzgyMDZdXSwgWydscnRyaScsIFs4ODk1XV0sIFsnbHNhcXVvJywgWzgyNDldXSwgWydsc2NyJywgWzEyMDAwMV1dLCBbJ0xzY3InLCBbODQ2Nl1dLCBbJ2xzaCcsIFs4NjI0XV0sIFsnTHNoJywgWzg2MjRdXSwgWydsc2ltJywgWzg4MThdXSwgWydsc2ltZScsIFsxMDg5M11dLCBbJ2xzaW1nJywgWzEwODk1XV0sIFsnbHNxYicsIFs5MV1dLCBbJ2xzcXVvJywgWzgyMTZdXSwgWydsc3F1b3InLCBbODIxOF1dLCBbJ0xzdHJvaycsIFszMjFdXSwgWydsc3Ryb2snLCBbMzIyXV0sIFsnbHRjYycsIFsxMDkxOF1dLCBbJ2x0Y2lyJywgWzEwODczXV0sIFsnbHQnLCBbNjBdXSwgWydMVCcsIFs2MF1dLCBbJ0x0JywgWzg4MTBdXSwgWydsdGRvdCcsIFs4OTE4XV0sIFsnbHRocmVlJywgWzg5MDddXSwgWydsdGltZXMnLCBbODkwNV1dLCBbJ2x0bGFycicsIFsxMDYxNF1dLCBbJ2x0cXVlc3QnLCBbMTA4NzVdXSwgWydsdHJpJywgWzk2NjddXSwgWydsdHJpZScsIFs4ODg0XV0sIFsnbHRyaWYnLCBbOTY2Nl1dLCBbJ2x0clBhcicsIFsxMDY0Nl1dLCBbJ2x1cmRzaGFyJywgWzEwNTcwXV0sIFsnbHVydWhhcicsIFsxMDU5OF1dLCBbJ2x2ZXJ0bmVxcScsIFs4ODA4LCA2NTAyNF1dLCBbJ2x2bkUnLCBbODgwOCwgNjUwMjRdXSwgWydtYWNyJywgWzE3NV1dLCBbJ21hbGUnLCBbOTc5NF1dLCBbJ21hbHQnLCBbMTAwMTZdXSwgWydtYWx0ZXNlJywgWzEwMDE2XV0sIFsnTWFwJywgWzEwNTAxXV0sIFsnbWFwJywgWzg2MTRdXSwgWydtYXBzdG8nLCBbODYxNF1dLCBbJ21hcHN0b2Rvd24nLCBbODYxNV1dLCBbJ21hcHN0b2xlZnQnLCBbODYxMl1dLCBbJ21hcHN0b3VwJywgWzg2MTNdXSwgWydtYXJrZXInLCBbOTY0Nl1dLCBbJ21jb21tYScsIFsxMDc5M11dLCBbJ01jeScsIFsxMDUyXV0sIFsnbWN5JywgWzEwODRdXSwgWydtZGFzaCcsIFs4MjEyXV0sIFsnbUREb3QnLCBbODc2Ml1dLCBbJ21lYXN1cmVkYW5nbGUnLCBbODczN11dLCBbJ01lZGl1bVNwYWNlJywgWzgyODddXSwgWydNZWxsaW50cmYnLCBbODQ5OV1dLCBbJ01mcicsIFsxMjAwODBdXSwgWydtZnInLCBbMTIwMTA2XV0sIFsnbWhvJywgWzg0ODddXSwgWydtaWNybycsIFsxODFdXSwgWydtaWRhc3QnLCBbNDJdXSwgWydtaWRjaXInLCBbMTA5OTJdXSwgWydtaWQnLCBbODczOV1dLCBbJ21pZGRvdCcsIFsxODNdXSwgWydtaW51c2InLCBbODg2M11dLCBbJ21pbnVzJywgWzg3MjJdXSwgWydtaW51c2QnLCBbODc2MF1dLCBbJ21pbnVzZHUnLCBbMTA3OTRdXSwgWydNaW51c1BsdXMnLCBbODcyM11dLCBbJ21sY3AnLCBbMTA5NzFdXSwgWydtbGRyJywgWzgyMzBdXSwgWydtbnBsdXMnLCBbODcyM11dLCBbJ21vZGVscycsIFs4ODcxXV0sIFsnTW9wZicsIFsxMjAxMzJdXSwgWydtb3BmJywgWzEyMDE1OF1dLCBbJ21wJywgWzg3MjNdXSwgWydtc2NyJywgWzEyMDAwMl1dLCBbJ01zY3InLCBbODQ5OV1dLCBbJ21zdHBvcycsIFs4NzY2XV0sIFsnTXUnLCBbOTI0XV0sIFsnbXUnLCBbOTU2XV0sIFsnbXVsdGltYXAnLCBbODg4OF1dLCBbJ211bWFwJywgWzg4ODhdXSwgWyduYWJsYScsIFs4NzExXV0sIFsnTmFjdXRlJywgWzMyM11dLCBbJ25hY3V0ZScsIFszMjRdXSwgWyduYW5nJywgWzg3MzYsIDg0MDJdXSwgWyduYXAnLCBbODc3N11dLCBbJ25hcEUnLCBbMTA4NjQsIDgyNF1dLCBbJ25hcGlkJywgWzg3NzksIDgyNF1dLCBbJ25hcG9zJywgWzMyOV1dLCBbJ25hcHByb3gnLCBbODc3N11dLCBbJ25hdHVyYWwnLCBbOTgzOF1dLCBbJ25hdHVyYWxzJywgWzg0NjldXSwgWyduYXR1cicsIFs5ODM4XV0sIFsnbmJzcCcsIFsxNjBdXSwgWyduYnVtcCcsIFs4NzgyLCA4MjRdXSwgWyduYnVtcGUnLCBbODc4MywgODI0XV0sIFsnbmNhcCcsIFsxMDgxOV1dLCBbJ05jYXJvbicsIFszMjddXSwgWyduY2Fyb24nLCBbMzI4XV0sIFsnTmNlZGlsJywgWzMyNV1dLCBbJ25jZWRpbCcsIFszMjZdXSwgWyduY29uZycsIFs4Nzc1XV0sIFsnbmNvbmdkb3QnLCBbMTA4NjEsIDgyNF1dLCBbJ25jdXAnLCBbMTA4MThdXSwgWydOY3knLCBbMTA1M11dLCBbJ25jeScsIFsxMDg1XV0sIFsnbmRhc2gnLCBbODIxMV1dLCBbJ25lYXJoaycsIFsxMDUzMl1dLCBbJ25lYXJyJywgWzg1OTldXSwgWyduZUFycicsIFs4NjYzXV0sIFsnbmVhcnJvdycsIFs4NTk5XV0sIFsnbmUnLCBbODgwMF1dLCBbJ25lZG90JywgWzg3ODQsIDgyNF1dLCBbJ05lZ2F0aXZlTWVkaXVtU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpY2tTcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGluU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnbmVxdWl2JywgWzg4MDJdXSwgWyduZXNlYXInLCBbMTA1MzZdXSwgWyduZXNpbScsIFs4NzcwLCA4MjRdXSwgWydOZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFs4ODExXV0sIFsnTmVzdGVkTGVzc0xlc3MnLCBbODgxMF1dLCBbJ25leGlzdCcsIFs4NzA4XV0sIFsnbmV4aXN0cycsIFs4NzA4XV0sIFsnTmZyJywgWzEyMDA4MV1dLCBbJ25mcicsIFsxMjAxMDddXSwgWyduZ0UnLCBbODgwNywgODI0XV0sIFsnbmdlJywgWzg4MTddXSwgWyduZ2VxJywgWzg4MTddXSwgWyduZ2VxcScsIFs4ODA3LCA4MjRdXSwgWyduZ2Vxc2xhbnQnLCBbMTA4NzgsIDgyNF1dLCBbJ25nZXMnLCBbMTA4NzgsIDgyNF1dLCBbJ25HZycsIFs4OTIxLCA4MjRdXSwgWyduZ3NpbScsIFs4ODIxXV0sIFsnbkd0JywgWzg4MTEsIDg0MDJdXSwgWyduZ3QnLCBbODgxNV1dLCBbJ25ndHInLCBbODgxNV1dLCBbJ25HdHYnLCBbODgxMSwgODI0XV0sIFsnbmhhcnInLCBbODYyMl1dLCBbJ25oQXJyJywgWzg2NTRdXSwgWyduaHBhcicsIFsxMDk5NF1dLCBbJ25pJywgWzg3MTVdXSwgWyduaXMnLCBbODk1Nl1dLCBbJ25pc2QnLCBbODk1NF1dLCBbJ25pdicsIFs4NzE1XV0sIFsnTkpjeScsIFsxMDM0XV0sIFsnbmpjeScsIFsxMTE0XV0sIFsnbmxhcnInLCBbODYwMl1dLCBbJ25sQXJyJywgWzg2NTNdXSwgWydubGRyJywgWzgyMjldXSwgWydubEUnLCBbODgwNiwgODI0XV0sIFsnbmxlJywgWzg4MTZdXSwgWydubGVmdGFycm93JywgWzg2MDJdXSwgWyduTGVmdGFycm93JywgWzg2NTNdXSwgWydubGVmdHJpZ2h0YXJyb3cnLCBbODYyMl1dLCBbJ25MZWZ0cmlnaHRhcnJvdycsIFs4NjU0XV0sIFsnbmxlcScsIFs4ODE2XV0sIFsnbmxlcXEnLCBbODgwNiwgODI0XV0sIFsnbmxlcXNsYW50JywgWzEwODc3LCA4MjRdXSwgWydubGVzJywgWzEwODc3LCA4MjRdXSwgWydubGVzcycsIFs4ODE0XV0sIFsnbkxsJywgWzg5MjAsIDgyNF1dLCBbJ25sc2ltJywgWzg4MjBdXSwgWyduTHQnLCBbODgxMCwgODQwMl1dLCBbJ25sdCcsIFs4ODE0XV0sIFsnbmx0cmknLCBbODkzOF1dLCBbJ25sdHJpZScsIFs4OTQwXV0sIFsnbkx0dicsIFs4ODEwLCA4MjRdXSwgWydubWlkJywgWzg3NDBdXSwgWydOb0JyZWFrJywgWzgyODhdXSwgWydOb25CcmVha2luZ1NwYWNlJywgWzE2MF1dLCBbJ25vcGYnLCBbMTIwMTU5XV0sIFsnTm9wZicsIFs4NDY5XV0sIFsnTm90JywgWzEwOTg4XV0sIFsnbm90JywgWzE3Ml1dLCBbJ05vdENvbmdydWVudCcsIFs4ODAyXV0sIFsnTm90Q3VwQ2FwJywgWzg4MTNdXSwgWydOb3REb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQyXV0sIFsnTm90RWxlbWVudCcsIFs4NzEzXV0sIFsnTm90RXF1YWwnLCBbODgwMF1dLCBbJ05vdEVxdWFsVGlsZGUnLCBbODc3MCwgODI0XV0sIFsnTm90RXhpc3RzJywgWzg3MDhdXSwgWydOb3RHcmVhdGVyJywgWzg4MTVdXSwgWydOb3RHcmVhdGVyRXF1YWwnLCBbODgxN11dLCBbJ05vdEdyZWF0ZXJGdWxsRXF1YWwnLCBbODgwNywgODI0XV0sIFsnTm90R3JlYXRlckdyZWF0ZXInLCBbODgxMSwgODI0XV0sIFsnTm90R3JlYXRlckxlc3MnLCBbODgyNV1dLCBbJ05vdEdyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4LCA4MjRdXSwgWydOb3RHcmVhdGVyVGlsZGUnLCBbODgyMV1dLCBbJ05vdEh1bXBEb3duSHVtcCcsIFs4NzgyLCA4MjRdXSwgWydOb3RIdW1wRXF1YWwnLCBbODc4MywgODI0XV0sIFsnbm90aW4nLCBbODcxM11dLCBbJ25vdGluZG90JywgWzg5NDksIDgyNF1dLCBbJ25vdGluRScsIFs4OTUzLCA4MjRdXSwgWydub3RpbnZhJywgWzg3MTNdXSwgWydub3RpbnZiJywgWzg5NTFdXSwgWydub3RpbnZjJywgWzg5NTBdXSwgWydOb3RMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDMsIDgyNF1dLCBbJ05vdExlZnRUcmlhbmdsZScsIFs4OTM4XV0sIFsnTm90TGVmdFRyaWFuZ2xlRXF1YWwnLCBbODk0MF1dLCBbJ05vdExlc3MnLCBbODgxNF1dLCBbJ05vdExlc3NFcXVhbCcsIFs4ODE2XV0sIFsnTm90TGVzc0dyZWF0ZXInLCBbODgyNF1dLCBbJ05vdExlc3NMZXNzJywgWzg4MTAsIDgyNF1dLCBbJ05vdExlc3NTbGFudEVxdWFsJywgWzEwODc3LCA4MjRdXSwgWydOb3RMZXNzVGlsZGUnLCBbODgyMF1dLCBbJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzEwOTE0LCA4MjRdXSwgWydOb3ROZXN0ZWRMZXNzTGVzcycsIFsxMDkxMywgODI0XV0sIFsnbm90bmknLCBbODcxNl1dLCBbJ25vdG5pdmEnLCBbODcxNl1dLCBbJ25vdG5pdmInLCBbODk1OF1dLCBbJ25vdG5pdmMnLCBbODk1N11dLCBbJ05vdFByZWNlZGVzJywgWzg4MzJdXSwgWydOb3RQcmVjZWRlc0VxdWFsJywgWzEwOTI3LCA4MjRdXSwgWydOb3RQcmVjZWRlc1NsYW50RXF1YWwnLCBbODkyOF1dLCBbJ05vdFJldmVyc2VFbGVtZW50JywgWzg3MTZdXSwgWydOb3RSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0LCA4MjRdXSwgWydOb3RSaWdodFRyaWFuZ2xlJywgWzg5MzldXSwgWydOb3RSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODk0MV1dLCBbJ05vdFNxdWFyZVN1YnNldCcsIFs4ODQ3LCA4MjRdXSwgWydOb3RTcXVhcmVTdWJzZXRFcXVhbCcsIFs4OTMwXV0sIFsnTm90U3F1YXJlU3VwZXJzZXQnLCBbODg0OCwgODI0XV0sIFsnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4OTMxXV0sIFsnTm90U3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWydOb3RTdWJzZXRFcXVhbCcsIFs4ODQwXV0sIFsnTm90U3VjY2VlZHMnLCBbODgzM11dLCBbJ05vdFN1Y2NlZWRzRXF1YWwnLCBbMTA5MjgsIDgyNF1dLCBbJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4OTI5XV0sIFsnTm90U3VjY2VlZHNUaWxkZScsIFs4ODMxLCA4MjRdXSwgWydOb3RTdXBlcnNldCcsIFs4ODM1LCA4NDAyXV0sIFsnTm90U3VwZXJzZXRFcXVhbCcsIFs4ODQxXV0sIFsnTm90VGlsZGUnLCBbODc2OV1dLCBbJ05vdFRpbGRlRXF1YWwnLCBbODc3Ml1dLCBbJ05vdFRpbGRlRnVsbEVxdWFsJywgWzg3NzVdXSwgWydOb3RUaWxkZVRpbGRlJywgWzg3NzddXSwgWydOb3RWZXJ0aWNhbEJhcicsIFs4NzQwXV0sIFsnbnBhcmFsbGVsJywgWzg3NDJdXSwgWyducGFyJywgWzg3NDJdXSwgWyducGFyc2wnLCBbMTEwMDUsIDg0MjFdXSwgWyducGFydCcsIFs4NzA2LCA4MjRdXSwgWyducG9saW50JywgWzEwNzcyXV0sIFsnbnByJywgWzg4MzJdXSwgWyducHJjdWUnLCBbODkyOF1dLCBbJ25wcmVjJywgWzg4MzJdXSwgWyducHJlY2VxJywgWzEwOTI3LCA4MjRdXSwgWyducHJlJywgWzEwOTI3LCA4MjRdXSwgWyducmFycmMnLCBbMTA1NDcsIDgyNF1dLCBbJ25yYXJyJywgWzg2MDNdXSwgWyduckFycicsIFs4NjU1XV0sIFsnbnJhcnJ3JywgWzg2MDUsIDgyNF1dLCBbJ25yaWdodGFycm93JywgWzg2MDNdXSwgWyduUmlnaHRhcnJvdycsIFs4NjU1XV0sIFsnbnJ0cmknLCBbODkzOV1dLCBbJ25ydHJpZScsIFs4OTQxXV0sIFsnbnNjJywgWzg4MzNdXSwgWyduc2NjdWUnLCBbODkyOV1dLCBbJ25zY2UnLCBbMTA5MjgsIDgyNF1dLCBbJ05zY3InLCBbMTE5OTc3XV0sIFsnbnNjcicsIFsxMjAwMDNdXSwgWyduc2hvcnRtaWQnLCBbODc0MF1dLCBbJ25zaG9ydHBhcmFsbGVsJywgWzg3NDJdXSwgWyduc2ltJywgWzg3NjldXSwgWyduc2ltZScsIFs4NzcyXV0sIFsnbnNpbWVxJywgWzg3NzJdXSwgWyduc21pZCcsIFs4NzQwXV0sIFsnbnNwYXInLCBbODc0Ml1dLCBbJ25zcXN1YmUnLCBbODkzMF1dLCBbJ25zcXN1cGUnLCBbODkzMV1dLCBbJ25zdWInLCBbODgzNl1dLCBbJ25zdWJFJywgWzEwOTQ5LCA4MjRdXSwgWyduc3ViZScsIFs4ODQwXV0sIFsnbnN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnbnN1YnNldGVxJywgWzg4NDBdXSwgWyduc3Vic2V0ZXFxJywgWzEwOTQ5LCA4MjRdXSwgWyduc3VjYycsIFs4ODMzXV0sIFsnbnN1Y2NlcScsIFsxMDkyOCwgODI0XV0sIFsnbnN1cCcsIFs4ODM3XV0sIFsnbnN1cEUnLCBbMTA5NTAsIDgyNF1dLCBbJ25zdXBlJywgWzg4NDFdXSwgWyduc3Vwc2V0JywgWzg4MzUsIDg0MDJdXSwgWyduc3Vwc2V0ZXEnLCBbODg0MV1dLCBbJ25zdXBzZXRlcXEnLCBbMTA5NTAsIDgyNF1dLCBbJ250Z2wnLCBbODgyNV1dLCBbJ050aWxkZScsIFsyMDldXSwgWydudGlsZGUnLCBbMjQxXV0sIFsnbnRsZycsIFs4ODI0XV0sIFsnbnRyaWFuZ2xlbGVmdCcsIFs4OTM4XV0sIFsnbnRyaWFuZ2xlbGVmdGVxJywgWzg5NDBdXSwgWydudHJpYW5nbGVyaWdodCcsIFs4OTM5XV0sIFsnbnRyaWFuZ2xlcmlnaHRlcScsIFs4OTQxXV0sIFsnTnUnLCBbOTI1XV0sIFsnbnUnLCBbOTU3XV0sIFsnbnVtJywgWzM1XV0sIFsnbnVtZXJvJywgWzg0NzBdXSwgWydudW1zcCcsIFs4MTk5XV0sIFsnbnZhcCcsIFs4NzgxLCA4NDAyXV0sIFsnbnZkYXNoJywgWzg4NzZdXSwgWydudkRhc2gnLCBbODg3N11dLCBbJ25WZGFzaCcsIFs4ODc4XV0sIFsnblZEYXNoJywgWzg4NzldXSwgWydudmdlJywgWzg4MDUsIDg0MDJdXSwgWydudmd0JywgWzYyLCA4NDAyXV0sIFsnbnZIYXJyJywgWzEwNTAwXV0sIFsnbnZpbmZpbicsIFsxMDcxOF1dLCBbJ252bEFycicsIFsxMDQ5OF1dLCBbJ252bGUnLCBbODgwNCwgODQwMl1dLCBbJ252bHQnLCBbNjAsIDg0MDJdXSwgWydudmx0cmllJywgWzg4ODQsIDg0MDJdXSwgWydudnJBcnInLCBbMTA0OTldXSwgWydudnJ0cmllJywgWzg4ODUsIDg0MDJdXSwgWydudnNpbScsIFs4NzY0LCA4NDAyXV0sIFsnbndhcmhrJywgWzEwNTMxXV0sIFsnbndhcnInLCBbODU5OF1dLCBbJ253QXJyJywgWzg2NjJdXSwgWydud2Fycm93JywgWzg1OThdXSwgWydud25lYXInLCBbMTA1MzVdXSwgWydPYWN1dGUnLCBbMjExXV0sIFsnb2FjdXRlJywgWzI0M11dLCBbJ29hc3QnLCBbODg1OV1dLCBbJ09jaXJjJywgWzIxMl1dLCBbJ29jaXJjJywgWzI0NF1dLCBbJ29jaXInLCBbODg1OF1dLCBbJ09jeScsIFsxMDU0XV0sIFsnb2N5JywgWzEwODZdXSwgWydvZGFzaCcsIFs4ODYxXV0sIFsnT2RibGFjJywgWzMzNl1dLCBbJ29kYmxhYycsIFszMzddXSwgWydvZGl2JywgWzEwODA4XV0sIFsnb2RvdCcsIFs4ODU3XV0sIFsnb2Rzb2xkJywgWzEwNjg0XV0sIFsnT0VsaWcnLCBbMzM4XV0sIFsnb2VsaWcnLCBbMzM5XV0sIFsnb2ZjaXInLCBbMTA2ODddXSwgWydPZnInLCBbMTIwMDgyXV0sIFsnb2ZyJywgWzEyMDEwOF1dLCBbJ29nb24nLCBbNzMxXV0sIFsnT2dyYXZlJywgWzIxMF1dLCBbJ29ncmF2ZScsIFsyNDJdXSwgWydvZ3QnLCBbMTA2ODldXSwgWydvaGJhcicsIFsxMDY3N11dLCBbJ29obScsIFs5MzddXSwgWydvaW50JywgWzg3NTBdXSwgWydvbGFycicsIFs4NjM0XV0sIFsnb2xjaXInLCBbMTA2ODZdXSwgWydvbGNyb3NzJywgWzEwNjgzXV0sIFsnb2xpbmUnLCBbODI1NF1dLCBbJ29sdCcsIFsxMDY4OF1dLCBbJ09tYWNyJywgWzMzMl1dLCBbJ29tYWNyJywgWzMzM11dLCBbJ09tZWdhJywgWzkzN11dLCBbJ29tZWdhJywgWzk2OV1dLCBbJ09taWNyb24nLCBbOTI3XV0sIFsnb21pY3JvbicsIFs5NTldXSwgWydvbWlkJywgWzEwNjc4XV0sIFsnb21pbnVzJywgWzg4NTRdXSwgWydPb3BmJywgWzEyMDEzNF1dLCBbJ29vcGYnLCBbMTIwMTYwXV0sIFsnb3BhcicsIFsxMDY3OV1dLCBbJ09wZW5DdXJseURvdWJsZVF1b3RlJywgWzgyMjBdXSwgWydPcGVuQ3VybHlRdW90ZScsIFs4MjE2XV0sIFsnb3BlcnAnLCBbMTA2ODFdXSwgWydvcGx1cycsIFs4ODUzXV0sIFsnb3JhcnInLCBbODYzNV1dLCBbJ09yJywgWzEwODM2XV0sIFsnb3InLCBbODc0NF1dLCBbJ29yZCcsIFsxMDg0NV1dLCBbJ29yZGVyJywgWzg1MDBdXSwgWydvcmRlcm9mJywgWzg1MDBdXSwgWydvcmRmJywgWzE3MF1dLCBbJ29yZG0nLCBbMTg2XV0sIFsnb3JpZ29mJywgWzg4ODZdXSwgWydvcm9yJywgWzEwODM4XV0sIFsnb3JzbG9wZScsIFsxMDgzOV1dLCBbJ29ydicsIFsxMDg0M11dLCBbJ29TJywgWzk0MTZdXSwgWydPc2NyJywgWzExOTk3OF1dLCBbJ29zY3InLCBbODUwMF1dLCBbJ09zbGFzaCcsIFsyMTZdXSwgWydvc2xhc2gnLCBbMjQ4XV0sIFsnb3NvbCcsIFs4ODU2XV0sIFsnT3RpbGRlJywgWzIxM11dLCBbJ290aWxkZScsIFsyNDVdXSwgWydvdGltZXNhcycsIFsxMDgwNl1dLCBbJ090aW1lcycsIFsxMDgwN11dLCBbJ290aW1lcycsIFs4ODU1XV0sIFsnT3VtbCcsIFsyMTRdXSwgWydvdW1sJywgWzI0Nl1dLCBbJ292YmFyJywgWzkwMjFdXSwgWydPdmVyQmFyJywgWzgyNTRdXSwgWydPdmVyQnJhY2UnLCBbOTE4Ml1dLCBbJ092ZXJCcmFja2V0JywgWzkxNDBdXSwgWydPdmVyUGFyZW50aGVzaXMnLCBbOTE4MF1dLCBbJ3BhcmEnLCBbMTgyXV0sIFsncGFyYWxsZWwnLCBbODc0MV1dLCBbJ3BhcicsIFs4NzQxXV0sIFsncGFyc2ltJywgWzEwOTk1XV0sIFsncGFyc2wnLCBbMTEwMDVdXSwgWydwYXJ0JywgWzg3MDZdXSwgWydQYXJ0aWFsRCcsIFs4NzA2XV0sIFsnUGN5JywgWzEwNTVdXSwgWydwY3knLCBbMTA4N11dLCBbJ3BlcmNudCcsIFszN11dLCBbJ3BlcmlvZCcsIFs0Nl1dLCBbJ3Blcm1pbCcsIFs4MjQwXV0sIFsncGVycCcsIFs4ODY5XV0sIFsncGVydGVuaycsIFs4MjQxXV0sIFsnUGZyJywgWzEyMDA4M11dLCBbJ3BmcicsIFsxMjAxMDldXSwgWydQaGknLCBbOTM0XV0sIFsncGhpJywgWzk2Nl1dLCBbJ3BoaXYnLCBbOTgxXV0sIFsncGhtbWF0JywgWzg0OTldXSwgWydwaG9uZScsIFs5NzQyXV0sIFsnUGknLCBbOTI4XV0sIFsncGknLCBbOTYwXV0sIFsncGl0Y2hmb3JrJywgWzg5MTZdXSwgWydwaXYnLCBbOTgyXV0sIFsncGxhbmNrJywgWzg0NjNdXSwgWydwbGFuY2toJywgWzg0NjJdXSwgWydwbGFua3YnLCBbODQ2M11dLCBbJ3BsdXNhY2lyJywgWzEwNzg3XV0sIFsncGx1c2InLCBbODg2Ml1dLCBbJ3BsdXNjaXInLCBbMTA3ODZdXSwgWydwbHVzJywgWzQzXV0sIFsncGx1c2RvJywgWzg3MjRdXSwgWydwbHVzZHUnLCBbMTA3ODldXSwgWydwbHVzZScsIFsxMDg2Nl1dLCBbJ1BsdXNNaW51cycsIFsxNzddXSwgWydwbHVzbW4nLCBbMTc3XV0sIFsncGx1c3NpbScsIFsxMDc5MF1dLCBbJ3BsdXN0d28nLCBbMTA3OTFdXSwgWydwbScsIFsxNzddXSwgWydQb2luY2FyZXBsYW5lJywgWzg0NjBdXSwgWydwb2ludGludCcsIFsxMDc3M11dLCBbJ3BvcGYnLCBbMTIwMTYxXV0sIFsnUG9wZicsIFs4NDczXV0sIFsncG91bmQnLCBbMTYzXV0sIFsncHJhcCcsIFsxMDkzNV1dLCBbJ1ByJywgWzEwOTM5XV0sIFsncHInLCBbODgyNl1dLCBbJ3ByY3VlJywgWzg4MjhdXSwgWydwcmVjYXBwcm94JywgWzEwOTM1XV0sIFsncHJlYycsIFs4ODI2XV0sIFsncHJlY2N1cmx5ZXEnLCBbODgyOF1dLCBbJ1ByZWNlZGVzJywgWzg4MjZdXSwgWydQcmVjZWRlc0VxdWFsJywgWzEwOTI3XV0sIFsnUHJlY2VkZXNTbGFudEVxdWFsJywgWzg4MjhdXSwgWydQcmVjZWRlc1RpbGRlJywgWzg4MzBdXSwgWydwcmVjZXEnLCBbMTA5MjddXSwgWydwcmVjbmFwcHJveCcsIFsxMDkzN11dLCBbJ3ByZWNuZXFxJywgWzEwOTMzXV0sIFsncHJlY25zaW0nLCBbODkzNl1dLCBbJ3ByZScsIFsxMDkyN11dLCBbJ3ByRScsIFsxMDkzMV1dLCBbJ3ByZWNzaW0nLCBbODgzMF1dLCBbJ3ByaW1lJywgWzgyNDJdXSwgWydQcmltZScsIFs4MjQzXV0sIFsncHJpbWVzJywgWzg0NzNdXSwgWydwcm5hcCcsIFsxMDkzN11dLCBbJ3BybkUnLCBbMTA5MzNdXSwgWydwcm5zaW0nLCBbODkzNl1dLCBbJ3Byb2QnLCBbODcxOV1dLCBbJ1Byb2R1Y3QnLCBbODcxOV1dLCBbJ3Byb2ZhbGFyJywgWzkwMDZdXSwgWydwcm9mbGluZScsIFs4OTc4XV0sIFsncHJvZnN1cmYnLCBbODk3OV1dLCBbJ3Byb3AnLCBbODczM11dLCBbJ1Byb3BvcnRpb25hbCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbicsIFs4NzU5XV0sIFsncHJvcHRvJywgWzg3MzNdXSwgWydwcnNpbScsIFs4ODMwXV0sIFsncHJ1cmVsJywgWzg4ODBdXSwgWydQc2NyJywgWzExOTk3OV1dLCBbJ3BzY3InLCBbMTIwMDA1XV0sIFsnUHNpJywgWzkzNl1dLCBbJ3BzaScsIFs5NjhdXSwgWydwdW5jc3AnLCBbODIwMF1dLCBbJ1FmcicsIFsxMjAwODRdXSwgWydxZnInLCBbMTIwMTEwXV0sIFsncWludCcsIFsxMDc2NF1dLCBbJ3FvcGYnLCBbMTIwMTYyXV0sIFsnUW9wZicsIFs4NDc0XV0sIFsncXByaW1lJywgWzgyNzldXSwgWydRc2NyJywgWzExOTk4MF1dLCBbJ3FzY3InLCBbMTIwMDA2XV0sIFsncXVhdGVybmlvbnMnLCBbODQ2MV1dLCBbJ3F1YXRpbnQnLCBbMTA3NzRdXSwgWydxdWVzdCcsIFs2M11dLCBbJ3F1ZXN0ZXEnLCBbODc5OV1dLCBbJ3F1b3QnLCBbMzRdXSwgWydRVU9UJywgWzM0XV0sIFsnckFhcnInLCBbODY2N11dLCBbJ3JhY2UnLCBbODc2NSwgODE3XV0sIFsnUmFjdXRlJywgWzM0MF1dLCBbJ3JhY3V0ZScsIFszNDFdXSwgWydyYWRpYycsIFs4NzMwXV0sIFsncmFlbXB0eXYnLCBbMTA2NzVdXSwgWydyYW5nJywgWzEwMjE3XV0sIFsnUmFuZycsIFsxMDIxOV1dLCBbJ3JhbmdkJywgWzEwNjQyXV0sIFsncmFuZ2UnLCBbMTA2NjFdXSwgWydyYW5nbGUnLCBbMTAyMTddXSwgWydyYXF1bycsIFsxODddXSwgWydyYXJyYXAnLCBbMTA2MTNdXSwgWydyYXJyYicsIFs4Njc3XV0sIFsncmFycmJmcycsIFsxMDUyOF1dLCBbJ3JhcnJjJywgWzEwNTQ3XV0sIFsncmFycicsIFs4NTk0XV0sIFsnUmFycicsIFs4NjA4XV0sIFsnckFycicsIFs4NjU4XV0sIFsncmFycmZzJywgWzEwNTI2XV0sIFsncmFycmhrJywgWzg2MThdXSwgWydyYXJybHAnLCBbODYyMF1dLCBbJ3JhcnJwbCcsIFsxMDU2NV1dLCBbJ3JhcnJzaW0nLCBbMTA2MTJdXSwgWydSYXJydGwnLCBbMTA1MThdXSwgWydyYXJydGwnLCBbODYxMV1dLCBbJ3JhcnJ3JywgWzg2MDVdXSwgWydyYXRhaWwnLCBbMTA1MjJdXSwgWydyQXRhaWwnLCBbMTA1MjRdXSwgWydyYXRpbycsIFs4NzU4XV0sIFsncmF0aW9uYWxzJywgWzg0NzRdXSwgWydyYmFycicsIFsxMDUwOV1dLCBbJ3JCYXJyJywgWzEwNTExXV0sIFsnUkJhcnInLCBbMTA1MTJdXSwgWydyYmJyaycsIFsxMDA5OV1dLCBbJ3JicmFjZScsIFsxMjVdXSwgWydyYnJhY2snLCBbOTNdXSwgWydyYnJrZScsIFsxMDYzNl1dLCBbJ3JicmtzbGQnLCBbMTA2MzhdXSwgWydyYnJrc2x1JywgWzEwNjQwXV0sIFsnUmNhcm9uJywgWzM0NF1dLCBbJ3JjYXJvbicsIFszNDVdXSwgWydSY2VkaWwnLCBbMzQyXV0sIFsncmNlZGlsJywgWzM0M11dLCBbJ3JjZWlsJywgWzg5NjldXSwgWydyY3ViJywgWzEyNV1dLCBbJ1JjeScsIFsxMDU2XV0sIFsncmN5JywgWzEwODhdXSwgWydyZGNhJywgWzEwNTUxXV0sIFsncmRsZGhhcicsIFsxMDYwMV1dLCBbJ3JkcXVvJywgWzgyMjFdXSwgWydyZHF1b3InLCBbODIyMV1dLCBbJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZScsIFs4MjIxXV0sIFsncmRzaCcsIFs4NjI3XV0sIFsncmVhbCcsIFs4NDc2XV0sIFsncmVhbGluZScsIFs4NDc1XV0sIFsncmVhbHBhcnQnLCBbODQ3Nl1dLCBbJ3JlYWxzJywgWzg0NzddXSwgWydSZScsIFs4NDc2XV0sIFsncmVjdCcsIFs5NjQ1XV0sIFsncmVnJywgWzE3NF1dLCBbJ1JFRycsIFsxNzRdXSwgWydSZXZlcnNlRWxlbWVudCcsIFs4NzE1XV0sIFsnUmV2ZXJzZUVxdWlsaWJyaXVtJywgWzg2NTFdXSwgWydSZXZlcnNlVXBFcXVpbGlicml1bScsIFsxMDYwN11dLCBbJ3JmaXNodCcsIFsxMDYyMV1dLCBbJ3JmbG9vcicsIFs4OTcxXV0sIFsncmZyJywgWzEyMDExMV1dLCBbJ1JmcicsIFs4NDc2XV0sIFsnckhhcicsIFsxMDU5Nl1dLCBbJ3JoYXJkJywgWzg2NDFdXSwgWydyaGFydScsIFs4NjQwXV0sIFsncmhhcnVsJywgWzEwNjA0XV0sIFsnUmhvJywgWzkyOV1dLCBbJ3JobycsIFs5NjFdXSwgWydyaG92JywgWzEwMDldXSwgWydSaWdodEFuZ2xlQnJhY2tldCcsIFsxMDIxN11dLCBbJ1JpZ2h0QXJyb3dCYXInLCBbODY3N11dLCBbJ3JpZ2h0YXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0YXJyb3cnLCBbODY1OF1dLCBbJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnLCBbODY0NF1dLCBbJ3JpZ2h0YXJyb3d0YWlsJywgWzg2MTFdXSwgWydSaWdodENlaWxpbmcnLCBbODk2OV1dLCBbJ1JpZ2h0RG91YmxlQnJhY2tldCcsIFsxMDIxNV1dLCBbJ1JpZ2h0RG93blRlZVZlY3RvcicsIFsxMDU4OV1dLCBbJ1JpZ2h0RG93blZlY3RvckJhcicsIFsxMDU4MV1dLCBbJ1JpZ2h0RG93blZlY3RvcicsIFs4NjQyXV0sIFsnUmlnaHRGbG9vcicsIFs4OTcxXV0sIFsncmlnaHRoYXJwb29uZG93bicsIFs4NjQxXV0sIFsncmlnaHRoYXJwb29udXAnLCBbODY0MF1dLCBbJ3JpZ2h0bGVmdGFycm93cycsIFs4NjQ0XV0sIFsncmlnaHRsZWZ0aGFycG9vbnMnLCBbODY1Ml1dLCBbJ3JpZ2h0cmlnaHRhcnJvd3MnLCBbODY0OV1dLCBbJ3JpZ2h0c3F1aWdhcnJvdycsIFs4NjA1XV0sIFsnUmlnaHRUZWVBcnJvdycsIFs4NjE0XV0sIFsnUmlnaHRUZWUnLCBbODg2Nl1dLCBbJ1JpZ2h0VGVlVmVjdG9yJywgWzEwNTg3XV0sIFsncmlnaHR0aHJlZXRpbWVzJywgWzg5MDhdXSwgWydSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0XV0sIFsnUmlnaHRUcmlhbmdsZScsIFs4ODgzXV0sIFsnUmlnaHRUcmlhbmdsZUVxdWFsJywgWzg4ODVdXSwgWydSaWdodFVwRG93blZlY3RvcicsIFsxMDU3NV1dLCBbJ1JpZ2h0VXBUZWVWZWN0b3InLCBbMTA1ODhdXSwgWydSaWdodFVwVmVjdG9yQmFyJywgWzEwNTgwXV0sIFsnUmlnaHRVcFZlY3RvcicsIFs4NjM4XV0sIFsnUmlnaHRWZWN0b3JCYXInLCBbMTA1NzldXSwgWydSaWdodFZlY3RvcicsIFs4NjQwXV0sIFsncmluZycsIFs3MzBdXSwgWydyaXNpbmdkb3RzZXEnLCBbODc4N11dLCBbJ3JsYXJyJywgWzg2NDRdXSwgWydybGhhcicsIFs4NjUyXV0sIFsncmxtJywgWzgyMDddXSwgWydybW91c3RhY2hlJywgWzkxMzddXSwgWydybW91c3QnLCBbOTEzN11dLCBbJ3JubWlkJywgWzEwOTkwXV0sIFsncm9hbmcnLCBbMTAyMjFdXSwgWydyb2FycicsIFs4NzAyXV0sIFsncm9icmsnLCBbMTAyMTVdXSwgWydyb3BhcicsIFsxMDYzMF1dLCBbJ3JvcGYnLCBbMTIwMTYzXV0sIFsnUm9wZicsIFs4NDc3XV0sIFsncm9wbHVzJywgWzEwNzk4XV0sIFsncm90aW1lcycsIFsxMDgwNV1dLCBbJ1JvdW5kSW1wbGllcycsIFsxMDYwOF1dLCBbJ3JwYXInLCBbNDFdXSwgWydycGFyZ3QnLCBbMTA2NDRdXSwgWydycHBvbGludCcsIFsxMDc3MF1dLCBbJ3JyYXJyJywgWzg2NDldXSwgWydScmlnaHRhcnJvdycsIFs4NjY3XV0sIFsncnNhcXVvJywgWzgyNTBdXSwgWydyc2NyJywgWzEyMDAwN11dLCBbJ1JzY3InLCBbODQ3NV1dLCBbJ3JzaCcsIFs4NjI1XV0sIFsnUnNoJywgWzg2MjVdXSwgWydyc3FiJywgWzkzXV0sIFsncnNxdW8nLCBbODIxN11dLCBbJ3JzcXVvcicsIFs4MjE3XV0sIFsnQ2xvc2VDdXJseVF1b3RlJywgWzgyMTddXSwgWydydGhyZWUnLCBbODkwOF1dLCBbJ3J0aW1lcycsIFs4OTA2XV0sIFsncnRyaScsIFs5NjU3XV0sIFsncnRyaWUnLCBbODg4NV1dLCBbJ3J0cmlmJywgWzk2NTZdXSwgWydydHJpbHRyaScsIFsxMDcwMl1dLCBbJ1J1bGVEZWxheWVkJywgWzEwNzQwXV0sIFsncnVsdWhhcicsIFsxMDYwMF1dLCBbJ3J4JywgWzg0NzhdXSwgWydTYWN1dGUnLCBbMzQ2XV0sIFsnc2FjdXRlJywgWzM0N11dLCBbJ3NicXVvJywgWzgyMThdXSwgWydzY2FwJywgWzEwOTM2XV0sIFsnU2Nhcm9uJywgWzM1Ml1dLCBbJ3NjYXJvbicsIFszNTNdXSwgWydTYycsIFsxMDk0MF1dLCBbJ3NjJywgWzg4MjddXSwgWydzY2N1ZScsIFs4ODI5XV0sIFsnc2NlJywgWzEwOTI4XV0sIFsnc2NFJywgWzEwOTMyXV0sIFsnU2NlZGlsJywgWzM1MF1dLCBbJ3NjZWRpbCcsIFszNTFdXSwgWydTY2lyYycsIFszNDhdXSwgWydzY2lyYycsIFszNDldXSwgWydzY25hcCcsIFsxMDkzOF1dLCBbJ3NjbkUnLCBbMTA5MzRdXSwgWydzY25zaW0nLCBbODkzN11dLCBbJ3NjcG9saW50JywgWzEwNzcxXV0sIFsnc2NzaW0nLCBbODgzMV1dLCBbJ1NjeScsIFsxMDU3XV0sIFsnc2N5JywgWzEwODldXSwgWydzZG90YicsIFs4ODY1XV0sIFsnc2RvdCcsIFs4OTAxXV0sIFsnc2RvdGUnLCBbMTA4NTRdXSwgWydzZWFyaGsnLCBbMTA1MzNdXSwgWydzZWFycicsIFs4NjAwXV0sIFsnc2VBcnInLCBbODY2NF1dLCBbJ3NlYXJyb3cnLCBbODYwMF1dLCBbJ3NlY3QnLCBbMTY3XV0sIFsnc2VtaScsIFs1OV1dLCBbJ3Nlc3dhcicsIFsxMDUzN11dLCBbJ3NldG1pbnVzJywgWzg3MjZdXSwgWydzZXRtbicsIFs4NzI2XV0sIFsnc2V4dCcsIFsxMDAzOF1dLCBbJ1NmcicsIFsxMjAwODZdXSwgWydzZnInLCBbMTIwMTEyXV0sIFsnc2Zyb3duJywgWzg5OTRdXSwgWydzaGFycCcsIFs5ODM5XV0sIFsnU0hDSGN5JywgWzEwNjVdXSwgWydzaGNoY3knLCBbMTA5N11dLCBbJ1NIY3knLCBbMTA2NF1dLCBbJ3NoY3knLCBbMTA5Nl1dLCBbJ1Nob3J0RG93bkFycm93JywgWzg1OTVdXSwgWydTaG9ydExlZnRBcnJvdycsIFs4NTkyXV0sIFsnc2hvcnRtaWQnLCBbODczOV1dLCBbJ3Nob3J0cGFyYWxsZWwnLCBbODc0MV1dLCBbJ1Nob3J0UmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnU2hvcnRVcEFycm93JywgWzg1OTNdXSwgWydzaHknLCBbMTczXV0sIFsnU2lnbWEnLCBbOTMxXV0sIFsnc2lnbWEnLCBbOTYzXV0sIFsnc2lnbWFmJywgWzk2Ml1dLCBbJ3NpZ21hdicsIFs5NjJdXSwgWydzaW0nLCBbODc2NF1dLCBbJ3NpbWRvdCcsIFsxMDg1OF1dLCBbJ3NpbWUnLCBbODc3MV1dLCBbJ3NpbWVxJywgWzg3NzFdXSwgWydzaW1nJywgWzEwOTEwXV0sIFsnc2ltZ0UnLCBbMTA5MTJdXSwgWydzaW1sJywgWzEwOTA5XV0sIFsnc2ltbEUnLCBbMTA5MTFdXSwgWydzaW1uZScsIFs4Nzc0XV0sIFsnc2ltcGx1cycsIFsxMDc4OF1dLCBbJ3NpbXJhcnInLCBbMTA2MTBdXSwgWydzbGFycicsIFs4NTkyXV0sIFsnU21hbGxDaXJjbGUnLCBbODcyOF1dLCBbJ3NtYWxsc2V0bWludXMnLCBbODcyNl1dLCBbJ3NtYXNocCcsIFsxMDgwM11dLCBbJ3NtZXBhcnNsJywgWzEwNzI0XV0sIFsnc21pZCcsIFs4NzM5XV0sIFsnc21pbGUnLCBbODk5NV1dLCBbJ3NtdCcsIFsxMDkyMl1dLCBbJ3NtdGUnLCBbMTA5MjRdXSwgWydzbXRlcycsIFsxMDkyNCwgNjUwMjRdXSwgWydTT0ZUY3knLCBbMTA2OF1dLCBbJ3NvZnRjeScsIFsxMTAwXV0sIFsnc29sYmFyJywgWzkwMjNdXSwgWydzb2xiJywgWzEwNjkyXV0sIFsnc29sJywgWzQ3XV0sIFsnU29wZicsIFsxMjAxMzhdXSwgWydzb3BmJywgWzEyMDE2NF1dLCBbJ3NwYWRlcycsIFs5ODI0XV0sIFsnc3BhZGVzdWl0JywgWzk4MjRdXSwgWydzcGFyJywgWzg3NDFdXSwgWydzcWNhcCcsIFs4ODUxXV0sIFsnc3FjYXBzJywgWzg4NTEsIDY1MDI0XV0sIFsnc3FjdXAnLCBbODg1Ml1dLCBbJ3NxY3VwcycsIFs4ODUyLCA2NTAyNF1dLCBbJ1NxcnQnLCBbODczMF1dLCBbJ3Nxc3ViJywgWzg4NDddXSwgWydzcXN1YmUnLCBbODg0OV1dLCBbJ3Nxc3Vic2V0JywgWzg4NDddXSwgWydzcXN1YnNldGVxJywgWzg4NDldXSwgWydzcXN1cCcsIFs4ODQ4XV0sIFsnc3FzdXBlJywgWzg4NTBdXSwgWydzcXN1cHNldCcsIFs4ODQ4XV0sIFsnc3FzdXBzZXRlcScsIFs4ODUwXV0sIFsnc3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZUludGVyc2VjdGlvbicsIFs4ODUxXV0sIFsnU3F1YXJlU3Vic2V0JywgWzg4NDddXSwgWydTcXVhcmVTdWJzZXRFcXVhbCcsIFs4ODQ5XV0sIFsnU3F1YXJlU3VwZXJzZXQnLCBbODg0OF1dLCBbJ1NxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODg1MF1dLCBbJ1NxdWFyZVVuaW9uJywgWzg4NTJdXSwgWydzcXVhcmYnLCBbOTY0Ml1dLCBbJ3NxdScsIFs5NjMzXV0sIFsnc3F1ZicsIFs5NjQyXV0sIFsnc3JhcnInLCBbODU5NF1dLCBbJ1NzY3InLCBbMTE5OTgyXV0sIFsnc3NjcicsIFsxMjAwMDhdXSwgWydzc2V0bW4nLCBbODcyNl1dLCBbJ3NzbWlsZScsIFs4OTk1XV0sIFsnc3N0YXJmJywgWzg5MDJdXSwgWydTdGFyJywgWzg5MDJdXSwgWydzdGFyJywgWzk3MzRdXSwgWydzdGFyZicsIFs5NzMzXV0sIFsnc3RyYWlnaHRlcHNpbG9uJywgWzEwMTNdXSwgWydzdHJhaWdodHBoaScsIFs5ODFdXSwgWydzdHJucycsIFsxNzVdXSwgWydzdWInLCBbODgzNF1dLCBbJ1N1YicsIFs4OTEyXV0sIFsnc3ViZG90JywgWzEwOTQxXV0sIFsnc3ViRScsIFsxMDk0OV1dLCBbJ3N1YmUnLCBbODgzOF1dLCBbJ3N1YmVkb3QnLCBbMTA5NDddXSwgWydzdWJtdWx0JywgWzEwOTQ1XV0sIFsnc3VibkUnLCBbMTA5NTVdXSwgWydzdWJuZScsIFs4ODQyXV0sIFsnc3VicGx1cycsIFsxMDk0M11dLCBbJ3N1YnJhcnInLCBbMTA2MTddXSwgWydzdWJzZXQnLCBbODgzNF1dLCBbJ1N1YnNldCcsIFs4OTEyXV0sIFsnc3Vic2V0ZXEnLCBbODgzOF1dLCBbJ3N1YnNldGVxcScsIFsxMDk0OV1dLCBbJ1N1YnNldEVxdWFsJywgWzg4MzhdXSwgWydzdWJzZXRuZXEnLCBbODg0Ml1dLCBbJ3N1YnNldG5lcXEnLCBbMTA5NTVdXSwgWydzdWJzaW0nLCBbMTA5NTFdXSwgWydzdWJzdWInLCBbMTA5NjVdXSwgWydzdWJzdXAnLCBbMTA5NjNdXSwgWydzdWNjYXBwcm94JywgWzEwOTM2XV0sIFsnc3VjYycsIFs4ODI3XV0sIFsnc3VjY2N1cmx5ZXEnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzJywgWzg4MjddXSwgWydTdWNjZWVkc0VxdWFsJywgWzEwOTI4XV0sIFsnU3VjY2VlZHNTbGFudEVxdWFsJywgWzg4MjldXSwgWydTdWNjZWVkc1RpbGRlJywgWzg4MzFdXSwgWydzdWNjZXEnLCBbMTA5MjhdXSwgWydzdWNjbmFwcHJveCcsIFsxMDkzOF1dLCBbJ3N1Y2NuZXFxJywgWzEwOTM0XV0sIFsnc3VjY25zaW0nLCBbODkzN11dLCBbJ3N1Y2NzaW0nLCBbODgzMV1dLCBbJ1N1Y2hUaGF0JywgWzg3MTVdXSwgWydzdW0nLCBbODcyMV1dLCBbJ1N1bScsIFs4NzIxXV0sIFsnc3VuZycsIFs5ODM0XV0sIFsnc3VwMScsIFsxODVdXSwgWydzdXAyJywgWzE3OF1dLCBbJ3N1cDMnLCBbMTc5XV0sIFsnc3VwJywgWzg4MzVdXSwgWydTdXAnLCBbODkxM11dLCBbJ3N1cGRvdCcsIFsxMDk0Ml1dLCBbJ3N1cGRzdWInLCBbMTA5NjhdXSwgWydzdXBFJywgWzEwOTUwXV0sIFsnc3VwZScsIFs4ODM5XV0sIFsnc3VwZWRvdCcsIFsxMDk0OF1dLCBbJ1N1cGVyc2V0JywgWzg4MzVdXSwgWydTdXBlcnNldEVxdWFsJywgWzg4MzldXSwgWydzdXBoc29sJywgWzEwMTg1XV0sIFsnc3VwaHN1YicsIFsxMDk2N11dLCBbJ3N1cGxhcnInLCBbMTA2MTldXSwgWydzdXBtdWx0JywgWzEwOTQ2XV0sIFsnc3VwbkUnLCBbMTA5NTZdXSwgWydzdXBuZScsIFs4ODQzXV0sIFsnc3VwcGx1cycsIFsxMDk0NF1dLCBbJ3N1cHNldCcsIFs4ODM1XV0sIFsnU3Vwc2V0JywgWzg5MTNdXSwgWydzdXBzZXRlcScsIFs4ODM5XV0sIFsnc3Vwc2V0ZXFxJywgWzEwOTUwXV0sIFsnc3Vwc2V0bmVxJywgWzg4NDNdXSwgWydzdXBzZXRuZXFxJywgWzEwOTU2XV0sIFsnc3Vwc2ltJywgWzEwOTUyXV0sIFsnc3Vwc3ViJywgWzEwOTY0XV0sIFsnc3Vwc3VwJywgWzEwOTY2XV0sIFsnc3dhcmhrJywgWzEwNTM0XV0sIFsnc3dhcnInLCBbODYwMV1dLCBbJ3N3QXJyJywgWzg2NjVdXSwgWydzd2Fycm93JywgWzg2MDFdXSwgWydzd253YXInLCBbMTA1MzhdXSwgWydzemxpZycsIFsyMjNdXSwgWydUYWInLCBbOV1dLCBbJ3RhcmdldCcsIFs4OTgyXV0sIFsnVGF1JywgWzkzMl1dLCBbJ3RhdScsIFs5NjRdXSwgWyd0YnJrJywgWzkxNDBdXSwgWydUY2Fyb24nLCBbMzU2XV0sIFsndGNhcm9uJywgWzM1N11dLCBbJ1RjZWRpbCcsIFszNTRdXSwgWyd0Y2VkaWwnLCBbMzU1XV0sIFsnVGN5JywgWzEwNThdXSwgWyd0Y3knLCBbMTA5MF1dLCBbJ3Rkb3QnLCBbODQxMV1dLCBbJ3RlbHJlYycsIFs4OTgxXV0sIFsnVGZyJywgWzEyMDA4N11dLCBbJ3RmcicsIFsxMjAxMTNdXSwgWyd0aGVyZTQnLCBbODc1Nl1dLCBbJ3RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGV0YScsIFs5MjBdXSwgWyd0aGV0YScsIFs5NTJdXSwgWyd0aGV0YXN5bScsIFs5NzddXSwgWyd0aGV0YXYnLCBbOTc3XV0sIFsndGhpY2thcHByb3gnLCBbODc3Nl1dLCBbJ3RoaWNrc2ltJywgWzg3NjRdXSwgWydUaGlja1NwYWNlJywgWzgyODcsIDgyMDJdXSwgWydUaGluU3BhY2UnLCBbODIwMV1dLCBbJ3RoaW5zcCcsIFs4MjAxXV0sIFsndGhrYXAnLCBbODc3Nl1dLCBbJ3Roa3NpbScsIFs4NzY0XV0sIFsnVEhPUk4nLCBbMjIyXV0sIFsndGhvcm4nLCBbMjU0XV0sIFsndGlsZGUnLCBbNzMyXV0sIFsnVGlsZGUnLCBbODc2NF1dLCBbJ1RpbGRlRXF1YWwnLCBbODc3MV1dLCBbJ1RpbGRlRnVsbEVxdWFsJywgWzg3NzNdXSwgWydUaWxkZVRpbGRlJywgWzg3NzZdXSwgWyd0aW1lc2JhcicsIFsxMDgwMV1dLCBbJ3RpbWVzYicsIFs4ODY0XV0sIFsndGltZXMnLCBbMjE1XV0sIFsndGltZXNkJywgWzEwODAwXV0sIFsndGludCcsIFs4NzQ5XV0sIFsndG9lYScsIFsxMDUzNl1dLCBbJ3RvcGJvdCcsIFs5MDE0XV0sIFsndG9wY2lyJywgWzEwOTkzXV0sIFsndG9wJywgWzg4NjhdXSwgWydUb3BmJywgWzEyMDEzOV1dLCBbJ3RvcGYnLCBbMTIwMTY1XV0sIFsndG9wZm9yaycsIFsxMDk3MF1dLCBbJ3Rvc2EnLCBbMTA1MzddXSwgWyd0cHJpbWUnLCBbODI0NF1dLCBbJ3RyYWRlJywgWzg0ODJdXSwgWydUUkFERScsIFs4NDgyXV0sIFsndHJpYW5nbGUnLCBbOTY1M11dLCBbJ3RyaWFuZ2xlZG93bicsIFs5NjYzXV0sIFsndHJpYW5nbGVsZWZ0JywgWzk2NjddXSwgWyd0cmlhbmdsZWxlZnRlcScsIFs4ODg0XV0sIFsndHJpYW5nbGVxJywgWzg3OTZdXSwgWyd0cmlhbmdsZXJpZ2h0JywgWzk2NTddXSwgWyd0cmlhbmdsZXJpZ2h0ZXEnLCBbODg4NV1dLCBbJ3RyaWRvdCcsIFs5NzA4XV0sIFsndHJpZScsIFs4Nzk2XV0sIFsndHJpbWludXMnLCBbMTA4MTBdXSwgWydUcmlwbGVEb3QnLCBbODQxMV1dLCBbJ3RyaXBsdXMnLCBbMTA4MDldXSwgWyd0cmlzYicsIFsxMDcwMV1dLCBbJ3RyaXRpbWUnLCBbMTA4MTFdXSwgWyd0cnBleml1bScsIFs5MTg2XV0sIFsnVHNjcicsIFsxMTk5ODNdXSwgWyd0c2NyJywgWzEyMDAwOV1dLCBbJ1RTY3knLCBbMTA2Ml1dLCBbJ3RzY3knLCBbMTA5NF1dLCBbJ1RTSGN5JywgWzEwMzVdXSwgWyd0c2hjeScsIFsxMTE1XV0sIFsnVHN0cm9rJywgWzM1OF1dLCBbJ3RzdHJvaycsIFszNTldXSwgWyd0d2l4dCcsIFs4ODEyXV0sIFsndHdvaGVhZGxlZnRhcnJvdycsIFs4NjA2XV0sIFsndHdvaGVhZHJpZ2h0YXJyb3cnLCBbODYwOF1dLCBbJ1VhY3V0ZScsIFsyMThdXSwgWyd1YWN1dGUnLCBbMjUwXV0sIFsndWFycicsIFs4NTkzXV0sIFsnVWFycicsIFs4NjA3XV0sIFsndUFycicsIFs4NjU3XV0sIFsnVWFycm9jaXInLCBbMTA1NjldXSwgWydVYnJjeScsIFsxMDM4XV0sIFsndWJyY3knLCBbMTExOF1dLCBbJ1VicmV2ZScsIFszNjRdXSwgWyd1YnJldmUnLCBbMzY1XV0sIFsnVWNpcmMnLCBbMjE5XV0sIFsndWNpcmMnLCBbMjUxXV0sIFsnVWN5JywgWzEwNTldXSwgWyd1Y3knLCBbMTA5MV1dLCBbJ3VkYXJyJywgWzg2NDVdXSwgWydVZGJsYWMnLCBbMzY4XV0sIFsndWRibGFjJywgWzM2OV1dLCBbJ3VkaGFyJywgWzEwNjA2XV0sIFsndWZpc2h0JywgWzEwNjIyXV0sIFsnVWZyJywgWzEyMDA4OF1dLCBbJ3VmcicsIFsxMjAxMTRdXSwgWydVZ3JhdmUnLCBbMjE3XV0sIFsndWdyYXZlJywgWzI0OV1dLCBbJ3VIYXInLCBbMTA1OTVdXSwgWyd1aGFybCcsIFs4NjM5XV0sIFsndWhhcnInLCBbODYzOF1dLCBbJ3VoYmxrJywgWzk2MDBdXSwgWyd1bGNvcm4nLCBbODk4OF1dLCBbJ3VsY29ybmVyJywgWzg5ODhdXSwgWyd1bGNyb3AnLCBbODk3NV1dLCBbJ3VsdHJpJywgWzk3MjBdXSwgWydVbWFjcicsIFszNjJdXSwgWyd1bWFjcicsIFszNjNdXSwgWyd1bWwnLCBbMTY4XV0sIFsnVW5kZXJCYXInLCBbOTVdXSwgWydVbmRlckJyYWNlJywgWzkxODNdXSwgWydVbmRlckJyYWNrZXQnLCBbOTE0MV1dLCBbJ1VuZGVyUGFyZW50aGVzaXMnLCBbOTE4MV1dLCBbJ1VuaW9uJywgWzg4OTldXSwgWydVbmlvblBsdXMnLCBbODg0Nl1dLCBbJ1VvZ29uJywgWzM3MF1dLCBbJ3VvZ29uJywgWzM3MV1dLCBbJ1VvcGYnLCBbMTIwMTQwXV0sIFsndW9wZicsIFsxMjAxNjZdXSwgWydVcEFycm93QmFyJywgWzEwNTE0XV0sIFsndXBhcnJvdycsIFs4NTkzXV0sIFsnVXBBcnJvdycsIFs4NTkzXV0sIFsnVXBhcnJvdycsIFs4NjU3XV0sIFsnVXBBcnJvd0Rvd25BcnJvdycsIFs4NjQ1XV0sIFsndXBkb3duYXJyb3cnLCBbODU5N11dLCBbJ1VwRG93bkFycm93JywgWzg1OTddXSwgWydVcGRvd25hcnJvdycsIFs4NjYxXV0sIFsnVXBFcXVpbGlicml1bScsIFsxMDYwNl1dLCBbJ3VwaGFycG9vbmxlZnQnLCBbODYzOV1dLCBbJ3VwaGFycG9vbnJpZ2h0JywgWzg2MzhdXSwgWyd1cGx1cycsIFs4ODQ2XV0sIFsnVXBwZXJMZWZ0QXJyb3cnLCBbODU5OF1dLCBbJ1VwcGVyUmlnaHRBcnJvdycsIFs4NTk5XV0sIFsndXBzaScsIFs5NjVdXSwgWydVcHNpJywgWzk3OF1dLCBbJ3Vwc2loJywgWzk3OF1dLCBbJ1Vwc2lsb24nLCBbOTMzXV0sIFsndXBzaWxvbicsIFs5NjVdXSwgWydVcFRlZUFycm93JywgWzg2MTNdXSwgWydVcFRlZScsIFs4ODY5XV0sIFsndXB1cGFycm93cycsIFs4NjQ4XV0sIFsndXJjb3JuJywgWzg5ODldXSwgWyd1cmNvcm5lcicsIFs4OTg5XV0sIFsndXJjcm9wJywgWzg5NzRdXSwgWydVcmluZycsIFszNjZdXSwgWyd1cmluZycsIFszNjddXSwgWyd1cnRyaScsIFs5NzIxXV0sIFsnVXNjcicsIFsxMTk5ODRdXSwgWyd1c2NyJywgWzEyMDAxMF1dLCBbJ3V0ZG90JywgWzg5NDRdXSwgWydVdGlsZGUnLCBbMzYwXV0sIFsndXRpbGRlJywgWzM2MV1dLCBbJ3V0cmknLCBbOTY1M11dLCBbJ3V0cmlmJywgWzk2NTJdXSwgWyd1dWFycicsIFs4NjQ4XV0sIFsnVXVtbCcsIFsyMjBdXSwgWyd1dW1sJywgWzI1Ml1dLCBbJ3V3YW5nbGUnLCBbMTA2NjNdXSwgWyd2YW5ncnQnLCBbMTA2NTJdXSwgWyd2YXJlcHNpbG9uJywgWzEwMTNdXSwgWyd2YXJrYXBwYScsIFsxMDA4XV0sIFsndmFybm90aGluZycsIFs4NzA5XV0sIFsndmFycGhpJywgWzk4MV1dLCBbJ3ZhcnBpJywgWzk4Ml1dLCBbJ3ZhcnByb3B0bycsIFs4NzMzXV0sIFsndmFycicsIFs4NTk3XV0sIFsndkFycicsIFs4NjYxXV0sIFsndmFycmhvJywgWzEwMDldXSwgWyd2YXJzaWdtYScsIFs5NjJdXSwgWyd2YXJzdWJzZXRuZXEnLCBbODg0MiwgNjUwMjRdXSwgWyd2YXJzdWJzZXRuZXFxJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcScsIFs4ODQzLCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcXEnLCBbMTA5NTYsIDY1MDI0XV0sIFsndmFydGhldGEnLCBbOTc3XV0sIFsndmFydHJpYW5nbGVsZWZ0JywgWzg4ODJdXSwgWyd2YXJ0cmlhbmdsZXJpZ2h0JywgWzg4ODNdXSwgWyd2QmFyJywgWzEwOTg0XV0sIFsnVmJhcicsIFsxMDk4N11dLCBbJ3ZCYXJ2JywgWzEwOTg1XV0sIFsnVmN5JywgWzEwNDJdXSwgWyd2Y3knLCBbMTA3NF1dLCBbJ3ZkYXNoJywgWzg4NjZdXSwgWyd2RGFzaCcsIFs4ODcyXV0sIFsnVmRhc2gnLCBbODg3M11dLCBbJ1ZEYXNoJywgWzg4NzVdXSwgWydWZGFzaGwnLCBbMTA5ODJdXSwgWyd2ZWViYXInLCBbODg5MV1dLCBbJ3ZlZScsIFs4NzQ0XV0sIFsnVmVlJywgWzg4OTddXSwgWyd2ZWVlcScsIFs4Nzk0XV0sIFsndmVsbGlwJywgWzg5NDJdXSwgWyd2ZXJiYXInLCBbMTI0XV0sIFsnVmVyYmFyJywgWzgyMTRdXSwgWyd2ZXJ0JywgWzEyNF1dLCBbJ1ZlcnQnLCBbODIxNF1dLCBbJ1ZlcnRpY2FsQmFyJywgWzg3MzldXSwgWydWZXJ0aWNhbExpbmUnLCBbMTI0XV0sIFsnVmVydGljYWxTZXBhcmF0b3InLCBbMTAwNzJdXSwgWydWZXJ0aWNhbFRpbGRlJywgWzg3NjhdXSwgWydWZXJ5VGhpblNwYWNlJywgWzgyMDJdXSwgWydWZnInLCBbMTIwMDg5XV0sIFsndmZyJywgWzEyMDExNV1dLCBbJ3ZsdHJpJywgWzg4ODJdXSwgWyd2bnN1YicsIFs4ODM0LCA4NDAyXV0sIFsndm5zdXAnLCBbODgzNSwgODQwMl1dLCBbJ1ZvcGYnLCBbMTIwMTQxXV0sIFsndm9wZicsIFsxMjAxNjddXSwgWyd2cHJvcCcsIFs4NzMzXV0sIFsndnJ0cmknLCBbODg4M11dLCBbJ1ZzY3InLCBbMTE5OTg1XV0sIFsndnNjcicsIFsxMjAwMTFdXSwgWyd2c3VibkUnLCBbMTA5NTUsIDY1MDI0XV0sIFsndnN1Ym5lJywgWzg4NDIsIDY1MDI0XV0sIFsndnN1cG5FJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZzdXBuZScsIFs4ODQzLCA2NTAyNF1dLCBbJ1Z2ZGFzaCcsIFs4ODc0XV0sIFsndnppZ3phZycsIFsxMDY1MF1dLCBbJ1djaXJjJywgWzM3Ml1dLCBbJ3djaXJjJywgWzM3M11dLCBbJ3dlZGJhcicsIFsxMDg0N11dLCBbJ3dlZGdlJywgWzg3NDNdXSwgWydXZWRnZScsIFs4ODk2XV0sIFsnd2VkZ2VxJywgWzg3OTNdXSwgWyd3ZWllcnAnLCBbODQ3Ml1dLCBbJ1dmcicsIFsxMjAwOTBdXSwgWyd3ZnInLCBbMTIwMTE2XV0sIFsnV29wZicsIFsxMjAxNDJdXSwgWyd3b3BmJywgWzEyMDE2OF1dLCBbJ3dwJywgWzg0NzJdXSwgWyd3cicsIFs4NzY4XV0sIFsnd3JlYXRoJywgWzg3NjhdXSwgWydXc2NyJywgWzExOTk4Nl1dLCBbJ3dzY3InLCBbMTIwMDEyXV0sIFsneGNhcCcsIFs4ODk4XV0sIFsneGNpcmMnLCBbOTcxMV1dLCBbJ3hjdXAnLCBbODg5OV1dLCBbJ3hkdHJpJywgWzk2NjFdXSwgWydYZnInLCBbMTIwMDkxXV0sIFsneGZyJywgWzEyMDExN11dLCBbJ3hoYXJyJywgWzEwMjMxXV0sIFsneGhBcnInLCBbMTAyMzRdXSwgWydYaScsIFs5MjZdXSwgWyd4aScsIFs5NThdXSwgWyd4bGFycicsIFsxMDIyOV1dLCBbJ3hsQXJyJywgWzEwMjMyXV0sIFsneG1hcCcsIFsxMDIzNl1dLCBbJ3huaXMnLCBbODk1NV1dLCBbJ3hvZG90JywgWzEwNzUyXV0sIFsnWG9wZicsIFsxMjAxNDNdXSwgWyd4b3BmJywgWzEyMDE2OV1dLCBbJ3hvcGx1cycsIFsxMDc1M11dLCBbJ3hvdGltZScsIFsxMDc1NF1dLCBbJ3hyYXJyJywgWzEwMjMwXV0sIFsneHJBcnInLCBbMTAyMzNdXSwgWydYc2NyJywgWzExOTk4N11dLCBbJ3hzY3InLCBbMTIwMDEzXV0sIFsneHNxY3VwJywgWzEwNzU4XV0sIFsneHVwbHVzJywgWzEwNzU2XV0sIFsneHV0cmknLCBbOTY1MV1dLCBbJ3h2ZWUnLCBbODg5N11dLCBbJ3h3ZWRnZScsIFs4ODk2XV0sIFsnWWFjdXRlJywgWzIyMV1dLCBbJ3lhY3V0ZScsIFsyNTNdXSwgWydZQWN5JywgWzEwNzFdXSwgWyd5YWN5JywgWzExMDNdXSwgWydZY2lyYycsIFszNzRdXSwgWyd5Y2lyYycsIFszNzVdXSwgWydZY3knLCBbMTA2N11dLCBbJ3ljeScsIFsxMDk5XV0sIFsneWVuJywgWzE2NV1dLCBbJ1lmcicsIFsxMjAwOTJdXSwgWyd5ZnInLCBbMTIwMTE4XV0sIFsnWUljeScsIFsxMDMxXV0sIFsneWljeScsIFsxMTExXV0sIFsnWW9wZicsIFsxMjAxNDRdXSwgWyd5b3BmJywgWzEyMDE3MF1dLCBbJ1lzY3InLCBbMTE5OTg4XV0sIFsneXNjcicsIFsxMjAwMTRdXSwgWydZVWN5JywgWzEwNzBdXSwgWyd5dWN5JywgWzExMDJdXSwgWyd5dW1sJywgWzI1NV1dLCBbJ1l1bWwnLCBbMzc2XV0sIFsnWmFjdXRlJywgWzM3N11dLCBbJ3phY3V0ZScsIFszNzhdXSwgWydaY2Fyb24nLCBbMzgxXV0sIFsnemNhcm9uJywgWzM4Ml1dLCBbJ1pjeScsIFsxMDQ3XV0sIFsnemN5JywgWzEwNzldXSwgWydaZG90JywgWzM3OV1dLCBbJ3pkb3QnLCBbMzgwXV0sIFsnemVldHJmJywgWzg0ODhdXSwgWydaZXJvV2lkdGhTcGFjZScsIFs4MjAzXV0sIFsnWmV0YScsIFs5MThdXSwgWyd6ZXRhJywgWzk1MF1dLCBbJ3pmcicsIFsxMjAxMTldXSwgWydaZnInLCBbODQ4OF1dLCBbJ1pIY3knLCBbMTA0Nl1dLCBbJ3poY3knLCBbMTA3OF1dLCBbJ3ppZ3JhcnInLCBbODY2OV1dLCBbJ3pvcGYnLCBbMTIwMTcxXV0sIFsnWm9wZicsIFs4NDg0XV0sIFsnWnNjcicsIFsxMTk5ODldXSwgWyd6c2NyJywgWzEyMDAxNV1dLCBbJ3p3aicsIFs4MjA1XV0sIFsnenduaicsIFs4MjA0XV1dO1xuXG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIGNoYXJJbmRleCA9IHt9O1xuXG5jcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0bWw1RW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2hyO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG5cbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W2NdO1xuICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrK1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYWxwaGFJbmRleCBQYXNzZWQgYnkgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJJbmRleCBQYXNzZWQgYnkgcmVmZXJlbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCkge1xuICAgIHZhciBpID0gRU5USVRJRVMubGVuZ3RoO1xuICAgIHZhciBfcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGUgPSBFTlRJVElFU1tpXTtcbiAgICAgICAgdmFyIGFscGhhID0gZVswXTtcbiAgICAgICAgdmFyIGNoYXJzID0gZVsxXTtcbiAgICAgICAgdmFyIGNociA9IGNoYXJzWzBdO1xuICAgICAgICB2YXIgYWRkQ2hhciA9IChjaHIgPCAzMiB8fCBjaHIgPiAxMjYpIHx8IGNociA9PT0gNjIgfHwgY2hyID09PSA2MCB8fCBjaHIgPT09IDM4IHx8IGNociA9PT0gMzQgfHwgY2hyID09PSAzOTtcbiAgICAgICAgdmFyIGNoYXJJbmZvO1xuICAgICAgICBpZiAoYWRkQ2hhcikge1xuICAgICAgICAgICAgY2hhckluZm8gPSBjaGFySW5kZXhbY2hyXSA9IGNoYXJJbmRleFtjaHJdIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyc1sxXSkge1xuICAgICAgICAgICAgdmFyIGNocjIgPSBjaGFyc1sxXTtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkQ2hhciAmJiAoY2hhckluZm9bY2hyMl0gPSBhbHBoYSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvWycnXSA9IGFscGhhKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDVFbnRpdGllcztcbiIsInZhciBBTFBIQV9JTkRFWCA9IHtcbiAgICAnJmx0JzogJzwnLFxuICAgICcmZ3QnOiAnPicsXG4gICAgJyZxdW90JzogJ1wiJyxcbiAgICAnJmFwb3MnOiAnXFwnJyxcbiAgICAnJmFtcCc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJmFwb3M7JzogJ1xcJycsXG4gICAgJyZhbXA7JzogJyYnXG59O1xuXG52YXIgQ0hBUl9JTkRFWCA9IHtcbiAgICA2MDogJ2x0JyxcbiAgICA2MjogJ2d0JyxcbiAgICAzNDogJ3F1b3QnLFxuICAgIDM5OiAnYXBvcycsXG4gICAgMzg6ICdhbXAnXG59O1xuXG52YXIgQ0hBUl9TX0lOREVYID0ge1xuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAnJic6ICcmYW1wOydcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFhtbEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzx8PnxcInwnfCYvZywgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gQ0hBUl9TX0lOREVYW3NdO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIz9bMC05YS16QS1aXSs7Py9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChzLmNoYXJBdCgxKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHMuY2hhckF0KDIpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMyksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMikpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQUxQSEFfSU5ERVhbc10gfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gQ0hBUl9JTkRFWFtjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5naHQgPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5naHQpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxubW9kdWxlLmV4cG9ydHMgPSBYbWxFbnRpdGllcztcbiIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8qZ2xvYmFsIFF1aW50dXM6ZmFsc2UgKi9cbi8qZ2xvYmFsICQ6ZmFsc2UgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihRKSB7XG4gIFxuICBRLnNldHVwRE9NID0gZnVuY3Rpb24oaWQsb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlkID0gaWQgfHwgXCJxdWludHVzXCI7XG4gICAgUS5lbCA9ICQoUS5faXNTdHJpbmcoaWQpID8gXCIjXCIgKyBpZCA6IGlkKTtcbiAgICBpZihRLmVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgUS5lbCA9ICQoXCI8ZGl2PlwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsaWQpXG4gICAgICAgICAgICAgICAgLmNzcyh7d2lkdGg6IDMyMCwgaGVpZ2h0OjQyMCB9KVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhcImJvZHlcIik7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMubWF4aW1pemUpIHtcbiAgICAgIHZhciB3ID0gJCh3aW5kb3cpLndpZHRoKCk7XG4gICAgICB2YXIgaCA9ICQod2luZG93KS5oZWlnaHQoKTtcbiAgICAgIFEuZWwuY3NzKHt3aWR0aDp3LGhlaWdodDpofSk7XG4gICAgfVxuICAgUS53cmFwcGVyID0gUS5lbFxuICAgICAgICAgICAgICAgICAud3JhcChcIjxkaXYgaWQ9J1wiICsgaWQgKyBcIl9jb250YWluZXInLz5cIilcbiAgICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgIC5jc3MoeyB3aWR0aDogUS5lbC53aWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBRLmVsLmhlaWdodCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMCBhdXRvJyB9KTtcbiAgICBRLmVsLmNzcyh7IHBvc2l0aW9uOidyZWxhdGl2ZScsIG92ZXJmbG93OiAnaGlkZGVuJyB9KTtcbiAgICBRLndpZHRoID0gUS5lbC53aWR0aCgpO1xuICAgIFEuaGVpZ2h0ID0gUS5lbC5oZWlnaHQoKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB3aW5kb3cuc2Nyb2xsVG8oMCwxKTsgfSwgMCk7XG4gICAgJCh3aW5kb3cpLmJpbmQoJ29yaWVudGF0aW9uY2hhbmdlJyxmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHdpbmRvdy5zY3JvbGxUbygwLDEpOyB9LCAwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUTtcbiAgfTtcblxuKGZ1bmN0aW9uKCkgeyBcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVCdWlsZGVyKGF0dHJpYnV0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbSx4LHkpIHtcbiAgICAgICAgZG9tLnN0eWxlW2F0dHJpYnV0ZV0gPSBcbiAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyBNYXRoLmZsb29yKHgpICsgXCJweCxcIiArXG4gICAgICAgIE1hdGguZmxvb3IoeSkgKyBcInB4KVwiO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlM0RCdWlsZGVyKGF0dHJpYnV0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbSx4LHkpIHtcbiAgICAgICAgZG9tLnN0eWxlW2F0dHJpYnV0ZV0gPSBcbiAgICAgICAgXCJ0cmFuc2xhdGUzZChcIiArIE1hdGguZmxvb3IoeCkgKyBcInB4LFwiICtcbiAgICAgICAgTWF0aC5mbG9vcih5KSArIFwicHgsMHB4KVwiO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVCdWlsZGVyKGF0dHJpYnV0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbSxzY2FsZSkge1xuICAgICAgICBkb20uc3R5bGVbYXR0cmlidXRlICsgJ09yaWdpbiddID0gXCIwJSAwJVwiO1xuICAgICAgICBkb20uc3R5bGVbYXR0cmlidXRlXSA9IFwic2NhbGUoXCIgKyBzY2FsZSArIFwiKVwiO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmFsbGJhY2tUcmFuc2xhdGUoZG9tLHgseSkge1xuICAgICAgZG9tLnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xuICAgICAgZG9tLnN0eWxlLnRvcCA9IHkgKyBcInB4XCI7XG4gICAgfVxuICAgIHZhciBoYXMzZCA9ICAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93ICYmIFxuICAgICAgICAgICAgICAgICAgJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSk7XG4gICAgdmFyIGR1bW15U3R5bGUgPSAkKFwiPGRpdj5cIilbMF0uc3R5bGU7XG4gICAgdmFyIHRyYW5zZm9ybU1ldGhvZHMgPSBbJ3RyYW5zZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dlYmtpdFRyYW5zZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ01velRyYW5zZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21zVHJhbnNmb3JtJyBdO1xuICAgIGZvcih2YXIgaT0wO2k8dHJhbnNmb3JtTWV0aG9kcy5sZW5ndGg7aSsrKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtTmFtZSA9IHRyYW5zZm9ybU1ldGhvZHNbaV07XG4gICAgICBpZighUS5faXNVbmRlZmluZWQoZHVtbXlTdHlsZVt0cmFuc2Zvcm1OYW1lXSkpIHtcbiAgICAgICAgaWYoaGFzM2QpIHtcbiAgICAgICAgICBRLnBvc2l0aW9uRE9NID0gdHJhbnNsYXRlM0RCdWlsZGVyKHRyYW5zZm9ybU5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFEucG9zaXRpb25ET00gPSB0cmFuc2xhdGVCdWlsZGVyKHRyYW5zZm9ybU5hbWUpOyBcbiAgICAgICAgfVxuICAgICAgICBRLnNjYWxlRE9NID0gc2NhbGVCdWlsZGVyKHRyYW5zZm9ybU5hbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgUS5wb3NpdGlvbkRPTSA9IFEucG9zaXRpb25ET00gfHwgZmFsbGJhY2tUcmFuc2xhdGU7XG4gICAgUS5zY2FsZURPTSA9IFEuc2NhbGVET00gfHwgZnVuY3Rpb24oc2NhbGUpIHt9O1xuICB9KCkpO1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICAgZnVuY3Rpb24gdHJhbnNpdGlvbkJ1aWxkZXIoYXR0cmlidXRlLHByZWZpeCl7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZG9tLHByb3BlcnR5LHNlYyxlYXNpbmcpIHtcbiAgICAgICAgZWFzaW5nID0gZWFzaW5nIHx8IFwiXCI7XG4gICAgICAgIGlmKHByb3BlcnR5ID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIHByb3BlcnR5ID0gcHJlZml4ICsgcHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjID0gc2VjIHx8IFwiMXNcIjtcbiAgICAgICAgZG9tLnN0eWxlW2F0dHJpYnV0ZV0gPSBwcm9wZXJ0eSArIFwiIFwiICsgc2VjICsgXCIgXCIgKyBlYXNpbmc7XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBEdW1teSBtZXRob2RcbiAgICBmdW5jdGlvbiBmYWxsYmFja1RyYW5zaXRpb24oKSB7IH1cbiAgICB2YXIgZHVtbXlTdHlsZSA9ICQoXCI8ZGl2PlwiKVswXS5zdHlsZTtcbiAgICB2YXIgdHJhbnNpdGlvbk1ldGhvZHMgPSBbJ3RyYW5zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3ZWJraXRUcmFuc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTW96VHJhbnNpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21zVHJhbnNpdGlvbicgXTtcbiAgICB2YXIgcHJlZml4TmFtZXMgPSBbICcnLCAnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW1zLScgXTtcbiAgICBmb3IodmFyIGk9MDtpPHRyYW5zaXRpb25NZXRob2RzLmxlbmd0aDtpKyspIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHRyYW5zaXRpb25NZXRob2RzW2ldO1xuICAgICAgdmFyIHByZWZpeE5hbWUgPSBwcmVmaXhOYW1lc1tpXTtcbiAgICAgIGlmKCFRLl9pc1VuZGVmaW5lZChkdW1teVN0eWxlW3RyYW5zaXRpb25OYW1lXSkpIHtcbiAgICAgICAgUS50cmFuc2l0aW9uRE9NID0gdHJhbnNpdGlvbkJ1aWxkZXIodHJhbnNpdGlvbk5hbWUscHJlZml4TmFtZSk7IFxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgUS50cmFuc2l0aW9uRE9NID0gUS50cmFuc2l0aW9uRE9NIHx8IGZhbGxiYWNrVHJhbnNpdGlvbjtcbiAgfSgpKTtcblxuICBRLkRPTVNwcml0ZSA9IFEuU3ByaXRlLmV4dGVuZCh7XG4gICAgaW5pdDogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIHRoaXMuX3N1cGVyKHByb3BzKTtcbiAgICAgIHRoaXMuZWwgPSAkKFwiPGRpdj5cIikuY3NzKHtcbiAgICAgICAgd2lkdGg6IHRoaXMucC53LFxuICAgICAgICBoZWlnaHQ6IHRoaXMucC5oLFxuICAgICAgICB6SW5kZXg6IHRoaXMucC56IHx8IDAsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZG9tID0gdGhpcy5lbFswXTtcbiAgICAgIHRoaXMucnAgPSB7fTtcbiAgICAgIHRoaXMuc2V0SW1hZ2UoKTtcbiAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKCk7XG4gICAgfSxcbiAgXG4gICAgc2V0SW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFzc2V0O1xuICAgICAgaWYodGhpcy5zaGVldCgpKSB7XG4gICAgICAgIGFzc2V0ID0gUS5hc3NldCh0aGlzLnNoZWV0KCkuYXNzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXQgPSB0aGlzLmFzc2V0KCk7XG4gICAgICB9XG4gICAgICBpZihhc3NldCkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybChcIiArIGFzc2V0LnNyYyArIFwiKVwiO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMucDtcbiAgICAgIHZhciBycCA9IHRoaXMucnA7XG4gICAgICBpZihycC5mcmFtZSAhPT0gcC5mcmFtZSkge1xuICAgICAgICBpZihwLnNoZWV0KSB7XG4gICAgICAgICAgdGhpcy5kb20uc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gXG4gICAgICAgICAgICAgICgtdGhpcy5zaGVldCgpLmZ4KHAuZnJhbWUpKSArIFwicHggXCIgKyBcbiAgICAgICAgICAgICAgKC10aGlzLnNoZWV0KCkuZnkocC5mcmFtZSkpICsgXCJweFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IFwiMHB4IDBweFwiO1xuICAgICAgICB9XG4gICAgICAgIHJwLmZyYW1lID0gcC5mcmFtZTtcbiAgICAgIH1cbiAgICAgIGlmKHJwLnggIT09IHAueCB8fCBycC55ICE9PSBwLnkpIHtcbiAgICAgICAgUS5wb3NpdGlvbkRPTSh0aGlzLmRvbSxwLngscC55KTtcbiAgICAgICAgcnAueCA9IHAueDtcbiAgICAgICAgcnAueSA9IHAueTtcbiAgICAgIH0gXG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb20uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RyYXcnKTtcbiAgICB9LFxuXG4gICAgc3RlcDogZnVuY3Rpb24oZHQpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignc3RlcCcsZHQpO1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLmRlc3Ryb3llZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIHRoaXMuX3N1cGVyKCk7XG4gICAgICB0aGlzLmVsLnJlbW92ZSgpO1xuICAgIH1cbiAgfSk7XG4gIFxuXG4gIGlmKFEuU3RhZ2UpIHtcbiAgICBRLkRPTVN0YWdlID0gUS5TdGFnZS5leHRlbmQoe1xuICAgICAgaW5pdDogZnVuY3Rpb24oc2NlbmUpIHtcbiAgICAgICAgdGhpcy5lbCA9ICQoXCI8ZGl2PlwiKS5jc3Moe1xuICAgICAgICAgIHRvcDowLFxuICAgICAgICAgIHBvc2l0aW9uOidyZWxhdGl2ZSdcbiAgICAgICAgfSkuYXBwZW5kVG8oUS5lbCk7XG4gICAgICAgIHRoaXMuZG9tID0gdGhpcy5lbFswXTtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gdGhpcy5lbC53cmFwKCc8ZGl2PicpLnBhcmVudCgpLmNzcyh7XG4gICAgICAgICAgcG9zaXRpb246J2Fic29sdXRlJyxcbiAgICAgICAgICBsZWZ0OjAsXG4gICAgICAgICAgdG9wOjBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLndyYXBwZXJfZG9tID0gdGhpcy53cmFwcGVyWzBdO1xuICAgICAgICB0aGlzLl9zdXBlcihzY2VuZSk7XG4gICAgICB9LFxuXG4gICAgICBpbnNlcnQ6IGZ1bmN0aW9uKGl0bSkge1xuICAgICAgICBpZihpdG0uZG9tKSB7IHRoaXMuZG9tLmFwcGVuZENoaWxkKGl0bS5kb20pOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlcihpdG0pO1xuICAgICAgfSxcblxuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fc3VwZXIoKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlc2NhbGU6IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgUS5zY2FsZURPTSh0aGlzLndyYXBwZXJfZG9tLHNjYWxlKTtcbiAgICAgIH0sXG5cbiAgICAgIGNlbnRlck9uOiBmdW5jdGlvbih4LHkpIHtcbiAgICAgICAgdGhpcy54ID0gUS53aWR0aC8yL3RoaXMuc2NhbGUgLSAgeDtcbiAgICAgICAgdGhpcy55ID0gUS5oZWlnaHQvMi90aGlzLnNjYWxlIC0geTtcbiAgICAgICAgUS5wb3NpdGlvbkRPTSh0aGlzLmRvbSx0aGlzLngsdGhpcy55KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIFEuZG9tT25seSA9IGZ1bmN0aW9uKCkge1xuICAgIFEuU3RhZ2UgPSBRLkRPTVN0YWdlO1xuICAgIFEuc2V0dXAgPSBRLnNldHVwRE9NO1xuICAgIFEuU3ByaXRlID0gUS5ET01TcHJpdGU7XG4gICAgcmV0dXJuIFE7XG4gIH07XG4gIFxuICBRLkRPTVRpbGVNYXAgPSBRLkRPTVNwcml0ZS5leHRlbmQoe1xuICAgIC8vIEV4cGVjdHMgYSBzcHJpdGUgc2hlZXQsIGFsb25nIHdpdGggY29scyBhbmQgcm93cyBwcm9wZXJ0aWVzXG4gICAgaW5pdDpmdW5jdGlvbihwcm9wcykge1xuICAgICAgdmFyIHNoZWV0ID0gUS5zaGVldChwcm9wcy5zaGVldCk7XG4gICAgICB0aGlzLl9zdXBlcihRLl9leHRlbmQocHJvcHMse1xuICAgICAgICB3OiBwcm9wcy5jb2xzICogc2hlZXQudGlsZXcsXG4gICAgICAgIGg6IHByb3BzLnJvd3MgKiBzaGVldC50aWxlaCxcbiAgICAgICAgdGlsZXc6IHNoZWV0LnRpbGV3LFxuICAgICAgICB0aWxlaDogc2hlZXQudGlsZWhcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuc2hvd24gPSBbXTtcbiAgICAgIHRoaXMuZG9tVGlsZXMgPSBbXTtcbiAgICB9LFxuXG4gICAgc2V0SW1hZ2U6IGZ1bmN0aW9uKCkgeyB9LFxuICBcbiAgICBzZXR1cDogZnVuY3Rpb24odGlsZXMsaGlkZSkge1xuICAgICAgdGhpcy50aWxlcyA9IHRpbGVzO1xuICAgICAgZm9yKHZhciB5PTAsaGVpZ2h0PXRpbGVzLmxlbmd0aDt5PGhlaWdodDt5KyspIHtcbiAgICAgICAgdGhpcy5kb21UaWxlcy5wdXNoKFtdKTtcbiAgICAgICAgdGhpcy5zaG93bi5wdXNoKFtdKTtcbiAgICAgICAgZm9yKHZhciB4PTAsd2lkdGg9dGlsZXNbMF0ubGVuZ3RoO3g8d2lkdGg7eCsrKSB7XG4gICAgICAgICAgdmFyIGRvbVRpbGUgPSB0aGlzLl9hZGRUaWxlKHRpbGVzW3ldW3hdKTtcbiAgICAgICAgICBpZihoaWRlKSB7IGRvbVRpbGUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nOyB9XG4gICAgICAgICAgdGhpcy5zaG93bi5wdXNoKGhpZGUgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgICAgIHRoaXMuZG9tVGlsZXNbeV0ucHVzaChkb21UaWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wO1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LnN0eWxlLndpZHRoID0gcC50aWxldyArIFwicHhcIjtcbiAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBwLnRpbGVoICsgXCJweFwiO1xuICAgICAgZGl2LnN0eWxlLnN0eWxlRmxvYXQgPSBkaXYuc3R5bGUuY3NzRmxvYXQgPSAnbGVmdCc7XG4gICAgICB0aGlzLl9zZXRUaWxlKGRpdixmcmFtZSk7XG4gICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LFxuXG4gICAgX3NldFRpbGU6IGZ1bmN0aW9uKGRvbSxmcmFtZSkge1xuICAgICAgdmFyIGFzc2V0ID0gUS5hc3NldCh0aGlzLnNoZWV0KCkuYXNzZXQpO1xuICAgICAgZG9tLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IFwidXJsKFwiICsgYXNzZXQuc3JjICsgXCIpXCI7XG4gICAgICBkb20uc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKC10aGlzLnNoZWV0KCkuZngoZnJhbWUpKSArXCJweCBcIiArICgtdGhpcy5zaGVldCgpLmZ5KGZyYW1lKSkgKyBcInB4XCI7XG4gICAgfSxcblxuICAgIHZhbGlkVGlsZTogZnVuY3Rpb24oeCx5KSB7XG4gICAgICByZXR1cm4gKHkgPj0gMCAmJiB5IDwgdGhpcy5wLnJvd3MpICYmIFxuICAgICAgICAgICAgICh4ID49IDAgJiYgeCA8IHRoaXMucC5jb2xzKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbih4LHkpIHsgcmV0dXJuIHRoaXMudmFsaWRUaWxlKHgseSkgPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aWxlc1t5XVt4XSA6IG51bGw7IH0sXG5cbiAgICBnZXREb206IGZ1bmN0aW9uKHgseSkgeyByZXR1cm4gdGhpcy52YWxpZFRpbGUoeCx5KSA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbVRpbGVzW3ldW3hdIDogbnVsbDsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHgseSxmcmFtZSkge1xuICAgICAgaWYoIXRoaXMudmFsaWRUaWxlKHgseSkpIHsgcmV0dXJuOyB9XG4gICAgICB0aGlzLnRpbGVzW3ldW3hdID0gZnJhbWU7XG4gICAgICB2YXIgZG9tVGlsZSA9IHRoaXMuZ2V0RG9tKHgseSk7XG4gICAgICB0aGlzLl9zZXRGaWxlKGRvbVRpbGUsZnJhbWUpO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbih4LHkpIHtcbiAgICAgIGlmKCF0aGlzLnZhbGlkVGlsZSh4LHkpKSB7IHJldHVybjsgfVxuICAgICAgaWYodGhpcy5zaG93blt5XVt4XSkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuZ2V0RG9tKHgseSkuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIHRoaXMuc2hvd25beV1beF0gPSB0cnVlO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbih4LHkpIHtcbiAgICAgIGlmKCF0aGlzLnZhbGlkVGlsZSh4LHkpKSB7IHJldHVybjsgfVxuICAgICAgaWYoIXRoaXMuc2hvd25beV1beF0pIHsgcmV0dXJuOyB9XG4gICAgICB0aGlzLmdldERvbSh4LHkpLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIHRoaXMuc2hvd25beV1beF0gPSBmYWxzZTtcbiAgICB9XG4gIH0pOyBcblxuXG5cblxufTtcblxuIiwiLypnbG9iYWwgUXVpbnR1czpmYWxzZSAqL1xuLypnbG9iYWwgQm94MkQ6ZmFsc2UgKi9cblxudmFyIEJveDJEID0gcmVxdWlyZSgnYm94MmR3ZWInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFEpIHtcbiAgdmFyIEIyZCA9IFEuQjJkID0ge1xuICAgICAgV29ybGQ6IEJveDJELkR5bmFtaWNzLmIyV29ybGQsXG4gICAgICBWZWM6IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcbiAgICAgIEJvZHlEZWY6IEJveDJELkR5bmFtaWNzLmIyQm9keURlZixcbiAgICAgIEJvZHk6IEJveDJELkR5bmFtaWNzLmIyQm9keSxcbiAgICAgIEZpeHR1cmVEZWY6IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZixcbiAgICAgIEZpeHR1cmU6IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZSxcbiAgICAgIFBvbHlnb25TaGFwZTogQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlBvbHlnb25TaGFwZSxcbiAgICAgIENpcmNsZVNoYXBlOiBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyQ2lyY2xlU2hhcGUsXG4gICAgICBMaXN0ZW5lcjogIEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyXG4gICAgfTtcblxuICB2YXIgZGVmT3B0cyA9IFEuUGh5c2ljc0RlZmF1bHRzID0ge1xuICAgIGdyYXZpdHlYOiAwLFxuICAgIGdyYXZpdHlZOiA5LjgsXG4gICAgc2NhbGU6IDMwLFxuICAgIHZlbG9jaXR5SXRlcmF0aW9uczogOCxcbiAgICBwb3NpdGlvbkl0ZXJhdGlvbnM6IDNcbiAgfTtcblxuICBRLmNvbXBvbmVudCgnd29ybGQnLHtcbiAgICBhZGRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm9wdHMgPSBRLl9leHRlbmQoe30sZGVmT3B0cyk7XG4gICAgICB0aGlzLl9ncmF2aXR5ID0gbmV3IEIyZC5WZWModGhpcy5vcHRzLmdyYXZpdHlYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLmdyYXZpdHlZKTtcbiAgICAgIHRoaXMuX3dvcmxkID0gbmV3IEIyZC5Xb3JsZCh0aGlzLl9ncmF2aXR5LCB0cnVlKTtcblxuICAgICAgdmFyIHBoeXNpY3MgPSB0aGlzLFxuICAgICAgICAgIGJvdW5kQmVnaW4gPSBmdW5jdGlvbihjb250YWN0KSB7IHBoeXNpY3MuYmVnaW5Db250YWN0KGNvbnRhY3QpOyB9LFxuICAgICAgICAgIGJvdW5kRW5kID0gZnVuY3Rpb24oY29udGFjdCkgeyBwaHlzaWNzLmVuZENvbnRhY3QoY29udGFjdCk7IH0sXG4gICAgICAgICAgYm91bmRQb3N0U29sdmUgPSBmdW5jdGlvbihjb250YWN0LGltcHVsc2UpIHsgcGh5c2ljcy5wb3N0U29sdmUoY29udGFjdCxpbXB1bHNlKTsgfTtcbiAgXG4gICAgICB0aGlzLl9saXN0ZW5lciA9IG5ldyBCMmQuTGlzdGVuZXIoKTtcbiAgICAgIHRoaXMuX2xpc3RlbmVyLkJlZ2luQ29udGFjdCA9IGJvdW5kQmVnaW47XG4gICAgICB0aGlzLl9saXN0ZW5lci5FbmRDb250YWN0ID0gYm91bmRFbmQ7XG4gICAgICB0aGlzLl9saXN0ZW5lci5Qb3N0U29sdmUgPSBib3VuZFBvc3RTb2x2ZTtcbiAgICAgIHRoaXMuX3dvcmxkLlNldENvbnRhY3RMaXN0ZW5lcih0aGlzLl9saXN0ZW5lcik7XG4gICAgICBcbiAgICAgIHRoaXMuY29sID0ge307XG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5vcHRzLnNjYWxlO1xuICAgICAgdGhpcy5lbnRpdHkub24oJ3N0ZXAnLHRoaXMsJ2JveFN0ZXAnKTtcbiAgICB9LFxuXG4gICAgc2V0Q29sbGlzaW9uRGF0YTogZnVuY3Rpb24oY29udGFjdCxpbXB1bHNlKSB7XG4gICAgICB2YXIgc3ByaXRlQSA9IGNvbnRhY3QuR2V0Rml4dHVyZUEoKS5HZXRCb2R5KCkuR2V0VXNlckRhdGEoKSxcbiAgICAgICAgICBzcHJpdGVCID0gY29udGFjdC5HZXRGaXh0dXJlQigpLkdldEJvZHkoKS5HZXRVc2VyRGF0YSgpO1xuICAgICAgIFxuICAgICAgdGhpcy5jb2xbXCJhXCJdID0gc3ByaXRlQTtcbiAgICAgIHRoaXMuY29sW1wiYlwiXSA9IHNwcml0ZUI7XG4gICAgICB0aGlzLmNvbFtcImltcHVsc2VcIl0gPSBpbXB1bHNlO1xuICAgICAgdGhpcy5jb2xbXCJzcHJpdGVcIl0gPSBudWxsO1xuICAgIH0sXG5cbiAgICBiZWdpbkNvbnRhY3Q6IGZ1bmN0aW9uKGNvbnRhY3QpIHtcbiAgICAgIHRoaXMuc2V0Q29sbGlzaW9uRGF0YShjb250YWN0LG51bGwpO1xuICAgICAgdGhpcy5jb2wuYS50cmlnZ2VyKFwiY29udGFjdFwiLHRoaXMuY29sLmIpO1xuICAgICAgdGhpcy5jb2wuYi50cmlnZ2VyKFwiY29udGFjdFwiLHRoaXMuY29sLmEpO1xuICAgICAgdGhpcy5lbnRpdHkudHJpZ2dlcihcImNvbnRhY3RcIix0aGlzLmNvbCk7XG4gICAgfSxcblxuICAgIGVuZENvbnRhY3Q6IGZ1bmN0aW9uKGNvbnRhY3QpIHtcbiAgICAgIHRoaXMuc2V0Q29sbGlzaW9uRGF0YShjb250YWN0LG51bGwpO1xuICAgICAgdGhpcy5jb2wuYS50cmlnZ2VyKFwiZW5kQ29udGFjdFwiLHRoaXMuY29sLmIpO1xuICAgICAgdGhpcy5jb2wuYi50cmlnZ2VyKFwiZW5kQ29udGFjdFwiLHRoaXMuY29sLmEpO1xuICAgICAgdGhpcy5lbnRpdHkudHJpZ2dlcihcImVuZENvbnRhY3RcIix0aGlzLmNvbCk7XG4gICAgfSxcblxuICAgIHBvc3RTb2x2ZTogZnVuY3Rpb24oY29udGFjdCwgaW1wdWxzZSkge1xuICAgICAgdGhpcy5zZXRDb2xsaXNpb25EYXRhKGNvbnRhY3QsaW1wdWxzZSk7XG4gICAgICB0aGlzLmNvbFtcInNwcml0ZVwiXSA9IHRoaXMuY29sLmI7XG4gICAgICB0aGlzLmNvbC5hLnRyaWdnZXIoXCJpbXB1bHNlXCIsdGhpcy5jb2wpO1xuICAgICAgdGhpcy5jb2xbXCJzcHJpdGVcIl0gPSB0aGlzLmNvbC5hO1xuICAgICAgdGhpcy5jb2wuYi50cmlnZ2VyKFwiaW1wdWxzZVwiLHRoaXMuY29sKTtcbiAgICAgIHRoaXMuZW50aXR5LnRyaWdnZXIoXCJpbXB1bHNlXCIsdGhpcy5jb2wpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVCb2R5OiBmdW5jdGlvbihkZWYpIHtcbiAgICAgIHJldHVybiB0aGlzLl93b3JsZC5DcmVhdGVCb2R5KGRlZik7XG4gICAgfSxcblxuICAgIGRlc3Ryb3lCb2R5OiBmdW5jdGlvbihib2R5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd29ybGQuRGVzdHJveUJvZHkoYm9keSk7XG4gICAgfSxcblxuICAgIGJveFN0ZXA6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICBpZihkdCA+IDEvMjApIHsgZHQgPSAxLzIwOyB9XG4gICAgICB0aGlzLl93b3JsZC5TdGVwKGR0LCBcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMudmVsb2NpdHlJdGVyYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5wb3NpdGlvbkl0ZXJhdGlvbnMpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudGl0eURlZmF1bHRzID0gUS5QaHlzaWNzRW50aXR5RGVmYXVsdHMgPSB7XG4gICAgZGVuc2l0eTogMSxcbiAgICBmcmljdGlvbjogMSxcbiAgICByZXN0aXR1dGlvbjogMC4xXG4gIH07XG5cbiAgUS5jb21wb25lbnQoJ3BoeXNpY3MnLHtcbiAgICBhZGRlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLmVudGl0eS5zdGFnZSkge1xuICAgICAgICB0aGlzLmluc2VydGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVudGl0eS5vbignaW5zZXJ0ZWQnLHRoaXMsJ2luc2VydGVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmVudGl0eS5vbignc3RlcCcsdGhpcywnc3RlcCcpO1xuICAgICAgdGhpcy5lbnRpdHkub24oJ3JlbW92ZWQnLHRoaXMsJ3JlbW92ZWQnKTtcbiAgICB9LFxuXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKHgseSkge1xuICAgICAgdmFyIHN0YWdlID0gdGhpcy5lbnRpdHkuc3RhZ2U7XG4gICAgICB0aGlzLl9ib2R5LlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5fYm9keS5TZXRQb3NpdGlvbihuZXcgQjJkLlZlYyh4IC8gc3RhZ2Uud29ybGQuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLyBzdGFnZS53b3JsZC5zY2FsZSkpO1xuICAgIH0sXG5cbiAgICBhbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIHRoaXMuX2JvZHkuU2V0QW5nbGUoYW5nbGUgLyAxODAgKiBNYXRoLlBJKTtcbiAgICB9LFxuXG4gICAgdmVsb2NpdHk6IGZ1bmN0aW9uKHgseSkge1xuICAgICAgdmFyIHN0YWdlID0gdGhpcy5lbnRpdHkuc3RhZ2U7XG4gICAgICB0aGlzLl9ib2R5LlNldEF3YWtlKHRydWUpO1xuICAgICAgdGhpcy5fYm9keS5TZXRMaW5lYXJWZWxvY2l0eShuZXcgQjJkLlZlYyh4IC8gc3RhZ2Uud29ybGQuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLyBzdGFnZS53b3JsZC5zY2FsZSkpO1xuICAgIH0sXG4gXG4gICAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVudGl0eSA9IHRoaXMuZW50aXR5LFxuICAgICAgICAgIHN0YWdlID0gZW50aXR5LnN0YWdlLFxuICAgICAgICAgIHNjYWxlID0gc3RhZ2Uud29ybGQuc2NhbGUsXG4gICAgICAgICAgcCA9IGVudGl0eS5wLFxuICAgICAgICAgIG9wcyA9IGVudGl0eURlZmF1bHRzLFxuICAgICAgICAgIGRlZiA9IHRoaXMuX2RlZiA9IG5ldyBCMmQuQm9keURlZigpLFxuICAgICAgICAgIGZpeHR1cmVEZWYgPSB0aGlzLl9maXh0dXJlID0gbmV3IEIyZC5GaXh0dXJlRGVmKCk7XG4gICAgICAgICAgICBcbiAgICAgIGRlZi5wb3NpdGlvbi54ID0gcC54IC8gc2NhbGU7XG4gICAgICBkZWYucG9zaXRpb24ueSA9IHAueSAvIHNjYWxlO1xuICAgICAgZGVmLnR5cGUgPSBwLnR5cGUgPT09ICdzdGF0aWMnID8gXG4gICAgICAgICAgICAgICAgIEIyZC5Cb2R5LmIyX3N0YXRpY0JvZHkgOlxuICAgICAgICAgICAgICAgICBCMmQuQm9keS5iMl9keW5hbWljQm9keTtcbiAgICAgIGRlZi5hY3RpdmUgPSB0cnVlO1xuICAgICAgXG4gICAgICB0aGlzLl9ib2R5ID0gc3RhZ2Uud29ybGQuY3JlYXRlQm9keShkZWYpOyBcbiAgICAgIHRoaXMuX2JvZHkuU2V0VXNlckRhdGEoZW50aXR5KTtcbiAgICAgIGZpeHR1cmVEZWYuZGVuc2l0eSA9IHAuZGVuc2l0eSB8fCBvcHMuZGVuc2l0eTtcbiAgICAgIGZpeHR1cmVEZWYuZnJpY3Rpb24gPSBwLmZyaWN0aW9uIHx8IG9wcy5mcmljdGlvbjtcbiAgICAgIGZpeHR1cmVEZWYucmVzdGl0dXRpb24gPSBwLnJlc3RpdHV0aW9uIHx8IG9wcy5yZXN0aXR1dGlvbjtcbiAgICAgIFxuICAgICAgc3dpdGNoKHAuc2hhcGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgZml4dHVyZURlZi5zaGFwZSA9IG5ldyBCMmQuUG9seWdvblNoYXBlKCk7XG4gICAgICAgICAgZml4dHVyZURlZi5zaGFwZS5TZXRBc0JveChwLncvMi9zY2FsZSwgcC5oLzIvc2NhbGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2lyY2xlXCI6XG4gICAgICAgICAgZml4dHVyZURlZi5zaGFwZSA9IG5ldyBCMmQuQ2lyY2xlU2hhcGUocC5yL3NjYWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICAgICAgICBmaXh0dXJlRGVmLnNoYXBlID0gbmV3IEIyZC5Qb2x5Z29uU2hhcGUoKTtcbiAgICAgICAgICB2YXIgcG9pbnRzT2JqID0gUS5fbWFwKHAucG9pbnRzLGZ1bmN0aW9uKHB0KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBwdFswXSAvIHNjYWxlLCB5OiBwdFsxXSAvIHNjYWxlIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZml4dHVyZURlZi5zaGFwZS5TZXRBc0FycmF5KHBvaW50c09iaiwgcC5wb2ludHMubGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5fYm9keS5DcmVhdGVGaXh0dXJlKGZpeHR1cmVEZWYpO1xuICAgICAgdGhpcy5fYm9keS5fYmJpZCA9IHAuaWQ7XG4gICAgfSxcblxuICAgIHJlbW92ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVudGl0eSA9IHRoaXMuZW50aXR5LFxuICAgICAgICAgIHN0YWdlID0gZW50aXR5LnBhcmVudDtcbiAgICAgIHN0YWdlLndvcmxkLmRlc3Ryb3lCb2R5KHRoaXMuX2JvZHkpO1xuICAgIH0sXG5cbiAgICBzdGVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwID0gdGhpcy5lbnRpdHkucCxcbiAgICAgICAgICBzdGFnZSA9IHRoaXMuZW50aXR5LnN0YWdlLFxuICAgICAgICAgIHBvcyA9IHRoaXMuX2JvZHkuR2V0UG9zaXRpb24oKSxcbiAgICAgICAgICBhbmdsZSA9IHRoaXMuX2JvZHkuR2V0QW5nbGUoKTtcbiAgICAgIHAueCA9IHBvcy54ICogc3RhZ2Uud29ybGQuc2NhbGU7XG4gICAgICBwLnkgPSBwb3MueSAqIHN0YWdlLndvcmxkLnNjYWxlO1xuICAgICAgcC5hbmdsZSA9IGFuZ2xlIC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9XG4gIH0pO1xuXG5cbn07XG4iLCIvKmdsb2JhbCBRdWludHVzOmZhbHNlICovXG4vKmdsb2JhbCAkOmZhbHNlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUSkge1xuICB2YXIgU1ZHX05TID1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7IFxuICBRLnNldHVwU1ZHID0gZnVuY3Rpb24oaWQsb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlkID0gaWQgfHwgXCJxdWludHVzXCI7XG4gICAgUS5zdmcgPVEuX2lzU3RyaW5nKGlkKSA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xuICAgIFxuICAgIGlmKCFRLnN2Zykge1xuICAgICAgUS5zdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCdzdmcnKTtcbiAgICAgIFEuc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLDMyMCk7XG4gICAgICBRLnN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsNDIwKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoUS5zdmcpO1xuICAgIH1cblxuICAgIGlmKG9wdGlvbnMubWF4aW1pemUpIHtcbiAgICAgIHZhciB3ID0gd2luZG93LmlubmVyV2lkdGgtMTtcbiAgICAgIHZhciBoID0gd2luZG93LmlubmVySGVpZ2h0LTEwO1xuICAgICAgUS5zdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsdyk7XG4gICAgICBRLnN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaCk7XG4gICAgfVxuXHRRLndpZHRoID0gUS5zdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIFEuaGVpZ2h0ID0gUS5zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgICB2YXIgcGFyZW50PVEuc3ZnLnBhcmVudE5vZGU7XG4gICAgdmFyIGNvbnRhaW5lcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsaWQrJ19jb250YWluZXInKTtcbiAgICBjb250YWluZXIuc3R5bGUud2lkdGg9US53aWR0aDtcbiAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0PVEuaGVpZ2h0O1xuICAgIGNvbnRhaW5lci5zdHlsZS5tYXJnaW49JzAgYXV0byc7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKFEuc3ZnKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBRLndyYXBwZXI9Y29udGFpbmVyO1xuIFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHdpbmRvdy5zY3JvbGxUbygwLDEpOyB9LCAwKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgd2luZG93LnNjcm9sbFRvKDAsMSk7IH0sIDApO1xuICAgIH0pO1xuICAgIHJldHVybiBRO1xuICB9O1xuXG4gIFEuU3ByaXRlLmV4dGVuZChcIlNWR1Nwcml0ZVwiLHtcbiAgICBpbml0OiBmdW5jdGlvbihwcm9wcykge1xuICAgICAgdGhpcy5fc3VwZXIoUS5fZGVmYXVsdHMocHJvcHMse1xuICAgICAgICBzaGFwZTogJ2Jsb2NrJyxcbiAgICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgIGN4OiAwLFxuICAgICAgICBjeTogMFxuICAgICAgfSkpO1xuICAgICAgdGhpcy5jcmVhdGVTaGFwZSgpO1xuICAgICAgdGhpcy5zdmcuc3ByaXRlID0gdGhpcztcbiAgICAgIHRoaXMucnAgPSB7fTtcbiAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKCk7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgUS5fZWFjaChhdHRyLGZ1bmN0aW9uKHZhbHVlLGtleSkge1xuICAgICAgICB0aGlzLnN2Zy5zZXRBdHRyaWJ1dGUoa2V5LHZhbHVlKTtcbiAgICAgIH0sdGhpcyk7XG4gICAgfSxcbiAgICBcbiAgICBjcmVhdGVTaGFwZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMucDtcbiAgICAgIHN3aXRjaChwLnNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgICB0aGlzLnN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsJ3JlY3QnKTtcbiAgICAgICAgICBRLl9leHRlbmQocCx7IGN4OiBwLncvMiwgY3k6IHAuaC8yIH0pO1xuICAgICAgICAgIHRoaXMuc2V0KHsgd2lkdGg6IHAudywgaGVpZ2h0OiBwLmggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgdGhpcy5zdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCdjaXJjbGUnKTtcbiAgICAgICAgICB0aGlzLnNldCh7IHI6IHAuciwgY3g6IDAsIGN5OiAwIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwb2x5Z29uJzpcbiAgICAgICAgICB0aGlzLnN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsJ3BvbHlnb24nKTtcbiAgICAgICAgICB2YXIgcHRzID0gUS5fbWFwKHAucG9pbnRzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ocHQpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB0WzBdICsgXCIsXCIgKyBwdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIiBcIik7XG4gICAgICAgICAgdGhpcy5zZXQoeyBwb2ludHM6IHB0cyB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KHsgZmlsbDogcC5jb2xvciB9KTtcbiAgICAgIGlmKHAub3V0bGluZSkge1xuICAgICAgICB0aGlzLnNldCh7XG4gICAgICAgICAgc3Ryb2tlOiBwLm91dGxpbmUsXG4gICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogcC5vdXRsaW5lV2lkdGggfHwgMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wO1xuICAgICAgdmFyIHJwID0gdGhpcy5ycDtcbiAgICAgIGlmKHJwLnggIT09IHAueCB8fCBcbiAgICAgICAgIHJwLnkgIT09IHAueSB8fCBcbiAgICAgICAgIHJwLmFuZ2xlICE9PSBwLmFuZ2xlICkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyAocC54IC0gcC5jeCkgKyBcIixcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocC55IC0gcC5jeSkgKyBcIikgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJyb3RhdGUoXCIgKyBwLmFuZ2xlICsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFwiICsgcC5jeCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLFwiICsgcC5jeSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKVwiO1xuICAgICAgICB0aGlzLnN2Zy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsdHJhbnNmb3JtKTtcbiAgICAgICAgcnAuYW5nbGUgPSBwLmFuZ2xlO1xuICAgICAgICBycC54ID0gcC54O1xuICAgICAgICBycC55ID0gcC55O1xuICAgICAgfSBcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgXHRcbiAgICBcdHRoaXMudHJpZ2dlcigncHJlZHJhdycsY3R4KTtcbiAgICBcdHRoaXMudHJpZ2dlcignYmVmb3JlZHJhdycsY3R4KTtcbiAgICBcdHRoaXMuZHJhdyhjdHgpO1xuICAgIFx0dGhpcy50cmlnZ2VyKCdiZWZvcmVkcmF3JyxjdHgpO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgfSxcblxuICAgIHN0ZXA6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3N0ZXAnLGR0KTtcbiAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKCk7XG4gICAgfVxuICB9KTtcblxuXG4gIFEuU3RhZ2UuZXh0ZW5kKFwiU1ZHU3RhZ2VcIix7XG4gICAgaW5pdDogZnVuY3Rpb24oc2NlbmUpIHtcbiAgICAgIHRoaXMuc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywnc3ZnJyk7XG4gICAgICB0aGlzLnN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxRLndpZHRoKTtcbiAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxRLmhlaWdodCk7XG4gICAgICBRLnN2Zy5hcHBlbmRDaGlsZCh0aGlzLnN2Zyk7XG4gICAgICBcbiAgICAgIHRoaXMudmlld0JveCA9IHsgeDogMCwgeTogMCwgdzogUS53aWR0aCwgaDogUS5oZWlnaHQgfTtcbiAgICAgIHRoaXMuX3N1cGVyKHNjZW5lKTtcbiAgICB9LFxuICAgIHJlbW92ZTpmdW5jdGlvbihpdG0pe1xuXHQgIGlmKGl0bS5zdmcpIHsgdGhpcy5zdmcucmVtb3ZlQ2hpbGQoaXRtLnN2Zyk7IH1cblx0ICByZXR1cm4gdGhpcy5fc3VwZXIoaXRtKTtcbiAgICB9LFxuICAgIGluc2VydDogZnVuY3Rpb24oaXRtKSB7XG4gICAgICBpZihpdG0uc3ZnKSB7IHRoaXMuc3ZnLmFwcGVuZENoaWxkKGl0bS5zdmcpOyB9XG4gICAgICByZXR1cm4gdGhpcy5fc3VwZXIoaXRtKTtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBRLnN2Zy5yZW1vdmVDaGlsZCh0aGlzLnN2Zyk7XG4gICAgICB0aGlzLl9zdXBlcigpO1xuICAgIH0sXG5cbiAgICB2aWV3cG9ydDogZnVuY3Rpb24odyxoKSB7XG4gICAgICB0aGlzLnZpZXdCb3gudyA9IHc7XG4gICAgICB0aGlzLnZpZXdCb3guaCA9IGg7XG4gICAgICBpZih0aGlzLnZpZXdCb3guY3ggfHwgdGhpcy52aWV3Qm94LmN5KSB7XG4gICAgICAgIHRoaXMuY2VudGVyT24odGhpcy52aWV3Qm94LmN4LFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0JveC5jeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFZpZXdCb3goKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2VudGVyT246IGZ1bmN0aW9uKHgseSkge1xuICAgICAgdGhpcy52aWV3Qm94LmN4ID0geDtcbiAgICAgIHRoaXMudmlld0JveC5jeSA9IHk7XG4gICAgICB0aGlzLnZpZXdCb3gueCA9IHggLSB0aGlzLnZpZXdCb3gudy8yO1xuICAgICAgdGhpcy52aWV3Qm94LnkgPSB5IC0gdGhpcy52aWV3Qm94LmgvMjtcbiAgICAgIHRoaXMuc2V0Vmlld0JveCgpO1xuICAgIH0sXG5cbiAgICBzZXRWaWV3Qm94OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Qm94LnggKyBcIiBcIiArIHRoaXMudmlld0JveC55ICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0JveC53ICsgXCIgXCIgKyB0aGlzLnZpZXdCb3guaCk7XG4gICAgfSxcblxuICAgIGJyb3dzZXJUb1dvcmxkOiBmdW5jdGlvbih4LHkpIHtcbiAgICAgIHZhciBtID0gdGhpcy5zdmcuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICB2YXIgcCA9IHRoaXMuc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICBwLnggPSB4OyBwLnkgPSB5O1xuICAgICAgcmV0dXJuIHAubWF0cml4VHJhbnNmb3JtKG0uaW52ZXJzZSgpKTtcbiAgICB9XG4gIH0pO1xuXG4gIFEuc3ZnT25seSA9IGZ1bmN0aW9uKCkge1xuICAgIFEuU3RhZ2UgPSBRLlNWR1N0YWdlO1xuICAgIFEuc2V0dXAgPSBRLnNldHVwU1ZHO1xuICAgIFEuU3ByaXRlID0gUS5TVkdTcHJpdGU7XG4gICAgcmV0dXJuIFE7XG4gIH07XG5cblxufTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9xdWludHVzJykiLCIvLyAgICAgUXVpbnR1cyBHYW1lIEVuZ2luZVxuLy8gICAgIChjKSAyMDEyIFBhc2NhbCBSZXR0aWcsIEN5a29kIExMQ1xuLy8gICAgIFF1aW50dXMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2Ugb3IgR1BMdjIgTGljZW5zZS5cbi8vICAgICBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4vLyAgICAgaHR0cDovL2h0bWw1cXVpbnR1cy5jb21cbi8vXG4vKipcblF1aW50dXMgSFRNTDUgR2FtZSBFbmdpbmUgXG5cblRoZSBjb2RlIGluIGBxdWludHVzLmpzYCBkZWZpbmVzIHRoZSBiYXNlIGBRdWludHVzKClgIG1ldGhvZFxud2hpY2ggY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBlbmdpbmUuIFRoZSBiYXNpYyBlbmdpbmUgZG9lc24ndFxuZG8gYSB3aG9sZSBsb3QgLSBpdCBwcm92aWRlcyBhbiBhcmNoaXRlY3R1cmUgZm9yIGV4dGVuc2lvbiwgYVxuZ2FtZSBsb29wLCBhbmQgYSBtZXRob2QgZm9yIGNyZWF0aW5nIG9yIGJpbmRpbmcgdG8gYW4gZXhzaXRpbmdcbmNhbnZhcyBjb250ZXh0LiBUaGUgZW5naW5lIGhhcyBkZXBlbmRlbmNpZXMgb24gVW5kZXJzY29yZS5qcyBhbmQgalF1ZXJ5LFxuYWx0aG91Z2ggdGhlIGpRdWVyeSBkZXBlbmRlbmN5IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuXG5Nb3N0IG9mIHRoZSBnYW1lLXNwZWNpZmljIGZ1bmN0aW9uYWxpdHkgaXMgaW4gdGhlIFxudmFyaW91cyBvdGhlciBtb2R1bGVzOlxuXG4qIGBxdWludHVzX2lucHV0LmpzYCAtIGBJbnB1dGAgbW9kdWxlLCB3aGljaCBhbGxvd3MgZm9yIHVzZXIgaW5wdXQgdmlhIGtleWJvYXJkIGFuZCB0b3VjaHNjcmVlblxuKiBgcXVpbnR1c19zcHJpdGVzLmpzYCAtIGBTcHJpdGVzYCBtb2R1bGUsIHdoaWNoIGRlZmluZXMgYSBiYXNpYyBgUS5TcHJpdGVgIGNsYXNzIGFsb25nIHdpdGggc3ByaXRlc2hlZXQgc3VwcG9ydCBpbiBgUS5TcHJpdGVTaGVldGAuXG4qIGBxdWludHVzX3NjZW5lcy5qc2AgLSBgU2NlbmVzYCBtb2R1bGUuIEl0IGRlZmluZXMgdGhlIGBRLlNjZW5lYCBjbGFzcywgd2hpY2ggYWxsb3dzIGNyZWF0aW9uIG9mIHJldXNhYmxlIHNjZW5lcywgYW5kIHRoZSBgUS5TdGFnZWAgY2xhc3MsIHdoaWNoIGhhbmRsZXMgbWFuYWdpbmcgYSBudW1iZXIgb2Ygc3ByaXRlcyBhdCBvbmNlLlxuKiBgcXVpbnR1c19hbmltLmpzYCAtIGBBbmltYCBtb2R1bGUsIHdoaWNoIGFkZHMgaW4gc3VwcG9ydCBmb3IgYW5pbWF0aW9ucyBvbiBzcHJpdGVzIGFsb25nIHdpdGggYSBgdmlld3BvcnRgIGNvbXBvbmVudCB0byBmb2xsb3cgdGhlIHBsYXllciBhcm91bmQgYW5kIGEgYFEuUmVwZWF0ZXJgIGNsYXNzIHRoYXQgY2FuIGNyZWF0ZSBhIHJlcGVhdGluZywgc2Nyb2xsaW5nIGJhY2tncm91bmQuXG5cbkBtb2R1bGUgUXVpbnR1c1xuKi9cblxuLyoqXG4gVG9wLWxldmVsIFF1aW50dXMgZW5naW5lIGZhY3Rvcnkgd3JhcHBlciwgXG4gY3JlYXRlcyBuZXcgaW5zdGFuY2VzIG9mIHRoZSBlbmdpbmUgYnkgY2FsbGluZzpcblxuICAgICAgdmFyIFEgPSBRdWludHVzKHsgIC4uLiAgfSk7XG5cbiBBbnkgaW5pdGlhbCBzZXR1cCBtZXRob2RzIGFsc28gYWxsIHJldHVybiB0aGUgYFFgIG9iamVjdCwgYWxsb3dpbmcgYW55IGluaXRpYWwgXG4gc2V0dXAgY2FsbHMgdG8gYmUgY2hhaW5lZCB0b2dldGhlci5cblxuICAgICAgdmFyIFEgPSBRdWludHVzKClcbiAgICAgICAgICAgICAgLmluY2x1ZGUoXCJJbnB1dCwgU3ByaXRlcywgU2NlbmVzXCIpXG4gICAgICAgICAgICAgIC5zZXR1cCgncXVpbnR1cycsIHsgbWF4aW1pemU6IHRydWUgfSlcbiAgICAgICAgICAgICAgLmNvbnRyb2xzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuIGBRYCBpcyB1c2VkIGludGVybmFsbHkgYXMgdGhlIG9iamVjdCBuYW1lLCBhbmQgaXMgdXNlZCBpbiBtb3N0IG9mIHRoZSBleGFtcGxlcywgXG4gYnV0IG11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGUgZW5naW5lIG9uIHRoZSBzYW1lIHBhZ2UgY2FuIGhhdmUgZGlmZmVyZW50IG5hbWVzLlxuXG4gICAgIHZhciBHYW1lMSA9IFF1aW50dXMoKSwgR2FtZTIgPSBRdWludHVzKCk7XG5cbkBjbGFzcyBRdWludHVzXG4qKi9cblxubW9kdWxlLmV4cG9ydHMgPSBRdWludHVzO1xuXG5RdWludHVzWycyRCddID0gcmVxdWlyZSgnLi9xdWludHVzXzJkJylcblF1aW50dXMuQW5pbSA9IHJlcXVpcmUoJy4vcXVpbnR1c19hbmltJylcblF1aW50dXMuQXVkaW8gPSByZXF1aXJlKCcuL3F1aW50dXNfYXVkaW8nKVxuUXVpbnR1cy5JbnB1dCA9IHJlcXVpcmUoJy4vcXVpbnR1c19pbnB1dCcpXG5RdWludHVzLlNjZW5lcyA9IHJlcXVpcmUoJy4vcXVpbnR1c19zY2VuZXMnKVxuUXVpbnR1cy5TcHJpdGVzID0gcmVxdWlyZSgnLi9xdWludHVzX3Nwcml0ZXMnKVxuUXVpbnR1cy5UTVggPSByZXF1aXJlKCcuL3F1aW50dXNfdG14JylcblF1aW50dXMuVG91Y2ggPSByZXF1aXJlKCcuL3F1aW50dXNfdG91Y2gnKVxuUXVpbnR1cy5VSSA9IHJlcXVpcmUoJy4vcXVpbnR1c191aScpXG5RdWludHVzLkRPTSA9IHJlcXVpcmUoJy4uL2V4dHJhL3F1aW50dXNfZG9tJylcblF1aW50dXMuUGh5c2ljcyA9IHJlcXVpcmUoJy4uL2V4dHJhL3F1aW50dXNfcGh5c2ljcycpXG5RdWludHVzLlNWRyA9IHJlcXVpcmUoJy4uL2V4dHJhL3F1aW50dXNfc3ZnJylcblxuZnVuY3Rpb24gUXVpbnR1cyhvcHRzKSB7XG5cbiAgLyoqXG4gICBBIGxhIGpRdWVyeSAtIHRoZSByZXR1cm5lZCBgUWAgb2JqZWN0IGlzIGFjdHVhbGx5XG4gICBhIG1ldGhvZCB0aGF0IGNhbGxzIGBRLnNlbGVjdGAuIGBRLnNlbGVjdGAgZG9lc24ndCBkbyBhbnl0aGluZ1xuICAgaW5pdGlhbGx5LCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgYSBtb2R1bGUgdG8gYWxsb3dcbiAgIHNlbGVjdGlvbiBvZiBnYW1lIG9iamVjdHMuIFRoZSBgU2NlbmVzYCBtb2R1bGUgYWRkcyBpbiBcbiAgIHRoZSBzZWxlY3QgbWV0aG9kIHdoaWNoIHNlbGVjdHMgZnJvbSB0aGUgZGVmYXVsdCBzdGFnZS5cbiAgXG4gICAgICAgdmFyIFEgPSBRdWludHVzKCkuaW5jbHVkZShcIlNwcml0ZXMsIFNjZW5lc1wiKTtcbiAgICAgICAuLi4gR2FtZSBDb2RlIC4uLlxuICAgICAgIC8vIFNldCB0aGUgYW5ncnkgcHJvcGVydHkgb24gYWxsIEVuZW15MSBjbGFzcyBvYmplY3RzIHRvIHRydWVcbiAgICAgICBRKFwiRW5lbXkxXCIpLnAoeyBhbmdyeTogdHJ1ZSB9KTtcbiAgICBcbiAgICBAbWV0aG9kIFFcbiAgICBAZm9yIFF1aW50dXNcbiAgKi8gIFxuICB2YXIgUSA9IGZ1bmN0aW9uKHNlbGVjdG9yLHNjb3BlLG9wdGlvbnMpIHsgICBcbiAgICByZXR1cm4gUS5zZWxlY3Qoc2VsZWN0b3Isc2NvcGUsb3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICBEZWZhdWx0IG5vLW9wIHNlbGVjdCBtZXRob2QuIFJlcGxhY2VkIHdpdGggdGhlIFF1aW50dXMuU2NlbmUgY2xhc3NcblxuICAgQG1ldGhvZCBRLnNlbGVjdFxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEuc2VsZWN0ID0gZnVuY3Rpb24oKSB7IC8qIE5vLW9wICovIH07XG5cbiAgLyoqXG4gICBEZWZhdWx0IG5vLW9wIHNlbGVjdCBtZXRob2QuIFJlcGxhY2VkIHdpdGggdGhlIFF1aW50dXMuU2NlbmUgY2xhc3NcblxuXG4gICBTeW50YXggZm9yIGluY2x1ZGluZyBvdGhlciBtb2R1bGVzIGludG8gcXVpbnR1cywgY2FuIGFjY2VwdCBhIGNvbW1hLXNlcGFyYXRlZFxuICAgbGlzdCBvZiBzdHJpbmdzLCBhbiBhcnJheSBvZiBzdHJpbmdzLCBvciBhbiBhcnJheSBvZiBhY3R1YWwgb2JqZWN0cy4gRXhhbXBsZTpcbiAgXG4gICAgICAgUS5pbmNsdWRlKFwiSW5wdXQsIFNwcml0ZXMsIFNjZW5lc1wiKVxuXG4gICBAbWV0aG9kIFEuaW5jbHVkZVxuICAgQHBhcmFtIHtTdHJpbmd9IG1vZCAtIEEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIG5hbWVzXG4gICBAcmV0dXJuIHtRdWludHVzfSByZXR1cm5zIFF1aW50dXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEubW9kdWxlcyA9IHt9XG5cbiAgUS5pbmNsdWRlID0gZnVuY3Rpb24obW9kKSB7XG4gICAgUS5fZWFjaChRLl9ub3JtYWxpemVBcmcobW9kKSxmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgbSA9IFF1aW50dXNbbmFtZV0gfHwgbmFtZTtcbiAgICAgIGlmKCFRLl9pc0Z1bmN0aW9uKG0pKSB7IHRocm93IFwiSW52YWxpZCBNb2R1bGU6XCIgKyBuYW1lOyB9XG4gICAgICBRLm1vZHVsZXNbbmFtZV0gPSBtO1xuICAgICAgbShRKVxuICAgIH0pO1xuICAgIHJldHVybiBRO1xuICB9O1xuXG4gIC8qKlxuICAgQW4gaW50ZXJuYWwgdXRpbGl0eSBtZXRob2QgKHV0aWxpdHkgbWV0aG9kcyBhcmUgcHJlZml4ZWQgd2l0aCB1bmRlcnNjb3JlcylcbiAgIEl0J3MgdXNlZCB0byB0YWtlIGEgc3RyaW5nIG9mIGNvbW1hIHNlcGFyYXRlZCBuYW1lcyBhbmQgdHVybiBpdCBpbnRvIGFuIGBBcnJheWBcbiAgIG9mIG5hbWVzLiBJZiBhbiBhcnJheSBvZiBuYW1lcyBpcyBwYXNzZWQgaW4sIGl0J3MgbGVmdCBhcyBpcy4gRXhhbXBsZSB1c2FnZTpcbiAgXG4gICAgICAgUS5fbm9ybWFsaXplQXJnKFwiU3ByaXRlcywgU2NlbmVzLCBQaHlzaWNzICAgXCIpO1xuICAgICAgIC8vIHJldHVybnMgWyBcIlNwcml0ZXNcIiwgXCJTY2VuZXNcIiwgXCJQaHlzaWNzXCIgXVxuICBcbiAgIFVzZWQgYnkgYFEuaW5jbHVkZWAgYW5kIGBRLlNwcml0ZS5hZGRgIHRvIGFkZCBtb2R1bGVzIGFuZCBjb21wb25lbnRzLCByZXNwZWN0aXZlbHkuXG5cbiAgIE1vc3Qgb2YgdGhlc2UgdXRpbGl0eSBtZXRob2RzIGFyZSBhIHN1YnNldCBvZiBVbmRlcnNjb3JlLmpzLFxuICAgTW9zdCBhcmUgcHVsbGVkIGRpcmVjdGx5IGZyb20gdW5kZXJzY29yZSBhbmQgc29tZSBhcmVcbiAgIG9jY2FzaW9uYWxseSBvcHRpbWl6ZWQgZm9yIHNwZWVkIGFuZCBtZW1vcnkgdXNhZ2UgaW4gbGlldSBvZiBmbGV4aWJpbGl0eS5cblxuICAgVW5kZXJzY29yZS5qcyBpcyAoYykgMjAwOS0yMDEyIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG5cbiAgIFVuZGVyc2NvcmUgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4gICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuXG4gICBAbWV0aG9kIFEuX25vcm1hbGl6ZUFyZ1xuICAgQHBhcmFtIHtTdHJpbmcgb3IgQXJyYXl9IGFyZyAtIEVpdGhlciBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb3IgYW4gYXJyYXlcbiAgIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBub3JtYWxpemVkIG5hbWVzXG4gICBAZm9yIFF1aW50dXNcbiAgKi9cbiAgUS5fbm9ybWFsaXplQXJnID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYoUS5faXNTdHJpbmcoYXJnKSkge1xuICAgICAgYXJnID0gYXJnLnJlcGxhY2UoL1xccysvZywnJykuc3BsaXQoXCIsXCIpO1xuICAgIH1cbiAgICBpZighUS5faXNBcnJheShhcmcpKSB7XG4gICAgICBhcmcgPSBbIGFyZyBdO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9O1xuXG5cbiAgLyoqXG4gICBFeHRlbmRzIGEgZGVzdGluYXRpb24gb2JqZWN0IHdpdGggYSBzb3VyY2Ugb2JqZWN0IChtb2RpZmllcyBkZXN0aW5hdGlvbiBvYmplY3QpXG5cbiAgIEBtZXRob2QgUS5fZXh0ZW5kXG4gICBAcGFyYW0ge09iamVjdH0gZGVzdCAtIGRlc3RpbmF0aW9uIG9iamVjdFxuICAgQHBhcmFtIHtPYmplY3R9IHNvdXJjZSAtIHNvdXJjZSBvYmplY3RcbiAgIEByZXR1cm4ge09iamVjdH0gcmV0dXJucyB0aGUgZGVzdCBvYmplY3RcbiAgIEBmb3IgUXVpbnR1c1xuICAqL1xuICBRLl9leHRlbmQgPSBmdW5jdGlvbihkZXN0LHNvdXJjZSkge1xuICAgIGlmKCFzb3VyY2UpIHsgcmV0dXJuIGRlc3Q7IH1cbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgZGVzdFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH07XG5cbiAgLyoqXG4gICBSZXR1cm4gYSBzaGFsbG93IGNvcHkgb2YgYW4gb2JqZWN0LiBTdWItb2JqZWN0cyAoYW5kIHN1Yi1hcnJheXMpIGFyZSBub3QgY2xvbmVkLiAodXNlcyBleHRlbmQgaW50ZXJuYWxseSlcblxuICAgQG1ldGhvZCBRLl9jbG9uZVxuICAgQHBhcmFtIHtPYmplY3R9IG9iaiAtIG9iamVjdCB0byBjbG9uZVxuICAgQHJldHVybiB7T2JqZWN0fSBjbG9uZWQgb2JqZWN0IFxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEuX2Nsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIFEuX2V4dGVuZCh7fSxvYmopO1xuICB9O1xuXG4gICAvKipcbiAgICBNZXRob2QgdGhhdCBhZGRzIGRlZmF1bHQgcHJvcGVydGllcyBvbnRvIGFuIG9iamVjdCBvbmx5IGlmIHRoZSBrZXkgb24gZGVzdCBpcyB1bmRlZmluZWRcblxuICAgQG1ldGhvZCBRLl9kZWZhdWx0c1xuICAgQHBhcmFtIHtPYmplY3R9IGRlc3QgLSBkZXN0aW5hdGlvbiBvYmplY3RcbiAgIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgLSBzb3VyY2Ugb2JqZWN0XG4gICBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhlIGRlc3Qgb2JqZWN0XG4gICBAZm9yIFF1aW50dXNcbiAgKi9cbiAgUS5fZGVmYXVsdHMgPSBmdW5jdGlvbihkZXN0LHNvdXJjZSkge1xuICAgIGlmKCFzb3VyY2UpIHsgcmV0dXJuIGRlc3Q7IH1cbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgaWYoZGVzdFtwcm9wXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlc3RbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9O1xuXG4gIC8qKlxuICAgU2hvcnRjdXQgZm9yIGhhc093blByb3BlcnR5XG5cbiAgIEBtZXRob2QgUS5fZGVmYXVsdHNcbiAgIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBkZXN0aW5hdGlvbiBvYmplY3RcbiAgIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBrZXkgdG8gY2hlY2sgZm9yXG4gICBAcmV0dXJuIHtCb29sZWFufSBcbiAgIEBmb3IgUXVpbnR1c1xuICAqLyBcbiAgUS5faGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAgLyoqXG4gICBDaGVjayBpZiBzb21ldGhpbmcgaXMgYSBzdHJpbmdcblxuICAgTk9URTogdGhpcyBmYWlscyBmb3Igbm9uLXByaW1pdGl2ZXNcblxuICAgQG1ldGhvZCBRLl9pc1N0cmluZ1xuICAgQHBhcmFtIHtWYXJ9IG9iaiAtIG9iamVjdCB0byBjaGVjayBcbiAgIEByZXR1cm4ge0Jvb2xlYW59IFxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEuX2lzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCI7XG4gIH07XG5cbiAgLyoqXG4gICBDaGVjayBpZiBzb21ldGhpbmcgaXMgYSBudW1iZXJcblxuICAgQG1ldGhvZCBRLl9pc051bWJlclxuICAgQHBhcmFtIHtWYXJ9IG9iaiAtIG9iamVjdCB0byBjaGVjayBcbiAgIEByZXR1cm4ge0Jvb2xlYW59IFxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEuX2lzTnVtYmVyID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgfTtcblxuICAvKipcbiAgIENoZWNrIGlmIHNvbWV0aGluZyBpcyBhIGZ1bmN0aW9uXG5cbiAgIEBtZXRob2QgUS5faXNGdW5jdGlvblxuICAgQHBhcmFtIHtWYXJ9IG9iaiAtIG9iamVjdCB0byBjaGVjayBcbiAgIEByZXR1cm4ge0Jvb2xlYW59IFxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEuX2lzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH07XG5cbiAgIC8qKlxuICAgQ2hlY2sgaWYgc29tZXRoaW5nIGlzIGFuIE9iamVjdFxuXG4gICBAbWV0aG9kIFEuX2lzT2JqZWN0XG4gICBAcGFyYW0ge1Zhcn0gb2JqIC0gb2JqZWN0IHRvIGNoZWNrIFxuICAgQHJldHVybiB7Qm9vbGVhbn0gXG4gICBAZm9yIFF1aW50dXNcbiAgKi8gXG4gIFEuX2lzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgfTtcblxuICAvKipcbiAgIENoZWNrIGlmIHNvbWV0aGluZyBpcyBhbiBBcnJheVxuXG4gICBAbWV0aG9kIFEuX2lzQXJyYXlcbiAgIEBwYXJhbSB7VmFyfSBvYmogLSBvYmplY3QgdG8gY2hlY2sgXG4gICBAcmV0dXJuIHtCb29sZWFufSBcbiAgIEBmb3IgUXVpbnR1c1xuICAqLyBcbiAgUS5faXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvKipcbiAgIENoZWNrIGlmIHNvbWV0aGluZyBpcyB1bmRlZmluZWRcblxuICAgQG1ldGhvZCBRLl9pc1VuZGVmaW5lZFxuICAgQHBhcmFtIHtWYXJ9IG9iaiAtIG9iamVjdCB0byBjaGVjayBcbiAgIEByZXR1cm4ge0Jvb2xlYW59IFxuICAgQGZvciBRdWludHVzXG4gICovIFxuICBRLl9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvKipcbiAgIFJlbW92ZXMgYSBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdCBhbmQgcmV0dXJucyBpdCBpZiBpdCBleGlzdHNcblxuICAgQG1ldGhvZCBRLl9wb3BQcm9wZXJ0eVxuICAgQHBhcmFtIHtPYmplY3R9IG9iaiBcbiAgIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHByb3BlcnR5IHRvIHBvcCBvZmYgdGhlIG9iamVjdFxuICAgQHJldHVybiB7VmFyfSBwb3BwZWQgcHJvcGVydHlcbiAgIEBmb3IgUXVpbnR1c1xuICAqLyBcbiAgUS5fcG9wUHJvcGVydHkgPSBmdW5jdGlvbihvYmoscHJvcGVydHkpIHtcbiAgICB2YXIgdmFsID0gb2JqW3Byb3BlcnR5XTtcbiAgICBkZWxldGUgb2JqW3Byb3BlcnR5XTtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xuXG4gIC8qKlxuICAgQmFzaWMgaXRlcmF0aW9uIG1ldGhvZC4gVGhpcyBjYW4gb2Z0ZW4gYmUgYSBwZXJmb3JtYW5jZVxuICAgaGFuZGljYXAgd2hlbiB0aGUgY2FsbGJhY2sgaXRlcmF0b3IgaXMgY3JlYXRlZCBpbmxpbmUsXG4gICBhcyB0aGlzIGxlYWRzIHRvIGxvdHMgb2YgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBHQydkLlxuICAgQmV0dGVyIGlzIHRvIGRlZmluZSB0aGUgaXRlcmF0b3IgYXMgYSBwcml2YXRlIG1ldGhvZCBzby5cbiAgIFVzZXMgdGhlIGJ1aWx0IGluIGBmb3JFYWNoYCBtZXRob2RcblxuICAgQG1ldGhvZCBRLl9lYWNoXG4gICBAcGFyYW0ge0FycmF5IG9yIE9iamVjdH0gb2JqIFxuICAgQHBhcmFtIHtGdW5jdGlvbiBpdGVyYXRvciBmdW5jdGlvbiwgYHRoaXNgIGlzIHVzZWQgZm9yIGVhY2ggb2JqZWN0XG4gICBAZm9yIFF1aW50dXNcbiAgKi8gXG4gIFEuX2VhY2ggPSBmdW5jdGlvbihvYmosaXRlcmF0b3IsY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgeyByZXR1cm47IH1cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgSW52b2tlIHRoZSBuYW1lZCBwcm9wZXJ0eSBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5XG5cbiAgIEBtZXRob2QgUS5faW52b2tlXG4gICBAcGFyYW0ge0FycmF5fSBhcnIgXG4gICBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBwcm9wZXJ0eSB0byBpbnZva2VcbiAgIEBwYXJhbSB7VmFyfSBbYXJnMV1cbiAgIEBwYXJhbSB7VmFyfSBbYXJnMl1cbiAgIEBmb3IgUXVpbnR1c1xuICAqLyBcbiAgUS5faW52b2tlID0gZnVuY3Rpb24oYXJyLHByb3BlcnR5LGFyZzEsYXJnMikge1xuICAgIGlmIChhcnIgPT0gbnVsbCkgeyByZXR1cm47IH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGFycltpXVtwcm9wZXJ0eV0oYXJnMSxhcmcyKTtcbiAgICB9XG4gIH07XG5cblxuXG4gIC8qKlxuICAgQmFzaWMgZGV0ZWN0aW9uIG1ldGhvZCwgcmV0dXJucyB0aGUgZmlyc3QgaW5zdGFuY2Ugd2hlcmUgdGhlXG4gICBpdGVyYXRvciByZXR1cm5zIHRydXRoeS4gXG5cbiAgIEBtZXRob2QgUS5fZGV0ZWN0XG4gICBAcGFyYW0ge0FycmF5IG9yIE9iamVjdH0gb2JqXG4gICBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvciBcbiAgIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICBAcGFyYW0ge1Zhcn0gW2FyZzFdXG4gICBAcGFyYW0ge1Zhcn0gW2FyZzJdXG4gICBAcmV0dXJucyB7VmFyfSBmaXJzdCB0cnV0aHkgdmFsdWVcbiAgIEBmb3IgUXVpbnR1c1xuICAqL1xuICBRLl9kZXRlY3QgPSBmdW5jdGlvbihvYmosaXRlcmF0b3IsY29udGV4dCxhcmcxLGFyZzIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChvYmogPT0gbnVsbCkgeyByZXR1cm47IH1cbiAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgYXJnMSxhcmcyKTtcbiAgICAgICAgaWYocmVzdWx0KSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIGFyZzEsYXJnMik7XG4gICAgICAgIGlmKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgUmV0dXJucyBhIG5ldyBBcnJheSB3aXRoIGVudHJpZXMgc2V0IHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGl0ZXJhdG9yLlxuXG4gICBAbWV0aG9kIFEuX2RldGVjdFxuICAgQHBhcmFtIHtBcnJheSBvciBPYmplY3R9IG9ialxuICAgQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3IgXG4gICBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgQHJldHVybnMge0FycmF5fVxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEuX21hcCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgeyByZXR1cm4gcmVzdWx0czsgfVxuICAgIGlmIChvYmoubWFwKSB7IHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTsgfVxuICAgIFEuX2VhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgIH0pO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgeyByZXN1bHRzLmxlbmd0aCA9IG9iai5sZW5ndGg7IH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvKipcbiAgIFJldHVybnMgYSBzb3J0ZWQgY29weSBvZiB1bmlxdWUgYXJyYXkgZWxlbWVudHMgd2l0aCBudWxsIHJlbW92ZWRcblxuICAgQG1ldGhvZCBRLl91bmlxXG4gICBAcGFyYW0ge0FycmF5fSBhcnJcbiAgIEByZXR1cm5zIHtBcnJheX0gdW5pcSdkIHNvcnRlZCBjb3B5IG9mIGFycmF5XG4gICBAZm9yIFF1aW50dXNcbiAgKi9cbiAgUS5fdW5pcSA9IGZ1bmN0aW9uKGFycikge1xuICAgIGFyciA9IGFyci5zbGljZSgpLnNvcnQoKTtcblxuICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgIHZhciBsYXN0ID0gbnVsbDtcbiAgICBmb3IodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKSB7XG4gICAgICBpZihhcnJbaV0gIT09IHZvaWQgMCAmJiBsYXN0ICE9PSBhcnJbaV0pIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYXJyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSBhcnJbaV07XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLyoqXG4gICBSZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggdGhlIHNhbWUgZW50cmllcyBhcyB0aGUgc291cmNlIGJ1dCBpbiBhIHJhbmRvbSBvcmRlci5cblxuICAgQG1ldGhvZCBRLl9zaHVmZmxlXG4gICBAcGFyYW0ge0FycmF5fSBhcnJcbiAgIEByZXR1cm5zIHtBcnJheX0gY29weSBvciBhcnIgaW4gc2h1ZmZsZWQgb3JkZXJcbiAgIEBmb3IgUXVpbnR1c1xuICAqL1xuICBRLl9zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNodWZmbGVkID0gW10sIHJhbmQ7XG4gICAgUS5fZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpbmRleCArIDEpKTtcbiAgICAgIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cblxuICAvKipcbiAgIFJldHVybiBhbiBvYmplY3QncyBrZXlzIGFzIGEgbmV3IEFycmF5XG5cbiAgIEBtZXRob2QgUS5fa2V5c1xuICAgQHBhcmFtIHtPYmplY3R9IG9ialxuICAgQHJldHVybnMge0FycmF5fVxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEuX2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICBpZihRLl9pc09iamVjdChvYmopKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb2JqZWN0Jyk7IH1cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKFEuX2hhcyhvYmosIGtleSkpIHsga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7IH0gfSBcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuXG4gIC8qKlxuICAgUmV0dXJuIGFuIGFycmF5IGluIHRoZSByYW5nZSBmcm9tIHN0YXJ0IHRvIHN0b3AgXG5cbiAgIEBtZXRob2QgUS5fcmFuZ2VcbiAgIEBwYXJhbSB7SW50ZWdlcn0gc3RhcnRcbiAgIEBwYXJhbSB7SW50ZWdlcn0gc3RvcFxuICAgQHBhcmFtIHtJbnRlZ2VyfSBbc3RlcF1cbiAgIEByZXR1cm5zIHtBcnJheX1cbiAgIEBmb3IgUXVpbnR1c1xuICAqL1xuICBRLl9yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LHN0b3Asc3RlcCkge1xuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgd2hpbGUoaWR4IDwgbGVuKSB7XG4gICAgICByYW5nZVtpZHgrK10gPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuXG4gIH07XG5cbiAgdmFyIGlkSW5kZXggPSAwO1xuICAvKipcbiAgIFJldHVybiBhIG5ldyB1bmlxdWUgaWRlbnRpZmllclxuXG4gICBAbWV0aG9kIFEuX3VuaXF1ZUlkXG4gICBAcmV0dXJucyB7SW50ZWdlcn1cbiAgIEBmb3IgUXVpbnR1c1xuICAqL1xuICBRLl91bmlxdWVJZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZEluZGV4Kys7XG4gIH07XG5cblxuXG4gIC8qKlxuICAgT3B0aW9uc1xuICBcbiAgIERlZmF1bHQgZW5naW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBhdGhzIFxuICAgd2hlcmUgaW1hZ2VzLCBhdWRpbyBhbmQgb3RoZXIgZGF0YSBmaWxlcyBzaG91bGQgYmUgZm91bmRcbiAgIHJlbGF0aXZlIHRvIHRoZSBiYXNlIEhUTUwgZmlsZS4gQXMgd2VsbCBhcyBhIGNvdXBsZSBvZiBvdGhlclxuICAgb3B0aW9ucy5cbiAgXG4gICBUaGVzZSBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHBhc3NpbmcgaW4gb3B0aW9ucyB0byB0aGUgYFF1aW50dXMoKWAgXG4gICBmYWN0b3J5IG1ldGhvZCwgZm9yIGV4YW1wbGU6XG4gIFxuICAgICAgIC8vIE92ZXJyaWRlIHRoZSBpbWFnZVBhdGggdG8gZGVmYXVsdCB0byAvYXNzZXRzL2ltYWdlcy9cbiAgICAgICB2YXIgUSA9IFF1aW50dXMoeyBpbWFnZVBhdGg6IFwiL2Fzc2V0cy9pbWFnZXMvXCIgfSk7XG4gIFxuICAgSWYgeW91IGZvbGxvdyB0aGUgZGVmYXVsdCBjb252ZW50aW9uIGZyb20gdGhlIGV4YW1wbGVzLCBob3dldmVyLFxuICAgeW91IHNob3VsZCBiZSBhYmxlIHRvIGNhbGwgYFF1aW50dXMoKWAgd2l0aG91dCBhbnkgb3B0aW9ucy5cblxuICAgRGVmYXVsdCBPcHRpb25zXG5cbiAgICAgICB7XG4gICAgICAgIGltYWdlUGF0aDogXCJpbWFnZXMvXCIsXG4gICAgICAgIGF1ZGlvUGF0aDogXCJhdWRpby9cIixcbiAgICAgICAgZGF0YVBhdGg6ICBcImRhdGEvXCIsXG4gICAgICAgIGF1ZGlvU3VwcG9ydGVkOiBbICdtcDMnLCdvZ2cnIF0sXG4gICAgICAgIHNvdW5kOiB0cnVlLFxuICAgICAgICBmcmFtZVRpbWVMaW1pdDogMTAwXG4gICAgICAgfVxuXG4gICBAcHJvcGVydHkgUS5vcHRpb25zXG4gICBAdHlwZSBPYmplY3RcbiAgIEBmb3IgUXVpbnR1c1xuICAqL1xuICBRLm9wdGlvbnMgPSB7XG4gICAgaW1hZ2VQYXRoOiBcImltYWdlcy9cIixcbiAgICBhdWRpb1BhdGg6IFwiYXVkaW8vXCIsXG4gICAgZGF0YVBhdGg6ICBcImRhdGEvXCIsXG4gICAgYXVkaW9TdXBwb3J0ZWQ6IFsgJ21wMycsJ29nZycgXSxcbiAgICBzb3VuZDogdHJ1ZSxcbiAgICBmcmFtZVRpbWVMaW1pdDogMTAwLFxuICAgIGF1dG9Gb2N1czogdHJ1ZVxuICB9O1xuICBpZihvcHRzKSB7IFEuX2V4dGVuZChRLm9wdGlvbnMsb3B0cyk7IH1cblxuXG4gIC8qKlxuICAgR2FtZSBMb29wIHN1cHBvcnRcblxuICAgQnkgZGVmYXVsdCB0aGUgZW5naW5lIGRvZXNuJ3Qgc3RhcnQgYSBnYW1lIGxvb3AgdW50aWwgeW91IGFjdHVhbGx5IHRlbGwgaXQgdG8uXG4gICBVc3VhbGx5IHRoZSBsb29wIGlzIHN0YXJ0ZWQgdGhlIGZpcnN0IHRpbWUgeW91IGNhbGwgYFEuc3RhZ2VTY2VuZWAsIGJ1dCBpZiB5b3UgXG4gICBhcmVuJ3QgdXNpbmcgdGhlIGBTY2VuZXNgIG1vZHVsZSB5b3UgY2FuIGV4cGxpY2l0bHkgc3RhcnQgdGhlIGdhbWUgbG9vcCB5b3Vyc2VsZlxuICAgYW5kIGNvbnRyb2wgKipleGFjdGx5Kiogd2hhdCB0aGUgZW5naW5lIGRvZXMgZWFjaCBjeWNsZS4gRm9yIGV4YW1wbGU6XG4gIFxuICAgICAgIHZhciBRID0gUXVpbnR1cygpLnNldHVwKCk7XG4gIFxuICAgICAgIHZhciBiYWxsID0gbmV3IFEuU3ByaXRlKHsgLi4gfSk7XG4gIFxuICAgICAgIFEuZ2FtZUxvb3AoZnVuY3Rpb24oZHQpIHtcbiAgICAgICAgIFEuY2xlYXIoKTsgXG4gICAgICAgICBiYWxsLnN0ZXAoZHQpO1xuICAgICAgICAgYmFsbC5kcmF3KFEuY3R4KTtcbiAgICAgICB9KTtcbiAgXG4gICBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBmcmFjdGlvbiBvZiBhIHNlY29uZCB0aGF0IGhhcyBlbGFwc2VkIHNpbmNlIFxuICAgdGhlIGxhc3QgY2FsbCB0byB0aGUgbG9vcCBtZXRob2QuXG5cbiAgIEBtZXRob2QgUS5nYW1lTG9vcFxuICAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgIEBmb3IgUXVpbnR1c1xuICAqL1xuICBRLmdhbWVMb29wID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBRLmxhc3RHYW1lTG9vcEZyYW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IHRoZSBsb29wIGNoZWNrIGluIGNhc2UgbXVsdGlwbGUgc2NlbmVzXG4gICAgLy8gYXJlIHN0YWdlZCBpbW1lZGlhdGVseVxuICAgIFEubG9vcCA9IHRydWU7IFxuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZnJhbWUgd2UgYXJlIG9uIChzbyB0aGF0IGFuaW1hdGlvbnMgY2FuIGJlIHN5bmNlZFxuICAgIC8vIHRvIHRoZSBuZXh0IGZyYW1lKVxuICAgIFEuX2xvb3BGcmFtZSA9IDA7XG5cbiAgICAvLyBXcmFwIHRoZSBjYWxsYmFjayB0byBzYXZlIGl0IGFuZCBzdGFuZGFyZGl6ZSB0aGUgcGFzc2VkXG4gICAgLy8gaW4gdGltZS4gXG4gICAgUS5nYW1lTG9vcENhbGxiYWNrV3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgUS5fbG9vcEZyYW1lKys7XG4gICAgICBRLmxvb3AgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKFEuZ2FtZUxvb3BDYWxsYmFja1dyYXBwZXIpO1xuICAgICAgdmFyIGR0ID0gbm93IC0gUS5sYXN0R2FtZUxvb3BGcmFtZTtcbiAgICAgIC8qIFByZXZlbnQgZmFzdC1mb3J3YXJkaW5nIGJ5IGxpbWl0aW5nIHRoZSBsZW5ndGggb2YgYSBzaW5nbGUgZnJhbWUuICovXG4gICAgICBpZihkdCA+IFEub3B0aW9ucy5mcmFtZVRpbWVMaW1pdCkgeyBkdCA9IFEub3B0aW9ucy5mcmFtZVRpbWVMaW1pdDsgfVxuICAgICAgY2FsbGJhY2suYXBwbHkoUSxbZHQgLyAxMDAwXSk7ICBcbiAgICAgIFEubGFzdEdhbWVMb29wRnJhbWUgPSBub3c7XG4gICAgfTtcblxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoUS5nYW1lTG9vcENhbGxiYWNrV3JhcHBlcik7XG4gICAgcmV0dXJuIFE7XG4gIH07XG5cbiAgLyoqXG4gICBQYXVzZSB0aGUgZW50aXJlIGdhbWUgYnkgY2FuY2VsaW5nIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbC4gSWYgeW91IHVzZSBzZXRUaW1lb3V0IG9yXG4gICBzZXRJbnRlcnZhbCBpbiB5b3VyIGdhbWUsIHRob3NlIHdpbGwsIG9mIGNvdXJzZSwga2VlcCBvbiByb2xsaW5nLi4uXG5cbiAgICBAbWV0aG9kIFEucGF1c2VHYW1lXG4gICAgQGZvciBRdWludHVzXG4gICovXG4gIFEucGF1c2VHYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoUS5sb29wKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoUS5sb29wKTsgXG4gICAgfVxuICAgIFEubG9vcCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICBVbnBhdXNlIHRoZSBnYW1lIGJ5IHJlc3RhcnRpbmcgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZS1iYXNlZCBsb29wLlxuICAgUGF1c2UgdGhlIGVudGlyZSBnYW1lIGJ5IGNhbmNlbGluZyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNhbGwuIElmIHlvdSB1c2Ugc2V0VGltZW91dCBvclxuICAgc2V0SW50ZXJ2YWwgaW4geW91ciBnYW1lLCB0aG9zZSB3aWxsLCBvZiBjb3Vyc2UsIGtlZXAgb24gcm9sbGluZy4uLlxuXG4gICAgQG1ldGhvZCBRLnBhdXNlR2FtZVxuICAgIEBmb3IgUXVpbnR1c1xuICAqL1xuICBRLnVucGF1c2VHYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoIVEubG9vcCkge1xuICAgICAgUS5sYXN0R2FtZUxvb3BGcmFtZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgUS5sb29wID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShRLmdhbWVMb29wQ2FsbGJhY2tXcmFwcGVyKTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgIFRoZSBiYXNlIENsYXNzIG9iamVjdFxuICBcbiAgIFF1aW50dXMgdXNlcyB0aGUgU2ltcGxlIEphdmFTY3JpcHQgaW5oZXJpdGFuY2UgQ2xhc3Mgb2JqZWN0LCBjcmVhdGVkIGJ5XG4gICBKb2huIFJlc2lnIGFuZCBkZXNjcmliZWQgb24gaGlzIGJsb2c6IFxuICBcbiAgIFtodHRwOi8vZWpvaG4ub3JnL2Jsb2cvc2ltcGxlLWphdmFzY3JpcHQtaW5oZXJpdGFuY2UvXShodHRwOi8vZWpvaG4ub3JnL2Jsb2cvc2ltcGxlLWphdmFzY3JpcHQtaW5oZXJpdGFuY2UvKVxuICBcbiAgIFRoZSBjbGFzcyBpcyB1c2VkIHdob2xlc2FsZSwgd2l0aCB0aGUgb25seSBkaWZmZXJlbmNlcyBiZWluZyB0aGF0IGluc3RlYWRcbiAgIG9mIGFwcGVhcmluZyBpbiBhIHRvcC1sZXZlbCBuYW1lc3BhY2UsIHRoZSBgQ2xhc3NgIG9iamVjdCBpcyBhdmFpbGFibGUgYXMgXG4gICBgUS5DbGFzc2AgYW5kIGEgc2Vjb25kIGFyZ3VtZW50IG9uIHRoZSBgZXh0ZW5kYCBtZXRob2QgYWxsb3dzIGZvciBhZGRpbmdcbiAgIGNsYXNzIGxldmVsIG1ldGhvZHMgYW5kIHRoZSBjbGFzcyBuYW1lIGlzIHBhc3NlZCBpbiBhIHBhcmFtZXRlciBmb3IgaW50cm9zcGVjdGlvblxuICAgcHVycG9zZXMuXG4gIFxuICAgQ2xhc3NlcyBjYW4gYmUgY3JlYXRlZCBieSBjYWxsaW5nIGBRLkNsYXNzLmV4dGVuZChuYW1lLHsgLi4gfSlgLCBhbHRob3VnaCBtb3N0IG9mIHRoZSB0aW1lXG4gICB5b3UnbGwgd2FudCB0byB1c2Ugb25lIG9mIHRoZSBkZXJpdml0aXZlIGNsYXNzZXMsIGBRLkV2ZW50ZWRgIG9yIGBRLkdhbWVPYmplY3RgIHdoaWNoXG4gICBoYXZlIGEgbGl0dGxlIGJpdCBvZiBmdW5jdGlvbmFsaXR5IGJ1aWx0LWluLiBgUS5FdmVudGVkYCBhZGRzIGV2ZW50IGJpbmRpbmcgYW5kIFxuICAgdHJpZ2dlcmluZyBzdXBwb3J0IGFuZCBgUS5HYW1lT2JqZWN0YCBhZGRzIHN1cHBvcnQgZm9yIGNvbXBvbmVudHMgYW5kIGEgZGVzdHJveSBtZXRob2QuXG4gIFxuICAgVGhlIG1haW4gdGhpbmdzIFEuQ2xhc3MgZ2V0IHlvdSBhcmUgZWFzeSBpbmhlcml0YW5jZSwgYSBjb25zdHJ1Y3RvciBtZXRob2QgY2FsbGVkIGBpbml0KClgLFxuICAgZHluYW1pYyBhZGRpdGlvbiBvZiBhIHRoaXMuX3N1cGVyIG1ldGhvZCB3aGVuIGEgbWV0aG9kIGlzIG92ZXJsb2FkZWQgKGJlIGNhcmVmdWwgd2l0aCBcbiAgIHRoaXMgYXMgaXQgYWRkcyBzb21lIG92ZXJoZWFkIHRvIG1ldGhvZCBjYWxscy4pIENhbGxzIHRvIGBpbnN0YW5jZW9mYCBhbHNvIGFsbCBcbiAgIHdvcmsgYXMgeW91J2QgaG9wZS5cbiAgXG4gICBCeSBjb252ZW50aW9uLCBjbGFzc2VzIHNob3VsZCBiZSBhZGRlZCBvbnRvIHRvIHRoZSBgUWAgb2JqZWN0IGFuZCBjYXBpdGFsaXplZCwgc28gaWYgXG4gICB5b3Ugd2FudGVkIHRvIGNyZWF0ZSBhIG5ldyBjbGFzcyBmb3IgeW91ciBnYW1lLCB5b3UnZCB3cml0ZTpcbiAgXG4gICAgICAgUS5DbGFzcy5leHRlbmQoXCJNeUNsYXNzXCIseyAuLi4gfSk7XG4gIFxuICAgRXhhbXBsZXM6XG4gIFxuICAgICAgIFEuQ2xhc3MuZXh0ZW5kKFwiQmlyZFwiLHsgXG4gICAgICAgICBpbml0OiBmdW5jdGlvbihuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH0sXG4gICAgICAgICBzcGVhazogZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKHRoaXMubmFtZSk7IH0sXG4gICAgICAgICBmbHk6IGZ1bmN0aW9uKCkgICB7IGNvbnNvbGUubG9nKFwiRmx5aW5nXCIpOyB9XG4gICAgICAgfSk7XG4gIFxuICAgICAgIFEuQmlyZC5leHRlbmQoXCJQZW5ndWluXCIse1xuICAgICAgICAgc3BlYWs6IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyh0aGlzLm5hbWUgKyBcIiB0aGUgcGVuZ3VpblwiKTsgfSxcbiAgICAgICAgIGZseTogZnVuY3Rpb24oKSAgIHsgY29uc29sZS5sb2coXCJDYW4ndCBmbHksIHNvcnJ5Li4uXCIpOyB9XG4gICAgICAgfSk7XG4gIFxuICAgICAgIHZhciByYW5kb21CaXJkID0gbmV3IFEuQmlyZChcIkZyYW5rXCIpLFxuICAgICAgICAgICBwZW5neSAgICAgID0gbmV3IFEuUGVuZ3VpbihcIlBlbmd5XCIpO1xuICBcbiAgICAgICByYW5kb21CaXJkLmZseSgpOyAvLyBMb2dzIFwiRmx5aW5nXCJcbiAgICAgICBwZW5neS5mbHkoKTsgICAgICAvLyBMb2dzIFwiQ2FuJ3QgZmx5LHNvcnJ5Li4uXCJcbiAgXG4gICAgICAgcmFuZG9tQmlyZC5zcGVhaygpOyAvLyBMb2dzIFwiRnJhbmtcIlxuICAgICAgIHBlbmd5LnNwZWFrKCk7ICAgICAgLy8gTG9ncyBcIlBlbmd5IHRoZSBwZW5ndWluXCJcbiAgXG4gICAgICAgY29uc29sZS5sb2cocmFuZG9tQmlyZCBpbnN0YW5jZW9mIFEuQmlyZCk7ICAgIC8vIHRydWUgXG4gICAgICAgY29uc29sZS5sb2cocmFuZG9tQmlyZCBpbnN0YW5jZW9mIFEuUGVuZ3Vpbik7IC8vIGZhbHNlXG4gICAgICAgY29uc29sZS5sb2cocGVuZ3kgaW5zdGFuY2VvZiBRLkJpcmQpOyAgICAgICAgIC8vIHRydWUgXG4gICAgICAgY29uc29sZS5sb2cocGVuZ3kgaW5zdGFuY2VvZiBRLlBlbmd1aW4pOyAgICAgIC8vIHRydWUgXG5cbiAgU2ltcGxlIEphdmFTY3JpcHQgSW5oZXJpdGFuY2VcbiAgQnkgSm9obiBSZXNpZyBodHRwOi8vZWpvaG4ub3JnL1xuICBNSVQgTGljZW5zZWQuXG4gIFxuICBJbnNwaXJlZCBieSBiYXNlMiBhbmQgUHJvdG90eXBlXG4gIEBjbGFzcyBRLkNsYXNzXG4gIEBmb3IgUXVpbnR1c1xuICAqL1xuICAoZnVuY3Rpb24oKXtcbiAgICB2YXIgaW5pdGlhbGl6aW5nID0gZmFsc2UsIFxuICAgICAgICBmblRlc3QgPSAveHl6Ly50ZXN0KGZ1bmN0aW9uKCl7IHZhciB4eXo7fSkgPyAvXFxiX3N1cGVyXFxiLyA6IC8uKi87XG4gICAgLyoqIFRoZSBiYXNlIENsYXNzIGltcGxlbWVudGF0aW9uIChkb2VzIG5vdGhpbmcpIFxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGZvciBRLkNsYXNzXG4gICAgICovXG4gICAgUS5DbGFzcyA9IGZ1bmN0aW9uKCl7fTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBpZiBhIG9iamVjdCBpcyBhIHNwZWNpZmljIGNsYXNzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzQVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgLSBjbGFzcyB0byBjaGVjayBhZ2FpbnN0XG4gICAgICovXG4gICAgUS5DbGFzcy5wcm90b3R5cGUuaXNBID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGFzc05hbWUgPT09IGNsYXNzTmFtZTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBDbGFzcyB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBjbGFzcyBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZXh0ZW5kXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gaGFzaCBvZiBwcm9wZXJ0aWVzIChpbml0IHdpbGwgYmUgdGhlIGNvbnN0cnVjdG9yKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2xhc3NNZXRob2RzXSAtIG9wdGlvbmFsIGNsYXNzIG1ldGhvZHMgdG8gYWRkIHRvIHRoZSBjbGFzc1xuICAgICAqL1xuICAgIFEuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBwcm9wLCBjbGFzc01ldGhvZHMpIHtcbiAgICAgIC8qIE5vIG5hbWUsIGRvbid0IGFkZCBvbnRvIFEgKi9cbiAgICAgIGlmKCFRLl9pc1N0cmluZyhjbGFzc05hbWUpKSB7XG4gICAgICAgIGNsYXNzTWV0aG9kcyA9IHByb3A7XG4gICAgICAgIHByb3AgPSBjbGFzc05hbWU7XG4gICAgICAgIGNsYXNzTmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3N1cGVyID0gdGhpcy5wcm90b3R5cGUsXG4gICAgICAgICAgVGhpc0NsYXNzID0gdGhpcztcbiAgICAgIFxuICAgICAgLyogSW5zdGFudGlhdGUgYSBiYXNlIGNsYXNzIChidXQgb25seSBjcmVhdGUgdGhlIGluc3RhbmNlLCAqL1xuICAgICAgLyogZG9uJ3QgcnVuIHRoZSBpbml0IGNvbnN0cnVjdG9yKSAqL1xuICAgICAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcbiAgICAgIHZhciBwcm90b3R5cGUgPSBuZXcgVGhpc0NsYXNzKCk7XG4gICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gX3N1cGVyRmFjdG9yeShuYW1lLGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdG1wID0gdGhpcy5fc3VwZXI7XG5cbiAgICAgICAgICAvKiBBZGQgYSBuZXcgLl9zdXBlcigpIG1ldGhvZCB0aGF0IGlzIHRoZSBzYW1lIG1ldGhvZCAqL1xuICAgICAgICAgIC8qIGJ1dCBvbiB0aGUgc3VwZXItY2xhc3MgKi9cbiAgICAgICAgICB0aGlzLl9zdXBlciA9IF9zdXBlcltuYW1lXTtcblxuICAgICAgICAgIC8qIFRoZSBtZXRob2Qgb25seSBuZWVkIHRvIGJlIGJvdW5kIHRlbXBvcmFyaWx5LCBzbyB3ZSAqL1xuICAgICAgICAgIC8qIHJlbW92ZSBpdCB3aGVuIHdlJ3JlIGRvbmUgZXhlY3V0aW5nICovXG4gICAgICAgICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7ICAgICAgICBcbiAgICAgICAgICB0aGlzLl9zdXBlciA9IHRtcDtcblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qIENvcHkgdGhlIHByb3BlcnRpZXMgb3ZlciBvbnRvIHRoZSBuZXcgcHJvdG90eXBlICovXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByb3ApIHtcbiAgICAgICAgLyogQ2hlY2sgaWYgd2UncmUgb3ZlcndyaXRpbmcgYW4gZXhpc3RpbmcgZnVuY3Rpb24gKi9cbiAgICAgICAgcHJvdG90eXBlW25hbWVdID0gdHlwZW9mIHByb3BbbmFtZV0gPT09IFwiZnVuY3Rpb25cIiAmJiBcbiAgICAgICAgICB0eXBlb2YgX3N1cGVyW25hbWVdID09PSBcImZ1bmN0aW9uXCIgJiYgXG4gICAgICAgICAgICBmblRlc3QudGVzdChwcm9wW25hbWVdKSA/IFxuICAgICAgICAgICAgICBfc3VwZXJGYWN0b3J5KG5hbWUscHJvcFtuYW1lXSkgOiBcbiAgICAgICAgICAgICAgcHJvcFtuYW1lXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogVGhlIGR1bW15IGNsYXNzIGNvbnN0cnVjdG9yICovXG4gICAgICBmdW5jdGlvbiBDbGFzcygpIHtcbiAgICAgICAgLyogQWxsIGNvbnN0cnVjdGlvbiBpcyBhY3R1YWxseSBkb25lIGluIHRoZSBpbml0IG1ldGhvZCAqL1xuICAgICAgICBpZiAoICFpbml0aWFsaXppbmcgJiYgdGhpcy5pbml0ICkge1xuICAgICAgICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFBvcHVsYXRlIG91ciBjb25zdHJ1Y3RlZCBwcm90b3R5cGUgb2JqZWN0ICovXG4gICAgICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICBcbiAgICAgIC8qIEVuZm9yY2UgdGhlIGNvbnN0cnVjdG9yIHRvIGJlIHdoYXQgd2UgZXhwZWN0ICovXG4gICAgICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcbiAgICAgIC8qIEFuZCBtYWtlIHRoaXMgY2xhc3MgZXh0ZW5kYWJsZSAqL1xuICAgICAgQ2xhc3MuZXh0ZW5kID0gUS5DbGFzcy5leHRlbmQ7XG4gICAgICBcbiAgICAgIC8qIElmIHRoZXJlIGFyZSBjbGFzcy1sZXZlbCBNZXRob2RzLCBhZGQgdGhlbSB0byB0aGUgY2xhc3MgKi9cbiAgICAgIGlmKGNsYXNzTWV0aG9kcykge1xuICAgICAgICBRLl9leHRlbmQoQ2xhc3MsY2xhc3NNZXRob2RzKTtcbiAgICAgIH1cblxuICAgICAgaWYoY2xhc3NOYW1lKSB7IFxuICAgICAgICAvKiBTYXZlIHRoZSBjbGFzcyBvbnRvIFEgKi9cbiAgICAgICAgUVtjbGFzc05hbWVdID0gQ2xhc3M7XG5cbiAgICAgICAgLyogTGV0IHRoZSBjbGFzcyBrbm93IGl0cyBuYW1lICovXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIENsYXNzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIENsYXNzO1xuICAgIH07XG4gIH0oKSk7XG4gICAgXG5cbiAgLy8gRXZlbnQgSGFuZGxpbmdcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAvKipcbiAgIFRoZSBgUS5FdmVudGVkYCBjbGFzcyBhZGRzIGV2ZW50IGhhbmRsaW5nIG9udG8gdGhlIGJhc2UgYFEuQ2xhc3NgIFxuICAgY2xhc3MuIFEuRXZlbnRlZCBvYmplY3RzIGNhbiB0cmlnZ2VyIGV2ZW50cyBhbmQgb3RoZXIgb2JqZWN0cyBjYW5cbiAgIGJpbmQgdG8gdGhvc2UgZXZlbnRzLlxuXG4gICBAY2xhc3MgUS5FdmVudGVkXG4gICBAZXh0ZW5kcyBRLkNsYXNzXG4gICBAZm9yIFF1aW50dXNcbiAgKi9cbiAgUS5DbGFzcy5leHRlbmQoXCJFdmVudGVkXCIse1xuXG4gICAgLyoqXG4gICAgQmluZHMgYSBjYWxsYmFjayB0byBhbiBldmVudCBvbiB0aGlzIG9iamVjdC4gSWYgeW91IHByb3ZpZGUgYVxuICAgIGB0YXJnZXRgIG9iamVjdCwgdGhhdCBvYmplY3Qgd2lsbCBhZGQgdGhpcyBldmVudCB0byBpdCdzIGxpc3Qgb2ZcbiAgICBiaW5kcywgYWxsb3dpbmcgaXQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgaXQgd2hlbiBpdCBpcyBkZXN0cm95ZWQuXG5cbiAgICBAbWV0aG9kIG9uXG4gICAgQGZvciBRLkV2ZW50ZWRcbiAgICBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBuYW1lIG9yIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50c1xuICAgIEBwYXJhbSB7T2JqZWN0fSBbdGFyZ2V0XSAtIG9wdGlvbmFsIGNvbnRleHQgZm9yIGNhbGxiYWNrLCBkZWZhdWx0cyB0byB0aGUgRXZlbnRlZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBjYWxsYmFjayAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBuYW1lIG9mIGV2ZW50IG9uIGNvbnRleHRcbiAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudCx0YXJnZXQsY2FsbGJhY2spIHtcbiAgICAgIGlmKFEuX2lzQXJyYXkoZXZlbnQpIHx8IGV2ZW50LmluZGV4T2YoXCIsXCIpICE9PSAtMSkge1xuICAgICAgICBldmVudCA9IFEuX25vcm1hbGl6ZUFyZyhldmVudCk7XG4gICAgICAgIGZvcih2YXIgaT0wO2k8ZXZlbnQubGVuZ3RoO2krKykge1xuICAgICAgICAgIHRoaXMub24oZXZlbnRbaV0sdGFyZ2V0LGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGVyZSBpcyBubyB0YXJnZXQgcHJvdmlkZWQsXG4gICAgICAvLyBzd2FwcGluZyB0aGUgdGFyZ2V0IGFuZCBjYWxsYmFjayBwYXJhbWV0ZXJzLlxuICAgICAgaWYoIWNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGFyZ2V0O1xuICAgICAgICB0YXJnZXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIG5vIGNhbGxiYWNrLCBkZWZhdWx0IHRvIHRoZSBldmVudCBuYW1lXG4gICAgICBpZighY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBldmVudDtcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBjYXNlIGZvciBjYWxsYmFjayB0aGF0IGlzIGEgc3RyaW5nLCB0aGlzIHdpbGxcbiAgICAgIC8vIHB1bGwgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHRhcmdldCBvYmplY3Qgb3IgZnJvbSB0aGlzXG4gICAgICAvLyBvYmplY3QuXG4gICAgICBpZihRLl9pc1N0cmluZyhjYWxsYmFjaykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSAodGFyZ2V0IHx8IHRoaXMpW2NhbGxiYWNrXTtcbiAgICAgIH1cblxuICAgICAgLy8gVG8ga2VlcCBgUS5FdmVudGVkYCBvYmplY3RzIGZyb20gbmVlZGluZyBhIGNvbnN0cnVjdG9yLFxuICAgICAgLy8gdGhlIGBsaXN0ZW5lcnNgIG9iamVjdCBpcyBjcmVhdGVkIG9uIHRoZSBmbHkgYXMgbmVlZGVkLlxuICAgICAgLy8gYGxpc3RlbmVyc2Aga2VlcHMgYSBsaXN0IG9mIGNhbGxiYWNrcyBpbmRleGVkIGJ5IGV2ZW50IG5hbWVcbiAgICAgIC8vIGZvciBxdWljayBsb29rdXAuIFxuICAgICAgdGhpcy5saXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyB8fCB7fTtcbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XSA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XS5wdXNoKFsgdGFyZ2V0IHx8IHRoaXMsIGNhbGxiYWNrXSk7XG5cbiAgICAgIC8vIFdpdGggYSBwcm92aWRlZCB0YXJnZXQsIHRoZSB0YXJnZXQgb2JqZWN0IGtlZXBzIHRyYWNrIG9mXG4gICAgICAvLyB0aGUgZXZlbnRzIGl0IGlzIGJvdW5kIHRvLCB3aGljaCBhbGxvd3MgZm9yIGF1dG9tYXRpYyBcbiAgICAgIC8vIHVuYmluZGluZyBvbiBkZXN0cm95LlxuICAgICAgaWYodGFyZ2V0KSB7XG4gICAgICAgIGlmKCF0YXJnZXQuYmluZHMpIHsgdGFyZ2V0LmJpbmRzID0gW107IH1cbiAgICAgICAgdGFyZ2V0LmJpbmRzLnB1c2goW3RoaXMsZXZlbnQsY2FsbGJhY2tdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFRyaWdnZXJzIGFuIGV2ZW50LCBwYXNzaW5nIGluIHNvbWUgb3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhIGFib3V0XG4gICAgIHRoZSBldmVudC4gXG5cbiAgICBAbWV0aG9kIHRyaWdnZXJcbiAgICBAZm9yIFEuRXZlbnRlZFxuICAgIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIG5hbWUgb2YgZXZlbnRcbiAgICBAcGFyYW0ge09iamVjdH0gW2RhdGFdIC0gb3B0aW9uYWwgZGF0YSB0byBwYXNzIHRvIHRoZSBjYWxsYmFja1xuICAgICovXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24oZXZlbnQsZGF0YSkge1xuICAgICAgLy8gRmlyc3QgbWFrZSBzdXJlIHRoZXJlIGFyZSBhbnkgbGlzdGVuZXJzLCB0aGVuIGNoZWNrIGZvciBhbnkgbGlzdGVuZXJzXG4gICAgICAvLyBvbiB0aGlzIHNwZWNpZmljIGV2ZW50LCBpZiBub3QsIGVhcmx5IG91dC5cbiAgICAgIGlmKHRoaXMubGlzdGVuZXJzICYmIHRoaXMubGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAvLyBDYWxsIGVhY2ggbGlzdGVuZXIgaW4gdGhlIGNvbnRleHQgb2YgZWl0aGVyIHRoZSB0YXJnZXQgcGFzc2VkIGludG9cbiAgICAgICAgLy8gYG9uYCBvciB0aGUgb2JqZWN0IGl0c2VsZi5cbiAgICAgICAgZm9yKHZhciBpPTAsbGVuID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdLmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVyc1tldmVudF1baV07XG4gICAgICAgICAgbGlzdGVuZXJbMV0uY2FsbChsaXN0ZW5lclswXSxkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICBVbmJpbmRzIGFuIGV2ZW50LiBDYW4gYmUgY2FsbGVkIHdpdGggMSwgMiwgb3IgMyBwYXJhbWV0ZXJzLCBlYWNoIFxuICAgICAgIG9mIHdoaWNoIHVuYmluZHMgYSBtb3JlIHNwZWNpZmljIGxpc3RlbmVyLlxuXG4gICAgQG1ldGhvZCBvZmZcbiAgICBAZm9yIFEuRXZlbnRlZFxuICAgIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIG5hbWUgb2YgZXZlbnRcbiAgICBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gLSBvcHRpb25hbGx5IGxpbWl0IHRvIGEgc3BlY2lmaWMgdGFyZ2V0XG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIG9wdGlvbmFsbHkgbGltaXQgdG8gb25lIHNwZWNpZmljIGNhbGxiYWNrXG4gICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50LHRhcmdldCxjYWxsYmFjaykge1xuICAgICAgLy8gV2l0aG91dCBhIHRhcmdldCwgcmVtb3ZlIGFsbCB0ZWggbGlzdGVuZXJzLlxuICAgICAgaWYoIXRhcmdldCkge1xuICAgICAgICBpZih0aGlzLmxpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgY2FsbGJhY2sgaXMgYSBzdHJpbmcsIGZpbmQgYSBtZXRob2Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgbmFtZSBvbiB0aGUgdGFyZ2V0LlxuICAgICAgICBpZihRLl9pc1N0cmluZyhjYWxsYmFjaykgJiYgdGFyZ2V0W2NhbGxiYWNrXSkge1xuICAgICAgICAgIGNhbGxiYWNrID0gdGFyZ2V0W2NhbGxiYWNrXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzICYmIHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgaWYobCkge1xuICAgICAgICAgIC8vIExvb3AgZnJvbSB0aGUgZW5kIHRvIHRoZSBiZWdpbm5pbmcsIHdoaWNoIGFsbG93cyB1c1xuICAgICAgICAgIC8vIHRvIHJlbW92ZSBlbGVtZW50cyB3aXRob3V0IGhhdmluZyB0byBhZmZlY3QgdGhlIGxvb3AuXG4gICAgICAgICAgZm9yKHZhciBpID0gbC5sZW5ndGgtMTtpPj0wO2ktLSkge1xuICAgICAgICAgICAgaWYobFtpXVswXSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgIGlmKCFjYWxsYmFjayB8fCBjYWxsYmFjayA9PT0gbFtpXVsxXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaSwxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogXG4gICAgIGBkZWJpbmRgIGlzIGNhbGxlZCB0byByZW1vdmUgYW55IGxpc3RlbmVycyBhbiBvYmplY3QgaGFkXG4gICAgIG9uIG90aGVyIG9iamVjdHMuIFRoZSBtb3N0IGNvbW1vbiBjYXNlIGlzIHdoZW4gYW4gb2JqZWN0IGlzXG4gICAgIGRlc3Ryb3llZCB5b3UnbGwgd2FudCBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0byBiZSByZW1vdmVkXG4gICAgIGZvciB5b3UuXG5cbiAgICBAbWV0aG9kIGRlYmluZFxuICAgIEBmb3IgUS5FdmVudGVkXG4gICAgKi9cbiAgICBkZWJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgIGlmKHRoaXMuYmluZHMpIHtcbiAgICAgICAgIGZvcih2YXIgaT0wLGxlbj10aGlzLmJpbmRzLmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgICAgICAgICAgdmFyIGJvdW5kRXZlbnQgPSB0aGlzLmJpbmRzW2ldLFxuICAgICAgICAgICAgICAgc291cmNlID0gYm91bmRFdmVudFswXSxcbiAgICAgICAgICAgICAgIGV2ZW50ID0gYm91bmRFdmVudFsxXTtcbiAgICAgICAgICAgc291cmNlLm9mZihldmVudCx0aGlzKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1cblxuICAgfSk7XG5cblxuICAgXG5cblxuICAvKipcbiAgIFRoZSBtYXN0ZXIgbGlzdCBvZiByZWdpc3RlcmVkIGNvbXBvbmVudHMsIGluZGV4ZWQgaW4gYW4gb2JqZWN0IGJ5IG5hbWUuXG5cbiAgIEBwcm9wZXJ0eSBRLmNvbXBvbmVudHNcbiAgIEB0eXBlIE9iamVjdFxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEuY29tcG9uZW50cyA9IHt9O1xuXG4gIC8qKlxuICAgQ29tcG9uZW50c1xuICAgPT09PT09PT09PT09PT1cbiAgXG4gICBDb21wb25lbnRzIGFyZSBzZWxmLWNvbnRhaW5lZCBwaWVjZXMgb2YgZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBhZGRlZCBvbnRvIGFuZCByZW1vdmVkXG4gICBmcm9tIG9iamVjdHMuIFRoZSBhbGxvdyBmb3IgYSBtb3JlIGR5bmFtaWMgZnVuY3Rpb25hbGl0eSB0cmVlIHRoYW4gdXNpbmcgaW5oZXJpdGFuY2UgKGkuZS5cbiAgIGJ5IGZhdm9yaW5nIGNvbXBvc2l0aW9uIG92ZXIgaW5oZXJpdGFuY2UpIGFuZCBhcmUgYWRkZWQgYW5kIHJlbW92ZWQgb24gdGhlIGZseSBhdCBydW50aW1lLlxuICAgKHllcywgSSBrbm93IGV2ZXJ5dGhpbmcgaW4gSlMgaXMgYXQgcnVudGltZSwgYnV0IHlvdSBrbm93IHdoYXQgSSBtZWFuLCBnZWV6KVxuICBcbiAgIENvbWJpbmluZyBjb21wb25lbnRzIHdpdGggZXZlbnRzIG1ha2VzIGl0IGVhc3kgdG8gY3JlYXRlIHJldXNhYmxlIHBpZWNlcyBvZlxuICAgZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBkZWNvdXBsZWQgZnJvbSBlYWNoIG90aGVyLlxuXG4gICBUaGUgYmFzZSBjbGFzcyBmb3IgY29tcG9uZW50cy4gVGhlc2UgYXJlIHVzdWFsbHkgbm90IGRlcml2ZWQgZGlyZWN0bHkgYnV0IGFyZSBpbnN0ZWFkXG4gICBjcmVhdGVkIGJ5IGNhbGxpbmcgYFEucmVnaXN0ZXJgIHRvIHJlZ2lzdGVyIGEgbmV3IGNvbXBvbmVudCBnaXZlbiBhIHNldCBvZiBtZXRob2RzIHRoZSBcbiAgIGNvbXBvbmVudCBzdXBwb3J0cy4gQ29tcG9uZW50cyBhcmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhleSBhcmUgYWRkZWQgdG8gYSBcbiAgIGBRLkdhbWVPYmplY3RgIHdpdGggdGhlIGBhZGRgIG1ldGhvZC5cbiAgXG4gICBNYW55IGNvbXBvbmVudHMgYWxzbyBkZWZpbmUgYW4gYGFkZGVkYCBtZXRob2QsIHdoaWNoIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZVxuICAgYGluaXRgIGNvbnN0cnVjdG9yIGFmdGVyIGEgY29tcG9uZW50IGhhcyBiZWVuIGFkZGVkIHRvIGFuIG9iamVjdC4gVGhpcyBpcyBhIGdvb2QgdGltZVxuICAgdG8gYWRkIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgb2JqZWN0LlxuXG4gICBAY2xhc3MgUS5Db21wb25lbnRcbiAgIEBldmVudHMgUS5FdmVudGVkXG4gICBAZm9yIFF1aW50dXNcbiAgKi9cbiAgUS5FdmVudGVkLmV4dGVuZChcIkNvbXBvbmVudFwiLHtcblxuICAgIC8vIENvbXBvbmVudHMgYXJlIGNyZWF0ZWQgd2hlbiB0aGV5IGFyZSBhZGRlZCBvbnRvIGEgYFEuR2FtZU9iamVjdGAgZW50aXR5LiBUaGUgZW50aXR5XG4gICAgLy8gaXMgZGlyZWN0bHkgZXh0ZW5kZWQgd2l0aCBhbnkgbWV0aG9kcyBpbnNpZGUgb2YgYW4gYGV4dGVuZGAgcHJvcGVydHkgYW5kIHRoZW4gdGhlIFxuICAgIC8vIGNvbXBvbmVudCBpdHNlbGYgaXMgYWRkZWQgb250byB0aGUgZW50aXR5IGFzIHdlbGwuIFxuICAgIGluaXQ6IGZ1bmN0aW9uKGVudGl0eSkge1xuICAgICAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG4gICAgICBpZih0aGlzLmV4dGVuZCkgeyBRLl9leHRlbmQoZW50aXR5LHRoaXMuZXh0ZW5kKTsgICB9XG4gICAgICBlbnRpdHlbdGhpcy5uYW1lXSA9IHRoaXM7XG5cbiAgICAgIGVudGl0eS5hY3RpdmVDb21wb25lbnRzLnB1c2godGhpcy5jb21wb25lbnROYW1lKTtcblxuICAgICAgaWYoZW50aXR5LnN0YWdlICYmIGVudGl0eS5zdGFnZS5hZGRUb0xpc3QpIHtcbiAgICAgICAgZW50aXR5LnN0YWdlLmFkZFRvTGlzdCh0aGlzLmNvbXBvbmVudE5hbWUsZW50aXR5KTtcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMuYWRkZWQpIHsgdGhpcy5hZGRlZCgpOyB9ICAgIFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgYGRlc3Ryb3lgIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYSBjb21wb25lbnQgaXMgcmVtb3ZlZCBmcm9tIGFuIGVudGl0eS4gSXQgaXMgXG4gICAgIG5vdCBjYWxsZWQsIGhvd2V2ZXIsIHdoZW4gYW4gZW50aXR5IGlzIGRlc3Ryb3llZCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLlxuICAgICBcbiAgICAgSXQncyBqb2IgaXMgdG8gcmVtb3ZlIGFueSBtZXRob2RzIHRoYXQgd2VyZSBhZGRlZCB3aXRoIGBleHRlbmRgIGFuZCB0aGVuIHJlbW92ZSBhbmRcbiAgICAgZGViaW5kIGl0c2VsZiBmcm9tIHRoZSBlbnRpdHkuIEl0IHdpbGwgYWxzbyBjYWxsIGBkZXN0cm95ZWRgIGlmIHRoZSBjb21wb25lbnQgaGFzXG4gICAgIGEgbWV0aG9kIGJ5IHRoYXQgbmFtZS5cblxuICAgICBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgQGZvciBRLkNvbXBvbmVudFxuICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLmV4dGVuZCkge1xuICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IFEuX2tleXModGhpcy5leHRlbmQpO1xuICAgICAgICBmb3IodmFyIGk9MCxsZW49ZXh0ZW5zaW9ucy5sZW5ndGg7aTxsZW47aSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuZW50aXR5W2V4dGVuc2lvbnNbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5lbnRpdHlbdGhpcy5uYW1lXTtcbiAgICAgIHZhciBpZHggPSB0aGlzLmVudGl0eS5hY3RpdmVDb21wb25lbnRzLmluZGV4T2YodGhpcy5jb21wb25lbnROYW1lKTtcbiAgICAgIGlmKGlkeCAhPT0gLTEpIHsgXG4gICAgICAgIHRoaXMuZW50aXR5LmFjdGl2ZUNvbXBvbmVudHMuc3BsaWNlKGlkeCwxKTtcblxuICAgICAgICBpZih0aGlzLmVudGl0eS5zdGFnZSAmJiB0aGlzLmVudGl0eS5zdGFnZS5hZGRUb0xpc3QpIHtcbiAgICAgICAgICB0aGlzLmVudGl0eS5zdGFnZS5hZGRUb0xpc3RzKHRoaXMuY29tcG9uZW50TmFtZSx0aGlzLmVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZGViaW5kKCk7XG4gICAgICBpZih0aGlzLmRlc3Ryb3llZCkgeyB0aGlzLmRlc3Ryb3llZCgpOyB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgIFxuICAgIEdhbWUgT2JqZWN0c1xuICAgID09PT09PT09PT09PVxuXG4gICBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIG1vc3QgUXVpbnR1cyBvYmplY3RzIGFyZSBkZXJpdmVkIGZyb20sIGl0IGV4dGVuZHMgXG4gICBgUS5FdmVudGVkYCBhbmQgYWRkcyBjb21wb25lbnQgc3VwcG9ydCB0byBhbiBvYmplY3QsIGFsbG93aW5nIGNvbXBvbmVudHMgdG9cbiAgIGJlIGFkZGVkIGFuZCByZW1vdmVkIGZyb20gYW4gb2JqZWN0LiBJdCBhbHNvIGRlZmluZXMgYSBkZXN0cm95ZWQgbWV0aG9kXG4gICB3aGljaCB3aWxsIGRlYmluZCB0aGUgb2JqZWN0LCByZW1vdmUgaXQgZnJvbSBpdCdzIHBhcmVudCAodXN1YWxseSBhIHNjZW5lKVxuICAgaWYgaXQgaGFzIG9uZSwgYW5kIHRyaWdnZXIgYSBkZXN0cm95ZWQgZXZlbnQuXG5cbiAgIEBjbGFzcyBRLkdhbWVPYmplY3RcbiAgIEBleHRlbmRzIFEuRXZlbnRlZFxuICAgQGZvciBRdWludHVzXG4gICovXG4gIFEuRXZlbnRlZC5leHRlbmQoXCJHYW1lT2JqZWN0XCIse1xuXG4gICAgLyoqXG4gICAgIFNpbXBsZSBjaGVjayB0byBzZWUgaWYgYSBjb21wb25lbnQgYWxyZWFkeSBleGlzdHNcbiAgICAgb24gYW4gb2JqZWN0IGJ5IHNlYXJjaGluZyBmb3IgYSBwcm9wZXJ0eSBvZiB0aGUgc2FtZSBuYW1lLlxuXG4gICAgIEBtZXRob2QgaGFzXG4gICAgIEBmb3IgUS5HYW1lT2JqZWN0XG4gICAgIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgLSBuYW1lIG9mIGNvbXBvbmVudCB0byB0ZXN0IGFnYWluc3RcbiAgICAgQHJldHVybnMge0Jvb2xlYW59XG4gICAgKi9cbiAgICBoYXM6IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIHRoaXNbY29tcG9uZW50XSA/IHRydWUgOiBmYWxzZTsgXG4gICAgfSxcblxuICAgIC8qKlxuICAgICBBZGRzIG9uZSBvciBtb3JlIGNvbXBvbmVudHMgdG8gYW4gb2JqZWN0LiBBY2NlcHRzIGVpdGhlciBcbiAgICAgYSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCBtYXBcbiAgICAgdG8gY29tcG9uZW50IG5hbWVzLlxuICAgIFxuICAgICBJbnN0YW50aWF0ZXMgYSBuZXcgY29tcG9uZW50IG9iamVjdCBvZiB0aGUgY29ycmVjdCB0eXBlXG4gICAgIChpZiB0aGUgY29tcG9uZW50IGV4aXN0cykgYW5kIHRoZW4gdHJpZ2dlcnMgYW4gYWRkQ29tcG9uZW50XG4gICAgIGV2ZW50LlxuXG4gICAgIEZvciBleGFtcGxlOlxuXG4gICAgICAgICB0aGlzLmFkZChcIjJkLCBhaUJvdW5jZVwiKVxuICAgIFxuICAgICBSZXR1cm5zIHRoZSBvYmplY3QgdG8gYWxsb3cgY2hhaW5pbmcuXG5cbiAgICAgQGZvciBRLkdhbWVPYmplY3RcbiAgICAgQG1ldGhvZCBhZGRcbiAgICAgQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudHMgLSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBjb21wb25lbnRzIHRvIGFkZFxuICAgICBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhpcyBmb3IgY2hhaW5pbmcgcHVycG9zZXNcbiAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24oY29tcG9uZW50cykge1xuICAgICAgY29tcG9uZW50cyA9IFEuX25vcm1hbGl6ZUFyZyhjb21wb25lbnRzKTtcbiAgICAgIGlmKCF0aGlzLmFjdGl2ZUNvbXBvbmVudHMpIHsgdGhpcy5hY3RpdmVDb21wb25lbnRzID0gW107IH1cbiAgICAgIGZvcih2YXIgaT0wLGxlbj1jb21wb25lbnRzLmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjb21wb25lbnRzW2ldLFxuICAgICAgICAgICAgQ29tcCA9IFEuY29tcG9uZW50c1tuYW1lXTtcbiAgICAgICAgaWYoIXRoaXMuaGFzKG5hbWUpICYmIENvbXApIHsgXG4gICAgICAgICAgdmFyIGMgPSBuZXcgQ29tcCh0aGlzKTsgXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdhZGRDb21wb25lbnQnLGMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBcblxuICAgIC8qKlxuICAgICBSZW1vdmVzIG9uZSBvciBtb3JlIGNvbXBvbmVudHMgZnJvbSBhbiBvYmplY3QuIEFjY2VwdHMgdGhlXG4gICAgIHNhbWUgc3R5bGUgb2YgcGFyYW1ldGVycyBhcyBgYWRkYC4gVHJpZ2dlcnMgYSBkZWxDb21wb25lbnQgZXZlbnRcbiAgICAgYW5kIGFuZCBjYWxscyBkZXN0cm95IG9uIHRoZSBjb21wb25lbnQuXG4gICAgXG4gICAgIFJldHVybnMgdGhlIGVsZW1lbnQgdG8gYWxsb3cgY2hhaW5pbmcuXG5cbiAgICAgQGZvciBRLkdhbWVPYmplY3RcbiAgICAgQG1ldGhvZCBkZWxcbiAgICAgQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudHMgLSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZVxuICAgICBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhpcyBmb3IgY2hhaW5pbmcgcHVycG9zZXNcbiAgICAqL1xuICAgIGRlbDogZnVuY3Rpb24oY29tcG9uZW50cykge1xuICAgICAgY29tcG9uZW50cyA9IFEuX25vcm1hbGl6ZUFyZyhjb21wb25lbnRzKTtcbiAgICAgIGZvcih2YXIgaT0wLGxlbj1jb21wb25lbnRzLmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICBpZihuYW1lICYmIHRoaXMuaGFzKG5hbWUpKSB7IFxuICAgICAgICAgIHRoaXMudHJpZ2dlcignZGVsQ29tcG9uZW50Jyx0aGlzW25hbWVdKTtcbiAgICAgICAgICB0aGlzW25hbWVdLmRlc3Ryb3koKTsgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgRGVzdHJveXMgdGhlIG9iamVjdCBieSBjYWxsaW5nIGRlYmluZCBhbmQgcmVtb3ZpbmcgdGhlXG4gICAgIG9iamVjdCBmcm9tIGl0J3MgcGFyZW50LiBXaWxsIHRyaWdnZXIgYSBkZXN0cm95ZWQgZXZlbnRcbiAgICAgY2FsbGJhY2suXG5cbiAgICAgQGZvciBRLkdhbWVPYmplY3RcbiAgICAgQG1ldGhvZCBkZWxcbiAgICAgQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudHMgLSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZVxuICAgICBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhpcyBmb3IgY2hhaW5pbmcgcHVycG9zZXNcbiAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYodGhpcy5pc0Rlc3Ryb3llZCkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMudHJpZ2dlcignZGVzdHJveWVkJyk7XG4gICAgICB0aGlzLmRlYmluZCgpO1xuICAgICAgaWYodGhpcy5zdGFnZSAmJiB0aGlzLnN0YWdlLnJlbW92ZSkge1xuICAgICAgICB0aGlzLnN0YWdlLnJlbW92ZSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgaWYodGhpcy5kZXN0cm95ZWQpIHsgdGhpcy5kZXN0cm95ZWQoKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICBSZWdpc3RlcnMgYSBjb21wb25lbnQgd2l0aCB0aGUgZW5naW5lLCBtYWtpbmcgaXQgYXZhaWxhYmxlIHRvIGBRLkdhbWVPYmplY3RgJ3MgXG4gICBUaGlzIGNyZWF0ZXMgYSBuZXcgZGVzY2VuZGVudCBjbGFzcyBvZiBgUS5Db21wb25lbnRgIHdpdGggbmV3IG1ldGhvZHMgYWRkZWQgaW4uXG5cbiAgIEBmb3IgUXVpbnR1c1xuICAgQG1ldGhvZCBRLmNvbXBvbmVudFxuICAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBjb21wb25lbnQgbmFtZVxuICAgQHBhcmFtIHtPYmplY3R9IG1ldGVob2RzIC0gaGFzaCBvZiBtZXRob2RzIGZvciB0aGUgY29tcG9uZW50XG4gICovXG4gIFEuY29tcG9uZW50ID0gZnVuY3Rpb24obmFtZSxtZXRob2RzKSB7XG4gICAgaWYoIW1ldGhvZHMpIHsgcmV0dXJuIFEuY29tcG9uZW50c1tuYW1lXTsgfVxuICAgIG1ldGhvZHMubmFtZSA9IG5hbWU7XG4gICAgbWV0aG9kcy5jb21wb25lbnROYW1lID0gXCIuXCIgKyBuYW1lO1xuICAgIHJldHVybiAoUS5jb21wb25lbnRzW25hbWVdID0gUS5Db21wb25lbnQuZXh0ZW5kKG5hbWUgKyBcIkNvbXBvbmVudFwiLG1ldGhvZHMpKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgR2VuZXJpYyBHYW1lIFN0YXRlIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gICB0cmFjayBvZiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgR2FtZSwgZm9yIGV4YW1wbGUgd2hlbiB0aGUgcGxheWVyIHN0YXJ0c1xuICAgYSBuZXcgZ2FtZSB5b3UgbWlnaHQgd2FudCB0byBrZWVwIHRyYWNrIG9mIHRoZWlyIHNjb3JlIGFuZCByZW1haW5pbmcgbGl2ZXM6XG4gIFxuICAgICAgIFEucmVzZXQoeyBzY29yZTogMCwgbGl2ZXM6IDIgfSk7XG4gIFxuICAgVGhlbiBpbiB5b3VyIGdhbWUgbWlnaHQgd2FudCB0byBhZGQgdG8gdGhlIHNjb3JlOlxuICAgICAgIFxuICAgICAgICBRLnN0YXRlLmluYyhcInNjb3JlXCIsNTApO1xuICBcbiAgIEluIHlvdXIgaHVkLCB5b3UgY2FuIGxpc3RlbiBmb3IgY2hhbmdlIGV2ZW50cyBvbiB0aGUgc3RhdGUgdG8gdXBkYXRlIHlvdXIgXG4gICBkaXNwbGF5OlxuICBcbiAgICAgICAgUS5zdGF0ZS5vbihcImNoYW5nZS5zY29yZVwiLGZ1bmN0aW9uKCkgeyAuLiB1cGRhdGUgdGhlIHNjb3JlIGRpc3BsYXkgLi4gfSk7XG4gIFxuICBAY2xhc3MgUS5HYW1lU3RhdGVcbiAgQGV4dGVuZHMgUS5HYW1lT2JqZWN0XG4gICovXG4gIFEuR2FtZU9iamVjdC5leHRlbmQoXCJHYW1lU3RhdGVcIix7XG4gICAgaW5pdDogZnVuY3Rpb24ocCkge1xuICAgICAgdGhpcy5wID0gUS5fZXh0ZW5kKHt9LHApO1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgUmVzZXRzIHRoZSBzdGF0ZSB0byB2YWx1ZSBwLCB0cmlnZ2VycyBhIHJlc2V0IGV2ZW50LlxuXG4gICAgIEBtZXRob2QgcmVzZXRcbiAgICAgQHBhcmFtIHtPYmplY3R9IHAgLSBwcm9wZXJ0aWVzIHRvIHJlaW5pdGlhbGl6ZSB0b1xuICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHApIHsgdGhpcy5pbml0KHApOyB0aGlzLnRyaWdnZXIoXCJyZXNldFwiKTsgfSxcbiAgICBcbiAgICAvLyBJbnRlcm5hbCBoZWxwZXIgbWV0aG9kIHRvIHNldCBhbiBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgX3RyaWdnZXJQcm9wZXJ0eTogZnVuY3Rpb24odmFsdWUsa2V5KSB7XG4gICAgICBpZih0aGlzLnBba2V5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiY2hhbmdlLlwiICsga2V5LHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFNldCBvbmUgb3IgbW9yZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyIGV2ZW50cyBvbiB0aG9zZVxuICAgICBwcm9wZXJ0aWVzIGNoYW5naW5nLlxuXG4gICAgIEBleGFtcGxlXG4gICAgICAgIFEuc3RhdGUuc2V0KHsgbGl2ZXM6IDUsIGhpdFBvaW50czogNCB9KTtcbiAgICAgICAgLy8gVHJpZ2dlcnMgMyBldmVudHM6IGNoYW5nZS5saXZlcywgY2hhbmdlLmhpdFBvaW50cywgY2hhbmdlXG5cblxuICAgICAgICBRLnN0YXRlLnNldChcImxpdmVzXCIsNSk7XG4gICAgICAgIC8vIFRyaWdnZXJzIDIgZXZlbnRzOiBjaGFuZ2UubGl2ZXMsIGNoYW5nZVxuXG4gICAgQG1ldGhvZCBzZXRcbiAgICBAcGFyYW0ge09iamVjdCBvciBTdHJpbmd9IHByb3BlcnRpZXMgLSBoYXNoIG9mIHByb3BlcnRpZXMgdG8gc2V0LCBvciBwcm9wZXJ0eSBuYW1lXG4gICAgQHBhcmFtIHtWYXJ9IFt2YWx1ZV0gLSBpZiBzZXR0aW5nIDEgcHJvcGVydHksIHRoZSB2YWx1ZSBvZiB0aGF0IHByb3BlcnR5XG4gICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHByb3BlcnRpZXMsdmFsdWUpIHtcbiAgICAgIGlmKFEuX2lzT2JqZWN0KHByb3BlcnRpZXMpKSB7XG4gICAgICAgIFEuX2VhY2gocHJvcGVydGllcyx0aGlzLl90cmlnZ2VyUHJvcGVydHksdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90cmlnZ2VyUHJvcGVydHkodmFsdWUscHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICBJbmNyZW1lbnQgYW4gaW5kaXZpZHVhbCBwcm9wZXJ0eSBieSBhbW91bnQsIHVzZXMgc2V0IGludGVybmFsbHlcblxuICAgICBAbWV0aG9kIGluY1xuICAgICBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICAgQHBhcmFtIHtJbnRlZ2VyfSBhbW91bnQgLSBhbW91bnQgdG8gaW5jcmVtZW50IGJ5XG4gICAgKi9cbiAgICBpbmM6IGZ1bmN0aW9uKHByb3BlcnR5LGFtb3VudCkge1xuICAgICAgdGhpcy5zZXQocHJvcGVydHksdGhpcy5nZXQocHJvcGVydHkpICsgYW1vdW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG5cbiAgICAgSW5jcmVtZW50IGFuIGluZGl2aWR1YWwgcHJvcGVydHkgYnkgYW1vdW50LCB1c2VzIHNldCBpbnRlcm5hbGx5XG5cbiAgICAgQG1ldGhvZCBkZWNcbiAgICAgQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAgIEBwYXJhbSB7SW50ZWdlcn0gYW1vdW50IC0gYW1vdW50IHRvIGRlY3JlbWVudCBieVxuICAgICovXG4gICAgZGVjOiBmdW5jdGlvbihwcm9wZXJ0eSxhbW91bnQpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LHRoaXMuZ2V0KHByb3BlcnR5KSAtIGFtb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuXG4gICAgIFJldHVybiBhbiBpbmRpdmlkdWFsIHByb3BlcnR5XG5cbiAgICAgQG1ldGhvZCBnZXRcbiAgICAgQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFxuICAgICBAcmV0dXJuIHtWYXJ9IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMucFtwcm9wZXJ0eV07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgIFRvcC1sZXZlbCBgUS5HYW1lU3RhdGVgIGluc3RhbmNlLCBnZW5lcmFsbHkgdXNlZCBmb3IgZ2xvYmFsIHN0YXRlIGluIHRoZSBnYW1lXG5cbiAgIEBmb3IgUXVpbnR1c1xuICAgQHByb3BlcnR5IFEuc3RhdGVcbiAgIEB0eXBlIFEuR2FtZVN0YXRlXG4gICovXG4gIFEuc3RhdGUgPSBuZXcgUS5HYW1lU3RhdGUoKTtcblxuICAvKiogXG4gICBSZXNldCB0aGUgZ2xvYmFsIGdhbWUgc3RhdGVcblxuICAgQGZvciBRdWludHVzXG4gICBAbWV0aG9kIFEucmVzZXRcbiAgKi9cbiAgUS5yZXNldCA9IGZ1bmN0aW9uKCkgeyBRLnN0YXRlLnJlc2V0KCk7IH07XG5cblxuXG5cbiAgUS50b3VjaERldmljZSA9ICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudCk7XG5cbiAgLyoqXG4gIFxuICAgQ2FudmFzIE1ldGhvZHNcbiAgIFxuICAgVGhlIGBzZXR1cGAgYW5kIGBjbGVhcmAgbWV0aG9kIGFyZSB0aGUgb25seSB0d28gY2FudmFzLXNwZWNpZmljIG1ldGhvZHMgaW4gXG4gICB0aGUgY29yZSBvZiBRdWludHVzLiBgaW1hZ2VEYXRhYCAgYWxzbyB1c2VzIGNhbnZhcyBidXQgaXQgY2FuIGJlIHVzZWQgaW5cbiAgIGFueSB0eXBlIG9mIGdhbWUuXG5cbiAgIFNldHVwIHdpbGwgZWl0aGVyIGNyZWF0ZSBhIG5ldyBjYW52YXMgZWxlbWVudCBhbmQgYXBwZW5kIGl0XG4gICB0byB0aGUgYm9keSBvZiB0aGUgZG9jdW1lbnQgb3IgdXNlIGFuIGV4aXN0aW5nIG9uZS4gSXQgd2lsbCB0aGVuXG4gICBwdWxsIG91dCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2FudmFzIGZvciBlbmdpbmUgdXNlLlxuICBcbiAgIEl0IGFsc28gYWRkcyBhIHdyYXBwZXIgY29udGFpbmVyIGFyb3VuZCB0aGUgZWxlbWVudC5cbiAgXG4gICBJZiB0aGUgYG1heGltaXplYCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIGNhbnZhcyBlbGVtZW50IGlzIG1heGltaXplZFxuICAgb24gdGhlIHBhZ2UgYW5kIHRoZSBzY3JvbGwgdHJpY2sgaXMgdXNlZCB0byB0cnkgdG8gZ2V0IHRoZSBhZGRyZXNzIGJhciBhd2F5LlxuICBcbiAgIFRoZSBlbmdpbmUgd2lsbCBhbHNvIHJlc2FtcGxlIHRoZSBnYW1lIHRvIENTUyBkaW1lbnNpb25zIGF0IHR3aWNlIHBpeGVsXG4gICBkaW1lbnNpb25zIGlmIHRoZSBgcmVzYW1wbGVXaWR0aGAgb3IgYHJlc2FtcGxlSGVpZ2h0YCBvcHRpb25zIGFyZSBzZXQuXG4gIFxuICAgVE9ETzogYWRkIHN1cHBvcnQgZm9yIGF1dG8tcmVzaXplIHcvIGVuZ2luZSBldmVudCBub3RpZmljYXRpb25zXG5cbiAgIEF2YWlsYWJsZSBvcHRpb25zOlxuXG4gICAgICAge1xuICAgICAgICB3aWR0aDogMzIwLCAgLy8gd2lkdGggb2YgY3JlYXRlZCBjYW52YXNcbiAgICAgICAgaGVpZ2h0OiA0MjAsIC8vIGhlaWdodCBvZiBjcmVhdGVkIGNhbnZhc1xuICAgICAgICBtYXhpbWl6ZTogZmFsc2UgLy8gc2V0IHRvIHRydWUgdG8gbWF4aW1pemUgdG8gc2NyZWVuLCBcInRvdWNoXCIgdG8gbWF4aW1pemUgb24gdG91Y2ggZGV2aWNlc1xuICAgICAgIH1cblxuICAgQGZvciBRdWludHVzXG4gICBAbWV0aG9kIFEuc2V0dXBcbiAgIEBwYXJhbSB7U3RyaW5nfSBbaWQ9XCJxdWludHVzXCJdIC0gaWQgb2YgdGhlIGNhbnZhcyBlbGVtZW50IHRvIHRyaWdnZXIgcXVpbnR1cyBvblxuICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgaGFzaFxuXG4gICovXG4gIFEuc2V0dXAgPSBmdW5jdGlvbihpZCwgb3B0aW9ucykge1xuICAgIGlmKFEuX2lzT2JqZWN0KGlkKSkge1xuICAgICAgb3B0aW9ucyA9IGlkO1xuICAgICAgaWQgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZCA9IGlkIHx8IFwicXVpbnR1c1wiO1xuXG4gICAgaWYoUS5faXNTdHJpbmcoaWQpKSB7XG4gICAgICBRLmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBRLmVsID0gaWQ7XG4gICAgfVxuXG4gICAgaWYoIVEuZWwpIHtcbiAgICAgIFEuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgUS5lbC53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMzIwO1xuICAgICAgUS5lbC5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCA0MjA7XG4gICAgICBRLmVsLmlkID0gaWQ7XG5cbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoUS5lbCk7XG4gICAgfVxuXG4gICAgdmFyIHcgPSBwYXJzZUludChRLmVsLndpZHRoLDEwKSxcbiAgICAgICAgaCA9IHBhcnNlSW50KFEuZWwuaGVpZ2h0LDEwKTtcblxuICAgIHZhciBtYXhXaWR0aCA9IG9wdGlvbnMubWF4V2lkdGggfHwgNTAwMCxcbiAgICAgICAgbWF4SGVpZ2h0ID0gb3B0aW9ucy5tYXhIZWlnaHQgfHwgNTAwMCxcbiAgICAgICAgcmVzYW1wbGVXaWR0aCA9IG9wdGlvbnMucmVzYW1wbGVXaWR0aCxcbiAgICAgICAgcmVzYW1wbGVIZWlnaHQgPSBvcHRpb25zLnJlc2FtcGxlSGVpZ2h0LFxuICAgICAgICB1cHNhbXBsZVdpZHRoID0gb3B0aW9ucy51cHNhbXBsZVdpZHRoLFxuICAgICAgICB1cHNhbXBsZUhlaWdodCA9IG9wdGlvbnMudXBzYW1wbGVIZWlnaHQ7XG5cbiAgICBpZihvcHRpb25zLm1heGltaXplID09PSB0cnVlIHx8IChRLnRvdWNoRGV2aWNlICYmIG9wdGlvbnMubWF4aW1pemUgPT09ICd0b3VjaCcpKSAge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gMDtcblxuICAgICAgdyA9IG9wdGlvbnMud2lkdGggfHwgTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsbWF4V2lkdGgpIC0gKChvcHRpb25zLnBhZ2VzY3JvbGwpPzE3OjApO1xuICAgICAgaCA9IG9wdGlvbnMuaGVpZ2h0IHx8IE1hdGgubWluKHdpbmRvdy5pbm5lckhlaWdodCAtIDUsbWF4SGVpZ2h0KTtcblxuICAgICAgaWYoUS50b3VjaERldmljZSkge1xuICAgICAgICBRLmVsLnN0eWxlLmhlaWdodCA9IChoKjIpICsgXCJweFwiO1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwxKTtcblxuICAgICAgICB3ID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsbWF4V2lkdGgpO1xuICAgICAgICBoID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LG1heEhlaWdodCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKFEudG91Y2hEZXZpY2UpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLDEpO1xuICAgIH1cblxuICAgIGlmKCh1cHNhbXBsZVdpZHRoICYmIHcgPD0gdXBzYW1wbGVXaWR0aCkgfHxcbiAgICAgICAodXBzYW1wbGVIZWlnaHQgJiYgaCA8PSB1cHNhbXBsZUhlaWdodCkpIHtcbiAgICAgIFEuZWwuc3R5bGUuaGVpZ2h0ID0gaCArIFwicHhcIjtcbiAgICAgIFEuZWwuc3R5bGUud2lkdGggPSB3ICsgXCJweFwiO1xuICAgICAgUS5lbC53aWR0aCA9IHcgKiAyO1xuICAgICAgUS5lbC5oZWlnaHQgPSBoICogMjtcbiAgICB9XG4gICAgZWxzZSBpZigoKHJlc2FtcGxlV2lkdGggJiYgdyA+IHJlc2FtcGxlV2lkdGgpIHx8XG4gICAgICAgIChyZXNhbXBsZUhlaWdodCAmJiBoID4gcmVzYW1wbGVIZWlnaHQpKSAmJiBcbiAgICAgICBRLnRvdWNoRGV2aWNlKSB7IFxuICAgICAgUS5lbC5zdHlsZS5oZWlnaHQgPSBoICsgXCJweFwiO1xuICAgICAgUS5lbC5zdHlsZS53aWR0aCA9IHcgKyBcInB4XCI7XG4gICAgICBRLmVsLndpZHRoID0gdyAvIDI7XG4gICAgICBRLmVsLmhlaWdodCA9IGggLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBRLmVsLnN0eWxlLmhlaWdodCA9IGggKyBcInB4XCI7XG4gICAgICBRLmVsLnN0eWxlLndpZHRoID0gdyArIFwicHhcIjtcbiAgICAgIFEuZWwud2lkdGggPSB3O1xuICAgICAgUS5lbC5oZWlnaHQgPSBoO1xuICAgIH1cblxuICAgIHZhciBlbFBhcmVudCA9IFEuZWwucGFyZW50Tm9kZTtcblxuICAgIGlmKGVsUGFyZW50KSB7XG4gICAgICBRLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgUS53cmFwcGVyLmlkID0gUS5lbC5pZCArICdfY29udGFpbmVyJztcbiAgICAgIFEud3JhcHBlci5zdHlsZS53aWR0aCA9IHcgKyBcInB4XCI7XG4gICAgICBRLndyYXBwZXIuc3R5bGUubWFyZ2luID0gXCIwIGF1dG9cIjtcbiAgICAgIFEud3JhcHBlci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblxuXG4gICAgICBlbFBhcmVudC5pbnNlcnRCZWZvcmUoUS53cmFwcGVyLFEuZWwpO1xuICAgICAgUS53cmFwcGVyLmFwcGVuZENoaWxkKFEuZWwpO1xuICAgIH1cbiAgICBcbiAgICBRLmVsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblxuICAgIFEuY3R4ID0gUS5lbC5nZXRDb250ZXh0ICYmIFxuICAgICAgICAgICAgUS5lbC5nZXRDb250ZXh0KFwiMmRcIik7XG5cblxuICAgIFEud2lkdGggPSBwYXJzZUludChRLmVsLndpZHRoLDEwKTtcbiAgICBRLmhlaWdodCA9IHBhcnNlSW50KFEuZWwuaGVpZ2h0LDEwKTtcbiAgICBRLmNzc1dpZHRoID0gdztcbiAgICBRLmNzc0hlaWdodCA9IGg7XG5cbiAgICAvL3NjYWxlIHRvIGZpdFxuICAgIGlmKG9wdGlvbnMuc2NhbGVUb0ZpdCkge1xuICAgICAgdmFyIGZhY3RvciA9IDE7XG5cbiAgICAgIHZhciB3aW5XID0gd2luZG93LmlubmVyV2lkdGgqZmFjdG9yO1xuICAgICAgdmFyIHdpbkggPSB3aW5kb3cuaW5uZXJIZWlnaHQqZmFjdG9yO1xuICAgICAgdmFyIHdpblJhdGlvID0gd2luVy93aW5IOyAgICBcbiAgICAgIHZhciBnYW1lUmF0aW8gPSBRLmVsLndpZHRoL1EuZWwuaGVpZ2h0O1xuICAgICAgdmFyIHNjYWxlUmF0aW8gPSBnYW1lUmF0aW8gPCB3aW5SYXRpbyA/IHdpbkgvUS5lbC5oZWlnaHQgOiB3aW5XL1EuZWwud2lkdGg7XG4gICAgICB2YXIgc2NhbGVkVyA9IFEuZWwud2lkdGggKiBzY2FsZVJhdGlvO1xuICAgICAgdmFyIHNjYWxlZEggPSBRLmVsLmhlaWdodCAqIHNjYWxlUmF0aW87XG5cbiAgICAgIFEuZWwuc3R5bGUud2lkdGggPSBzY2FsZWRXICsgXCJweFwiOyBcbiAgICAgIFEuZWwuc3R5bGUuaGVpZ2h0ID0gc2NhbGVkSCArIFwicHhcIjsgXG5cbiAgICAgIGlmKFEuZWwucGFyZW50Tm9kZSkge1xuICAgICAgICBRLmVsLnBhcmVudE5vZGUuc3R5bGUud2lkdGggPSBzY2FsZWRXICsgXCJweFwiOyBcbiAgICAgICAgUS5lbC5wYXJlbnROb2RlLnN0eWxlLmhlaWdodCA9IHNjYWxlZEggKyBcInB4XCI7IFxuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICBRLmNzc1dpZHRoID0gcGFyc2VJbnQoc2NhbGVkVywxMCk7XG4gICAgICBRLmNzc0hlaWdodCA9IHBhcnNlSW50KHNjYWxlZEgsMTApOyAgICAgXG5cbiAgICAgIC8vY2VudGVyIHZlcnRpY2FsbHkgd2hlbiBhZGp1c3RpbmcgdG8gd2lkdGhcbiAgICAgIGlmKGdhbWVSYXRpbyA+IHdpblJhdGlvKSB7XG4gICAgICAgIHZhciB0b3BQb3MgPSAod2luSCAtIHNjYWxlZEgpLzI7ICAgICAgICAgIFxuICAgICAgICBRLmVsLnN0eWxlLnRvcCA9IHRvcFBvcysncHgnO1xuICAgICAgfVxuICAgIH0gICBcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB3aW5kb3cuc2Nyb2xsVG8oMCwxKTsgfSwgMCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUTtcbiAgfTtcblxuXG4gIC8qKlxuICAgQ2xlYXIgdGhlIGNhbnZhcyBjb21wbGV0ZWx5LlxuXG4gICBJZiB5b3Ugd2FudCBpdCBjbGVhcmVkIHRvIGEgc3BlY2lmaWMgY29sb3IgLSBzZXQgYFEuY2xlYXJDb2xvcmAgdG8gdGhhdCBjb2xvclxuXG4gICBAbWV0aG9kIFEuY2xlYXJcbiAgIEBmb3IgUXVpbnR1c1xuICAqL1xuICBRLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoUS5jbGVhckNvbG9yKSB7XG4gICAgICBRLmN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBRLmN0eC5maWxsU3R5bGUgPSBRLmNsZWFyQ29sb3I7XG4gICAgICBRLmN0eC5maWxsUmVjdCgwLDAsUS53aWR0aCxRLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFEuY3R4LmNsZWFyUmVjdCgwLDAsUS53aWR0aCxRLmhlaWdodCk7XG4gICAgfVxuICB9O1xuICBcbiAgUS5zZXRJbWFnZVNtb290aGluZyA9IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICBRLmN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBlbmFibGVkO1xuICAgIFEuY3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgUS5jdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBlbmFibGVkO1xuICAgIFEuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGVuYWJsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICBSZXR1cm4gY2FudmFzIGltYWdlIGRhdGEgZ2l2ZW4gYW4gSW1hZ2Ugb2JqZWN0LlxuXG4gICBAbWV0aG9kIFEuaW1hZ2VEYXRhXG4gICBAZm9yIFF1aW50dXNcbiAgIEBwYXJhbSB7SW1hZ2V9IGltZyAtIGltYWdlIHRvIGdldCBpbWFnZSBkYXRkYSBmb3JcbiAgKi9cbiAgUS5pbWFnZURhdGEgPSBmdW5jdGlvbihpbWcpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBcbiAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZHJhd0ltYWdlKGltZywwLDApO1xuXG4gICAgcmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoMCwwLGltZy53aWR0aCxpbWcuaGVpZ2h0KTtcbiAgfTtcblxuICBcbiAgLyoqXG4gICBBc3NldCBMb2FkaW5nIFN1cHBvcnRcbiAgXG4gICBUaGUgZW5naW5lIHN1cHBvcnRzIGxvYWRpbmcgYXNzZXRzIG9mIGRpZmZlcmVudCB0eXBlcyB1c2luZ1xuICAgYGxvYWRgIG9yIGBwcmVsb2FkYC4gQXNzZXRzIGFyZSBzdG9yZWQgYnkgdGhlaXIgbmFtZSBzbyB0aGUgXG4gICBzYW1lIGFzc2V0IHdvbid0IGJlIGxvYWRlZCB0d2ljZSBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cblxuICAgQXVnbWVudGFibGUgbGlzdCBvZiBhc3NldCB0eXBlcywgbG9hZHMgYSBzcGVjaWZpYyBhc3NldCBcbiAgIHR5cGUgaWYgdGhlIGZpbGUgdHlwZSBtYXRjaGVzLCBvdGhlcndpc2UgZGVmYXVsdHMgdG8gYSBBamF4XG4gICBsb2FkIG9mIHRoZSBkYXRhLlxuICBcbiAgIFlvdSBjYW4gbmV3IHR5cGVzIG9mIGFzc2V0cyBiYXNlZCBvbiBmaWxlIGV4dGVuc2lvbiBieVxuICAgYWRkaW5nIHRvIGBhc3NldFR5cGVzYCBhbmQgYWRkaW5nIGEgbWV0aG9kIGNhbGxlZFxuICAgbG9hZEFzc2V0VFlQRU5BTUUgd2hlcmUgVFlQRU5BTUUgaXMgdGhlIG5hbWUgb2YgdGhlXG4gICB0eXBlIHlvdSBhZGRlZCBpbi5cblxuICAgRGVmYXVsdCBiaW5kaW5ncyBhcmU6XG5cbiAgICAgKiBwbmcsIGpwZywgZ2lmLCBqcGVnIC0+IEltYWdlXG4gICAgICogb2dnLCB3YXYsIG00YSwgbXAzIC0+IEF1ZGlvXG4gICAgICogRXZlcnl0aGluZyBlbHNlIC0+IERhdGFcbiAgICBcbiAgIFRvIGFkZCBhIG5ldyBmaWxlIGV4dGVuc2lvbiBpbiB0byBhbiBleGlzdGluZyB0eXBlIHlvdSBjYW4ganVzdCBhZGQgaXQgdG8gYXNzZXQgdHlwZXM6XG5cbiAgICAgICBRLmFzc2V0VHlwZXNbJ2JtcCddID0gXCJJbWFnZVwiO1xuXG4gICBUbyBhZGQgaW4gYSBuZXcgbG9hZGVyLCB5b3UnbGwgbmVlZCB0byBkZWZpbmUgYSBtZXRob2QgZm9yIHRoYXQgdHlwZSBhbmQgYWRkIHRvIHRoZSBgUS5hc3NldFR5cGVzYCBvYmplY3QsIGUuZy46XG5cbiAgICAgICBRLmxvYWRBc3NldFZpZGVvID0gZnVuY3Rpb24oa2V5LHNyYyxjYWxsYmFjayxlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZpZCA9IG5ldyBWaWRlbygpO1xuICAgICAgICAgIHZpZC5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIixmdW5jdGlvbigpIHsgIGNhbGxiYWNrKGtleSx2aWQpOyB9KTtcbiAgICAgICAgICB2aWQub25lcnJvciA9IGVycm9yQ2FsbGJhY2s7XG4gICAgICAgICAgdmlkLnNyYyA9IFEuYXNzZXRVcmwoUS5vcHRpb25zLmltYWdlUGF0aCxzcmMpO1xuICAgICAgIH07XG5cbiAgICAgICBRLmFzc2V0VHlwZXNbJ21wNCddID0gJ1ZpZGVvJ1xuXG5cbiAgIEBmb3IgUXVpbnR1c1xuICAgQHByb3BlcnR5IFEuYXNzZXRUeXBlc1xuICAgQHR5cGUgT2JqZWN0XG4gICovXG4gIFEuYXNzZXRUeXBlcyA9IHsgXG4gICAgcG5nOiAnSW1hZ2UnLCBqcGc6ICdJbWFnZScsIGdpZjogJ0ltYWdlJywganBlZzogJ0ltYWdlJyxcbiAgICBvZ2c6ICdBdWRpbycsIHdhdjogJ0F1ZGlvJywgbTRhOiAnQXVkaW8nLCBtcDM6ICdBdWRpbydcbiAgfTtcblxuXG4gIC8qKlxuICAgUmV0dXJuIHRoZSBmaWxlIGV4dGVuc2lvbiBvZiBhIGZpbGVuYW1lXG5cbiAgIEBmb3IgUXVpbnR1c1xuICAgQG1ldGhvZCBRLl9maWxlRXh0ZW5zaW9uXG4gICBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgIEByZXR1cm4ge1N0cmluZ30gbG93ZXJjYXNlZCBleHRlbnNpb25cbiAgKi9cbiAgUS5fZmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgdmFyIGZpbGVQYXJ0cyA9IGZpbGVuYW1lLnNwbGl0KFwiLlwiKSxcbiAgICAgICAgZmlsZUV4dCA9IGZpbGVQYXJ0c1tmaWxlUGFydHMubGVuZ3RoLTFdLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGZpbGVFeHQ7XG4gIH07XG5cbiAgLyoqXG4gICBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgYXNzZXQgYmFzZWQgb24gdGhlIGBRLmFzc2V0VHlwZXNgIGxvb2t1cCB0YWJsZVxuXG4gICBAZm9yIFF1aW50dXNcbiAgIEBtZXRob2QgUS5hc3NldFR5cGVcbiAgIEBwYXJhbSB7U3RyaW5nfSBhc3NldFxuICAqL1xuICBRLmFzc2V0VHlwZSA9IGZ1bmN0aW9uKGFzc2V0KSB7XG4gICAgLyogRGV0ZXJtaW5lIHRoZSBsb3dlcmNhc2UgZXh0ZW5zaW9uIG9mIHRoZSBmaWxlICovXG4gICAgdmFyIGZpbGVFeHQgPSBRLl9maWxlRXh0ZW5zaW9uKGFzc2V0KTtcblxuICAgIC8vIFVzZSB0aGUgd2ViIGF1ZGlvIGxvYWRlciBpbnN0ZWFkIG9mIHRoZSByZWd1bGFyIGxvYWRlclxuICAgIC8vIGlmIGl0J3Mgc3VwcG9ydGVkLlxuICAgIHZhciBmaWxlVHlwZSA9ICBRLmFzc2V0VHlwZXNbZmlsZUV4dF07XG4gICAgaWYoZmlsZVR5cGUgPT09ICdBdWRpbycgJiYgUS5hdWRpbyAmJiBRLmF1ZGlvLnR5cGUgPT09IFwiV2ViQXVkaW9cIikge1xuICAgICAgZmlsZVR5cGUgPSAnV2ViQXVkaW8nO1xuICAgIH1cblxuICAgIC8qIExvb2t1cCB0aGUgYXNzZXQgaW4gdGhlIGFzc2V0VHlwZXMgaGFzaCwgb3IgcmV0dXJuIG90aGVyICovXG4gICAgcmV0dXJuIGZpbGVUeXBlIHx8ICdPdGhlcic7XG4gIH07XG5cbiAgLyoqXG4gICBFaXRoZXIgcmV0dXJuIGFuIGFic29sdXRlIFVSTCwgb3IgYWRkIGEgYmFzZSB0byBhIHJlbGF0aXZlIFVSTFxuXG4gICBAZm9yIFF1aW50dXNcbiAgIEBtZXRob2QgUS5hc3NldFVybFxuICAgQHBhcmFtIHtTdHJpbmd9IGJhc2UgLSBiYXNlIGZvciByZWxhdGl2ZSBwYXRoc1xuICAgQHBhcmFtIHtTdHJpbmd9IHVybCAtIHVybCB0byByZXNvbHZlIHRvIGFzc2V0IHVybFxuICAgQHJldHVybiB7U3RyaW5nfSByZXNvbHZlZCB1cmxcbiAgKi9cbiAgUS5hc3NldFVybCA9IGZ1bmN0aW9uKGJhc2UsdXJsKSB7XG4gICAgdmFyIHRpbWVzdGFtcCA9IFwiXCI7XG4gICAgaWYoUS5vcHRpb25zLmRldmVsb3BtZW50KSB7XG4gICAgICB0aW1lc3RhbXAgPSAoL1xcPy8udGVzdCh1cmwpID8gXCImXCIgOiBcIj9cIikgKyBcIl90PVwiICtuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG4gICAgaWYoL15odHRwcz86XFwvXFwvLy50ZXN0KHVybCkgfHwgdXJsWzBdID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHVybCArIHRpbWVzdGFtcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJhc2UgKyB1cmwgKyB0aW1lc3RhbXA7XG4gICAgfVxuICB9O1xuXG4gIC8qKiBcbiAgTG9hZGVyIGZvciBJbWFnZXMsIGNyZWF0ZXMgYSBuZXcgYEltYWdlYCBvYmplY3QgYW5kIHVzZXMgdGhlIFxuICBsb2FkIGNhbGxiYWNrIHRvIGRldGVybWluZSB0aGUgaW1hZ2UgaGFzIGJlZW4gbG9hZGVkXG5cbiAgQGZvciBRdWludHVzXG4gIEBtZXRob2QgUS5sb2FkQXNzZXRJbWFnZVxuICBAcGFyYW0ge1N0cmluZ30ga2V5XG4gIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3JDYWxsYmFja1xuICAqL1xuICBRLmxvYWRBc3NldEltYWdlID0gZnVuY3Rpb24oa2V5LHNyYyxjYWxsYmFjayxlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHsgIGNhbGxiYWNrKGtleSxpbWcpOyB9O1xuICAgIGltZy5vbmVycm9yID0gZXJyb3JDYWxsYmFjaztcbiAgICBpbWcuc3JjID0gUS5hc3NldFVybChRLm9wdGlvbnMuaW1hZ2VQYXRoLHNyYyk7XG4gIH07XG5cblxuICAvLyBMaXN0IG9mIG1pbWUgdHlwZXMgZ2l2ZW4gYW4gYXVkaW8gZmlsZSBleHRlbnNpb24sIHVzZWQgdG8gXG4gIC8vIGRldGVybWluZSB3aGF0IHNvdW5kIHR5cGVzIHRoZSBicm93c2VyIGNhbiBwbGF5IHVzaW5nIHRoZSBcbiAgLy8gYnVpbHQtaW4gYFNvdW5kLmNhblBsYXlUeXBlYFxuICBRLmF1ZGlvTWltZVR5cGVzID0geyBtcDM6ICdhdWRpby9tcGVnJywgXG4gICAgICAgICAgICAgICAgICAgICAgIG9nZzogJ2F1ZGlvL29nZzsgY29kZWNzPVwidm9yYmlzXCInLFxuICAgICAgICAgICAgICAgICAgICAgICBtNGE6ICdhdWRpby9tNGEnLFxuICAgICAgICAgICAgICAgICAgICAgICB3YXY6ICdhdWRpby93YXYnIH07XG5cblxuICBRLl9hdWRpb0Fzc2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoUS5fYXVkaW9Bc3NldFByZWZlcnJlZEV4dGVuc2lvbikgeyByZXR1cm4gUS5fYXVkaW9Bc3NldFByZWZlcnJlZEV4dGVuc2lvbjsgfVxuXG4gICAgdmFyIHNuZCA9IG5ldyBBdWRpbygpO1xuXG4gICAgLyogRmluZCBhIHN1cHBvcnRlZCB0eXBlICovXG4gICAgcmV0dXJuIFEuX2F1ZGlvQXNzZXRQcmVmZXJyZWRFeHRlbnNpb24gPSBcbiAgICAgIFEuX2RldGVjdChRLm9wdGlvbnMuYXVkaW9TdXBwb3J0ZWQsXG4gICAgICAgICBmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICAgICAgIHJldHVybiBzbmQuY2FuUGxheVR5cGUoUS5hdWRpb01pbWVUeXBlc1tleHRlbnNpb25dKSA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gOiBudWxsO1xuICAgICAgfSk7XG4gIH07XG5cblxuICAvKiogXG4gICBMb2FkZXIgZm9yIEF1ZGlvIGFzc2V0cy4gQnkgZGVmYXVsdCBjaG9wcyBvZmYgdGhlIGV4dGVuc2lvbiBhbmQgXG4gICB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIHdoaWNoIG9mIHRoZSBzdXBwb3J0ZWQgdHlwZXMgaXMgXG4gICBwbGF5YWJsZSBieSB0aGUgYnJvd3NlciBhbmQgbG9hZCB0aGF0IHR5cGUuXG4gIFxuICAgV2hpY2ggdHlwZXMgYXJlIGF2YWlsYWJsZSBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlsZSBleHRlbnNpb25zXG4gICBsaXN0ZWQgaW4gdGhlIFF1aW50dXMgYG9wdGlvbnMuYXVkaW9TdXBwb3J0ZWRgXG5cblxuICBAZm9yIFF1aW50dXNcbiAgQG1ldGhvZCBRLmxvYWRBc3NldEF1ZGlvXG4gIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgQHBhcmFtIHtTdHJpbmd9IHNyY1xuICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrXG4gICovXG4gIFEubG9hZEFzc2V0QXVkaW8gPSBmdW5jdGlvbihrZXksc3JjLGNhbGxiYWNrLGVycm9yQ2FsbGJhY2spIHtcbiAgICBpZighZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpLnBsYXkgfHwgIVEub3B0aW9ucy5zb3VuZCkge1xuICAgICAgY2FsbGJhY2soa2V5LG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiYXNlTmFtZSA9IFEuX3JlbW92ZUV4dGVuc2lvbihzcmMpLFxuICAgICAgICBleHRlbnNpb24gPSBRLl9hdWRpb0Fzc2V0RXh0ZW5zaW9uKCksXG4gICAgICAgIGZpbGVuYW1lID0gbnVsbCxcbiAgICAgICAgc25kID0gbmV3IEF1ZGlvKCk7XG5cbiAgICAvKiBObyBzdXBwb3J0ZWQgYXVkaW8gPSB0cmlnZ2VyIG9rIGNhbGxiYWNrIGFueXdheSAqL1xuICAgIGlmKCFleHRlbnNpb24pIHtcbiAgICAgIGNhbGxiYWNrKGtleSxudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzbmQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZXJyb3JDYWxsYmFjayk7XG5cbiAgICAvLyBEb24ndCB3YWl0IGZvciBjYW5wbGF5dGhyb3VnaCBvbiBtb2JpbGVcbiAgICBpZighUS50b3VjaERldmljZSkgeyBcbiAgICAgIHNuZC5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsZnVuY3Rpb24oKSB7IFxuICAgICAgICBjYWxsYmFjayhrZXksc25kKTsgXG4gICAgICB9KTtcbiAgICB9XG4gICAgc25kLnNyYyA9ICBRLmFzc2V0VXJsKFEub3B0aW9ucy5hdWRpb1BhdGgsYmFzZU5hbWUgKyBcIi5cIiArIGV4dGVuc2lvbik7XG4gICAgc25kLmxvYWQoKTtcblxuICAgIGlmKFEudG91Y2hEZXZpY2UpIHtcbiAgICAgIGNhbGxiYWNrKGtleSxzbmQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgIEFzc2V0IGxvYWRlciBmb3IgQXVkaW8gZmlsZXMgaWYgdXNpbmcgdGhlIFdlYkF1ZGlvIEFQSSBlbmdpbmVcblxuICBAZm9yIFF1aW50dXNcbiAgQG1ldGhvZCBRLmxvYWRBc3NldFdlYkF1ZGlvXG4gIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgQHBhcmFtIHtTdHJpbmd9IHNyY1xuICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrXG4gICovXG4gIFEubG9hZEFzc2V0V2ViQXVkaW8gPSBmdW5jdGlvbihrZXksc3JjLGNhbGxiYWNrLGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBiYXNlTmFtZSA9IFEuX3JlbW92ZUV4dGVuc2lvbihzcmMpLFxuICAgICAgICBleHRlbnNpb24gPSBRLl9hdWRpb0Fzc2V0RXh0ZW5zaW9uKCk7XG5cbiAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgUS5hc3NldFVybChRLm9wdGlvbnMuYXVkaW9QYXRoLGJhc2VOYW1lICsgXCIuXCIgKyBleHRlbnNpb24pLCB0cnVlKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcblxuICAgIC8vIE91ciBhc3luY2hyb25vdXMgY2FsbGJhY2tcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF1ZGlvRGF0YSA9IHJlcXVlc3QucmVzcG9uc2U7XG5cbiAgICAgIFEuYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShyZXF1ZXN0LnJlc3BvbnNlLCBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgY2FsbGJhY2soa2V5LGJ1ZmZlcik7XG4gICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZCgpO1xuXG4gIH07XG5cbiAgLyoqXG4gICBMb2FkZXIgZm9yIG90aGVyIGZpbGUgdHlwZXMsIGp1c3Qgc3RvcmVzIHRoZSBkYXRhIHJldHVybmVkIGZyb20gYW4gQWpheCBjYWxsLlxuXG4gICBKdXN0IG1ha2VzIGEgQWpheCByZXF1ZXN0IGZvciBhbGwgb3RoZXIgZmlsZSB0eXBlc1xuXG4gIEBmb3IgUXVpbnR1c1xuICBAbWV0aG9kIFEubG9hZEFzc2V0T3RoZXJcbiAgQHBhcmFtIHtTdHJpbmd9IGtleVxuICBAcGFyYW0ge1N0cmluZ30gc3JjXG4gIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yQ2FsbGJhY2tcbiAgKi9cbiAgUS5sb2FkQXNzZXRPdGhlciA9IGZ1bmN0aW9uKGtleSxzcmMsY2FsbGJhY2ssZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICB2YXIgZmlsZVBhcnRzID0gc3JjLnNwbGl0KFwiLlwiKSxcbiAgICAgICAgZmlsZUV4dCA9IGZpbGVQYXJ0c1tmaWxlUGFydHMubGVuZ3RoLTFdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIGlmKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICBpZihmaWxlRXh0ID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGtleSxKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGtleSxyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgUS5hc3NldFVybChRLm9wdGlvbnMuZGF0YVBhdGgsc3JjKSwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5zZW5kKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgSGVscGVyIG1ldGhvZCB0byByZXR1cm4gYSBuYW1lIHdpdGhvdXQgYW4gZXh0ZW5zaW9uXG5cbiAgIEBmb3IgUXVpbnR1c1xuICAgQG1ldGhvZCBfcmVtb3ZlRXh0ZW5zaW9uXG4gICBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgIEByZXR1cm4ge1N0cmluZ30gZmlsZW5hbWUgd2l0aG91dCBhbiBleHRlbnNpb25cbiAgKi9cbiAgUS5fcmVtb3ZlRXh0ZW5zaW9uID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gZmlsZW5hbWUucmVwbGFjZSgvXFwuKFxcd3szLDR9KSQvLFwiXCIpO1xuICB9O1xuXG4gIC8vIEFzc2V0IGhhc2ggc3RvcmluZyBhbnkgbG9hZGVkIGFzc2V0c1xuICBRLmFzc2V0cyA9IHt9O1xuXG4gIC8qKlxuICAgR2V0dGVyIG1ldGhvZCB0byByZXR1cm4gYW4gYXNzZXQgYnkgaXRzIG5hbWUuXG4gIFxuICAgQXNzZXQgbmFtZXMgZGVmYXVsdCB0byB0aGVpciBmaWxlbmFtZXMsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlblxuICAgYnkgcGFzc2luZyBhIGhhc2ggdG8gYGxvYWRgIHRvIHNldCBkaWZmZXJlbnQgbmFtZXMuXG5cbiAgIEBmb3IgUXVpbnR1c1xuICAgQG1ldGhvZCBhc3NldFxuICAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIG9mIGFzc2V0IHRvIGxvb2t1cFxuICAqL1xuICBRLmFzc2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBRLmFzc2V0c1tuYW1lXTtcbiAgfTtcblxuICAvKipcbiAgIExvYWQgYXNzZXRzLCBhbmQgY2FsbCBvdXIgY2FsbGJhY2sgd2hlbiBkb25lLlxuICBcbiAgIEFsc28gb3B0aW9uYWxseSB0YWtlcyBhIGBwcm9ncmVzc0NhbGxiYWNrYCB3aGljaCB3aWxsIGJlIGNhbGxlZCBcbiAgIHdpdGggdGhlIG51bWJlciBvZiBhc3NldHMgbG9hZGVkIGFuZCB0aGUgdG90YWwgbnVtYmVyIG9mIGFzc2V0c1xuICAgdG8gYWxsb3cgc2hvd2luZyBvZiBhIHByb2dyZXNzLiBcbiAgXG4gICBBc3NldHMgY2FuIGJlIHBhc3NlZCBpbiBhcyBhbiBhcnJheSBvZiBmaWxlIG5hbWVzLCBhbmQgUXVpbnR1c1xuICAgd2lsbCB1c2UgdGhlIGZpbGUgbmFtZXMgYXMgdGhlIG5hbWUgZm9yIHJlZmVyZW5jZSwgb3IgYXMgYSBoYXNoIG9mIFxuICAgYHsgbmFtZTogZmlsZW5hbWUgfWAuIFxuICBcbiAgIEV4YW1wbGUgdXNhZ2U6XG4gICAgICAgUS5sb2FkKFsnc3ByaXRlcy5wbmcnLCdzcHJpdGVzLixqc29uJ10sZnVuY3Rpb24oKSB7XG4gICAgICAgICAgUS5zdGFnZVNjZW5lKFwibGV2ZWwxXCIpOyAvLyBvciBzb21ldGhpbmcgdG8gc3RhcnQgdGhlIGdhbWUuXG4gICAgICAgfSk7XG5cbiAgQGZvciBRdWludHVzXG4gIEBtZXRob2QgUS5sb2FkXG4gIEBwYXJhbSB7U3RyaW5nLCBBcnJheSBvciBBcnJheX0gYXNzZXRzIC0gY29tbWEgc2VwYXJhdGVkIHN0cmluZywgYXJyYXkgb3IgT2JqZWN0IGhhc2ggb2YgYXNzZXRzIHRvIGxvYWRcbiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBjYWxsZWQgd2hlbiBkb25lIGxvYWRpbmdcbiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgKi9cbiAgUS5sb2FkID0gZnVuY3Rpb24oYXNzZXRzLGNhbGxiYWNrLG9wdGlvbnMpIHtcbiAgICB2YXIgYXNzZXRPYmogPSB7fTtcblxuICAgIC8qIE1ha2Ugc3VyZSB3ZSBoYXZlIGFuIG9wdGlvbnMgaGFzaCB0byB3b3JrIHdpdGggKi9cbiAgICBpZighb3B0aW9ucykgeyBvcHRpb25zID0ge307IH1cblxuICAgIC8qIEdldCBvdXIgcHJvZ3Jlc3NDYWxsYmFjayBpZiB3ZSBoYXZlIG9uZSAqL1xuICAgIHZhciBwcm9ncmVzc0NhbGxiYWNrID0gb3B0aW9ucy5wcm9ncmVzc0NhbGxiYWNrO1xuXG4gICAgdmFyIGVycm9ycyA9IGZhbHNlLFxuICAgICAgICBlcnJvckNhbGxiYWNrID0gZnVuY3Rpb24oaXRtKSB7XG4gICAgICAgICAgZXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAob3B0aW9ucy5lcnJvckNhbGxiYWNrICB8fFxuICAgICAgICAgICBmdW5jdGlvbihpdG0pIHsgdGhyb3coXCJFcnJvciBMb2FkaW5nOiBcIiArIGl0bSApOyB9KShpdG0pO1xuICAgICAgICB9O1xuXG4gICAgLyogQ29udmVydCB0byBhbiBhcnJheSBpZiBpdCdzIGEgc3RyaW5nICovXG4gICAgaWYoUS5faXNTdHJpbmcoYXNzZXRzKSkge1xuICAgICAgYXNzZXRzID0gUS5fbm9ybWFsaXplQXJnKGFzc2V0cyk7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlIHVzZXIgcGFzc2VkIGluIGFuIGFycmF5LCBjb252ZXJ0IGl0ICovXG4gICAgLyogdG8gYSBoYXNoIHdpdGggbG9va3VwcyBieSBmaWxlbmFtZSAqL1xuICAgIGlmKFEuX2lzQXJyYXkoYXNzZXRzKSkgeyBcbiAgICAgIFEuX2VhY2goYXNzZXRzLGZ1bmN0aW9uKGl0bSkge1xuICAgICAgICBpZihRLl9pc09iamVjdChpdG0pKSB7XG4gICAgICAgICAgUS5fZXh0ZW5kKGFzc2V0T2JqLGl0bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXRPYmpbaXRtXSA9IGl0bTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE90aGVyd2lzZSBqdXN0IHVzZSB0aGUgYXNzZXRzIGFzIGlzICovXG4gICAgICBhc3NldE9iaiA9IGFzc2V0cztcbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSAjIG9mIGFzc2V0cyB3ZSdyZSBsb2FkaW5nICovXG4gICAgdmFyIGFzc2V0c1RvdGFsID0gUS5fa2V5cyhhc3NldE9iaikubGVuZ3RoLFxuICAgICAgICBhc3NldHNSZW1haW5pbmcgPSBhc3NldHNUb3RhbDtcblxuICAgIC8qIENsb3N1cmUnZCBwZXItYXNzZXQgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgKi9cbiAgICAvKiBlYWNoIHRpbWUgYW4gYXNzZXQgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRkZWQgKi9cbiAgICB2YXIgbG9hZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbihrZXksb2JqLGZvcmNlKSB7XG4gICAgICBpZihlcnJvcnMpIHsgcmV0dXJuOyB9XG5cbiAgICAgIC8vIFByZXZlbnQgZG91YmxlIGNhbGxiYWNrcyAoSSdtIGxvb2tpbmcgYXQgeW91IEZpcmVmb3gsIGNhbnBsYXl0aHJvdWdoXG4gICAgICBpZighUS5hc3NldHNba2V5XXx8Zm9yY2UpIHtcblxuICAgICAgICAvKiBBZGQgdGhlIG9iamVjdCB0byBvdXIgYXNzZXQgbGlzdCAqL1xuICAgICAgICBRLmFzc2V0c1trZXldID0gb2JqO1xuXG4gICAgICAgIC8qIFdlJ3ZlIGdvdCBvbmUgbGVzcyBhc3NldCB0byBsb2FkICovXG4gICAgICAgIGFzc2V0c1JlbWFpbmluZy0tO1xuXG4gICAgICAgIC8qIFVwZGF0ZSBvdXIgcHJvZ3Jlc3MgaWYgd2UgaGF2ZSBpdCAqL1xuICAgICAgICBpZihwcm9ncmVzc0NhbGxiYWNrKSB7IFxuICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGFzc2V0c1RvdGFsIC0gYXNzZXRzUmVtYWluaW5nLGFzc2V0c1RvdGFsKTsgXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogSWYgd2UncmUgb3V0IG9mIGFzc2V0cywgY2FsbCBvdXIgZnVsbCBjYWxsYmFjayAqL1xuICAgICAgLyogaWYgdGhlcmUgaXMgb25lICovXG4gICAgICBpZihhc3NldHNSZW1haW5pbmcgPT09IDAgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgLyogaWYgd2UgaGF2ZW4ndCBzZXQgdXAgb3VyIGNhbnZhcyBlbGVtZW50IHlldCwgKi9cbiAgICAgICAgLyogYXNzdW1lIHdlJ3JlIHVzaW5nIGEgY2FudmFzIHdpdGggaWQgJ3F1aW50dXMnICovXG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KFEpOyBcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogTm93IGFjdHVhbGx5IGxvYWQgZWFjaCBhc3NldCAqL1xuICAgIFEuX2VhY2goYXNzZXRPYmosZnVuY3Rpb24oaXRtLGtleSkge1xuXG4gICAgICAvKiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIGFzc2V0ICovXG4gICAgICB2YXIgYXNzZXRUeXBlID0gUS5hc3NldFR5cGUoaXRtKTtcblxuICAgICAgLyogSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBhc3NldCBsb2FkZWQsICovXG4gICAgICAvKiBkb24ndCBsb2FkIGl0IGFnYWluICovXG4gICAgICBpZihRLmFzc2V0c1trZXldKSB7XG4gICAgICAgIGxvYWRlZENhbGxiYWNrKGtleSxRLmFzc2V0c1trZXldLHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogQ2FsbCB0aGUgYXBwcm9wcmlhdGUgbG9hZGVyIGZ1bmN0aW9uICovXG4gICAgICAgIC8qIHBhc3NpbmcgaW4gb3VyIHBlci1hc3NldCBjYWxsYmFjayAqL1xuICAgICAgICAvKiBEcm9wcGluZyBvdXIgYXNzZXQgYnkgbmFtZSBpbnRvIFEuYXNzZXRzICovXG4gICAgICAgIFFbXCJsb2FkQXNzZXRcIiArIGFzc2V0VHlwZV0oa2V5LGl0bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBlcnJvckNhbGxiYWNrKGl0bSk7IH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH07XG5cbiAgLy8gQXJyYXkgdG8gc3RvcmUgYW55IGFzc2V0cyB0aGF0IG5lZWQgdG8gYmUgXG4gIC8vIHByZWxvYWRlZFxuICBRLnByZWxvYWRzID0gW107XG4gIFxuICAvKipcbiAgIExldCB1cyBnYXRoZXIgYXNzZXRzIHRvIGxvYWQgYXQgYSBsYXRlciB0aW1lLFxuICAgYW5kIHRoZW4gcHJlbG9hZCB0aGVtIGFsbCBhdCB0aGUgc2FtZSB0aW1lIHdpdGhcbiAgIGEgc2luZ2xlIGNhbGxiYWNrLiBPcHRpb25zIGFyZSBwYXNzZWQgdGhyb3VnaCB0byB0aGVcbiAgIFEubG9hZCBtZXRob2QgaWYgdXNlZC5cbiAgXG4gICBFeGFtcGxlIHVzYWdlOlxuICAgICAgICBRLnByZWxvYWQoXCJzcHJpdGVzLnBuZ1wiKTtcbiAgICAgICAgLi4uXG4gICAgICAgIFEucHJlbG9hZChcInNwcml0ZXMuanNvblwiKTtcbiAgICAgICAgLi4uXG4gIFxuICAgICAgICBRLnByZWxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIFEuc3RhZ2VTY2VuZShcImxldmVsMVwiKTsgLy8gb3Igc29tZXRoaW5nIHRvIHN0YXJ0IHRoZSBnYW1lXG4gICAgICAgIH0pO1xuICBAZm9yIFF1aW50dXNcbiAgQG1ldGhvZCBRLnByZWxvYWRcbiAgQHBhcmFtIHtTdHJpbmcgb3IgRnVuY3Rpb259IGFyZyAtIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb2YgYXNzZXRzIHRvIGxvYWQsIG9yIGNhbGxiYWNrXG4gIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIHRvIHBhc3MgdG8gbG9hZFxuICAqL1xuICBRLnByZWxvYWQgPSBmdW5jdGlvbihhcmcsb3B0aW9ucykge1xuICAgIGlmKFEuX2lzRnVuY3Rpb24oYXJnKSkge1xuICAgICAgUS5sb2FkKFEuX3VuaXEoUS5wcmVsb2FkcyksYXJnLG9wdGlvbnMpO1xuICAgICAgUS5wcmVsb2FkcyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBRLnByZWxvYWRzID0gUS5wcmVsb2Fkcy5jb25jYXQoYXJnKTtcbiAgICB9XG4gIH07XG5cblxuICAvLyBNYXRoIE1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT1cbiAgLy9cbiAgLy8gTWF0aCBtZXRob2RzLCBmb3Igcm90YXRpbmcgYW5kIHNjYWxpbmcgcG9pbnRzXG5cbiAgLy8gQSBsaXN0IG9mIG1hdHJpY2VzIGF2YWlsYWJsZVxuICBRLm1hdHJpY2VzMmQgPSBbXTtcblxuICBRLm1hdHJpeDJkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFEubWF0cmljZXMyZC5sZW5ndGggPiAwID8gUS5tYXRyaWNlczJkLnBvcCgpLmlkZW50aXR5KCkgOiBuZXcgUS5NYXRyaXgyRCgpO1xuICB9O1xuXG4gIC8qKlxuICAgQSAyRCBtYXRyaXggY2xhc3MsIG9wdGltaXplZCBmb3IgMkQgcG9pbnRzLFxuICAgd2hlcmUgdGhlIGxhc3Qgcm93IG9mIHRoZSBtYXRyaXggd2lsbCBhbHdheXMgYmUgMCwwLDEgXG5cbiAgIERvIG5vdCBjYWxsIGBuZXcgUS5NYXRyaXgyRGAgLSB1c2UgdGhlIHByb3ZpZGVkIFEubWF0cml4MkQgZmFjdG9yeSBmdW5jdGlvbiBmb3IgR0MgaGFwcGluZXNzXG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IFEubWF0cml4MmQoKTtcblxuICAgR29vZCBEb2NzIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9oZXlncmFkeS90cmFuc2Zvcm0vd2lraS9jYWxjdWxhdGluZy0yZC1tYXRyaWNlc1xuXG4gICBVc2VkIGludGVybmFsbHkgYnkgUXVpbnR1cyBmb3IgYWxsIHRyYW5zZm9ybXMgLyBjb2xsaXNpb24gZGV0ZWN0aW9uLiBNb3N0IG9mIHRoZSBtZXRob2RzIG1vZGlmeSB0aGUgbWF0cml4IHRoZXkgYXJlIGNhbGxlZCB1cG9uIGFuZCBhcmUgY2hhaW5hYmxlLlxuXG4gICBAY2xhc3MgUS5NYXRyaXgyRFxuICAgQGZvciBRdWludHVzXG4gICBAZXh0ZW5kcyBRLkNsYXNzXG4gICovXG4gIFEuTWF0cml4MkQgPSBRLkNsYXNzLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgIEluaXRpYWxpemUgYSBtYXRyaXggZnJvbSBhIHNvdXJjZSBvciB3aXRoIHRoZSBpZGVudGlmeSBtYXRyaXhcblxuICAgICBAY29uc3RydWN0b3JcbiAgICAgQGZvciBRLk1hdHJpeDJEXG4gICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGlmKHNvdXJjZSkge1xuICAgICAgICB0aGlzLm0gPSBbXTtcbiAgICAgICAgdGhpcy5jbG9uZShzb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tID0gWzEsMCwwLDAsMSwwXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFR1cm4gdGhpcyBtYXRyaXggaW50byB0aGUgaWRlbnRpdHlcblxuICAgICBAZm9yIFEuTWF0cml4MkRcbiAgICAgQG1ldGhvZCBpZGVudGl0eVxuICAgICBAY2hhaW5hYmxlXG4gICAgKi9cbiAgICBpZGVudGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbSA9IHRoaXMubTtcbiAgICAgIG1bMF0gPSAxOyBtWzFdID0gMDsgbVsyXSA9IDA7XG4gICAgICBtWzNdID0gMDsgbVs0XSA9IDE7IG1bNV0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKiBcblxuICAgICBDbG9uZSBhbm90aGVyIG1hdHJpeCBpbnRvIHRoaXMgb25lXG5cbiAgICAgQGZvciBRLk1hdHJpeDJEXG4gICAgIEBtZXRob2QgY2xvbmVcbiAgICAgQHBhcmFtIHtRLk1hdHJpeDJEfSBtYXRyaXggLSBtYXRyaXggdG8gY2xvbmVcbiAgICAgQGNoYWluYWJsZVxuICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgdmFyIGQgPSB0aGlzLm0sIHMgPSBtYXRyaXgubTtcbiAgICAgIGRbMF09c1swXTsgZFsxXT1zWzFdOyBkWzJdID0gc1syXTtcbiAgICAgIGRbM109c1szXTsgZFs0XT1zWzRdOyBkWzVdID0gc1s1XTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgbXVsdGlwbHkgdHdvIG1hdHJpY2VzIChsZWF2aW5nIHRoZSByZXN1bHQgaW4gdGhpcylcblxuICAgICAgICBhICogYiA9IFxuICAgICAgICAgICBbIFsgYTExKmIxMSArIGExMipiMjEgXSwgWyBhMTEqYjEyICsgYTEyKmIyMiBdLCBbIGExMSpiMzEgKyBhMTIqYjMyICsgYTEzIF0gLFxuICAgICAgICAgICBbIGEyMSpiMTEgKyBhMjIqYjIxIF0sIFsgYTIxKmIxMiArIGEyMipiMjIgXSwgWyBhMjEqYjMxICsgYTIyKmIzMiArIGEyMyBdIF1cblxuICAgICBAZm9yIFEuTWF0cml4MkRcbiAgICAgQG1ldGhvZCBjbG9uZVxuICAgICBAcGFyYW0ge1EuTWF0cml4MkR9IG1hdHJpeCAtIG1hdHJpeCB0byBtdWx0aXBseSBieVxuICAgICBAY2hhaW5hYmxlXG4gICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgIHZhciBhID0gdGhpcy5tLCBiID0gbWF0cml4Lm07XG5cbiAgICAgIHZhciBtMTEgPSBhWzBdKmJbMF0gKyBhWzFdKmJbM107XG4gICAgICB2YXIgbTEyID0gYVswXSpiWzFdICsgYVsxXSpiWzRdO1xuICAgICAgdmFyIG0xMyA9IGFbMF0qYlsyXSArIGFbMV0qYls1XSArIGFbMl07XG5cbiAgICAgIHZhciBtMjEgPSBhWzNdKmJbMF0gKyBhWzRdKmJbM107XG4gICAgICB2YXIgbTIyID0gYVszXSpiWzFdICsgYVs0XSpiWzRdO1xuICAgICAgdmFyIG0yMyA9IGFbM10qYlsyXSArIGFbNF0qYls1XSArIGFbNV07XG5cbiAgICAgIGFbMF09bTExOyBhWzFdPW0xMjsgYVsyXSA9IG0xMztcbiAgICAgIGFbM109bTIxOyBhWzRdPW0yMjsgYVs1XSA9IG0yMztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKiogXG4gICAgIFxuICAgICBNdWx0aXBseSB0aGlzIG1hdHJpeCBieSBhIHJvdGF0aW9uIG1hdHJpeCByb3RhdGVkIHJhZGlhbnMgcmFkaWFucyBcblxuICAgIEBmb3IgUS5NYXRyaXgyRFxuICAgIEBtZXRob2Qgcm90YXRlXG4gICAgQHBhcmFtIHtGbG9hdH0gcmFkaWFucyAtIGFuZ2xlIHRvIHJvdGF0ZSBieVxuICAgIEBjaGFpbmFibGVcbiAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24ocmFkaWFucykge1xuICAgICAgaWYocmFkaWFucyA9PT0gMCkgeyByZXR1cm4gdGhpczsgfVxuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJhZGlhbnMpLFxuICAgICAgICAgIHNpbiA9IE1hdGguc2luKHJhZGlhbnMpLFxuICAgICAgICAgIG0gPSB0aGlzLm07XG5cbiAgICAgIHZhciBtMTEgPSBtWzBdKmNvcyAgKyBtWzFdKnNpbjtcbiAgICAgIHZhciBtMTIgPSBtWzBdKi1zaW4gKyBtWzFdKmNvcztcblxuICAgICAgdmFyIG0yMSA9IG1bM10qY29zICArIG1bNF0qc2luO1xuICAgICAgdmFyIG0yMiA9IG1bM10qLXNpbiArIG1bNF0qY29zO1xuXG4gICAgICBtWzBdID0gbTExOyBtWzFdID0gbTEyOyAvLyBtWzJdID09IG1bMl1cbiAgICAgIG1bM10gPSBtMjE7IG1bNF0gPSBtMjI7IC8vIG1bNV0gPT0gbVs1XVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuXG4gICAgIEhlbHBlciBtZXRob2QgdG8gcm90YXRlIGJ5IGEgc2V0IG51bWJlciBvZiBkZWdyZWVzIChjYWxscyByb3RhdGUgaW50ZXJuYWxseSlcblxuICAgICBAZm9yIFEuTWF0cml4MkRcbiAgICAgQG1ldGhvZCByb3RhdGVEZWdcbiAgICAgQHBhcmFtIHtGbG9hdH0gZGVncmVlc1xuICAgICBAY2hhaW5hYmxlXG4gICAgKi9cbiAgICByb3RhdGVEZWc6IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICAgIGlmKGRlZ3JlZXMgPT09IDApIHsgcmV0dXJuIHRoaXM7IH1cbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZShNYXRoLlBJICogZGVncmVlcyAvIDE4MCk7XG4gICAgfSxcblxuICAgIC8qKlxuXG4gICAgIE11bHRpcGx5IHRoaXMgbWF0cml4IGJ5IGEgc2NhbGluZyBtYXRyaXggc2NhbGluZyBzeCBhbmQgc3lcbiAgICAgQGZvciBRLk1hdHJpeDJEXG4gICAgIEBtZXRob2Qgc2NhbGVcbiAgICAgQHBhcmFtIHtGbG9hdH0gc3ggLSBzY2FsZSBpbiB4IGRpbWVuc2lvbiAoc2NhbGluZyBpcyB1bmlmb3JtIHVubGVzcyBgc3lgIGlzIHByb3ZpZGVkKVxuICAgICBAcGFyYW0ge0Zsb2F0fSBbc3ldIC0gc2NhbGUgaW4gdGhlIHkgZGltZW5zaW9uXG4gICAgIEBjaGFpbmFibGVcbiAgICAqL1xuICAgIHNjYWxlOiBmdW5jdGlvbihzeCxzeSkge1xuICAgICAgdmFyIG0gPSB0aGlzLm07XG4gICAgICBpZihzeSA9PT0gdm9pZCAwKSB7IHN5ID0gc3g7IH1cblxuICAgICAgbVswXSAqPSBzeDtcbiAgICAgIG1bMV0gKj0gc3k7XG4gICAgICBtWzNdICo9IHN4O1xuICAgICAgbVs0XSAqPSBzeTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKiBcbiAgICAgTXVsdGlwbHkgdGhpcyBtYXRyaXggYnkgYSB0cmFuc2xhdGlvbiBtYXRyaXggdHJhbnNsYXRlIGJ5IHR4IGFuZCB0eVxuXG4gICAgIEBmb3IgUS5NYXRyaXgyRFxuICAgICBAbWV0aG9kIHRyYW5zbGF0ZVxuICAgICBAcGFyYW0ge0Zsb2F0fSB0eFxuICAgICBAcGFyYW0ge0Zsb2F0fSB0eVxuICAgICBAY2hhaW5hYmxlXG4gICAgKi9cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LHR5KSB7XG4gICAgICB2YXIgbSA9IHRoaXMubTtcblxuICAgICAgbVsyXSArPSBtWzBdKnR4ICsgbVsxXSp0eTtcbiAgICAgIG1bNV0gKz0gbVszXSp0eCArIG1bNF0qdHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgVHJhbnNmb3JtIHggYW5kIHkgY29vcmRpbmF0ZXMgYnkgdGhpcyBtYXRyaXhcbiAgICAgTWVtb3J5IEhvZ2d5IHZlcnNpb24sIHJldHVybnMgYSBuZXcgQXJyYXlcblxuICAgICBAZm9yIFEuTWF0cml4MkRcbiAgICAgQG1ldGhvZCB0cmFuc2Zvcm1cbiAgICAgQHBhcmFtIHtGbG9hdH0geFxuICAgICBAcGFyYW0ge0Zsb2F0fSB5XG5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHgseSkge1xuICAgICAgcmV0dXJuIFsgeCAqIHRoaXMubVswXSArIHkgKiB0aGlzLm1bMV0gKyB0aGlzLm1bMl0sIFxuICAgICAgICAgICAgICAgeCAqIHRoaXMubVszXSArIHkgKiB0aGlzLm1bNF0gKyB0aGlzLm1bNV0gXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFRyYW5zZm9ybSBhbiBvYmplY3Qgd2l0aCBhbiB4IGFuZCB5IHByb3BlcnR5IGJ5IHRoaXMgTWF0cml4XG4gICAgIEBmb3IgUS5NYXRyaXgyRFxuICAgICBAbWV0aG9kIHRyYW5zZm9ybVB0XG4gICAgIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgQHJldHVybiB7T2JqZWN0fSBvYmpcbiAgICAqL1xuICAgIHRyYW5zZm9ybVB0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciB4ID0gb2JqLngsIHkgPSBvYmoueTtcblxuICAgICAgb2JqLnggPSB4ICogdGhpcy5tWzBdICsgeSAqIHRoaXMubVsxXSArIHRoaXMubVsyXTtcbiAgICAgIG9iai55ID0geCAqIHRoaXMubVszXSArIHkgKiB0aGlzLm1bNF0gKyB0aGlzLm1bNV07XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICBUcmFuc2Zvcm0gYW4gYXJyYXkgd2l0aCBhbiB4IGFuZCB5IGVsZW1lbnRzIGJ5IHRoaXMgTWF0cml4IGFuZCBwdXQgdGhlIHJlc3VsdCBpbiBcbiAgICAgdGhlIG91dEFyclxuXG4gICAgIEBmb3IgUS5NYXRyaXgyRFxuICAgICBAbWV0aG9kIHRyYW5zZm9ybUFyclxuICAgICBAcGFyYW0ge0FycmF5fSBpbkFyciAtIGlucHV0IGFycmF5XG4gICAgIEBwYXJhbSB7QXJyYXl9IG91dEFyciAtIG91dHB1dCBhcnJheVxuICAgICBAcmV0dXJuIHtPYmplY3R9IG9ialxuICAgICovXG4gICAgdHJhbnNmb3JtQXJyOiBmdW5jdGlvbihpbkFycixvdXRBcnIpIHtcbiAgICAgIHZhciB4ID0gaW5BcnJbMF0sIHkgPSBpbkFyclsxXTtcbiAgICAgIFxuICAgICAgb3V0QXJyWzBdID0geCAqIHRoaXMubVswXSArIHkgKiB0aGlzLm1bMV0gKyB0aGlzLm1bMl07XG4gICAgICBvdXRBcnJbMV0gPSB4ICogdGhpcy5tWzNdICsgeSAqIHRoaXMubVs0XSArIHRoaXMubVs1XTtcblxuICAgICAgcmV0dXJuIG91dEFycjtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgUmV0dXJuIGp1c3QgdGhlIHggY29vcmRpbmF0ZSB0cmFuc2Zvcm1lZCBieSB0aGlzIE1hdHJpeFxuXG4gICAgIEBmb3IgUS5NYXRyaXgyRFxuICAgICBAbWV0aG9kIHRyYW5zZm9ybVhcbiAgICAgQHBhcmFtIHtGbG9hdH0geFxuICAgICBAcGFyYW0ge0Zsb2F0fSB5XG4gICAgIEByZXR1cm4ge0Zsb2F0fSB4IHRyYW5zZm9ybWVkXG4gICAgKi9cbiAgICB0cmFuc2Zvcm1YOiBmdW5jdGlvbih4LHkpIHtcbiAgICAgIHJldHVybiB4ICogdGhpcy5tWzBdICsgeSAqIHRoaXMubVsxXSArIHRoaXMubVsyXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFJldHVybiBqdXN0IHRoZSB5IGNvb3JkaW5hdGUgdHJhbnNmb3JtZWQgYnkgdGhpcyBNYXRyaXhcblxuICAgICBAZm9yIFEuTWF0cml4MkRcbiAgICAgQG1ldGhvZCB0cmFuc2Zvcm1ZXG4gICAgIEBwYXJhbSB7RmxvYXR9IHhcbiAgICAgQHBhcmFtIHtGbG9hdH0geVxuICAgICBAcmV0dXJuIHtGbG9hdH0geSB0cmFuc2Zvcm1lZFxuICAgICovXG4gICAgdHJhbnNmb3JtWTogZnVuY3Rpb24oeCx5KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMubVszXSArIHkgKiB0aGlzLm1bNF0gKyB0aGlzLm1bNV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICBSZWxlYXNlIHRoaXMgTWF0cml4IHRvIGJlIHJldXNlZFxuXG4gICAgIEBmb3IgUS5NYXRyaXgyRFxuICAgICBAbWV0aG9kIHJlbGVhc2VcbiAgICAqL1xuICAgIHJlbGVhc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgUS5tYXRyaWNlczJkLnB1c2godGhpcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFNldCB0aGUgY29tcGxldGUgdHJhbnNmb3JtIG9uIGEgQ2FudmFzIDJEIGNvbnRleHRcblxuICAgICBAZm9yIFEuTWF0cml4MkRcbiAgICAgQG1ldGhvZCBzZXRDb250ZXh0VHJhbnNmb3JtXG4gICAgIEBwYXJhbSB7Q29udGV4dDJEfSBjdHggLSAyRCBjYW52cyBjb250ZXh0XG4gICAgICovICBcbiAgICAgc2V0Q29udGV4dFRyYW5zZm9ybTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgbSA9IHRoaXMubTtcbiAgICAgIC8vIHNvdXJjZTpcbiAgICAgIC8vICBtWzBdIG1bMV0gbVsyXVxuICAgICAgLy8gIG1bM10gbVs0XSBtWzVdXG4gICAgICAvLyAgMCAgICAgMCAgIDFcbiAgICAgIC8vXG4gICAgICAvLyBkZXN0aW5hdGlvbjpcbiAgICAgIC8vICBtMTEgIG0yMSAgZHhcbiAgICAgIC8vICBtMTIgIG0yMiAgZHlcbiAgICAgIC8vICAwICAgIDAgICAgMVxuICAgICAgLy8gIHNldFRyYW5zZm9ybShtMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeSlcbiAgICAgIGN0eC50cmFuc2Zvcm0obVswXSxtWzNdLG1bMV0sbVs0XSxtWzJdLG1bNV0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBBbmQgdGhhdCdzIGl0Li5cbiAgLy8gPT09PT09PT09PT09PT09XG4gIC8vXG4gIC8vIFJldHVybiB0aGUgYFFgIG9iamVjdCBmcm9tIHRoZSBgUXVpbnR1cygpYCBmYWN0b3J5IG1ldGhvZC4gQ3JlYXRlIGF3ZXNvbWUgZ2FtZXMuIFJlcGVhdC5cbiAgcmV0dXJuIFE7XG59O1xuXG4vLyBMYXN0bHksIGFkZCBpbiB0aGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgc2hpbSwgaWYgbmVjZXNzYXJ5LiBEb2VzIG5vdGhpbmcgXG4vLyBpZiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBpcyBhbHJlYWR5IG9uIHRoZSBgd2luZG93YCBvYmplY3QuXG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG4gICAgZm9yKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdKydSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gXG4gICAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0rJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd2luZG93W3ZlbmRvcnNbeF0rJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIH1cbiBcbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7IH0sIFxuICAgICAgICAgICAgICB0aW1lVG9DYWxsKTtcbiAgICAgICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuICAgIH1cbiBcbiAgICBpZiAoIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuXG5cbiIsIi8qZ2xvYmFsIFF1aW50dXM6ZmFsc2UgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihRKSB7XG5cbiAgUS5jb21wb25lbnQoJ3ZpZXdwb3J0Jyx7XG4gICAgYWRkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbnRpdHkub24oJ3ByZXJlbmRlcicsdGhpcywncHJlcmVuZGVyJyk7XG4gICAgICB0aGlzLmVudGl0eS5vbigncmVuZGVyJyx0aGlzLCdwb3N0cmVuZGVyJyk7XG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMub2Zmc2V0WCA9IDA7XG4gICAgICB0aGlzLm9mZnNldFkgPSAwO1xuICAgICAgdGhpcy5jZW50ZXJYID0gUS53aWR0aC8yO1xuICAgICAgdGhpcy5jZW50ZXJZID0gUS5oZWlnaHQvMjtcbiAgICAgIHRoaXMuc2NhbGUgPSAxO1xuICAgIH0sXG5cbiAgICBleHRlbmQ6IHtcbiAgICAgIGZvbGxvdzogZnVuY3Rpb24oc3ByaXRlLGRpcmVjdGlvbnMsYm91bmRpbmdCb3gpIHtcbiAgICAgICAgdGhpcy5vZmYoJ3Bvc3RzdGVwJyx0aGlzLnZpZXdwb3J0LCdmb2xsb3cnKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5kaXJlY3Rpb25zID0gZGlyZWN0aW9ucyB8fCB7IHg6IHRydWUsIHk6IHRydWUgfTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5mb2xsb3dpbmcgPSBzcHJpdGU7XG4gICAgICAgIHRoaXMudmlld3BvcnQuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveDtcbiAgICAgICAgdGhpcy5vbigncG9zdHN0ZXAnLHRoaXMudmlld3BvcnQsJ2ZvbGxvdycpO1xuICAgICAgICB0aGlzLnZpZXdwb3J0LmZvbGxvdyh0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZm9sbG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vZmYoJ3Bvc3RzdGVwJyx0aGlzLnZpZXdwb3J0LCdmb2xsb3cnKTtcbiAgICAgIH0sXG5cbiAgICAgIGNlbnRlck9uOiBmdW5jdGlvbih4LHkpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5jZW50ZXJPbih4LHkpO1xuICAgICAgfSxcblxuICAgICAgbW92ZVRvOiBmdW5jdGlvbih4LHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQubW92ZVRvKHgseSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZvbGxvdzogZnVuY3Rpb24oZmlyc3QpIHtcbiAgICAgIHZhciBmb2xsb3dYID0gUS5faXNGdW5jdGlvbih0aGlzLmRpcmVjdGlvbnMueCkgPyB0aGlzLmRpcmVjdGlvbnMueCh0aGlzLmZvbGxvd2luZykgOiB0aGlzLmRpcmVjdGlvbnMueDtcbiAgICAgIHZhciBmb2xsb3dZID0gUS5faXNGdW5jdGlvbih0aGlzLmRpcmVjdGlvbnMueSkgPyB0aGlzLmRpcmVjdGlvbnMueSh0aGlzLmZvbGxvd2luZykgOiB0aGlzLmRpcmVjdGlvbnMueTtcblxuICAgICAgdGhpc1tmaXJzdCA9PT0gdHJ1ZSA/ICdjZW50ZXJPbicgOiAnc29mdENlbnRlck9uJ10oXG4gICAgICAgICAgICAgICAgICAgIGZvbGxvd1ggPyBcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbGxvd2luZy5wLnggKyB0aGlzLmZvbGxvd2luZy5wLncvMiAtIHRoaXMub2Zmc2V0WCA6XG4gICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBmb2xsb3dZID9cbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9sbG93aW5nLnAueSArIHRoaXMuZm9sbG93aW5nLnAuaC8yIC0gdGhpcy5vZmZzZXRZIDpcbiAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgb2Zmc2V0OiBmdW5jdGlvbih4LHkpIHtcbiAgICAgIHRoaXMub2Zmc2V0WCA9IHg7XG4gICAgICB0aGlzLm9mZnNldFkgPSB5O1xuICAgIH0sXG5cbiAgICBzb2Z0Q2VudGVyT246IGZ1bmN0aW9uKHgseSkge1xuICAgICAgaWYoeCAhPT0gdm9pZCAwKSB7ICAgICAgICBcbiAgICAgICAgdmFyIGR4ID0gKHggLSBRLndpZHRoIC8gMiAvIHRoaXMuc2NhbGUgLSB0aGlzLngpLzM7XG4gICAgICAgIGlmKHRoaXMuYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICBpZih0aGlzLnggKyBkeCA8IHRoaXMuYm91bmRpbmdCb3gubWluWCkge1xuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5ib3VuZGluZ0JveC5taW5YIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZih0aGlzLnggKyBkeCA+ICh0aGlzLmJvdW5kaW5nQm94Lm1heFggLSBRLndpZHRoKSAvIHRoaXMuc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMueCA9ICh0aGlzLmJvdW5kaW5nQm94Lm1heFggLSBRLndpZHRoKSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54ICs9IGR4O1xuICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnggKz0gZHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHkgIT09IHZvaWQgMCkgeyBcbiAgICAgICAgdmFyIGR5ID0gKHkgLSBRLmhlaWdodCAvIDIgLyB0aGlzLnNjYWxlIC0gdGhpcy55KS8zO1xuICAgICAgICBpZih0aGlzLmJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgaWYodGhpcy55ICsgZHkgPCB0aGlzLmJvdW5kaW5nQm94Lm1pblkpIHtcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuYm91bmRpbmdCb3gubWluWSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYodGhpcy55ICsgZHkgPiAodGhpcy5ib3VuZGluZ0JveC5tYXhZIC0gUS5oZWlnaHQpIC8gdGhpcy5zY2FsZSkge1xuICAgICAgICAgICAgdGhpcy55ID0gKHRoaXMuYm91bmRpbmdCb3gubWF4WSAtIFEuaGVpZ2h0KSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55ICs9IGR5O1xuICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnkgKz0gZHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0sXG4gICAgY2VudGVyT246IGZ1bmN0aW9uKHgseSkge1xuICAgICAgaWYoeCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMueCA9IHggLSBRLndpZHRoIC8gMiAvIHRoaXMuc2NhbGU7XG4gICAgICB9XG4gICAgICBpZih5ICE9PSB2b2lkIDApIHsgXG4gICAgICAgIHRoaXMueSA9IHkgLSBRLmhlaWdodCAvIDIgLyB0aGlzLnNjYWxlO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIG1vdmVUbzogZnVuY3Rpb24oeCx5KSB7XG4gICAgICBpZih4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgIH1cbiAgICAgIGlmKHkgIT09IHZvaWQgMCkgeyBcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVudGl0eTtcblxuICAgIH0sXG5cbiAgICBwcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jZW50ZXJYID0gdGhpcy54ICsgUS53aWR0aCAvIDIgL3RoaXMuc2NhbGU7XG4gICAgICB0aGlzLmNlbnRlclkgPSB0aGlzLnkgKyBRLmhlaWdodCAvIDIgL3RoaXMuc2NhbGU7XG4gICAgICBRLmN0eC5zYXZlKCk7XG4gICAgICBRLmN0eC50cmFuc2xhdGUoTWF0aC5mbG9vcihRLndpZHRoLzIpLE1hdGguZmxvb3IoUS5oZWlnaHQvMikpO1xuICAgICAgUS5jdHguc2NhbGUodGhpcy5zY2FsZSx0aGlzLnNjYWxlKTtcbiAgICAgIFEuY3R4LnRyYW5zbGF0ZSgtTWF0aC5mbG9vcih0aGlzLmNlbnRlclgpLCAtTWF0aC5mbG9vcih0aGlzLmNlbnRlclkpKTtcbiAgICB9LFxuXG4gICAgcG9zdHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICBRLmN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9KTtcblxuXG4gUS5TcHJpdGUuZXh0ZW5kKFwiVGlsZUxheWVyXCIse1xuXG4gICAgaW5pdDogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIHRoaXMuX3N1cGVyKHByb3BzLHtcbiAgICAgICAgdGlsZVc6IDMyLFxuICAgICAgICB0aWxlSDogMzIsXG4gICAgICAgIGJsb2NrVGlsZVc6IDEwLFxuICAgICAgICBibG9ja1RpbGVIOiAxMCxcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgcmVuZGVyQWx3YXlzOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmKHRoaXMucC5kYXRhQXNzZXQpIHtcbiAgICAgICAgdGhpcy5sb2FkKHRoaXMucC5kYXRhQXNzZXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcblxuICAgICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgICAgIHRoaXMucC5ibG9ja1cgPSB0aGlzLnAudGlsZVcgKiB0aGlzLnAuYmxvY2tUaWxlVztcbiAgICAgIHRoaXMucC5ibG9ja0ggPSB0aGlzLnAudGlsZUggKiB0aGlzLnAuYmxvY2tUaWxlSDtcbiAgICAgIHRoaXMuY29sQm91bmRzID0ge307IFxuICAgICAgdGhpcy5kaXJlY3Rpb25zID0gWyAndG9wJywnbGVmdCcsJ3JpZ2h0JywnYm90dG9tJ107XG4gICAgICB0aGlzLnRpbGVQcm9wZXJ0aWVzID0ge307XG5cbiAgICAgIHRoaXMuY29sbGlzaW9uT2JqZWN0ID0geyBcbiAgICAgICAgcDoge1xuICAgICAgICAgIHc6IHRoaXMucC50aWxlVyxcbiAgICAgICAgICBoOiB0aGlzLnAudGlsZUgsXG4gICAgICAgICAgY3g6IHRoaXMucC50aWxlVy8yLFxuICAgICAgICAgIGN5OiB0aGlzLnAudGlsZUgvMlxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICB0aGlzLnRpbGVDb2xsaXNpb25PYmplY3RzID0ge307ICAgICAgXG5cbiAgICAgIHRoaXMuY29sbGlzaW9uTm9ybWFsID0geyBzZXBhcmF0ZTogW119O1xuXG4gICAgICB0aGlzLl9nZW5lcmF0ZUNvbGxpc2lvbk9iamVjdHMoKTtcbiAgICB9LFxuXG4gICAgLy8gR2VuZXJhdGUgdGhlIHRpbGVDb2xsaXNpb25PYmplY3Qgb3ZlcnJpZGVzIHdoZXJlIG5lZWRlZFxuICAgIF9nZW5lcmF0ZUNvbGxpc2lvbk9iamVjdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiByZXR1cm5Qb2ludChwdCkge1xuICAgICAgICByZXR1cm4gWyBwdFswXSAqIHNlbGYucC50aWxlVyAtIHNlbGYucC50aWxlVy8yLFxuICAgICAgICAgICAgICAgICBwdFsxXSAqIHNlbGYucC50aWxlSCAtIHNlbGYucC50aWxlSC8yXG4gICAgICAgICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICBpZih0aGlzLnNoZWV0KCkgJiYgdGhpcy5zaGVldCgpLmZyYW1lUHJvcGVydGllcykge1xuICAgICAgICB2YXIgZnJhbWVQcm9wZXJ0aWVzID0gdGhpcy5zaGVldCgpLmZyYW1lUHJvcGVydGllcztcbiAgICAgICAgZm9yKHZhciBrIGluIGZyYW1lUHJvcGVydGllcykgeyBcbiAgICAgICAgICB2YXIgY29sT2JqID0gdGhpcy50aWxlQ29sbGlzaW9uT2JqZWN0c1trXSA9IHsgcDogUS5fY2xvbmUodGhpcy5jb2xsaXNpb25PYmplY3QucCkgfTtcbiAgICAgICAgICBRLl9leHRlbmQoY29sT2JqLnAsZnJhbWVQcm9wZXJ0aWVzW2tdKTtcblxuICAgICAgICAgIGlmKGNvbE9iai5wLnBvaW50cykge1xuICAgICAgICAgICAgY29sT2JqLnAucG9pbnRzID0gUS5fbWFwKGNvbE9iai5wLnBvaW50cywgcmV0dXJuUG9pbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudGlsZUNvbGxpc2lvbk9iamVjdHNba10gPSBjb2xPYmo7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbihkYXRhQXNzZXQpIHtcbiAgICAgIHZhciBmaWxlUGFydHMgPSBkYXRhQXNzZXQuc3BsaXQoXCIuXCIpLFxuICAgICAgICAgIGZpbGVFeHQgPSBmaWxlUGFydHNbZmlsZVBhcnRzLmxlbmd0aC0xXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIGRhdGE7XG5cbiAgICAgIGlmIChmaWxlRXh0ID09PSBcImpzb25cIikgeyAgXG4gICAgICAgIGRhdGEgPSBRLl9pc1N0cmluZyhkYXRhQXNzZXQpID8gIFEuYXNzZXQoZGF0YUFzc2V0KSA6IGRhdGFBc3NldDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBcImZpbGUgdHlwZSBub3Qgc3VwcG9ydGVkXCI7XG4gICAgICB9XG4gICAgICB0aGlzLnAudGlsZXMgPSBkYXRhO1xuICAgIH0sXG5cbiAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aWxlcyA9IHRoaXMucC50aWxlcztcblxuICAgICAgaWYodGlsZXMpIHsgXG4gICAgICAgIHRoaXMucC5yb3dzID0gdGlsZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLnAuY29scyA9IHRpbGVzWzBdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wLncgPSB0aGlzLnAuY29scyAqIHRoaXMucC50aWxlVztcbiAgICAgICAgdGhpcy5wLmggPSB0aGlzLnAucm93cyAqIHRoaXMucC50aWxlSDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VGlsZTogZnVuY3Rpb24odGlsZVgsdGlsZVkpIHtcbiAgICAgIHJldHVybiB0aGlzLnAudGlsZXNbdGlsZVldICYmIHRoaXMucC50aWxlc1t0aWxlWV1bdGlsZVhdO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0VGlsZVByb3BlcnR5OiBmdW5jdGlvbih0aWxlLCBwcm9wKSB7XG4gICAgICBpZih0aGlzLnRpbGVQcm9wZXJ0aWVzW3RpbGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVByb3BlcnRpZXNbdGlsZV1bcHJvcF07ICAgICAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZ2V0VGlsZVByb3BlcnRpZXM6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgIGlmKHRoaXMudGlsZVByb3BlcnRpZXNbdGlsZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlUHJvcGVydGllc1t0aWxlXTsgICAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBnZXRUaWxlUHJvcGVydHlBdDogZnVuY3Rpb24odGlsZVgsIHRpbGVZLCBwcm9wKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaWxlUHJvcGVydHkodGhpcy5nZXRUaWxlKHRpbGVYLCB0aWxlWSksIHByb3ApO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0VGlsZVByb3BlcnRpZXNBdDogZnVuY3Rpb24odGlsZVgsIHRpbGVZKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaWxlUHJvcGVydGllcyh0aGlzLmdldFRpbGUodGlsZVgsIHRpbGVZKSk7XG4gICAgfSxcbiAgICBcbiAgICB0aWxlSGFzUHJvcGVydHk6IGZ1bmN0aW9uKHRpbGUsIHByb3ApIHtcbiAgICAgIHJldHVybih0aGlzLmdldFRpbGVQcm9wZXJ0eSh0aWxlLCBwcm9wKSAhPT0gdW5kZWZpbmVkKTtcbiAgICB9LCAgICBcblxuICAgIHNldFRpbGU6IGZ1bmN0aW9uKHgseSx0aWxlKSB7XG4gICAgICB2YXIgcCA9IHRoaXMucCxcbiAgICAgICAgICBibG9ja1ggPSBNYXRoLmZsb29yKHgvcC5ibG9ja1RpbGVXKSxcbiAgICAgICAgICBibG9ja1kgPSBNYXRoLmZsb29yKHkvcC5ibG9ja1RpbGVIKTtcblxuICAgICAgaWYoeCA+PSAwICYmIHggPCB0aGlzLnAuY29scyAmJlxuICAgICAgICAgeSA+PSAwICYmIHkgPCB0aGlzLnAucm93cykgeyBcblxuICAgICAgICB0aGlzLnAudGlsZXNbeV1beF0gPSB0aWxlO1xuXG4gICAgICAgIGlmKHRoaXMuYmxvY2tzW2Jsb2NrWV0pIHtcbiAgICAgICAgICB0aGlzLmJsb2Nrc1tibG9ja1ldW2Jsb2NrWF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpbGVQcmVzZW50OiBmdW5jdGlvbih0aWxlWCx0aWxlWSkge1xuICAgICAgcmV0dXJuIHRoaXMucC50aWxlc1t0aWxlWV0gJiYgdGhpcy5jb2xsaWRhYmxlVGlsZSh0aGlzLnAudGlsZXNbdGlsZVldW3RpbGVYXSk7XG4gICAgfSxcblxuICAgIC8vIE92ZXJsb2FkIHRoaXMgbWV0aG9kIHRvIGRyYXcgdGlsZXMgYXQgZnJhbWUgMCBvciBub3QgZHJhd1xuICAgIC8vIHRpbGVzIGF0IGhpZ2hlciBudW1iZXIgZnJhbWVzXG4gICAgZHJhd2FibGVUaWxlOiBmdW5jdGlvbih0aWxlTnVtKSB7XG4gICAgICByZXR1cm4gdGlsZU51bSA+IDA7XG4gICAgfSxcblxuICAgIC8vIE92ZXJsb2FkIHRoaXMgbWV0aG9kIHRvIGNvbnRyb2wgd2hpY2ggdGlsZXMgdHJpZ2dlciBhIGNvbGxpc2lvblxuICAgIC8vIChkZWZhdWx0cyB0byBhbGwgdGlsZXMgPiBudW1iZXIgMClcbiAgICBjb2xsaWRhYmxlVGlsZTogZnVuY3Rpb24odGlsZU51bSkge1xuICAgICAgcmV0dXJuIHRpbGVOdW0gPiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0Q29sbGlzaW9uT2JqZWN0OiBmdW5jdGlvbih0aWxlWCwgdGlsZVkpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wLFxuICAgICAgICAgIHRpbGUgPSB0aGlzLmdldFRpbGUodGlsZVgsIHRpbGVZKSxcbiAgICAgICAgICBjb2xPYmo7XG4gICAgICBcbiAgICAgIGNvbE9iaiA9ICh0aGlzLnRpbGVDb2xsaXNpb25PYmplY3RzW3RpbGVdICE9PSB1bmRlZmluZWQpID8gXG4gICAgICAgIHRoaXMudGlsZUNvbGxpc2lvbk9iamVjdHNbdGlsZV0gOiB0aGlzLmNvbGxpc2lvbk9iamVjdDsgICAgIFxuICAgICAgXG4gICAgICBjb2xPYmoucC54ID0gdGlsZVggKiBwLnRpbGVXICsgcC54ICsgcC50aWxlVy8yO1xuICAgICAgY29sT2JqLnAueSA9IHRpbGVZICogcC50aWxlSCArIHAueSArIHAudGlsZUgvMjtcbiAgICAgIFxuICAgICAgcmV0dXJuIGNvbE9iajtcbiAgICB9LFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgcCA9IHRoaXMucCxcbiAgICAgICAgICBvYmpQID0gb2JqLmMgfHwgb2JqLnAsIFxuICAgICAgICAgIHRpbGVTdGFydFggPSBNYXRoLmZsb29yKChvYmpQLnggLSBvYmpQLmN4IC0gcC54KSAvIHAudGlsZVcpLFxuICAgICAgICAgIHRpbGVTdGFydFkgPSBNYXRoLmZsb29yKChvYmpQLnkgLSBvYmpQLmN5IC0gcC55KSAvIHAudGlsZUgpLFxuICAgICAgICAgIHRpbGVFbmRYID0gIE1hdGguY2VpbCgob2JqUC54IC0gb2JqUC5jeCArIG9ialAudyAtIHAueCkgLyBwLnRpbGVXKSxcbiAgICAgICAgICB0aWxlRW5kWSA9ICBNYXRoLmNlaWwoKG9ialAueSAtIG9ialAuY3kgKyBvYmpQLmggLSBwLnkpIC8gcC50aWxlSCksXG4gICAgICAgICAgbm9ybWFsID0gdGhpcy5jb2xsaXNpb25Ob3JtYWwsXG4gICAgICAgICAgY29sLCBjb2xPYmo7XG4gIFxuICAgICAgbm9ybWFsLmNvbGxpZGVkID0gZmFsc2U7XG5cbiAgICAgIGZvcih2YXIgdGlsZVkgPSB0aWxlU3RhcnRZOyB0aWxlWTw9dGlsZUVuZFk7IHRpbGVZKyspIHtcbiAgICAgICAgZm9yKHZhciB0aWxlWCA9IHRpbGVTdGFydFg7IHRpbGVYPD10aWxlRW5kWDsgdGlsZVgrKykge1xuICAgICAgICAgIGlmKHRoaXMudGlsZVByZXNlbnQodGlsZVgsdGlsZVkpKSB7XG4gICAgICAgICAgICBjb2xPYmogPSB0aGlzLmdldENvbGxpc2lvbk9iamVjdCh0aWxlWCwgdGlsZVkpO1xuXG4gICAgICAgICAgICBjb2wgPSBRLmNvbGxpc2lvbihvYmosY29sT2JqKTtcbiAgICAgIFxuICAgICAgICAgICAgaWYoY29sICYmIGNvbC5tYWduaXR1ZGUgPiAwKSB7XG4gICAgICAgICAgICAgIGlmKGNvbE9iai5wLnNlbnNvcikge1xuICAgICAgICAgICAgICAgIGNvbE9iai50aWxlID0gdGhpcy5nZXRUaWxlKHRpbGVYLHRpbGVZKTtcbiAgICAgICAgICAgICAgICBpZihvYmoudHJpZ2dlcikgeyBcbiAgICAgICAgICAgICAgICAgIG9iai50cmlnZ2VyKCdzZW5zb3IudGlsZScsY29sT2JqKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYoIW5vcm1hbC5jb2xsaWRlZCB8fCBub3JtYWwubWFnbml0dWRlIDwgY29sLm1hZ25pdHVkZSApIHtcbiAgICAgICAgICAgICAgICAgbm9ybWFsLmNvbGxpZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgbm9ybWFsLnNlcGFyYXRlWzBdID0gY29sLnNlcGFyYXRlWzBdO1xuICAgICAgICAgICAgICAgICBub3JtYWwuc2VwYXJhdGVbMV0gPSBjb2wuc2VwYXJhdGVbMV07XG4gICAgICAgICAgICAgICAgIG5vcm1hbC5tYWduaXR1ZGUgPSBjb2wubWFnbml0dWRlO1xuICAgICAgICAgICAgICAgICBub3JtYWwuZGlzdGFuY2UgPSBjb2wuZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxYID0gY29sLm5vcm1hbFg7XG4gICAgICAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxZID0gY29sLm5vcm1hbFk7XG4gICAgICAgICAgICAgICAgIG5vcm1hbC50aWxlWCA9IHRpbGVYO1xuICAgICAgICAgICAgICAgICBub3JtYWwudGlsZVkgPSB0aWxlWTtcbiAgICAgICAgICAgICAgICAgbm9ybWFsLnRpbGUgPSB0aGlzLmdldFRpbGUodGlsZVgsdGlsZVkpO1xuICAgICAgICAgICAgICAgICBpZihvYmoucC5jb2xsaXNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICBvYmoucC5jb2xsaXNpb25zLnB1c2gobm9ybWFsKTsgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub3JtYWwuY29sbGlkZWQgPyBub3JtYWwgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgcHJlcmVuZGVyQmxvY2s6IGZ1bmN0aW9uKGJsb2NrWCxibG9ja1kpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wLFxuICAgICAgICAgIHRpbGVzID0gcC50aWxlcyxcbiAgICAgICAgICBzaGVldCA9IHRoaXMuc2hlZXQoKSxcbiAgICAgICAgICBibG9ja09mZnNldFggPSBibG9ja1gqcC5ibG9ja1RpbGVXLFxuICAgICAgICAgIGJsb2NrT2Zmc2V0WSA9IGJsb2NrWSpwLmJsb2NrVGlsZUg7XG5cbiAgICAgIGlmKGJsb2NrT2Zmc2V0WCA8IDAgfHwgYmxvY2tPZmZzZXRYID49IHRoaXMucC5jb2xzIHx8XG4gICAgICAgICBibG9ja09mZnNldFkgPCAwIHx8IGJsb2NrT2Zmc2V0WSA+PSB0aGlzLnAucm93cykge1xuICAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgY2FudmFzLndpZHRoID0gcC5ibG9ja1c7XG4gICAgICBjYW52YXMuaGVpZ2h0PSBwLmJsb2NrSDtcbiAgICAgIHRoaXMuYmxvY2tzW2Jsb2NrWV0gPSB0aGlzLmJsb2Nrc1tibG9ja1ldIHx8IHt9O1xuICAgICAgdGhpcy5ibG9ja3NbYmxvY2tZXVtibG9ja1hdID0gY2FudmFzO1xuXG4gICAgICBmb3IodmFyIHk9MDt5PHAuYmxvY2tUaWxlSDt5KyspIHtcbiAgICAgICAgaWYodGlsZXNbeStibG9ja09mZnNldFldKSB7XG4gICAgICAgICAgZm9yKHZhciB4PTA7eDxwLmJsb2NrVGlsZVc7eCsrKSB7XG4gICAgICAgICAgICBpZih0aGlzLmRyYXdhYmxlVGlsZSh0aWxlc1t5K2Jsb2NrT2Zmc2V0WV1beCtibG9ja09mZnNldFhdKSkge1xuICAgICAgICAgICAgICBzaGVldC5kcmF3KGN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICB4KnAudGlsZVcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgeSpwLnRpbGVILFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVzW3krYmxvY2tPZmZzZXRZXVt4K2Jsb2NrT2Zmc2V0WF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkcmF3QmxvY2s6IGZ1bmN0aW9uKGN0eCwgYmxvY2tYLCBibG9ja1kpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wLFxuICAgICAgICAgIHN0YXJ0WCA9IE1hdGguZmxvb3IoYmxvY2tYICogcC5ibG9ja1cgKyBwLngpLFxuICAgICAgICAgIHN0YXJ0WSA9IE1hdGguZmxvb3IoYmxvY2tZICogcC5ibG9ja0ggKyBwLnkpO1xuXG4gICAgICBpZighdGhpcy5ibG9ja3NbYmxvY2tZXSB8fCAhdGhpcy5ibG9ja3NbYmxvY2tZXVtibG9ja1hdKSB7XG4gICAgICAgIHRoaXMucHJlcmVuZGVyQmxvY2soYmxvY2tYLGJsb2NrWSk7XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMuYmxvY2tzW2Jsb2NrWV0gICYmIHRoaXMuYmxvY2tzW2Jsb2NrWV1bYmxvY2tYXSkge1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuYmxvY2tzW2Jsb2NrWV1bYmxvY2tYXSxzdGFydFgsc3RhcnRZKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgcCA9IHRoaXMucCxcbiAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuc3RhZ2Uudmlld3BvcnQsXG4gICAgICAgICAgc2NhbGUgPSB2aWV3cG9ydCA/IHZpZXdwb3J0LnNjYWxlIDogMSxcbiAgICAgICAgICB4ID0gdmlld3BvcnQgPyB2aWV3cG9ydC54IDogMCxcbiAgICAgICAgICB5ID0gdmlld3BvcnQgPyB2aWV3cG9ydC55IDogMCxcbiAgICAgICAgICB2aWV3VyA9IFEud2lkdGggLyBzY2FsZSxcbiAgICAgICAgICB2aWV3SCA9IFEuaGVpZ2h0IC8gc2NhbGUsXG4gICAgICAgICAgc3RhcnRCbG9ja1ggPSBNYXRoLmZsb29yKCh4IC0gcC54KSAvIHAuYmxvY2tXKSxcbiAgICAgICAgICBzdGFydEJsb2NrWSA9IE1hdGguZmxvb3IoKHkgLSBwLnkpIC8gcC5ibG9ja0gpLFxuICAgICAgICAgIGVuZEJsb2NrWCA9IE1hdGguZmxvb3IoKHggKyB2aWV3VyAtIHAueCkgLyBwLmJsb2NrVyksXG4gICAgICAgICAgZW5kQmxvY2tZID0gTWF0aC5mbG9vcigoeSArIHZpZXdIIC0gcC55KSAvIHAuYmxvY2tIKTtcblxuICAgICAgZm9yKHZhciBpeT1zdGFydEJsb2NrWTtpeTw9ZW5kQmxvY2tZO2l5KyspIHtcbiAgICAgICAgZm9yKHZhciBpeD1zdGFydEJsb2NrWDtpeDw9ZW5kQmxvY2tYO2l4KyspIHtcbiAgICAgICAgICB0aGlzLmRyYXdCbG9jayhjdHgsaXgsaXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBRLmdyYXZpdHlZID0gOS44KjEwMDtcbiAgUS5ncmF2aXR5WCA9IDA7XG5cbiAgUS5jb21wb25lbnQoJzJkJyx7XG4gICAgYWRkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVudGl0eSA9IHRoaXMuZW50aXR5O1xuICAgICAgUS5fZGVmYXVsdHMoZW50aXR5LnAse1xuICAgICAgICB2eDogMCxcbiAgICAgICAgdnk6IDAsXG4gICAgICAgIGF4OiAwLFxuICAgICAgICBheTogMCxcbiAgICAgICAgZ3Jhdml0eTogMSxcbiAgICAgICAgY29sbGlzaW9uTWFzazogUS5TUFJJVEVfREVGQVVMVFxuICAgICAgfSk7XG4gICAgICBlbnRpdHkub24oJ3N0ZXAnLHRoaXMsXCJzdGVwXCIpO1xuICAgICAgZW50aXR5Lm9uKCdoaXQnLHRoaXMsJ2NvbGxpc2lvbicpO1xuICAgIH0sXG5cbiAgICBjb2xsaXNpb246IGZ1bmN0aW9uKGNvbCxsYXN0KSB7XG4gICAgICB2YXIgZW50aXR5ID0gdGhpcy5lbnRpdHksXG4gICAgICAgICAgcCA9IGVudGl0eS5wLFxuICAgICAgICAgIG1hZ25pdHVkZSA9IDA7XG5cbiAgICAgIGlmKGNvbC5vYmoucCAmJiBjb2wub2JqLnAuc2Vuc29yKSB7XG4gICAgICAgIGNvbC5vYmoudHJpZ2dlcihcInNlbnNvclwiLGVudGl0eSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29sLmltcGFjdCA9IDA7XG4gICAgICB2YXIgaW1wYWN0WCA9IE1hdGguYWJzKHAudngpO1xuICAgICAgdmFyIGltcGFjdFkgPSBNYXRoLmFicyhwLnZ5KTtcblxuICAgICAgcC54IC09IGNvbC5zZXBhcmF0ZVswXTtcbiAgICAgIHAueSAtPSBjb2wuc2VwYXJhdGVbMV07XG5cbiAgICAgIC8vIFRvcCBjb2xsaXNpb25cbiAgICAgIGlmKGNvbC5ub3JtYWxZIDwgLTAuMykgeyBcbiAgICAgICAgaWYoIXAuc2tpcENvbGxpZGUgJiYgcC52eSA+IDApIHsgcC52eSA9IDA7IH1cbiAgICAgICAgY29sLmltcGFjdCA9IGltcGFjdFk7XG4gICAgICAgIGVudGl0eS50cmlnZ2VyKFwiYnVtcC5ib3R0b21cIixjb2wpO1xuICAgICAgfVxuICAgICAgaWYoY29sLm5vcm1hbFkgPiAwLjMpIHtcbiAgICAgICAgaWYoIXAuc2tpcENvbGxpZGUgJiYgcC52eSA8IDApIHsgcC52eSA9IDA7IH1cbiAgICAgICAgY29sLmltcGFjdCA9IGltcGFjdFk7XG5cbiAgICAgICAgZW50aXR5LnRyaWdnZXIoXCJidW1wLnRvcFwiLGNvbCk7XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbC5ub3JtYWxYIDwgLTAuMykgeyBcbiAgICAgICAgaWYoIXAuc2tpcENvbGxpZGUgJiYgcC52eCA+IDApIHsgcC52eCA9IDA7ICB9XG4gICAgICAgIGNvbC5pbXBhY3QgPSBpbXBhY3RYO1xuICAgICAgICBlbnRpdHkudHJpZ2dlcihcImJ1bXAucmlnaHRcIixjb2wpO1xuICAgICAgfVxuICAgICAgaWYoY29sLm5vcm1hbFggPiAwLjMpIHsgXG4gICAgICAgIGlmKCFwLnNraXBDb2xsaWRlICYmIHAudnggPCAwKSB7IHAudnggPSAwOyB9XG4gICAgICAgIGNvbC5pbXBhY3QgPSBpbXBhY3RYO1xuXG4gICAgICAgIGVudGl0eS50cmlnZ2VyKFwiYnVtcC5sZWZ0XCIsY29sKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RlcDogZnVuY3Rpb24oZHQpIHtcbiAgICAgIHZhciBwID0gdGhpcy5lbnRpdHkucCxcbiAgICAgICAgICBkdFN0ZXAgPSBkdDtcbiAgICAgIC8vIFRPRE86IGNoZWNrIHRoZSBlbnRpdHkncyBtYWduaXR1ZGUgb2YgdnggYW5kIHZ5LFxuICAgICAgLy8gcmVkdWNlIHRoZSBtYXggZHRTdGVwIGlmIG5lY2Vzc2FyeSB0byBwcmV2ZW50IFxuICAgICAgLy8gc2tpcHBpbmcgdGhyb3VnaCBvYmplY3RzLlxuICAgICAgd2hpbGUoZHRTdGVwID4gMCkge1xuICAgICAgICBkdCA9IE1hdGgubWluKDEvMzAsZHRTdGVwKTtcbiAgICAgICAgLy8gVXBkYXRlZCBiYXNlZCBvbiB0aGUgdmVsb2NpdHkgYW5kIGFjY2VsZXJhdGlvblxuICAgICAgICBwLnZ4ICs9IHAuYXggKiBkdCArIChwLmdyYXZpdHlYID09PSB2b2lkIDAgPyBRLmdyYXZpdHlYIDogcC5ncmF2aXR5WCkgKiBkdCAqIHAuZ3Jhdml0eTtcbiAgICAgICAgcC52eSArPSBwLmF5ICogZHQgKyAocC5ncmF2aXR5WSA9PT0gdm9pZCAwID8gUS5ncmF2aXR5WSA6IHAuZ3Jhdml0eVkpICogZHQgKiBwLmdyYXZpdHk7XG4gICAgICAgIHAueCArPSBwLnZ4ICogZHQ7XG4gICAgICAgIHAueSArPSBwLnZ5ICogZHQ7XG5cbiAgICAgICAgdGhpcy5lbnRpdHkuc3RhZ2UuY29sbGlkZSh0aGlzLmVudGl0eSk7XG4gICAgICAgIGR0U3RlcCAtPSBkdDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIFEuY29tcG9uZW50KCdhaUJvdW5jZScsIHtcbiAgICBhZGRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVudGl0eS5vbihcImJ1bXAucmlnaHRcIix0aGlzLFwiZ29MZWZ0XCIpO1xuICAgICAgdGhpcy5lbnRpdHkub24oXCJidW1wLmxlZnRcIix0aGlzLFwiZ29SaWdodFwiKTtcbiAgICB9LFxuXG4gICAgZ29MZWZ0OiBmdW5jdGlvbihjb2wpIHtcbiAgICAgIHRoaXMuZW50aXR5LnAudnggPSAtY29sLmltcGFjdDsgICAgICBcbiAgICAgIGlmKHRoaXMuZW50aXR5LnAuZGVmYXVsdERpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuZW50aXR5LnAuZmxpcCA9ICd4JztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW50aXR5LnAuZmxpcCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnb1JpZ2h0OiBmdW5jdGlvbihjb2wpIHtcbiAgICAgIHRoaXMuZW50aXR5LnAudnggPSBjb2wuaW1wYWN0O1xuICAgICAgaWYodGhpcy5lbnRpdHkucC5kZWZhdWx0RGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0aGlzLmVudGl0eS5wLmZsaXAgPSAneCc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVudGl0eS5wLmZsaXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG59O1xuIiwiLypnbG9iYWwgUXVpbnR1czpmYWxzZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFEpIHtcblxuICBRLl9hbmltYXRpb25zID0ge307XG4gIFEuYW5pbWF0aW9ucyA9IGZ1bmN0aW9uKHNwcml0ZSxhbmltYXRpb25zKSB7XG4gICAgaWYoIVEuX2FuaW1hdGlvbnNbc3ByaXRlXSkgeyBRLl9hbmltYXRpb25zW3Nwcml0ZV0gPSB7fTsgfVxuICAgIFEuX2V4dGVuZChRLl9hbmltYXRpb25zW3Nwcml0ZV0sYW5pbWF0aW9ucyk7XG4gIH07XG5cbiAgUS5hbmltYXRpb24gPSBmdW5jdGlvbihzcHJpdGUsbmFtZSkge1xuICAgIHJldHVybiBRLl9hbmltYXRpb25zW3Nwcml0ZV0gJiYgUS5fYW5pbWF0aW9uc1tzcHJpdGVdW25hbWVdO1xuICB9O1xuXG4gIFEuY29tcG9uZW50KCdhbmltYXRpb24nLHtcbiAgICBhZGRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuZW50aXR5LnA7XG4gICAgICBwLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICBwLmFuaW1hdGlvblByaW9yaXR5ID0gLTE7XG4gICAgICBwLmFuaW1hdGlvbkZyYW1lID0gMDtcbiAgICAgIHAuYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICB0aGlzLmVudGl0eS5vbihcInN0ZXBcIix0aGlzLFwic3RlcFwiKTtcbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgcGxheTogZnVuY3Rpb24obmFtZSxwcmlvcml0eSxyZXNldEZyYW1lKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnBsYXkobmFtZSxwcmlvcml0eSxyZXNldEZyYW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0ZXA6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICB2YXIgZW50aXR5ID0gdGhpcy5lbnRpdHksXG4gICAgICAgICAgcCA9IGVudGl0eS5wO1xuICAgICAgaWYocC5hbmltYXRpb24pIHtcbiAgICAgICAgdmFyIGFuaW0gPSBRLmFuaW1hdGlvbihwLnNwcml0ZSxwLmFuaW1hdGlvbiksXG4gICAgICAgICAgICByYXRlID0gYW5pbS5yYXRlIHx8IHAucmF0ZSxcbiAgICAgICAgICAgIHN0ZXBwZWQgPSAwO1xuICAgICAgICBwLmFuaW1hdGlvblRpbWUgKz0gZHQ7XG4gICAgICAgIGlmKHAuYW5pbWF0aW9uQ2hhbmdlZCkge1xuICAgICAgICAgIHAuYW5pbWF0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgeyBcbiAgICAgICAgICBwLmFuaW1hdGlvblRpbWUgKz0gZHQ7XG4gICAgICAgICAgaWYocC5hbmltYXRpb25UaW1lID4gcmF0ZSkge1xuICAgICAgICAgICAgc3RlcHBlZCA9IE1hdGguZmxvb3IocC5hbmltYXRpb25UaW1lIC8gcmF0ZSk7XG4gICAgICAgICAgICBwLmFuaW1hdGlvblRpbWUgLT0gc3RlcHBlZCAqIHJhdGU7XG4gICAgICAgICAgICBwLmFuaW1hdGlvbkZyYW1lICs9IHN0ZXBwZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHN0ZXBwZWQgPiAwKSB7XG4gICAgICAgICAgaWYocC5hbmltYXRpb25GcmFtZSA+PSBhbmltLmZyYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmKGFuaW0ubG9vcCA9PT0gZmFsc2UgfHwgYW5pbS5uZXh0KSB7XG4gICAgICAgICAgICAgIHAuYW5pbWF0aW9uRnJhbWUgPSBhbmltLmZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBlbnRpdHkudHJpZ2dlcignYW5pbUVuZCcpO1xuICAgICAgICAgICAgICBlbnRpdHkudHJpZ2dlcignYW5pbUVuZC4nICsgcC5hbmltYXRpb24pO1xuICAgICAgICAgICAgICBwLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIHAuYW5pbWF0aW9uUHJpb3JpdHkgPSAtMTtcbiAgICAgICAgICAgICAgaWYoYW5pbS50cmlnZ2VyKSB7ICBcbiAgICAgICAgICAgICAgICBlbnRpdHkudHJpZ2dlcihhbmltLnRyaWdnZXIsYW5pbS50cmlnZ2VyRGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYoYW5pbS5uZXh0KSB7IHRoaXMucGxheShhbmltLm5leHQsYW5pbS5uZXh0UHJpb3JpdHkpOyB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVudGl0eS50cmlnZ2VyKCdhbmltTG9vcCcpO1xuICAgICAgICAgICAgICBlbnRpdHkudHJpZ2dlcignYW5pbUxvb3AuJyArIHAuYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgcC5hbmltYXRpb25GcmFtZSA9IHAuYW5pbWF0aW9uRnJhbWUgJSBhbmltLmZyYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVudGl0eS50cmlnZ2VyKFwiYW5pbUZyYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hlZXQgPSBhbmltLnNoZWV0IHx8IHAuc2hlZXQ7XG4gICAgICAgIHAuZnJhbWUgPSBhbmltLmZyYW1lc1twLmFuaW1hdGlvbkZyYW1lXTtcbiAgICAgICAgaWYoYW5pbS5oYXNPd25Qcm9wZXJ0eShcImZsaXBcIikpIHsgcC5mbGlwICA9IGFuaW0uZmxpcDsgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwbGF5OiBmdW5jdGlvbihuYW1lLHByaW9yaXR5LHJlc2V0RnJhbWUpIHtcbiAgICAgIHZhciBlbnRpdHkgPSB0aGlzLmVudGl0eSxcbiAgICAgICAgICBwID0gZW50aXR5LnA7XG4gICAgICBwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG4gICAgICBpZihuYW1lICE9PSBwLmFuaW1hdGlvbiAmJiBwcmlvcml0eSA+PSBwLmFuaW1hdGlvblByaW9yaXR5KSB7XG4gICAgICAgIGlmKHJlc2V0RnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc2V0RnJhbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHAuYW5pbWF0aW9uID0gbmFtZTtcbiAgICAgICAgaWYocmVzZXRGcmFtZSkge1xuICAgICAgICAgIHAuYW5pbWF0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgcC5hbmltYXRpb25UaW1lID0gMDsgICAgICAgICAgXG4gICAgICAgICAgcC5hbmltYXRpb25GcmFtZSA9IDA7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBwLmFuaW1hdGlvblByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIGVudGl0eS50cmlnZ2VyKCdhbmltJyk7XG4gICAgICAgIGVudGl0eS50cmlnZ2VyKCdhbmltLicgKyBwLmFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICBcbiAgfSk7XG5cblxuICBRLlNwcml0ZS5leHRlbmQoXCJSZXBlYXRlclwiLHtcbiAgICBpbml0OiBmdW5jdGlvbihwcm9wcykge1xuICAgICAgdGhpcy5fc3VwZXIoUS5fZGVmYXVsdHMocHJvcHMse1xuICAgICAgICBzcGVlZFg6IDEsXG4gICAgICAgIHNwZWVkWTogMSxcbiAgICAgICAgcmVwZWF0WTogdHJ1ZSxcbiAgICAgICAgcmVwZWF0WDogdHJ1ZSxcbiAgICAgICAgcmVuZGVyQWx3YXlzOiB0cnVlLFxuICAgICAgICB0eXBlOiAwXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnAucmVwZWF0VyA9IHRoaXMucC5yZXBlYXRXIHx8IHRoaXMucC53O1xuICAgICAgdGhpcy5wLnJlcGVhdEggPSB0aGlzLnAucmVwZWF0SCB8fCB0aGlzLnAuaDtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgcCA9IHRoaXMucCxcbiAgICAgICAgICBhc3NldCA9IHRoaXMuYXNzZXQoKSxcbiAgICAgICAgICBzaGVldCA9IHRoaXMuc2hlZXQoKSxcbiAgICAgICAgICBzY2FsZSA9IHRoaXMuc3RhZ2Uudmlld3BvcnQgPyB0aGlzLnN0YWdlLnZpZXdwb3J0LnNjYWxlIDogMSxcbiAgICAgICAgICB2aWV3WCA9IE1hdGguZmxvb3IodGhpcy5zdGFnZS52aWV3cG9ydCA/IHRoaXMuc3RhZ2Uudmlld3BvcnQueCA6IDApLFxuICAgICAgICAgIHZpZXdZID0gTWF0aC5mbG9vcih0aGlzLnN0YWdlLnZpZXdwb3J0ID8gdGhpcy5zdGFnZS52aWV3cG9ydC55IDogMCksXG4gICAgICAgICAgb2Zmc2V0WCA9IE1hdGguZmxvb3IocC54ICsgdmlld1ggKiB0aGlzLnAuc3BlZWRYKSxcbiAgICAgICAgICBvZmZzZXRZID0gTWF0aC5mbG9vcihwLnkgKyB2aWV3WSAqIHRoaXMucC5zcGVlZFkpLFxuICAgICAgICAgIGN1clgsIGN1clksIHN0YXJ0WDtcbiAgICAgIGlmKHAucmVwZWF0WCkge1xuICAgICAgICBjdXJYID0gLW9mZnNldFggJSBwLnJlcGVhdFc7XG4gICAgICAgIGlmKGN1clggPiAwKSB7IGN1clggLT0gcC5yZXBlYXRXOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJYID0gcC54IC0gdmlld1g7XG4gICAgICB9XG4gICAgICBpZihwLnJlcGVhdFkpIHtcbiAgICAgICAgY3VyWSA9IC1vZmZzZXRZICUgcC5yZXBlYXRIO1xuICAgICAgICBpZihjdXJZID4gMCkgeyBjdXJZIC09IHAucmVwZWF0SDsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyWSA9IHAueSAtIHZpZXdZO1xuICAgICAgfVxuXG4gICAgICBzdGFydFggPSBjdXJYO1xuICAgICAgd2hpbGUoY3VyWSA8IFEuaGVpZ2h0IC8gc2NhbGUpIHtcbiAgICAgICAgY3VyWCA9IHN0YXJ0WDtcbiAgICAgICAgd2hpbGUoY3VyWCA8IFEud2lkdGggLyBzY2FsZSkge1xuICAgICAgICAgIGlmKHNoZWV0KSB7XG4gICAgICAgICAgICBzaGVldC5kcmF3KGN0eCxjdXJYICsgdmlld1gsY3VyWSArIHZpZXdZLHAuZnJhbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGFzc2V0LGN1clggKyB2aWV3WCxjdXJZICsgdmlld1kpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJYICs9IHAucmVwZWF0VztcbiAgICAgICAgICBpZighcC5yZXBlYXRYKSB7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgY3VyWSArPSBwLnJlcGVhdEg7XG4gICAgICAgIGlmKCFwLnJlcGVhdFkpIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIFEuVHdlZW4gPSBRLkNsYXNzLmV4dGVuZCh7XG4gICAgaW5pdDogZnVuY3Rpb24oZW50aXR5LHByb3BlcnRpZXMsZHVyYXRpb24sZWFzaW5nLG9wdGlvbnMpIHtcbiAgICAgIGlmKFEuX2lzT2JqZWN0KGVhc2luZykpIHsgb3B0aW9ucyA9IGVhc2luZzsgZWFzaW5nID0gUS5FYXNpbmcuTGluZWFyOyB9XG4gICAgICBpZihRLl9pc09iamVjdChkdXJhdGlvbikpIHsgb3B0aW9ucyA9IGR1cmF0aW9uOyBkdXJhdGlvbiA9IDE7IH1cblxuICAgICAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG4gICAgICAvL3RoaXMucCA9IChlbnRpdHkgaW5zdGFuY2VvZiBRLlN0YWdlKSA/IGVudGl0eS52aWV3cG9ydCA6IGVudGl0eS5wO1xuICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDE7XG4gICAgICB0aGlzLnRpbWUgPSAwO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuZGVsYXkgPSB0aGlzLm9wdGlvbnMuZGVsYXkgfHwgMDtcbiAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IHRoaXMub3B0aW9ucy5lYXNpbmcgfHwgUS5FYXNpbmcuTGluZWFyO1xuXG4gICAgICB0aGlzLnN0YXJ0RnJhbWUgPSBRLl9sb29wRnJhbWUgKyAxO1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgIHRoaXMuc3RhcnQgPSB7fTtcbiAgICAgIHRoaXMuZGlmZiA9IHt9O1xuICAgIH0sXG5cbiAgICBzdGVwOiBmdW5jdGlvbihkdCkge1xuICAgICAgdmFyIHByb3BlcnR5O1xuXG4gICAgICBpZih0aGlzLnN0YXJ0RnJhbWUgPiBRLl9sb29wRnJhbWUpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGlmKHRoaXMuZGVsYXkgPj0gZHQpIHtcbiAgICAgICAgdGhpcy5kZWxheSAtPSBkdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMuZGVsYXkgPiAwKSB7XG4gICAgICAgIGR0IC09IHRoaXMuZGVsYXk7XG4gICAgICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZih0aGlzLnRpbWUgPT09IDApIHtcbiAgICAgICAgLy8gZmlyc3QgdGltZSBydW5uaW5nPyBJbml0aWFsaXplIHRoZSBwcm9wZXJ0aWVzIHRvIGNoYWluaW5nIGNvcnJlY3RseS5cbiAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuZW50aXR5LCBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnAgPSAoZW50aXR5IGluc3RhbmNlb2YgUS5TdGFnZSkgPyBlbnRpdHkudmlld3BvcnQgOiBlbnRpdHkucDtcbiAgICAgICAgZm9yKHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0W3Byb3BlcnR5XSA9IHRoaXMucFtwcm9wZXJ0eV07XG4gICAgICAgICAgaWYoIVEuX2lzVW5kZWZpbmVkKHRoaXMuc3RhcnRbcHJvcGVydHldKSkge1xuICAgICAgICAgICAgdGhpcy5kaWZmW3Byb3BlcnR5XSA9IHByb3BlcnRpZXNbcHJvcGVydHldIC0gdGhpcy5zdGFydFtwcm9wZXJ0eV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRpbWUgKz0gZHQ7XG5cbiAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKDEsdGhpcy50aW1lIC8gdGhpcy5kdXJhdGlvbiksXG4gICAgICAgICAgbG9jYXRpb24gPSB0aGlzLmVhc2luZyhwcm9ncmVzcyk7XG5cbiAgICAgIGZvcihwcm9wZXJ0eSBpbiB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIGlmKCFRLl9pc1VuZGVmaW5lZCh0aGlzLnBbcHJvcGVydHldKSkge1xuICAgICAgICAgIHRoaXMucFtwcm9wZXJ0eV0gPSB0aGlzLnN0YXJ0W3Byb3BlcnR5XSArIHRoaXMuZGlmZltwcm9wZXJ0eV0gKiBsb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5jYWxsYmFjaykgeyBcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY2FsbGJhY2suYXBwbHkodGhpcy5lbnRpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3Jlc3MgPCAxO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ29kZSByaXBwZWQgZGlyZWN0bHkgZnJvbSBUd2Vlbi5qc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ibG9iL21hc3Rlci9zcmMvVHdlZW4uanNcbiAgUS5FYXNpbmcgPSB7XG4gICAgTGluZWFyOiBmdW5jdGlvbiAoaykgeyByZXR1cm4gazsgfSxcblxuICAgIFF1YWRyYXRpYzoge1xuICAgICAgSW46IGZ1bmN0aW9uICggayApICB7IHJldHVybiBrICogazsgfSxcbiAgICAgIE91dDogZnVuY3Rpb24gKCBrICkge3JldHVybiBrICogKCAyIC0gayApOyB9LFxuICAgICAgSW5PdXQ6IGZ1bmN0aW9uICggayApIHtcbiAgICAgICAgaWYgKChrICo9IDIgKSA8IDEpIHsgcmV0dXJuIDAuNSAqIGsgKiBrOyB9XG4gICAgICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUS5jb21wb25lbnQoJ3R3ZWVuJyx7XG4gICAgYWRkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdHdlZW5zID0gW107XG4gICAgICB0aGlzLmVudGl0eS5vbihcInN0ZXBcIix0aGlzLFwic3RlcFwiKTtcbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgYW5pbWF0ZTogZnVuY3Rpb24ocHJvcGVydGllcyxkdXJhdGlvbixlYXNpbmcsb3B0aW9ucykge1xuICAgICAgICB0aGlzLnR3ZWVuLl90d2VlbnMucHVzaChuZXcgUS5Ud2Vlbih0aGlzLHByb3BlcnRpZXMsZHVyYXRpb24sZWFzaW5nLG9wdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBjaGFpbjogZnVuY3Rpb24ocHJvcGVydGllcyxkdXJhdGlvbixlYXNpbmcsb3B0aW9ucykge1xuICAgICAgICBpZihRLl9pc09iamVjdChlYXNpbmcpKSB7IG9wdGlvbnMgPSBlYXNpbmc7IGVhc2luZyA9IFEuRWFzaW5nLkxpbmVhcjsgfVxuICAgICAgICAvLyBDaGFpbiBhbiBhbmltYXRpb24gdG8gdGhlIGVuZFxuICAgICAgICB2YXIgdHdlZW5DbnQgPSB0aGlzLnR3ZWVuLl90d2VlbnMubGVuZ3RoO1xuICAgICAgICBpZih0d2VlbkNudCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdFR3ZWVuID0gdGhpcy50d2Vlbi5fdHdlZW5zW3R3ZWVuQ250IC0gMV07XG4gICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgb3B0aW9uc1snZGVsYXknXSA9IGxhc3RUd2Vlbi5kdXJhdGlvbiAtIGxhc3RUd2Vlbi50aW1lICsgbGFzdFR3ZWVuLmRlbGF5O1xuICAgICAgICB9IFxuXG4gICAgICAgIHRoaXMuYW5pbWF0ZShwcm9wZXJ0aWVzLGR1cmF0aW9uLGVhc2luZyxvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50d2Vlbi5fdHdlZW5zLmxlbmd0aCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGVwOiBmdW5jdGlvbihkdCkge1xuICAgICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLl90d2VlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoIXRoaXMuX3R3ZWVuc1tpXS5zdGVwKGR0KSkge1xuICAgICAgICAgIHRoaXMuX3R3ZWVucy5zcGxpY2UoaSwxKTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG5cbn07XG5cbiIsIi8qZ2xvYmFsIFF1aW50dXM6ZmFsc2UsIEF1ZGlvQ29udGV4dDpmYWxzZSwgd2luZG93OmZhbHNlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUSkge1xuXG4gIFEuYXVkaW8gPSB7XG4gICAgY2hhbm5lbHM6IFtdLFxuICAgIGNoYW5uZWxNYXg6ICBRLm9wdGlvbnMuY2hhbm5lbE1heCB8fCAxMCxcbiAgICBhY3RpdmU6IHt9LFxuICAgIHBsYXk6IGZ1bmN0aW9uKCkge31cbiAgfTtcblxuXG4gIFEuaGFzV2ViQXVkaW8gPSAodHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikgfHwgKHR5cGVvZiB3ZWJraXRBdWRpb0NvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpO1xuXG4gIGlmKFEuaGFzV2ViQXVkaW8pIHsgXG4gICAgaWYodHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgUS5hdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFEuYXVkaW9Db250ZXh0ID0gbmV3IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQoKTtcbiAgICB9XG4gIH1cblxuICBRLmVuYWJsZVNvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhhc1RvdWNoID0gICEhKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG5cbiAgICBpZihRLmhhc1dlYkF1ZGlvKSB7XG4gICAgICBRLmF1ZGlvLmVuYWJsZVdlYkF1ZGlvU291bmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUS5hdWRpby5lbmFibGVIVE1MNVNvdW5kKCk7XG4gICAgfVxuICAgIHJldHVybiBRO1xuICB9O1xuXG4gIFEuYXVkaW8uZW5hYmxlV2ViQXVkaW9Tb3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgIFEuYXVkaW8udHlwZSA9IFwiV2ViQXVkaW9cIjtcblxuICAgIFEuYXVkaW8uc291bmRJRCA9IDA7XG5cbiAgICBRLmF1ZGlvLnBsYXlpbmdTb3VuZHMgPSB7fTtcblxuICAgIFEuYXVkaW8ucmVtb3ZlU291bmQgPSBmdW5jdGlvbihzb3VuZElEKSB7XG4gICAgICBkZWxldGUgUS5hdWRpby5wbGF5aW5nU291bmRzW3NvdW5kSURdO1xuICAgIH07XG5cbiAgICAvLyBQbGF5IGEgc2luZ2xlIHNvdW5kLCBvcHRpb25hbGx5IGRlYm91bmNlZCBcbiAgICAvLyB0byBwcmV2ZW50IHJlcGVhdGVkIHBsYXlzIGluIGEgc2hvcnQgdGltZVxuICAgIFEuYXVkaW8ucGxheSA9IGZ1bmN0aW9uKHMsb3B0aW9ucykge1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAvLyBTZWUgaWYgdGhpcyBhdWRpbyBmaWxlIGlzIGN1cnJlbnRseSBiZWluZyBkZWJvdW5jZWQsIGlmIFxuICAgICAgLy8gaXQgaXMsIGRvbid0IGRvIGFueXRoaW5nIGFuZCBqdXN0IHJldHVyblxuICAgICAgaWYoUS5hdWRpby5hY3RpdmVbc10gJiYgUS5hdWRpby5hY3RpdmVbc10gPiBub3cpIHsgcmV0dXJuOyB9XG5cbiAgICAgIC8vIElmIGFueSBvcHRpb25zIHdlcmUgcGFzc2VkIGluLCBjaGVjayBmb3IgYSBkZWJvdW5jZSxcbiAgICAgIC8vIHdoaWNoIGlzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlYm91bmNlIHRoaXMgc291bmRcbiAgICAgIGlmKG9wdGlvbnMgJiYgb3B0aW9uc1snZGVib3VuY2UnXSkge1xuICAgICAgICBRLmF1ZGlvLmFjdGl2ZVtzXSA9IG5vdyArIG9wdGlvbnNbJ2RlYm91bmNlJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgUS5hdWRpby5hY3RpdmVbc107XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VuZElEID0gUS5hdWRpby5zb3VuZElEKys7XG5cbiAgICAgIHZhciBzb3VyY2UgPSBRLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIHNvdXJjZS5idWZmZXIgPSBRLmFzc2V0KHMpO1xuICAgICAgc291cmNlLmNvbm5lY3QoUS5hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zWydsb29wJ10pIHtcbiAgICAgICAgc291cmNlLmxvb3AgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBRLmF1ZGlvLnJlbW92ZVNvdW5kKHNvdW5kSUQpO1xuICAgICAgICB9LHNvdXJjZS5idWZmZXIuZHVyYXRpb24gKiAxMDAwKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5hc3NldE5hbWUgPSBzO1xuICAgICAgaWYoc291cmNlLnN0YXJ0KSB7IHNvdXJjZS5zdGFydCgwKTsgfSBlbHNlIHsgc291cmNlLm5vdGVPbigwKTsgfVxuXG4gICAgICBRLmF1ZGlvLnBsYXlpbmdTb3VuZHNbc291bmRJRF0gPSBzb3VyY2U7XG5cblxuICAgIH07XG5cbiAgICBRLmF1ZGlvLnN0b3AgPSBmdW5jdGlvbihzKSB7XG4gICAgICBmb3IodmFyIGtleSBpbiBRLmF1ZGlvLnBsYXlpbmdTb3VuZHMpIHtcbiAgICAgICAgdmFyIHNuZCA9IFEuYXVkaW8ucGxheWluZ1NvdW5kc1trZXldO1xuICAgICAgICBpZighcyB8fCBzID09PSBzbmQuYXNzZXROYW1lKSB7XG4gICAgICAgICAgaWYoc25kLnN0b3ApIHsgc25kLnN0b3AoMCk7ICB9IGVsc2UgeyAgc25kLm5vdGVPZmYoMCk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgfTtcblxuICBRLmF1ZGlvLmVuYWJsZUhUTUw1U291bmQgPSBmdW5jdGlvbigpIHtcbiAgICBRLmF1ZGlvLnR5cGUgPSBcIkhUTUw1XCI7XG5cbiAgICBmb3IgKHZhciBpPTA7aTxRLmF1ZGlvLmNoYW5uZWxNYXg7aSsrKSB7XHRcbiAgICAgIFEuYXVkaW8uY2hhbm5lbHNbaV0gPSB7fTtcbiAgICAgIFEuYXVkaW8uY2hhbm5lbHNbaV1bJ2NoYW5uZWwnXSA9IG5ldyBBdWRpbygpOyBcbiAgICAgIFEuYXVkaW8uY2hhbm5lbHNbaV1bJ2ZpbmlzaGVkJ10gPSAtMTtcdFxuICAgIH1cblxuICAgIC8vIFBsYXkgYSBzaW5nbGUgc291bmQsIG9wdGlvbmFsbHkgZGVib3VuY2VkIFxuICAgIC8vIHRvIHByZXZlbnQgcmVwZWF0ZWQgcGxheXMgaW4gYSBzaG9ydCB0aW1lXG4gICAgUS5hdWRpby5wbGF5ID0gZnVuY3Rpb24ocyxvcHRpb25zKSB7XG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgIC8vIFNlZSBpZiB0aGlzIGF1ZGlvIGZpbGUgaXMgY3VycmVudGx5IGJlaW5nIGRlYm91bmNlZCwgaWYgXG4gICAgICAvLyBpdCBpcywgZG9uJ3QgZG8gYW55dGhpbmcgYW5kIGp1c3QgcmV0dXJuXG4gICAgICBpZihRLmF1ZGlvLmFjdGl2ZVtzXSAmJiBRLmF1ZGlvLmFjdGl2ZVtzXSA+IG5vdykgeyByZXR1cm47IH1cblxuICAgICAgLy8gSWYgYW55IG9wdGlvbnMgd2VyZSBwYXNzZWQgaW4sIGNoZWNrIGZvciBhIGRlYm91bmNlLFxuICAgICAgLy8gd2hpY2ggaXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVib3VuY2UgdGhpcyBzb3VuZFxuICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zWydkZWJvdW5jZSddKSB7XG4gICAgICAgIFEuYXVkaW8uYWN0aXZlW3NdID0gbm93ICsgb3B0aW9uc1snZGVib3VuY2UnXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBRLmF1ZGlvLmFjdGl2ZVtzXTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBhIGZyZWUgYXVkaW8gY2hhbm5lbCBhbmQgcGxheSB0aGUgc291bmRcbiAgICAgIGZvciAodmFyIGk9MDtpPFEuYXVkaW8uY2hhbm5lbHMubGVuZ3RoO2krKykge1xuICAgICAgICAvLyBDaGVjayB0aGUgY2hhbm5lbCBpcyBlaXRoZXIgZmluaXNoZWQgb3Igbm90IGxvb3BpbmdcbiAgICAgICAgaWYgKCFRLmF1ZGlvLmNoYW5uZWxzW2ldWydsb29wJ10gJiYgUS5hdWRpby5jaGFubmVsc1tpXVsnZmluaXNoZWQnXSA8IG5vdykge1x0XG5cbiAgICAgICAgICBRLmF1ZGlvLmNoYW5uZWxzW2ldWydjaGFubmVsJ10uc3JjID0gUS5hc3NldChzKS5zcmM7XG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBsb29waW5nIC0ganVzdCBzZXQgbG9vcCB0byB0cnVlIHRvIHByZXZlbnQgdGhpcyBjaGFubmNlbFxuICAgICAgICAgIC8vIGZyb20gYmVpbmcgdXNlZC5cbiAgICAgICAgICBpZihvcHRpb25zICYmIG9wdGlvbnNbJ2xvb3AnXSkgeyBcbiAgICAgICAgICAgIFEuYXVkaW8uY2hhbm5lbHNbaV1bJ2xvb3AnXSA9IHRydWU7XG4gICAgICAgICAgICBRLmF1ZGlvLmNoYW5uZWxzW2ldWydjaGFubmVsJ10ubG9vcCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFEuYXVkaW8uY2hhbm5lbHNbaV1bJ2ZpbmlzaGVkJ10gPSBub3cgKyBRLmFzc2V0KHMpLmR1cmF0aW9uKjEwMDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFEuYXVkaW8uY2hhbm5lbHNbaV1bJ2NoYW5uZWwnXS5sb2FkKCk7XG4gICAgICAgICAgUS5hdWRpby5jaGFubmVsc1tpXVsnY2hhbm5lbCddLnBsYXkoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTdG9wIGEgc2luZ2xlIHNvdW5kIGFzc2V0IG9yIHN0b3AgYWxsIHNvdW5kcyBjdXJyZW50bHkgcGxheWluZ1xuICAgIFEuYXVkaW8uc3RvcCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBzcmMgPSBzID8gUS5hc3NldChzKS5zcmMgOiBudWxsO1xuICAgICAgdmFyIHRtID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBmb3IgKHZhciBpPTA7aTxRLmF1ZGlvLmNoYW5uZWxzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgaWYgKCghc3JjIHx8IFEuYXVkaW8uY2hhbm5lbHNbaV1bJ2NoYW5uZWwnXS5zcmMgPT09IHNyYykgJiYgXG4gICAgICAgICAgICAoUS5hdWRpby5jaGFubmVsc1tpXVsnbG9vcCddIHx8IFEuYXVkaW8uY2hhbm5lbHNbaV1bJ2ZpbmlzaGVkJ10gPj0gdG0pKSB7XG4gICAgICAgICAgUS5hdWRpby5jaGFubmVsc1tpXVsnY2hhbm5lbCddLnBhdXNlKCk7XG4gICAgICAgICAgUS5hdWRpby5jaGFubmVsc1tpXVsnbG9vcCddID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIH07XG5cbn07XG4gIFxuIiwiLypnbG9iYWwgUXVpbnR1czpmYWxzZSAqL1xuLyoqXG5RdWludHVzIEhUTUw1IEdhbWUgRW5naW5lIC0gSW5wdXQgTW9kdWxlXG5cblRoZSBjb2RlIGluIGBxdWludHVzX2lucHV0LmpzYCBkZWZpbmVzIHRoZSBgUXVpbnR1cy5JbnB1dGAgbW9kdWxlLCB3aGljaFxuY29uY2VybnMgaXRzZWxmIHdpdGggZ2FtZS10eXBlIChwcmV0dHkgYW55dGhpbmcgYmVzaWRlcyB0b3VjaHNjcmVlbiBpbnB1dClcblxuQG1vZHVsZSBRdWludHVzLklucHV0XG4qL1xuXG4vKipcbiAqIFF1aW50dXMgSW5wdXQgTW9kdWxlXG4gKlxuICogQGNsYXNzIFF1aW50dXMuSW5wdXRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihRKSB7XG4gIC8qKlxuICAgKiBQcm92aWRlZCBrZXkgbmFtZXMgbWFwcGVkIHRvIGtleSBjb2RlcyAtIGFkZCBtb3JlIG5hbWVzIGFuZCBrZXkgY29kZXMgYXMgbmVjZXNzYXJ5XG4gICAqXG4gICAqIEBmb3IgUXVpbnR1cy5JbnB1dFxuICAgKiBAcHJvcGVydHkgS0VZX05BTUVTXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqL1xuICB2YXIgS0VZX05BTUVTID0gUS5LRVlfTkFNRVMgPSB7XG4gICAgTEVGVDogMzcsIFJJR0hUOiAzOSxcbiAgICBVUDogMzgsIERPV046IDQwLFxuICAgIFNQQUNFOiAzMixcbiAgICBaOiA5MCxcbiAgICBYOiA4OCxcbiAgICBFTlRFUjogMTMsXG4gICAgRVNDOiAyNyxcbiAgICBQOiA4MCxcbiAgICBTOiA4M1xuICB9O1xuXG4gIHZhciBERUZBVUxUX0tFWVMgPSB7XG4gICAgTEVGVDogJ2xlZnQnLCBSSUdIVDogJ3JpZ2h0JyxcbiAgICBVUDogJ3VwJywgICAgIERPV046ICdkb3duJyxcbiAgICBTUEFDRTogJ2ZpcmUnLFxuICAgIFo6ICdmaXJlJyxcbiAgICBYOiAnYWN0aW9uJyxcbiAgICBFTlRFUjogJ2NvbmZpcm0nLFxuICAgIEVTQzogJ2VzYycsXG4gICAgUDogJ1AnLFxuICAgIFM6ICdTJ1xuICB9O1xuXG4gIHZhciBERUZBVUxUX1RPVUNIX0NPTlRST0xTICA9IFsgWydsZWZ0JywnPCcgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ3JpZ2h0JywnPicgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ2FjdGlvbicsJ2InXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ2ZpcmUnLCAnYScgXV07XG5cbiAgLy8gQ2xvY2t3aXNlIGZyb20gbWlkbmlnaHQgKGEgbGEgQ1NTKVxuICB2YXIgREVGQVVMVF9KT1lQQURfSU5QVVRTID0gIFsgJ3VwJywncmlnaHQnLCdkb3duJywnbGVmdCddO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHN0YXRlIG9mIGJvdW5kIGlucHV0c1xuICAgKlxuICAgKiBAZm9yIFF1aW50dXMuSW5wdXRcbiAgICogQHByb3BlcnR5IFEuaW5wdXRzXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cbiAgUS5pbnB1dHMgPSB7fTtcbiAgUS5qb3lwYWQgPSB7fTtcblxuICB2YXIgaGFzVG91Y2ggPSAgISEoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcblxuXG4gIC8qKlxuICAgKlxuICAgKiBDb252ZXJ0IGEgY2FudmFzIHBvaW50IHRvIGEgc3RhZ2UgcG9pbnQsIHggZGltZW5zaW9uXG4gICAqXG4gICAqIEBtZXRob2QgUS5jYW52YXNUb1N0YWdlWFxuICAgKiBAZm9yIFF1aW50dXMuSW5wdXRcbiAgICogQHBhcmFtIHtGbG9hdH0geFxuICAgKiBAcGFyYW0ge1EuU3RhZ2V9IHN0YWdlXG4gICAqIEByZXR1cm5zIHtJbnRlZ2VyfSB4XG4gICAqL1xuICBRLmNhbnZhc1RvU3RhZ2VYID0gZnVuY3Rpb24oeCxzdGFnZSkge1xuICAgIHggPSB4IC8gUS5jc3NXaWR0aCAqIFEud2lkdGg7XG4gICAgaWYoc3RhZ2Uudmlld3BvcnQpIHtcbiAgICAgIHggLz0gc3RhZ2Uudmlld3BvcnQuc2NhbGU7XG4gICAgICB4ICs9IHN0YWdlLnZpZXdwb3J0Lng7XG4gICAgfVxuXG4gICAgcmV0dXJuIHg7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIENvbnZlcnQgYSBjYW52YXMgcG9pbnQgdG8gYSBzdGFnZSBwb2ludCwgeSBkaW1lbnNpb25cbiAgICpcbiAgICogQG1ldGhvZCBRLmNhbnZhc1RvU3RhZ2VZXG4gICAqIEBwYXJhbSB7RmxvYXR9IHlcbiAgICogQHBhcmFtIHtRLlN0YWdlfSBzdGFnZVxuICAgKiBAcmV0dXJucyB7SW50ZWdlcn0geVxuICAgKi9cbiAgUS5jYW52YXNUb1N0YWdlWSA9IGZ1bmN0aW9uKHksc3RhZ2UpIHtcbiAgICAgIHkgPSB5IC8gUS5jc3NXaWR0aCAqIFEud2lkdGg7XG4gICAgICBpZihzdGFnZS52aWV3cG9ydCkge1xuICAgICAgICB5IC89IHN0YWdlLnZpZXdwb3J0LnNjYWxlO1xuICAgICAgICB5ICs9IHN0YWdlLnZpZXdwb3J0Lnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB5O1xuICB9O1xuXG5cblxuICAvKipcbiAgICpcbiAgICogQnV0dG9uIGFuZCBtb3VzZSBpbnB1dCBzdWJzeXN0ZW0gZm9yIFF1aW50dXMuXG4gICAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgYXV0by1jcmVhdGVkIGFzIHt7I2Nyb3NzTGluayBcIlEuaW5wdXRcIn19e3svY3Jvc3NMaW5rfX1cbiAgICpcbiAgICogQGNsYXNzIFEuSW5wdXRTeXN0ZW1cbiAgICogQGV4dGVuZHMgUS5FdmVudGVkXG4gICAqIEBmb3IgUXVpbnR1cy5JbnB1dFxuICAgKi9cbiAgUS5JbnB1dFN5c3RlbSA9IFEuRXZlbnRlZC5leHRlbmQoe1xuICAgIGtleXM6IHt9LFxuICAgIGtleXBhZDoge30sXG4gICAga2V5Ym9hcmRFbmFibGVkOiBmYWxzZSxcbiAgICB0b3VjaEVuYWJsZWQ6IGZhbHNlLFxuICAgIGpveXBhZEVuYWJsZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQmluZCBhIGtleSBuYW1lIG9yIGtleWNvZGUgdG8gYW4gYWN0aW9uIG5hbWUgKHVzZWQgYnkgYGtleWJvYXJkQ29udHJvbHNgKVxuICAgICAqXG4gICAgICogQG1ldGhvZCBiaW5kS2V5XG4gICAgICogQGZvciBRLklucHV0U3lzdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmcgb3IgSW50ZWdlcn0ga2V5IC0gbmFtZSBvciBpbnRlZ2VyIGtleWNvZGUgZm9yIHRvIGJpbmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWUgb2YgYWN0aW9uIHRvIGJpbmQgdG9cbiAgICAgKi9cbiAgICBiaW5kS2V5OiBmdW5jdGlvbihrZXksbmFtZSkge1xuICAgICAgUS5pbnB1dC5rZXlzW0tFWV9OQU1FU1trZXldIHx8IGtleV0gPSBuYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUga2V5Ym9hcmQgY29udHJvbHMgYnkgYmluZGluZyB0byBldmVudHNcbiAgICAgKlxuICAgICAqIEBmb3IgUS5JbnB1dFN5c3RlbVxuICAgICAqIEBtZXRob2QgZW5hYmxlS2V5Ym9hcmRcbiAgICAgKi9cbiAgICBlbmFibGVLZXlib2FyZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLmtleWJvYXJkRW5hYmxlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgLy8gTWFrZSBzZWxlY3RhYmxlIGFuZCByZW1vdmUgYW4gOmZvY3VzIG91dGxpbmVcbiAgICAgIFEuZWwudGFiSW5kZXggPSAwO1xuICAgICAgUS5lbC5zdHlsZS5vdXRsaW5lID0gMDtcblxuICAgICAgUS5lbC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoUS5pbnB1dC5rZXlzW2Uua2V5Q29kZV0pIHtcbiAgICAgICAgICB2YXIgYWN0aW9uTmFtZSA9IFEuaW5wdXQua2V5c1tlLmtleUNvZGVdO1xuICAgICAgICAgIFEuaW5wdXRzW2FjdGlvbk5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBRLmlucHV0LnRyaWdnZXIoYWN0aW9uTmFtZSk7XG4gICAgICAgICAgUS5pbnB1dC50cmlnZ2VyKCdrZXlkb3duJyxlLmtleUNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sZmFsc2UpO1xuXG4gICAgICBRLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoUS5pbnB1dC5rZXlzW2Uua2V5Q29kZV0pIHtcbiAgICAgICAgICB2YXIgYWN0aW9uTmFtZSA9IFEuaW5wdXQua2V5c1tlLmtleUNvZGVdO1xuICAgICAgICAgIFEuaW5wdXRzW2FjdGlvbk5hbWVdID0gZmFsc2U7XG4gICAgICAgICAgUS5pbnB1dC50cmlnZ2VyKGFjdGlvbk5hbWUgKyBcIlVwXCIpO1xuICAgICAgICAgIFEuaW5wdXQudHJpZ2dlcigna2V5dXAnLGUua2V5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSxmYWxzZSk7XG5cbiAgICAgIGlmKFEub3B0aW9ucy5hdXRvRm9jdXMpIHsgIFEuZWwuZm9jdXMoKTsgfVxuICAgICAgdGhpcy5rZXlib2FyZEVuYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhY3RpdmF0ZSBrZXlib2FyZCBjb250cm9scyAoY2FsbCBgYmluZEtleWAgYW5kIGBlbmFibGVLZXlib2FyZGAgaW50ZXJuYWxseSlcbiAgICAgICpcbiAgICAgKiBAbWV0aG9kIGtleWJvYXJkQ29udHJvbHNcbiAgICAgKiBAZm9yIFEuSW5wdXRTeXN0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2tleXNdIC0gaGFzaCBvZiBrZXkgbmFtZXMgb3IgY29kZXMgdG8gYWN0aW9uc1xuICAgICAqL1xuICAgIGtleWJvYXJkQ29udHJvbHM6IGZ1bmN0aW9uKGtleXMpIHtcbiAgICAgIGtleXMgPSBrZXlzIHx8IERFRkFVTFRfS0VZUztcbiAgICAgIFEuX2VhY2goa2V5cyxmdW5jdGlvbihuYW1lLGtleSkge1xuICAgICAgIHRoaXMuYmluZEtleShrZXksbmFtZSk7XG4gICAgICB9LFEuaW5wdXQpO1xuICAgICAgdGhpcy5lbmFibGVLZXlib2FyZCgpO1xuICAgIH0sXG5cbiAgICBfY29udGFpbmVyT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIFEuaW5wdXQub2Zmc2V0WCA9IDA7XG4gICAgICBRLmlucHV0Lm9mZnNldFkgPSAwO1xuICAgICAgdmFyIGVsID0gUS5lbDtcbiAgICAgIGRvIHtcbiAgICAgICAgUS5pbnB1dC5vZmZzZXRYICs9IGVsLm9mZnNldExlZnQ7XG4gICAgICAgIFEuaW5wdXQub2Zmc2V0WSArPSBlbC5vZmZzZXRUb3A7XG4gICAgICB9IHdoaWxlKGVsID0gZWwub2Zmc2V0UGFyZW50KTtcbiAgICB9LFxuXG4gICAgdG91Y2hMb2NhdGlvbjogZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHZhciBlbCA9IFEuZWwsIFxuICAgICAgICBwb3NYID0gdG91Y2gub2Zmc2V0WCxcbiAgICAgICAgcG9zWSA9IHRvdWNoLm9mZnNldFksXG4gICAgICAgIHRvdWNoWCwgdG91Y2hZO1xuXG4gICAgICBpZihRLl9pc1VuZGVmaW5lZChwb3NYKSB8fCBRLl9pc1VuZGVmaW5lZChwb3NZKSkge1xuICAgICAgICBwb3NYID0gdG91Y2gubGF5ZXJYO1xuICAgICAgICBwb3NZID0gdG91Y2gubGF5ZXJZO1xuICAgICAgfVxuXG4gICAgICBpZihRLl9pc1VuZGVmaW5lZChwb3NYKSB8fCBRLl9pc1VuZGVmaW5lZChwb3NZKSkge1xuICAgICAgICBpZihRLmlucHV0Lm9mZnNldFggPT09IHZvaWQgMCkgeyBRLmlucHV0Ll9jb250YWluZXJPZmZzZXQoKTsgfVxuICAgICAgICBwb3NYID0gdG91Y2gucGFnZVggLSBRLmlucHV0Lm9mZnNldFg7XG4gICAgICAgIHBvc1kgPSB0b3VjaC5wYWdlWSAtIFEuaW5wdXQub2Zmc2V0WTtcbiAgICAgIH1cblxuICAgICAgdG91Y2hYID0gUS53aWR0aCAqIHBvc1ggLyBRLmNzc1dpZHRoO1xuICAgICAgdG91Y2hZID0gUS5oZWlnaHQgKiBwb3NZIC8gUS5jc3NIZWlnaHQ7XG5cblxuICAgICAgcmV0dXJuIHsgeDogdG91Y2hYLCB5OiB0b3VjaFkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgdG91Y2ggYnV0dG9uIGNvbnRyb2xzIC0gcGFzcyBpbiBhbiBvcHRpb25zIGhhc2ggdG8gb3ZlcnJpZGVcbiAgICAgKlxuICAgICAqIERlZmF1bHQgT3B0aW9uczpcbiAgICAgKlxuICAgICAqICAgICB7XG4gICAgICogICAgICAgIGxlZnQ6IDAsXG4gICAgICogICAgICAgIGd1dHRlcjoxMCxcbiAgICAgKiAgICAgICAgY29udHJvbHM6IERFRkFVTFRfVE9VQ0hfQ09OVFJPTFMsXG4gICAgICogICAgICAgIHdpZHRoOiBRLndpZHRoLFxuICAgICAqICAgICAgICBib3R0b206IFEuaGVpZ2h0XG4gICAgICogICAgICB9XG4gICAgICpcbiAgICAgKiBEZWZhdWx0IGNvbnRyb2xzIGFyZSBsZWZ0IGFuZCByaWdodCBidXR0b25zLCBhIHNwYWNlLCBhbmQgJ2EnIGFuZCAnYicgYnV0dG9ucywgYXMgZGVmaW5lZCBhcyBhbiBBcnJheSBvZiBBcnJheXMgYmVsb3c6XG4gICAgICpcbiAgICAgKiAgICAgIFsgWydsZWZ0JywnPCcgXSxcbiAgICAgKiAgICAgICAgWydyaWdodCcsJz4nIF0sXG4gICAgICogICAgICAgIFtdLCAgLy8gdXNlIGFuIGVtcHR5IGFycmF5IGFzIGEgc3BhY2VyXG4gICAgICogICAgICAgIFsnYWN0aW9uJywnYiddLFxuICAgICAqICAgICAgICBbJ2ZpcmUnLCAnYScgXV1cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG91Y2hDb250cm9sc1xuICAgICAqIEBmb3IgUS5JbnB1dFN5c3RlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25zIGhhc2hcbiAgICAgKi9cbiAgICB0b3VjaENvbnRyb2xzOiBmdW5jdGlvbihvcHRzKSB7XG4gICAgICBpZih0aGlzLnRvdWNoRW5hYmxlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGlmKCFoYXNUb3VjaCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgUS5pbnB1dC5rZXlwYWQgPSBvcHRzID0gUS5fZXh0ZW5kKHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgZ3V0dGVyOjEwLFxuICAgICAgICBjb250cm9sczogREVGQVVMVF9UT1VDSF9DT05UUk9MUyxcbiAgICAgICAgd2lkdGg6IFEud2lkdGgsXG4gICAgICAgIGJvdHRvbTogUS5oZWlnaHQsXG4gICAgICAgIGZ1bGxIZWlnaHQ6IGZhbHNlXG4gICAgICB9LG9wdHMpO1xuXG4gICAgICBvcHRzLnVuaXQgPSAob3B0cy53aWR0aCAvIG9wdHMuY29udHJvbHMubGVuZ3RoKTtcbiAgICAgIG9wdHMuc2l6ZSA9IG9wdHMudW5pdCAtIDIgKiBvcHRzLmd1dHRlcjtcblxuICAgICAgZnVuY3Rpb24gZ2V0S2V5KHRvdWNoKSB7XG4gICAgICAgIHZhciBwb3MgPSBRLmlucHV0LnRvdWNoTG9jYXRpb24odG91Y2gpLFxuICAgICAgICAgICAgbWluWSA9IG9wdHMuYm90dG9tIC0gb3B0cy51bml0O1xuICAgICAgICBmb3IodmFyIGk9MCxsZW49b3B0cy5jb250cm9scy5sZW5ndGg7aTxsZW47aSsrKSB7XG4gICAgICAgICAgdmFyIG1pblggPSBvcHRzLmxlZnQgKyBpICogb3B0cy51bml0ICsgaSAqIG9wdHMuZ3V0dGVyO1xuICAgICAgICAgIGlmKHBvcy54ID49ICBtaW5YICYmIHBvcy54IDw9IChtaW5YK29wdHMudW5pdCkgJiYgKG9wdHMuZnVsbEhlaWdodCB8fCAocG9zLnkgPj0gbWluWSAmJiBwb3MueSA8PSAobWluWStvcHRzLnVuaXQpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRzLmNvbnRyb2xzW2ldWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b3VjaERpc3BhdGNoKGV2ZW50KSB7XG4gICAgICAgIHZhciB3YXNPbiA9IHt9LFxuICAgICAgICAgICAgaSwgbGVuLCB0Y2gsIGtleSwgYWN0aW9uTmFtZTtcblxuICAgICAgICAvLyBSZXNldCBhbGwgdGhlIGFjdGlvbnMgYm91bmQgdG8gY29udHJvbHNcbiAgICAgICAgLy8gYnV0IGtlZXAgdHJhY2sgb2YgYWxsIHRoZSBhY3Rpb25zIHRoYXQgd2VyZSBvblxuICAgICAgICBmb3IoaT0wLGxlbiA9IG9wdHMuY29udHJvbHMubGVuZ3RoO2k8bGVuO2krKykge1xuICAgICAgICAgIGFjdGlvbk5hbWUgPSBvcHRzLmNvbnRyb2xzW2ldWzBdO1xuICAgICAgICAgIGlmKFEuaW5wdXRzW2FjdGlvbk5hbWVdKSB7IHdhc09uW2FjdGlvbk5hbWVdID0gdHJ1ZTsgfVxuICAgICAgICAgIFEuaW5wdXRzW2FjdGlvbk5hbWVdID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMgPyBldmVudC50b3VjaGVzIDogWyBldmVudCBdO1xuXG4gICAgICAgIGZvcihpPTAsbGVuPXRvdWNoZXMubGVuZ3RoO2k8bGVuO2krKykge1xuICAgICAgICAgIHRjaCA9IHRvdWNoZXNbaV07XG4gICAgICAgICAga2V5ID0gZ2V0S2V5KHRjaCk7XG5cbiAgICAgICAgICBpZihrZXkpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgdGhpcyBpbnB1dCBhcyBvblxuICAgICAgICAgICAgUS5pbnB1dHNba2V5XSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEVpdGhlciB0cmlnZ2VyIGEgbmV3IGFjdGlvblxuICAgICAgICAgICAgLy8gb3IgcmVtb3ZlIGZyb20gd2FzT24gbGlzdFxuICAgICAgICAgICAgaWYoIXdhc09uW2tleV0pIHtcbiAgICAgICAgICAgICAgUS5pbnB1dC50cmlnZ2VyKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgd2FzT25ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbnkgcmVtYWluaW5nIHdlcmUgb24gdGhlIGxhc3QgZnJhbWVcbiAgICAgICAgLy8gYW5kIG5lZWQgdG8gdHJpZ2dlciBhbiB1cCBhY3Rpb25cbiAgICAgICAgZm9yKGFjdGlvbk5hbWUgaW4gd2FzT24pIHtcbiAgICAgICAgICBRLmlucHV0LnRyaWdnZXIoYWN0aW9uTmFtZSArIFwiVXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b3VjaERpc3BhdGNoSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdG91Y2hEaXNwYXRjaChlKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfTtcblxuXG4gICAgICBRLl9lYWNoKFtcInRvdWNoc3RhcnRcIixcInRvdWNoZW5kXCIsXCJ0b3VjaG1vdmVcIixcInRvdWNoY2FuY2VsXCJdLGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBRLmVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LHRoaXMudG91Y2hEaXNwYXRjaEhhbmRsZXIpO1xuICAgICAgfSx0aGlzKTtcblxuICAgICAgdGhpcy50b3VjaEVuYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUdXJuIG9mZiB0b3VjaCAoYnV5dHRvbiBhbmQgam95cGFkKSBjb250cm9scyBhbmQgcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqXG4gICAgICogQG1ldGhvZCBkaXNhYmxlVG91Y2hDb250cm9sc1xuICAgICAqIEBmb3IgUS5JbnB1dFN5c3RlbVxuICAgICAqL1xuICAgIGRpc2FibGVUb3VjaENvbnRyb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgIFEuX2VhY2goW1widG91Y2hzdGFydFwiLFwidG91Y2hlbmRcIixcInRvdWNobW92ZVwiLFwidG91Y2hjYW5jZWxcIl0sZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIFEuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsdGhpcy50b3VjaERpc3BhdGNoSGFuZGxlcik7XG4gICAgICB9LHRoaXMpO1xuXG4gICAgICBRLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLHRoaXMuam95cGFkU3RhcnQpO1xuICAgICAgUS5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLHRoaXMuam95cGFkTW92ZSk7XG4gICAgICBRLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJyx0aGlzLmpveXBhZEVuZCk7XG4gICAgICBRLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJyx0aGlzLmpveXBhZEVuZCk7XG4gICAgICB0aGlzLnRvdWNoRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBjbGVhciBleGlzdGluZyBpbnB1dHNcbiAgICAgIGZvcih2YXIgaW5wdXQgaW4gUS5pbnB1dHMpIHtcbiAgICAgICAgUS5pbnB1dHNbaW5wdXRdID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBcbiAgICAgKiBBY3RpdmF0ZSBqb3lwYWQgY29udHJvbHMgKGkuZS4gNC13YXkgdG91Y2ggY29udHJvbHMpXG4gICAgICpcbiAgICAgKiBMb3RzIG9mIG9wdGlvbnMsIGRlZmF1bHRzIGFyZTpcbiAgICAgKiBcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgc2l6ZTogNTAsXG4gICAgICogICAgICB0cmlnZ2VyOiAyMCxcbiAgICAgKiAgICAgIGNlbnRlcjogMjUsXG4gICAgICogICAgICBjb2xvcjogXCIjQ0NDXCIsXG4gICAgICogICAgICBiYWNrZ3JvdW5kOiBcIiMwMDBcIixcbiAgICAgKiAgICAgIGFscGhhOiAwLjUsXG4gICAgICogICAgICB6b25lOiBRLndpZHRoIC8gMixcbiAgICAgKiAgICAgIGlucHV0czogREVGQVVMVF9KT1lQQURfSU5QVVRTXG4gICAgICogICAgfVxuICAgICAqXG4gICAgICogIERlZmF1bHQgam95cGFkIGNvbnRyb2xzIGlzIGFuIGFycmF5IHRoYXQgZGVmaW5lcyB0aGUgaW5wdXRzIHRvIGJpbmQgdG86XG4gICAgICpcbiAgICAgKiAgICAgICAvLyBDbG9ja3dpc2UgZnJvbSBtaWRuaWdodCAoYSBsYSBDU1MpXG4gICAgICogICAgICAgdmFyIERFRkFVTFRfSk9ZUEFEX0lOUFVUUyA9ICBbICd1cCcsJ3JpZ2h0JywnZG93bicsJ2xlZnQnXTtcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgam95cGFkQ29udHJvbHNcbiAgICAgKiBAZm9yIFEuSW5wdXRTeXN0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gIGpveXBhZCBvcHRpb25zXG4gICAgICovXG4gICBqb3lwYWRDb250cm9sczogZnVuY3Rpb24ob3B0cykge1xuICAgICAgaWYodGhpcy5qb3lwYWRFbmFibGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaWYoIWhhc1RvdWNoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgam95cGFkID0gUS5qb3lwYWQgPSBRLl9kZWZhdWx0cyhvcHRzIHx8IHt9LHtcbiAgICAgICAgc2l6ZTogNTAsXG4gICAgICAgIHRyaWdnZXI6IDIwLFxuICAgICAgICBjZW50ZXI6IDI1LFxuICAgICAgICBjb2xvcjogXCIjQ0NDXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzAwMFwiLFxuICAgICAgICBhbHBoYTogMC41LFxuICAgICAgICB6b25lOiBRLndpZHRoIC8gMixcbiAgICAgICAgam95cGFkVG91Y2g6IG51bGwsXG4gICAgICAgIGlucHV0czogREVGQVVMVF9KT1lQQURfSU5QVVRTLFxuICAgICAgICB0cmlnZ2VyczogW11cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmpveXBhZFN0YXJ0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmKGpveXBhZC5qb3lwYWRUb3VjaCA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0b3VjaCA9IGV2dC5jaGFuZ2VkVG91Y2hlc1swXSxcbiAgICAgICAgICAgICAgbG9jID0gUS5pbnB1dC50b3VjaExvY2F0aW9uKHRvdWNoKTtcblxuICAgICAgICAgIGlmKGxvYy54IDwgam95cGFkLnpvbmUpIHtcbiAgICAgICAgICAgIGpveXBhZC5qb3lwYWRUb3VjaCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgICAgICBqb3lwYWQuY2VudGVyWCA9IGxvYy54O1xuICAgICAgICAgICAgam95cGFkLmNlbnRlclkgPSBsb2MueTsgXG4gICAgICAgICAgICBqb3lwYWQueCA9IG51bGw7XG4gICAgICAgICAgICBqb3lwYWQueSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBcbiAgICAgIHRoaXMuam95cGFkTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoam95cGFkLmpveXBhZFRvdWNoICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGV2dCA9IGU7XG5cbiAgICAgICAgICBmb3IodmFyIGk9MCxsZW49ZXZ0LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2dC5jaGFuZ2VkVG91Y2hlc1tpXTtcblxuICAgICAgICAgICAgaWYodG91Y2guaWRlbnRpZmllciA9PT0gam95cGFkLmpveXBhZFRvdWNoKSB7XG4gICAgICAgICAgICAgIHZhciBsb2MgPSBRLmlucHV0LnRvdWNoTG9jYXRpb24odG91Y2gpLFxuICAgICAgICAgICAgICAgICAgZHggPSBsb2MueCAtIGpveXBhZC5jZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgZHkgPSBsb2MueSAtIGpveXBhZC5jZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgICAgICAgICBvdmVyYWdlID0gTWF0aC5tYXgoMSxkaXN0IC8gam95cGFkLnNpemUpLFxuICAgICAgICAgICAgICAgICAgYW5nID0gIE1hdGguYXRhbjIoZHgsZHkpO1xuXG4gICAgICAgICAgICAgIGlmKG92ZXJhZ2UgPiAxKSB7XG4gICAgICAgICAgICAgICAgZHggLz0gb3ZlcmFnZTtcbiAgICAgICAgICAgICAgICBkeSAvPSBvdmVyYWdlO1xuICAgICAgICAgICAgICAgIGRpc3QgLz0gb3ZlcmFnZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciB0cmlnZ2VycyA9IFtcbiAgICAgICAgICAgICAgICBkeSA8IC1qb3lwYWQudHJpZ2dlcixcbiAgICAgICAgICAgICAgICBkeCA+IGpveXBhZC50cmlnZ2VyLFxuICAgICAgICAgICAgICAgIGR5ID4gam95cGFkLnRyaWdnZXIsXG4gICAgICAgICAgICAgICAgZHggPCAtam95cGFkLnRyaWdnZXJcbiAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICBmb3IodmFyIGs9MDtrPHRyaWdnZXJzLmxlbmd0aDtrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uTmFtZSA9IGpveXBhZC5pbnB1dHNba107XG4gICAgICAgICAgICAgICAgaWYodHJpZ2dlcnNba10pIHtcbiAgICAgICAgICAgICAgICAgIFEuaW5wdXRzW2FjdGlvbk5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgaWYoIWpveXBhZC50cmlnZ2Vyc1trXSkgeyBcbiAgICAgICAgICAgICAgICAgICAgUS5pbnB1dC50cmlnZ2VyKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBRLmlucHV0c1thY3Rpb25OYW1lXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYoam95cGFkLnRyaWdnZXJzW2tdKSB7IFxuICAgICAgICAgICAgICAgICAgICBRLmlucHV0LnRyaWdnZXIoYWN0aW9uTmFtZSArIFwiVXBcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgUS5fZXh0ZW5kKGpveXBhZCwge1xuICAgICAgICAgICAgICAgIGR4OiBkeCwgZHk6IGR5LFxuICAgICAgICAgICAgICAgIHg6IGpveXBhZC5jZW50ZXJYICsgZHgsXG4gICAgICAgICAgICAgICAgeTogam95cGFkLmNlbnRlclkgKyBkeSxcbiAgICAgICAgICAgICAgICBkaXN0OiBkaXN0LFxuICAgICAgICAgICAgICAgIGFuZzogYW5nLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJzOiB0cmlnZ2Vyc1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5qb3lwYWRFbmQgPSBmdW5jdGlvbihlKSB7IFxuICAgICAgICAgIHZhciBldnQgPSBlO1xuXG4gICAgICAgICAgaWYoam95cGFkLmpveXBhZFRvdWNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IodmFyIGk9MCxsZW49ZXZ0LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDtpPGxlbjtpKyspIHsgXG4gICAgICAgICAgICB2YXIgdG91Y2ggPSBldnQuY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgICAgICAgIGlmKHRvdWNoLmlkZW50aWZpZXIgPT09IGpveXBhZC5qb3lwYWRUb3VjaCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wO2s8am95cGFkLnRyaWdnZXJzLmxlbmd0aDtrKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25OYW1lID0gam95cGFkLmlucHV0c1trXTtcbiAgICAgICAgICAgICAgICAgIFEuaW5wdXRzW2FjdGlvbk5hbWVdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmKGpveXBhZC50cmlnZ2Vyc1trXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUS5pbnB1dC50cmlnZ2VyKGFjdGlvbk5hbWUgKyBcIlVwXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpveXBhZC5qb3lwYWRUb3VjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfTtcblxuICAgICAgUS5lbC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMuam95cGFkU3RhcnQpO1xuICAgICAgUS5lbC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5qb3lwYWRNb3ZlKTtcbiAgICAgIFEuZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5qb3lwYWRFbmQpO1xuICAgICAgUS5lbC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIix0aGlzLmpveXBhZEVuZCk7XG5cbiAgICAgIHRoaXMuam95cGFkRW5hYmxlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlIG1vdXNlIGNvbnRyb2xzIC0gbW91c2UgY29udHJvbHMgZG9uJ3QgdHJpZ2dlciBldmVudHMsIGJ1dCBqdXN0IHNldCBgUS5pbnB1dHNbJ21vdXNlWCddYCAmIGBRLmlucHV0c1snbW91c2VZJ11gIG9uIGVhY2ggZnJhbWUuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IG9wdGlvbnM6XG4gICAgICpcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIHN0YWdlTnVtOiAwLFxuICAgICAqICAgICAgIG1vdXNlWDogXCJtb3VzZVhcIixcbiAgICAgKiAgICAgICBtb3VzZVk6IFwibW91c2VZXCIsXG4gICAgICogICAgICAgY3Vyc29yOiBcIm9mZlwiXG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbW91c2VDb250cm9sc1xuICAgICAqIEBmb3IgUS5JbnB1dFN5c3RlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvdmVycmlkZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBtb3VzZUNvbnRyb2xzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIHN0YWdlTnVtID0gb3B0aW9ucy5zdGFnZU51bSB8fCAwO1xuICAgICAgdmFyIG1vdXNlSW5wdXRYID0gb3B0aW9ucy5tb3VzZVggfHwgXCJtb3VzZVhcIjtcbiAgICAgIHZhciBtb3VzZUlucHV0WSA9IG9wdGlvbnMubW91c2VZIHx8IFwibW91c2VZXCI7XG4gICAgICB2YXIgY3Vyc29yID0gb3B0aW9ucy5jdXJzb3IgfHwgXCJvZmZcIjtcblxuICAgICAgdmFyIG1vdXNlTW92ZU9iaiA9IHt9O1xuXG4gICAgICBpZihjdXJzb3IgIT09IFwib25cIikge1xuICAgICAgICAgIGlmKGN1cnNvciA9PT0gXCJvZmZcIikge1xuICAgICAgICAgICAgICBRLmVsLnN0eWxlLmN1cnNvciA9ICdub25lJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIFEuZWwuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUS5pbnB1dHNbbW91c2VJbnB1dFhdID0gMDtcbiAgICAgIFEuaW5wdXRzW21vdXNlSW5wdXRZXSA9IDA7XG5cbiAgICAgIFEuX21vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xuICAgICAgICB2YXIgZWwgPSBRLmVsLCBcbiAgICAgICAgICAgIHBvc1ggPSB0b3VjaC5vZmZzZXRYLFxuICAgICAgICAgICAgcG9zWSA9IHRvdWNoLm9mZnNldFksXG4gICAgICAgICAgICBlWCwgZVksXG4gICAgICAgICAgICBzdGFnZSA9IFEuc3RhZ2Uoc3RhZ2VOdW0pO1xuXG4gICAgICAgIGlmKFEuX2lzVW5kZWZpbmVkKHBvc1gpIHx8IFEuX2lzVW5kZWZpbmVkKHBvc1kpKSB7XG4gICAgICAgICAgcG9zWCA9IHRvdWNoLmxheWVyWDtcbiAgICAgICAgICBwb3NZID0gdG91Y2gubGF5ZXJZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoUS5faXNVbmRlZmluZWQocG9zWCkgfHwgUS5faXNVbmRlZmluZWQocG9zWSkpIHtcbiAgICAgICAgICBpZihRLmlucHV0Lm9mZnNldFggPT09IHZvaWQgMCkgeyBRLmlucHV0Ll9jb250YWluZXJPZmZzZXQoKTsgfVxuICAgICAgICAgIHBvc1ggPSB0b3VjaC5wYWdlWCAtIFEuaW5wdXQub2Zmc2V0WDtcbiAgICAgICAgICBwb3NZID0gdG91Y2gucGFnZVkgLSBRLmlucHV0Lm9mZnNldFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihzdGFnZSkge1xuICAgICAgICAgIG1vdXNlTW92ZU9iai54PSBRLmNhbnZhc1RvU3RhZ2VYKHBvc1gsc3RhZ2UpO1xuICAgICAgICAgIG1vdXNlTW92ZU9iai55PSBRLmNhbnZhc1RvU3RhZ2VZKHBvc1ksc3RhZ2UpO1xuXG4gICAgICAgICAgUS5pbnB1dHNbbW91c2VJbnB1dFhdID0gbW91c2VNb3ZlT2JqLng7XG4gICAgICAgICAgUS5pbnB1dHNbbW91c2VJbnB1dFldID0gbW91c2VNb3ZlT2JqLnk7XG5cbiAgICAgICAgICBRLmlucHV0LnRyaWdnZXIoJ21vdXNlTW92ZScsbW91c2VNb3ZlT2JqKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgUS5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLFEuX21vdXNlTW92ZSx0cnVlKTtcbiAgICAgIFEuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsUS5fbW91c2VNb3ZlLHRydWUpO1xuICAgICAgUS5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLFEuX21vdXNlTW92ZSx0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybiBvZmYgbW91c2UgY29udHJvbHNcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGlzYWJsZU1vdXNlQ29udHJvbHNcbiAgICAgKiBAZm9yIFEuSW5wdXRTeXN0ZW1cbiAgICAgKi9cbiAgICBkaXNhYmxlTW91c2VDb250cm9sczogZnVuY3Rpb24oKSB7XG4gICAgICBpZihRLl9tb3VzZU1vdmUpIHtcbiAgICAgICAgUS5lbC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsUS5fbW91c2VNb3ZlLCB0cnVlKTtcbiAgICAgICAgUS5lbC5zdHlsZS5jdXJzb3IgPSAnaW5oZXJpdCc7XG4gICAgICAgIFEuX21vdXNlTW92ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBcbiAgICAgKiBEcmF3IHRoZSB0b3VjaCBidXR0b25zIG9uIHRoZSBzY3JlZW5cbiAgICAgKlxuICAgICAqIG92ZXJsb2FkIHRoaXMgdG8gY2hhbmdlIGhvdyBidXR0b25zIGFyZSBkcmF3blxuICAgICAqXG4gICAgICogQG1ldGhvZCBkcmF3QnV0dG9uc1xuICAgICAqIEBmb3IgUS5JbnB1dFN5c3RlbVxuICAgICAqL1xuICAgIGRyYXdCdXR0b25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXlwYWQgPSBRLmlucHV0LmtleXBhZCxcbiAgICAgICAgICBjdHggPSBRLmN0eDtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiOyBcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuXG4gICAgICBmb3IodmFyIGk9MDtpPGtleXBhZC5jb250cm9scy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIHZhciBjb250cm9sID0ga2V5cGFkLmNvbnRyb2xzW2ldO1xuXG4gICAgICAgIGlmKGNvbnRyb2xbMF0pIHtcbiAgICAgICAgICBjdHguZm9udCA9IFwiYm9sZCBcIiArIChrZXlwYWQuc2l6ZS8yKSArIFwicHggYXJpYWxcIjtcbiAgICAgICAgICB2YXIgeCA9IGtleXBhZC5sZWZ0ICsgaSAqIGtleXBhZC51bml0ICsga2V5cGFkLmd1dHRlcixcbiAgICAgICAgICAgICAgeSA9IGtleXBhZC5ib3R0b20gLSBrZXlwYWQudW5pdCxcbiAgICAgICAgICAgICAga2V5ID0gUS5pbnB1dHNbY29udHJvbFswXV07XG5cbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0ga2V5cGFkLmNvbG9yIHx8IFwiI0ZGRkZGRlwiO1xuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGtleSA/IDEuMCA6IDAuNTtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoeCx5LGtleXBhZC5zaXplLGtleXBhZC5zaXplKTtcblxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBrZXlwYWQudGV4dCB8fCBcIiMwMDAwMDBcIjtcbiAgICAgICAgICBjdHguZmlsbFRleHQoY29udHJvbFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgeCtrZXlwYWQuc2l6ZS8yLFxuICAgICAgICAgICAgICAgICAgICAgICB5K2tleXBhZC5zaXplLzIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIGRyYXdDaXJjbGU6IGZ1bmN0aW9uKHgseSxjb2xvcixzaXplKSB7XG4gICAgICB2YXIgY3R4ID0gUS5jdHgsXG4gICAgICAgICAgam95cGFkID0gUS5qb3lwYWQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGE9am95cGFkLmFscGhhO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmFyYyh4LCB5LCBzaXplLCAwLCBNYXRoLlBJKjIsIHRydWUpOyBcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cblxuXG4gICAgLyoqIFxuICAgICAqIERyYXcgdGhlIGpveXBhZCBvbiB0aGUgc2NyZWVuXG4gICAgICpcbiAgICAgKiBvdmVybG9hZCB0aGlzIHRvIGNoYW5nZSBob3cgam95cGFkIGlzIGRyYXduXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRyYXdKb3lwYWRcbiAgICAgKiBAZm9yIFEuSW5wdXRTeXN0ZW1cbiAgICAgKi9cbiAgICBkcmF3Sm95cGFkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBqb3lwYWQgPSBRLmpveXBhZDtcbiAgICAgIGlmKGpveXBhZC5qb3lwYWRUb3VjaCAhPT0gbnVsbCkge1xuICAgICAgICBRLmlucHV0LmRyYXdDaXJjbGUoam95cGFkLmNlbnRlclgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBqb3lwYWQuY2VudGVyWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGpveXBhZC5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgam95cGFkLnNpemUpO1xuXG4gICAgICAgIGlmKGpveXBhZC54ICE9PSBudWxsKSB7XG4gICAgICAgICAgUS5pbnB1dC5kcmF3Q2lyY2xlKGpveXBhZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgam95cGFkLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBqb3lwYWQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBqb3lwYWQuY2VudGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKiBcbiAgICAgKiBDYWxsZWQgZWFjaCBmcmFtZSBieSB0aGUgc3RhZ2UgZ2FtZSBsb29wIHRvIHJlbmRlciBhbnkgb25zY3JlZW4gVUlcbiAgICAgKlxuICAgICAqIGNhbGxzIGBkcmF3Sm95cGFkYCBhbmQgYGRyYXdCdXR0b25zYCBpZiBlbmFibGVkXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRyYXdDYW52YXNcbiAgICAgKiBAZm9yIFEuSW5wdXRTeXN0ZW1cbiAgICAgKi9cbiAgICBkcmF3Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmKHRoaXMudG91Y2hFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZHJhd0J1dHRvbnMoKTtcbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5qb3lwYWRFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZHJhd0pveXBhZCgpO1xuICAgICAgfVxuICAgIH1cblxuXG4gIH0pO1xuICBcbiAgLyoqXG4gICAqIEluc3RhbmNlIG9mIHRoZSBpbnB1dCBzdWJzeXRlbSB0aGF0IGlzIGFjdHVhbGx5IHVzZWQgZHVyaW5nIGdhbWVwbGF5XG4gICAqXG4gICAqIEBwcm9wZXJ0eSBRLmlucHV0XG4gICAqIEBmb3IgUXVpbnR1cy5JbnB1dFxuICAgKiBAdHlwZSBRLklucHV0U3lzdGVtXG4gICAqL1xuICBRLmlucHV0ID0gbmV3IFEuSW5wdXRTeXN0ZW0oKTtcblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBhY3RpdmF0ZSBjb250cm9scyB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICAgKlxuICAgKiBAZm9yIFF1aW50dXMuSW5wdXRcbiAgICogQG1ldGhvZCBRLmNvbnRyb2xzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gam95cGFkIC0gZW5hYmxlIDQtd2F5IGpveXBhZCAodHJ1ZSkgb3IganVzdCBsZWZ0LCByaWdodCBjb250cm9scyAoZmFsc2UsIHVuZGVmaW5lZClcbiAgICovXG4gIFEuY29udHJvbHMgPSBmdW5jdGlvbihqb3lwYWQpIHtcbiAgICBRLmlucHV0LmtleWJvYXJkQ29udHJvbHMoKTtcblxuICAgIGlmKGpveXBhZCkge1xuICAgICAgUS5pbnB1dC50b3VjaENvbnRyb2xzKHtcbiAgICAgICAgY29udHJvbHM6IFsgW10sW10sW10sWydhY3Rpb24nLCdiJ10sWydmaXJlJywnYSddXVxuICAgICAgfSk7XG4gICAgICBRLmlucHV0LmpveXBhZENvbnRyb2xzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFEuaW5wdXQudG91Y2hDb250cm9scygpO1xuICAgIH1cblxuICAgIHJldHVybiBRO1xuICB9O1xuICBcblxuICAvKipcbiAgICogUGxhdGZvcm1lciBDb250cm9sIENvbXBvbmVudFxuICAgKlxuICAgKiBBZGRzIDJEIHBsYXRmb3JtZXIgY29udHJvbHMgb250byBhIFNwcml0ZVxuICAgKlxuICAgKiBQbGF0Zm9ybWVyIGNvbnRyb2xzIGJpbmQgdG8gbGVmdCwgYW5kIHJpZ2h0IGFuZCBhbGxvdyB0aGUgcGxheWVyIHRvIGp1bXAuIFxuICAgKlxuICAgKiBBZGRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyB0byB0aGUgZW50aXR5IHRvIGNvbnRyb2wgc3BlZWQgYW5kIGp1bXBpbmc6XG4gICAqXG4gICAqICAgICAgeyBcbiAgICogICAgICAgIHNwZWVkOiAyMDAsXG4gICAqICAgICAgICBqdW1wU3BlZWQ6IC0zMDBcbiAgICogICAgICB9XG4gICAqXG4gICAqXG4gICAqIEBjbGFzcyBwbGF0Zm9ybWVyQ29udHJvbHNcbiAgICogQGZvciBRdWludHVzLklucHV0XG4gICAqL1xuICBRLmNvbXBvbmVudChcInBsYXRmb3JtZXJDb250cm9sc1wiLCB7XG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIHNwZWVkOiAyMDAsXG4gICAgICBqdW1wU3BlZWQ6IC0zMDAsXG4gICAgICBjb2xsaXNpb25zOiBbXVxuICAgIH0sXG5cbiAgICBhZGRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuZW50aXR5LnA7XG5cbiAgICAgIFEuX2RlZmF1bHRzKHAsdGhpcy5kZWZhdWx0cyk7XG5cbiAgICAgIHRoaXMuZW50aXR5Lm9uKFwic3RlcFwiLHRoaXMsXCJzdGVwXCIpO1xuICAgICAgdGhpcy5lbnRpdHkub24oXCJidW1wLmJvdHRvbVwiLHRoaXMsXCJsYW5kZWRcIik7XG5cbiAgICAgIHAubGFuZGVkID0gMDtcbiAgICAgIHAuZGlyZWN0aW9uID0ncmlnaHQnO1xuICAgIH0sXG5cbiAgICBsYW5kZWQ6IGZ1bmN0aW9uKGNvbCkge1xuICAgICAgdmFyIHAgPSB0aGlzLmVudGl0eS5wO1xuICAgICAgcC5sYW5kZWQgPSAxLzU7XG4gICAgfSxcblxuICAgIHN0ZXA6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICB2YXIgcCA9IHRoaXMuZW50aXR5LnA7XG4gICAgICBcbiAgICAgIGlmKHAuaWdub3JlQ29udHJvbHMgPT09IHVuZGVmaW5lZCB8fCAhcC5pZ25vcmVDb250cm9scykge1xuICAgICAgICB2YXIgY29sbGlzaW9uID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvbGxvdyBhbG9uZyB0aGUgY3VycmVudCBzbG9wZSwgaWYgcG9zc2libGUuXG4gICAgICAgIGlmKHAuY29sbGlzaW9ucyAhPT0gdW5kZWZpbmVkICYmIHAuY29sbGlzaW9ucy5sZW5ndGggPiAwICYmIChRLmlucHV0c1snbGVmdCddIHx8IFEuaW5wdXRzWydyaWdodCddIHx8IHAubGFuZGVkID4gMCkpIHtcbiAgICAgICAgICBpZihwLmNvbGxpc2lvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwLmNvbGxpc2lvbnNbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSBwb3NzaWJsZSBzbG9wZSwgZm9sbG93IHNsb3BlIHdpdGggbmVnYXRpdmUgWSBub3JtYWxcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IG51bGw7XG5cbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwLmNvbGxpc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYocC5jb2xsaXNpb25zW2ldLm5vcm1hbFkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29sbGlzaW9uID0gcC5jb2xsaXNpb25zW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEb24ndCBjbGltYiB1cCB3YWxscy4gICAgICBcbiAgICAgICAgICBpZihjb2xsaXNpb24gIT09IG51bGwgJiYgY29sbGlzaW9uLm5vcm1hbFkgPiAtMC4zICYmIGNvbGxpc2lvbi5ub3JtYWxZIDwgMC4zKSB7ICAgICAgICBcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IG51bGw7XG4gICAgICAgICAgfSAgICAgICAgXG4gICAgICAgIH0gICAgICBcblxuICAgICAgICBpZihRLmlucHV0c1snbGVmdCddKSB7XG4gICAgICAgICAgcC5kaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgaWYoY29sbGlzaW9uICYmIHAubGFuZGVkID4gMCkge1xuICAgICAgICAgICAgcC52eCA9IHAuc3BlZWQgKiBjb2xsaXNpb24ubm9ybWFsWTtcbiAgICAgICAgICAgIHAudnkgPSAtcC5zcGVlZCAqIGNvbGxpc2lvbi5ub3JtYWxYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwLnZ4ID0gLXAuc3BlZWQ7XG4gICAgICAgICAgfSAgICAgICAgXG4gICAgICAgIH0gZWxzZSBpZihRLmlucHV0c1sncmlnaHQnXSkge1xuICAgICAgICAgIHAuZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICBpZihjb2xsaXNpb24gJiYgcC5sYW5kZWQgPiAwKSB7XG4gICAgICAgICAgICBwLnZ4ID0gLXAuc3BlZWQgKiBjb2xsaXNpb24ubm9ybWFsWTtcbiAgICAgICAgICAgIHAudnkgPSBwLnNwZWVkICogY29sbGlzaW9uLm5vcm1hbFg7ICAgICAgICAgIFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwLnZ4ID0gcC5zcGVlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcC52eCA9IDA7XG4gICAgICAgICAgaWYoY29sbGlzaW9uICYmIHAubGFuZGVkID4gMCkge1xuICAgICAgICAgICAgcC52eSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihwLmxhbmRlZCA+IDAgJiYgKFEuaW5wdXRzWyd1cCddIHx8IFEuaW5wdXRzWydhY3Rpb24nXSkgJiYgIXAuanVtcGluZykge1xuICAgICAgICAgIHAudnkgPSBwLmp1bXBTcGVlZDtcbiAgICAgICAgICBwLmxhbmRlZCA9IC1kdDtcbiAgICAgICAgICBwLmp1bXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoUS5pbnB1dHNbJ3VwJ10gfHwgUS5pbnB1dHNbJ2FjdGlvbiddKSB7XG4gICAgICAgICAgdGhpcy5lbnRpdHkudHJpZ2dlcignanVtcCcsIHRoaXMuZW50aXR5KTtcbiAgICAgICAgICBwLmp1bXBpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihwLmp1bXBpbmcgJiYgIShRLmlucHV0c1sndXAnXSB8fCBRLmlucHV0c1snYWN0aW9uJ10pKSB7XG4gICAgICAgICAgcC5qdW1waW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5lbnRpdHkudHJpZ2dlcignanVtcGVkJywgdGhpcy5lbnRpdHkpO1xuICAgICAgICAgIGlmKHAudnkgPCBwLmp1bXBTcGVlZCAvIDMpIHtcbiAgICAgICAgICAgIHAudnkgPSBwLmp1bXBTcGVlZCAvIDM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwLmxhbmRlZCAtPSBkdDtcbiAgICB9XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIFN0ZXAgQ29udHJvbHMgY29tcG9uZW50XG4gICAqXG4gICAqIEFkZHMgU3RlcCAoc3F1YXJlIGdyaWQgYmFzZWQpIDQtd2F5cyBjb250cm9scyBvbnRvIGEgU3ByaXRlXG4gICAqXG4gICAqIEFkZHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHRvIHRoZSBlbnRpdHk6XG4gICAqXG4gICAqICAgICAgeyBcbiAgICogICAgICAgIHN0ZXBEaXN0YW5jZTogMzIsIC8vIHNob3VsZCBiZSB0aWxlIHNpemVcbiAgICogICAgICAgIHN0ZXBEZWxheTogMC4yICAvLyBzZWNvbmRzIHRvIGRlbGF5IGJlZm9yZSBuZXh0IHN0ZXBcbiAgICogICAgICB9XG4gICAqXG4gICAqXG4gICAqIEBjbGFzcyBzdGVwQ29udHJvbHNcbiAgICogQGZvciBRdWludHVzLklucHV0XG4gICAqL1xuICBRLmNvbXBvbmVudChcInN0ZXBDb250cm9sc1wiLCB7XG5cbiAgICBhZGRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuZW50aXR5LnA7XG5cbiAgICAgIGlmKCFwLnN0ZXBEaXN0YW5jZSkgeyBwLnN0ZXBEaXN0YW5jZSA9IDMyOyB9XG4gICAgICBpZighcC5zdGVwRGVsYXkpIHsgcC5zdGVwRGVsYXkgPSAwLjI7IH1cblxuICAgICAgcC5zdGVwV2FpdCA9IDA7XG4gICAgICB0aGlzLmVudGl0eS5vbihcInN0ZXBcIix0aGlzLFwic3RlcFwiKTtcbiAgICAgIHRoaXMuZW50aXR5Lm9uKFwiaGl0XCIsIHRoaXMsXCJjb2xsaXNpb25cIik7XG4gICAgfSxcblxuICAgIGNvbGxpc2lvbjogZnVuY3Rpb24oY29sKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuZW50aXR5LnA7XG5cbiAgICAgIGlmKHAuc3RlcHBpbmcpIHtcbiAgICAgICAgcC5zdGVwcGluZyA9IGZhbHNlO1xuICAgICAgICBwLnggPSBwLm9yaWdYO1xuICAgICAgICBwLnkgPSBwLm9yaWdZO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHN0ZXA6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICB2YXIgcCA9IHRoaXMuZW50aXR5LnAsXG4gICAgICAgICAgbW92ZWQgPSBmYWxzZTtcbiAgICAgIHAuc3RlcFdhaXQgLT0gZHQ7XG5cbiAgICAgIGlmKHAuc3RlcHBpbmcpIHtcbiAgICAgICAgcC54ICs9IHAuZGlmZlggKiBkdCAvIHAuc3RlcERlbGF5O1xuICAgICAgICBwLnkgKz0gcC5kaWZmWSAqIGR0IC8gcC5zdGVwRGVsYXk7XG4gICAgICB9XG5cbiAgICAgIGlmKHAuc3RlcFdhaXQgPiAwKSB7IHJldHVybjsgfVxuICAgICAgaWYocC5zdGVwcGluZykge1xuICAgICAgICBwLnggPSBwLmRlc3RYO1xuICAgICAgICBwLnkgPSBwLmRlc3RZO1xuICAgICAgfVxuICAgICAgcC5zdGVwcGluZyA9IGZhbHNlO1xuXG4gICAgICBwLmRpZmZYID0gMDtcbiAgICAgIHAuZGlmZlkgPSAwO1xuXG4gICAgICBpZihRLmlucHV0c1snbGVmdCddKSB7XG4gICAgICAgIHAuZGlmZlggPSAtcC5zdGVwRGlzdGFuY2U7XG4gICAgICB9IGVsc2UgaWYoUS5pbnB1dHNbJ3JpZ2h0J10pIHtcbiAgICAgICAgcC5kaWZmWCA9IHAuc3RlcERpc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICBpZihRLmlucHV0c1sndXAnXSkge1xuICAgICAgICBwLmRpZmZZID0gLXAuc3RlcERpc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmKFEuaW5wdXRzWydkb3duJ10pIHtcbiAgICAgICAgcC5kaWZmWSA9IHAuc3RlcERpc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICBpZihwLmRpZmZZIHx8IHAuZGlmZlggKSB7IFxuICAgICAgICBwLnN0ZXBwaW5nID0gdHJ1ZTtcbiAgICAgICAgcC5vcmlnWCA9IHAueDtcbiAgICAgICAgcC5vcmlnWSA9IHAueTtcbiAgICAgICAgcC5kZXN0WCA9IHAueCArIHAuZGlmZlg7XG4gICAgICAgIHAuZGVzdFkgPSBwLnkgKyBwLmRpZmZZO1xuICAgICAgICBwLnN0ZXBXYWl0ID0gcC5zdGVwRGVsYXk7IFxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0pO1xufTtcblxuIiwiLypnbG9iYWwgUXVpbnR1czpmYWxzZSAqL1xuXG4vKipcblF1aW50dXMgSFRNTDUgR2FtZSBFbmdpbmUgLSBTY2VuZXMgTW9kdWxlXG5cblRoZSBjb2RlIGluIGBxdWludHVzX3NjZW5lcy5qc2AgZGVmaW5lcyB0aGUgYFF1aW50dXMuU2NlbmVzYCBtb2R1bGUsIHdoaWNoXG5hZGRzIGluIHN1cHBvcnQgZm9yIFNjZW5lcyBhbmQgU3RhZ2VzIGludG8gUXVpbnR1cy4gXG5cbkRlcGVuZHMgb24gdGhlIGBRdWludHVzLlNwcml0ZWAgbW9kdWxlLlxuXG5TY2VuZXMgbGV0IHlvdSBjcmVhdGUgcmV1c2FibGUgZGVmaW5pdGlvbnMgZm9yIHNldHRpbmcgdXAgbGV2ZWxzIGFuZCBzY3JlZW5zLlxuXG5TdGFnZXMgYXJlIHRoZSBwcmltYXJ5IGNvbnRhaW5lciBvYmplY3QgaW4gUXVpbnR1cywgaGFuZGxpbmcgU3ByaXRlIG1hbmFnZW1lbnQsXG5zdGVwcGluZywgcmVuZGVyaW5nIGFuZCBjb2xsaXNpb24gZGV0ZWN0aW9uLlxuXG5AbW9kdWxlIFF1aW50dXMuU2NlbmVzXG4qL1xuXG4vKiogXG4gKiBRdWludHVzIFNjZW5lcyBNb2R1bGUgQ2xhc3NcbiAqXG4gKiBAY2xhc3MgUXVpbnR1cy5TY2VuZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihRKSB7XG5cbiAgUS5zY2VuZXMgPSB7fTtcbiAgUS5zdGFnZXMgPSBbXTtcblxuXG4gIC8qKiBcbiAgIEJhc2ljIHNjZW5lIGNsYXNzLCBjb25zaXN0aW5nIHByaW1hcmlseSBvZiBhIHNjZW5lIGZ1bmN0aW9uIFxuICAgYW5kIHNvbWUgb3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlIHN0YWdlLlxuXG4gICBTaG91bGQgYmUgaW5zdGFudGlhdGVkIGJ5IGNhbGxpbmcgYFEuc2NlbmVgIG5vdCBuZXdcblxuICAgQGNsYXNzIFEuU2NlbmVcbiAgIEBmb3IgUXVpbnR1cy5TY2VuZXNcbiAgKi9cbiAgUS5DbGFzcy5leHRlbmQoJ1NjZW5lJyx7XG4gICAgaW5pdDogZnVuY3Rpb24oc2NlbmVGdW5jLG9wdHMpIHtcbiAgICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge307XG4gICAgICB0aGlzLnNjZW5lRnVuYyA9IHNjZW5lRnVuYztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgU2V0IHVwIGEgbmV3IHNjZW5lIG9yIHJldHVybiBhbiBleGlzdGluZyBzY2VuZS4gSWYgeW91IGRvbid0IHBhc3MgaW4gYHNjZW5lRnVuY2AsIFxuICAgaXQnbGwgcmV0dXJuIGEgc2NlbmUgb3RoZXJ3aXNlIGl0J2xsIGNyZWF0ZSBhIG5ldyBvbmUuXG5cbiAgIEBtZXRob2QgUS5zY2VuZVxuICAgQGZvciBRdWludHVzLlNjZW5lc1xuICAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHNjZW5lIHRvIGNyZWF0ZSBvciByZXR1cm5cbiAgIEBwYXJhbSB7RnVuY3Rpb259IFtzY2VuZUZ1bmNdIC0gc2NlbmUgZnVuY3Rpb246IGBmdW5jdGlvbihzdGFnZSkgeyAuLiB9YCB0aGF0IHNldHMgdXAgdGhlIHN0YWdlXG4gICovXG4gIFEuc2NlbmUgPSBmdW5jdGlvbihuYW1lLHNjZW5lRnVuYyxvcHRzKSB7XG4gICAgaWYoc2NlbmVGdW5jID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBRLnNjZW5lc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoUS5faXNGdW5jdGlvbihzY2VuZUZ1bmMpKSB7XG4gICAgICAgIHNjZW5lRnVuYyA9IG5ldyBRLlNjZW5lKHNjZW5lRnVuYyxvcHRzKTtcbiAgICAgICAgc2NlbmVGdW5jLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuICAgICAgUS5zY2VuZXNbbmFtZV0gPSBzY2VuZUZ1bmM7XG4gICAgICByZXR1cm4gc2NlbmVGdW5jO1xuICAgIH1cbiAgfTtcblxuICBRLl9udWxsQ29udGFpbmVyID0ge1xuICAgIGM6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgYW5nbGU6IDAsXG4gICAgICBzY2FsZTogMVxuICAgIH0sXG4gICAgbWF0cml4OiBRLm1hdHJpeDJkKClcbiAgfTtcblxuIFxuICAvKipcbiAgIFNBVCBjb2xsaXNpb24gZGV0ZWN0aW9uIGJldHdlZW4gdHdvIG9iamVjdHNcbiAgIFRoYW5rcyB0byBkb2MncyBhdDogaHR0cDovL3d3dy5zZXZlbnNvbi5jb20uYXUvYWN0aW9uc2NyaXB0L3NhdC9cblxuICAgVGhpcyBpcyBzb3J0IG9mIGEgYmxhY2sgYm94IC0gdXNlIHRoZSBtZXRob2RzIG9uIHN0YWdlIGxpa2UgYHNlYXJjaGAgYW5kIGBjb2xsaWRlYCB0b1xuICAgcnVuIHRoZSBjb2xsaXNpb24gc3lzdGVtLlxuXG4gICBAcHJvcGVydHkgUS5jb2xsaXNpb25cbiAgIEBmb3IgUXVpbnR1cy5TY2VuZXNcbiAgKi9cbiAgUS5jb2xsaXNpb24gPSAoZnVuY3Rpb24oKSB7IFxuICAgIHZhciBub3JtYWxYLCBub3JtYWxZLFxuICAgICAgICBvZmZzZXQgPSBbIDAsMCBdLFxuICAgICAgICByZXN1bHQxID0geyBzZXBhcmF0ZTogW10gfSxcbiAgICAgICAgcmVzdWx0MiA9IHsgc2VwYXJhdGU6IFtdIH07XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWwocG9pbnRzLGlkeCkge1xuICAgICAgdmFyIHB0MSA9IHBvaW50c1tpZHhdLFxuICAgICAgICAgIHB0MiA9IHBvaW50c1tpZHgrMV0gfHwgcG9pbnRzWzBdO1xuXG4gICAgICBub3JtYWxYID0gLShwdDJbMV0gLSBwdDFbMV0pO1xuICAgICAgbm9ybWFsWSA9IHB0MlswXSAtIHB0MVswXTtcblxuICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQobm9ybWFsWCpub3JtYWxYICsgbm9ybWFsWSpub3JtYWxZKTtcbiAgICAgIGlmKGRpc3QgPiAwKSB7XG4gICAgICAgIG5vcm1hbFggLz0gZGlzdDtcbiAgICAgICAgbm9ybWFsWSAvPSBkaXN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvdFByb2R1Y3RBZ2FpbnN0Tm9ybWFsKHBvaW50KSB7XG4gICAgICByZXR1cm4gKG5vcm1hbFggKiBwb2ludFswXSkgKyAobm9ybWFsWSAqIHBvaW50WzFdKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxpZGUobzEsbzIsZmxpcCkge1xuICAgICAgdmFyIG1pbjEsbWF4MSxcbiAgICAgICAgICBtaW4yLG1heDIsXG4gICAgICAgICAgZDEsIGQyLFxuICAgICAgICAgIG9mZnNldExlbmd0aCxcbiAgICAgICAgICB0bXAsIGksIGosXG4gICAgICAgICAgbWluRGlzdCwgbWluRGlzdEFicyxcbiAgICAgICAgICBzaG9ydGVzdERpc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgY29sbGlkZWQgPSBmYWxzZSxcbiAgICAgICAgICBwMSwgcDI7XG5cbiAgICAgIHZhciByZXN1bHQgPSBmbGlwID8gcmVzdWx0MiA6IHJlc3VsdDE7XG5cbiAgICAgIG9mZnNldFswXSA9IDA7IC8vbzEueCArIG8xLmN4IC0gbzIueCAtIG8yLmN4O1xuICAgICAgb2Zmc2V0WzFdID0gMDsgLy9vMS55ICsgbzEuY3kgLSBvMi55IC0gbzIuY3k7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3NpdGlvbiBtYXRyaXgsIGp1c3QgdXNlIHRob3NlIHBvaW50cyxcbiAgICAgIGlmKG8xLmMpIHtcbiAgICAgICAgcDEgPSBvMS5jLnBvaW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAxID0gbzEucC5wb2ludHM7XG4gICAgICAgIG9mZnNldFswXSArPSBvMS5wLng7XG4gICAgICAgIG9mZnNldFsxXSArPSBvMS5wLnk7XG4gICAgICB9XG5cbiAgICAgIGlmKG8yLmMpIHtcbiAgICAgICAgcDIgPSBvMi5jLnBvaW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAyID0gbzIucC5wb2ludHM7XG4gICAgICAgIG9mZnNldFswXSArPSAtbzIucC54O1xuICAgICAgICBvZmZzZXRbMV0gKz0gLW8yLnAueTsgXG4gICAgICB9XG5cbiAgICAgIG8xID0gbzEucDtcbiAgICAgIG8yID0gbzIucDtcblxuXG4gICAgICBmb3IoaSA9IDA7aTxwMS5sZW5ndGg7aSsrKSB7XG4gICAgICAgIGNhbGN1bGF0ZU5vcm1hbChwMSxpKTtcblxuICAgICAgICBtaW4xID0gZG90UHJvZHVjdEFnYWluc3ROb3JtYWwocDFbMF0pO1xuICAgICAgICBtYXgxID0gbWluMTtcblxuICAgICAgICBmb3IoaiA9IDE7IGo8cDEubGVuZ3RoO2orKykge1xuICAgICAgICAgIHRtcCA9IGRvdFByb2R1Y3RBZ2FpbnN0Tm9ybWFsKHAxW2pdKTtcbiAgICAgICAgICBpZih0bXAgPCBtaW4xKSB7IG1pbjEgPSB0bXA7IH1cbiAgICAgICAgICBpZih0bXAgPiBtYXgxKSB7IG1heDEgPSB0bXA7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1pbjIgPSBkb3RQcm9kdWN0QWdhaW5zdE5vcm1hbChwMlswXSk7XG4gICAgICAgIG1heDIgPSBtaW4yO1xuXG4gICAgICAgIGZvcihqID0gMTtqPHAyLmxlbmd0aDtqKyspIHtcbiAgICAgICAgICB0bXAgPSBkb3RQcm9kdWN0QWdhaW5zdE5vcm1hbChwMltqXSk7XG4gICAgICAgICAgaWYodG1wIDwgbWluMikgeyBtaW4yID0gdG1wOyB9XG4gICAgICAgICAgaWYodG1wID4gbWF4MikgeyBtYXgyID0gdG1wOyB9XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXRMZW5ndGggPSBkb3RQcm9kdWN0QWdhaW5zdE5vcm1hbChvZmZzZXQpO1xuICAgICAgICBtaW4xICs9IG9mZnNldExlbmd0aDtcbiAgICAgICAgbWF4MSArPSBvZmZzZXRMZW5ndGg7XG5cbiAgICAgICAgZDEgPSBtaW4xIC0gbWF4MjtcbiAgICAgICAgZDIgPSBtaW4yIC0gbWF4MTtcblxuICAgICAgICBpZihkMSA+IDAgfHwgZDIgPiAwKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgbWluRGlzdCA9IChtYXgyIC0gbWluMSkgKiAtMTtcbiAgICAgICAgaWYoZmxpcCkgeyBtaW5EaXN0ICo9IC0xOyB9XG5cbiAgICAgICAgbWluRGlzdEFicyA9IE1hdGguYWJzKG1pbkRpc3QpO1xuXG4gICAgICAgIGlmKG1pbkRpc3RBYnMgPCBzaG9ydGVzdERpc3QpIHtcbiAgICAgICAgICByZXN1bHQuZGlzdGFuY2UgPSBtaW5EaXN0O1xuICAgICAgICAgIHJlc3VsdC5tYWduaXR1ZGUgPSBtaW5EaXN0QWJzO1xuICAgICAgICAgIHJlc3VsdC5ub3JtYWxYID0gbm9ybWFsWDtcbiAgICAgICAgICByZXN1bHQubm9ybWFsWSA9IG5vcm1hbFk7XG5cbiAgICAgICAgICBpZihyZXN1bHQuZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQuZGlzdGFuY2UgKj0gLTE7XG4gICAgICAgICAgICByZXN1bHQubm9ybWFsWCAqPSAtMTtcbiAgICAgICAgICAgIHJlc3VsdC5ub3JtYWxZICo9IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbGxpZGVkID0gdHJ1ZTtcbiAgICAgICAgICBzaG9ydGVzdERpc3QgPSBtaW5EaXN0QWJzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERvIHJldHVybiB0aGUgYWN0dWFsIGNvbGxpc2lvblxuICAgICAgcmV0dXJuIGNvbGxpZGVkID8gcmVzdWx0IDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYXRDb2xsaXNpb24obzEsbzIpIHtcbiAgICAgIHZhciByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQ7XG5cbiAgICAgIGlmKCFvMS5wLnBvaW50cykgeyBRLl9nZW5lcmF0ZVBvaW50cyhvMSk7IH1cbiAgICAgIGlmKCFvMi5wLnBvaW50cykgeyBRLl9nZW5lcmF0ZVBvaW50cyhvMik7IH1cblxuICAgICAgcmVzdWx0MSA9IGNvbGxpZGUobzEsbzIpO1xuICAgICAgaWYoIXJlc3VsdDEpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIHJlc3VsdDIgPSBjb2xsaWRlKG8yLG8xLHRydWUpO1xuICAgICAgaWYoIXJlc3VsdDIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIHJlc3VsdCA9IChyZXN1bHQyLm1hZ25pdHVkZSA8IHJlc3VsdDEubWFnbml0dWRlKSA/IHJlc3VsdDIgOiByZXN1bHQxO1xuXG4gICAgICBpZihyZXN1bHQubWFnbml0dWRlID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgcmVzdWx0LnNlcGFyYXRlWzBdID0gcmVzdWx0LmRpc3RhbmNlICogcmVzdWx0Lm5vcm1hbFg7XG4gICAgICByZXN1bHQuc2VwYXJhdGVbMV0gPSByZXN1bHQuZGlzdGFuY2UgKiByZXN1bHQubm9ybWFsWTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2F0Q29sbGlzaW9uO1xuICB9KCkpO1xuXG5cbiAgLyoqXG4gICBDaGVjayBmb3IgdGhlIG92ZXJsYXAgb2YgdGhlIGJvdWRuaW5nIGJveGVzIG9mIHR3byBTcHJpdGVzXG5cbiAgIEBtZXRob2QgUS5vdmVybGFwXG4gICBAZm9yIFF1aW50dXMuU2NlbmVzXG4gICBAcGFyYW0ge1EuU3ByaXRlfSBvMVxuICAgQHBhcmFtIHtRLlNwcml0ZX0gbzJcbiAgIEByZXR1cm5zIHtCb29sZWFufVxuICAqL1xuICBRLm92ZXJsYXAgPSBmdW5jdGlvbihvMSxvMikge1xuICAgIHZhciBjMSA9IG8xLmMgfHwgbzEucCB8fCBvMTtcbiAgICB2YXIgYzIgPSBvMi5jIHx8IG8yLnAgfHwgbzI7XG5cbiAgICB2YXIgbzF4ID0gYzEueCAtIChjMS5jeCB8fCAwKSxcbiAgICAgICAgbzF5ID0gYzEueSAtIChjMS5jeSB8fCAwKTtcbiAgICB2YXIgbzJ4ID0gYzIueCAtIChjMi5jeCB8fCAwKSxcbiAgICAgICAgbzJ5ID0gYzIueSAtIChjMi5jeSB8fCAwKTtcblxuICAgIHJldHVybiAhKChvMXkrYzEuaDxvMnkpIHx8IChvMXk+bzJ5K2MyLmgpIHx8XG4gICAgICAgICAgICAgKG8xeCtjMS53PG8yeCkgfHwgKG8xeD5vMngrYzIudykpO1xuICB9O1xuXG4gIC8qKlxuICAgQmFzZSBzdGFnZSBjbGFzcywgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHNldHMgb2Ygc3ByaXRlcy5cblxuICAgYFEuU3RhZ2VgJ3MgYXJlbid0IGdlbmVyYWxseSBpbnN0YW50aWF0ZWQgZGlyZWN0bHksIGJ1dCByYXRoZXIgYXJlIGNyZWF0ZWRcbiAgIGF1dG9tYXRpY2FsbHkgd2hlbiB5b3UgY2FsbCBgUS5zdGFnZVNjZW5lKCdzY2VuZU5hbWUnKWBcblxuICAgQGNsYXNzIFEuU3RhZ2VcbiAgIEBleHRlbmRzIFEuR2FtZU9iamVjdFxuICAgQGZvciBRdWludHVzLlNjZW5lc1xuICAqL1xuICBRLlN0YWdlID0gUS5HYW1lT2JqZWN0LmV4dGVuZCh7XG4gICAgLy8gU2hvdWxkIGtub3cgd2hldGhlciBvciBub3QgdGhlIHN0YWdlIGlzIHBhdXNlZFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICBzb3J0OiBmYWxzZSxcbiAgICAgIGdyaWRXOiA0MDAsXG4gICAgICBncmlkSDogNDAwLFxuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LFxuXG4gICAgaW5pdDogZnVuY3Rpb24oc2NlbmUsb3B0cykge1xuICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgdGhpcy5saXN0cyA9IHt9O1xuICAgICAgdGhpcy5pbmRleCA9IHt9O1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ID0gW107XG4gICAgICB0aGlzLmdyaWQgPSB7fTtcbiAgICAgIHRoaXMuX2NvbGxpc2lvbkxheWVycyA9IFtdO1xuXG4gICAgICB0aGlzLnRpbWUgPSAwO1xuXG4gICAgICB0aGlzLmRlZmF1bHRzWyd3J10gPSBRLndpZHRoO1xuICAgICAgdGhpcy5kZWZhdWx0c1snaCddID0gUS5oZWlnaHQ7XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IFEuX2V4dGVuZCh7fSx0aGlzLmRlZmF1bHRzKTtcbiAgICAgIGlmKHRoaXMuc2NlbmUpICB7IFxuICAgICAgICBRLl9leHRlbmQodGhpcy5vcHRpb25zLHNjZW5lLm9wdHMpO1xuICAgICAgfVxuICAgICAgaWYob3B0cykgeyBRLl9leHRlbmQodGhpcy5vcHRpb25zLG9wdHMpOyB9XG5cblxuICAgICAgaWYodGhpcy5vcHRpb25zLnNvcnQgJiYgIVEuX2lzRnVuY3Rpb24odGhpcy5vcHRpb25zLnNvcnQpKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNvcnQgPSBmdW5jdGlvbihhLGIpIHsgcmV0dXJuICgoYS5wICYmIGEucC56KSB8fCAtMSkgLSAoKGIucCAmJiBiLnAueikgfHwgLTEpOyB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbnZva2UoXCJkZWJpbmRcIik7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJkZXN0cm95ZWRcIik7XG4gICAgfSxcblxuICAgIC8vIE5lZWRzIHRvIGJlIHNlcGFyYXRlZCBvdXQgc28gdGhlIGN1cnJlbnQgc3RhZ2UgY2FuIGJlIHNldFxuICAgIGxvYWRTY2VuZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLnNjZW5lKSAgeyBcbiAgICAgICAgdGhpcy5zY2VuZS5zY2VuZUZ1bmModGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAgTG9hZCBhbiBhcnJheSBvZiBhc3NldHMgb2YgdGhlIGZvcm06XG5cbiAgICAgICAgICBbIFsgXCJQbGF5ZXJcIiwgeyB4OiAxNSwgeTogNTQgfSBdLFxuICAgICAgICAgICAgWyBcIkVuZW15XCIsICB7IHg6IDU0LCB5OiA0MiB9IF0gXVxuXG4gICAgICBFaXRoZXIgcGFzcyBpbiB0aGUgYXJyYXkgb3IgYSBzdHJpbmcgb2YgYXNzZXQgbmFtZVxuXG4gICAgIEBtZXRob2QgbG9hZEFzc2V0c1xuICAgICBAcGFyYW0ge0FycmF5IG9yIFN0cmluZ30gYXNzZXQgLSBBcnJheSBvZiBhc3NldHMgb3IgYSBzdHJpbmcgb2YgYXNzZXQgbmFtZVxuICAgICBAZm9yIFEuU3RhZ2VcbiAgICAqL1xuICAgIC8vIExvYWQgYW4gYXJyYXkgb2YgYXNzZXRzIG9mIHRoZSBmb3JtOlxuICAgIC8vIFsgWyBcIlBsYXllclwiLCB7IHg6IDE1LCB5OiA1NCB9IF0sXG4gICAgLy8gICBbIFwiRW5lbXlcIiwgIHsgeDogNTQsIHk6IDQyIH0gXSBdXG4gICAgLy8gRWl0aGVyIHBhc3MgaW4gdGhlIGFycmF5IG9yIGEgc3RyaW5nIG9mIGFzc2V0IG5hbWVcbiAgICBsb2FkQXNzZXRzOiBmdW5jdGlvbihhc3NldCkge1xuICAgICAgdmFyIGFzc2V0QXJyYXkgPSBRLl9pc0FycmF5KGFzc2V0KSA/IGFzc2V0IDogUS5hc3NldChhc3NldCk7XG4gICAgICBmb3IodmFyIGk9MDtpPGFzc2V0QXJyYXkubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgc3ByaXRlQ2xhc3MgPSBhc3NldEFycmF5W2ldWzBdO1xuICAgICAgICB2YXIgc3ByaXRlUHJvcHMgPSBhc3NldEFycmF5W2ldWzFdO1xuICAgICAgICB0aGlzLmluc2VydChuZXcgUVtzcHJpdGVDbGFzc10oc3ByaXRlUHJvcHMpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBpdGVtIGluIHRoZSBzY2VuZVxuXG4gICAgIEBtZXRob2QgZWFjaFxuICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICBAZm9yIFEuU3RhZ2VcbiAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBmb3IodmFyIGk9MCxsZW49dGhpcy5pdGVtcy5sZW5ndGg7aTxsZW47aSsrKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcy5pdGVtc1tpXSxhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIGludm9rZXMgYSBmdW5jdGlvbmNhbGwgZm9yIGVhY2ggaXRlbSBpbiB0aGUgc2NlbmVcblxuICAgICBAbWV0aG9kIGludm9rZVxuICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jTmFtZVxuICAgICBAZm9yIFEuU3RhZ2VcbiAgICAqL1xuICAgIGludm9rZTogZnVuY3Rpb24oZnVuY05hbWUpIHtcbiAgICAgIGZvcih2YXIgaT0wLGxlbj10aGlzLml0ZW1zLmxlbmd0aDtpPGxlbjtpKyspIHsgICAgICAgICAgICAgIFxuICAgICAgICB0aGlzLml0ZW1zW2ldW2Z1bmNOYW1lXS5jYWxsKFxuICAgICAgICAgIHRoaXMuaXRlbXNbaV0sYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcblxuICAgICBAbWV0aG9kIGRldGVjdFxuICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAgIEBmb3IgUS5TdGFnZVxuICAgICovXG4gICAgZGV0ZWN0OiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICBmb3IodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aC0xO2kgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmKGZ1bmMuY2FsbCh0aGlzLml0ZW1zW2ldLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuXG4gICAgLyoqXG5cbiAgICAgQG1ldGhvZCBpZGVudGlmeVxuICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAgIEBmb3IgUS5TdGFnZVxuICAgICovXG4gICAgaWRlbnRpZnk6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBmb3IodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aC0xO2kgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmKHJlc3VsdCA9IGZ1bmMuY2FsbCh0aGlzLml0ZW1zW2ldLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdKSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG5cbiAgICAgQG1ldGhvZCBmaW5kXG4gICAgIEBwYXJhbSB7TnVtYmVyIG9yIFN0cmluZ30gaWRcbiAgICAgQGZvciBRLlN0YWdlXG4gICAgKi9cbiAgICBmaW5kOiBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhbaWRdO1xuICAgIH0sXG5cbiAgICBhZGRUb0xpc3RzOiBmdW5jdGlvbihsaXN0cyxvYmplY3QpIHtcbiAgICAgIGZvcih2YXIgaT0wO2k8bGlzdHMubGVuZ3RoO2krKykge1xuICAgICAgICB0aGlzLmFkZFRvTGlzdChsaXN0c1tpXSxvYmplY3QpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRUb0xpc3Q6IGZ1bmN0aW9uKGxpc3QsIGl0bSkge1xuICAgICAgaWYoIXRoaXMubGlzdHNbbGlzdF0pIHsgdGhpcy5saXN0c1tsaXN0XSA9IFtdOyB9XG4gICAgICB0aGlzLmxpc3RzW2xpc3RdLnB1c2goaXRtKTtcbiAgICB9LFxuXG5cbiAgICByZW1vdmVGcm9tTGlzdHM6IGZ1bmN0aW9uKGxpc3RzLCBpdG0pIHtcbiAgICAgIGZvcih2YXIgaT0wO2k8bGlzdHMubGVuZ3RoO2krKykge1xuICAgICAgICB0aGlzLnJlbW92ZUZyb21MaXN0KGxpc3RzW2ldLGl0bSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZUZyb21MaXN0OiBmdW5jdGlvbihsaXN0LCBpdG0pIHtcbiAgICAgIHZhciBsaXN0SW5kZXggPSB0aGlzLmxpc3RzW2xpc3RdLmluZGV4T2YoaXRtKTtcbiAgICAgIGlmKGxpc3RJbmRleCAhPT0gLTEpIHsgXG4gICAgICAgIHRoaXMubGlzdHNbbGlzdF0uc3BsaWNlKGxpc3RJbmRleCwxKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIEluc2VydHMgYW4gaXRlbSBkaXJlY3RseSBpbnRvIHRoZSBzY2VuZSwgb3IgaW5zaWRlIGEgY29udGFpbmVyLlxuICAgICBUaGUgb2JqZWN0IGNhbiBsYXRlciBhY2Nlc3NlZCB2aWEgYGNoaWxkcmVuYCBwcm9wZXJ0eSBvZiB0aGUgc2NlbmUgb3IgdGhlIGNvbnRhaW5lci5cblxuICAgICBAbWV0aG9kIGluc2VydFxuICAgICBAZm9yIFEuU3RhZ2VcbiAgICAgQHBhcmFtIHtRLkdhbWVPYmplY3R9IGl0bSAtIHRoZSBJdGVtIHRvIGluc2VydFxuICAgICBAcGFyYW0gW2NvbnRhaW5lcl0gLSBgY29udGFpbmVyYCB0byBhZGQgdGhlIGl0ZW0gdG9cbiAgICAgQHJldHVybiB0aGUgaW5zZXJ0ZWQgb2JqZWN0IGZvciBjaGFpbmluZ1xuICAgICovXG4gICAgaW5zZXJ0OiBmdW5jdGlvbihpdG0sY29udGFpbmVyKSB7XG4gICAgICB0aGlzLml0ZW1zLnB1c2goaXRtKTtcbiAgICAgIGl0bS5zdGFnZSA9IHRoaXM7XG4gICAgICBpdG0uY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgaWYoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5wdXNoKGl0bSk7XG4gICAgICB9XG5cbiAgICAgIGl0bS5ncmlkID0ge307XG5cblxuICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBzcXVhcmUgb2YgY29sbGlzaW9uIHBvaW50c1xuICAgICAgUS5fZ2VuZXJhdGVQb2ludHMoaXRtKTtcbiAgICAgIFEuX2dlbmVyYXRlQ29sbGlzaW9uUG9pbnRzKGl0bSk7XG5cbiAgICAgIFxuICAgICAgaWYoaXRtLmNsYXNzTmFtZSkgeyB0aGlzLmFkZFRvTGlzdChpdG0uY2xhc3NOYW1lLCBpdG0pOyB9XG4gICAgICBpZihpdG0uYWN0aXZlQ29tcG9uZW50cykgeyB0aGlzLmFkZFRvTGlzdHMoaXRtLmFjdGl2ZUNvbXBvbmVudHMsIGl0bSk7IH1cblxuICAgICAgaWYoaXRtLnApIHtcbiAgICAgICAgdGhpcy5pbmRleFtpdG0ucC5pZF0gPSBpdG07XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ2luc2VydGVkJyxpdG0pO1xuICAgICAgaXRtLnRyaWdnZXIoJ2luc2VydGVkJyx0aGlzKTtcblxuICAgICAgdGhpcy5yZWdyaWQoaXRtKTtcbiAgICAgIHJldHVybiBpdG07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgc2NlbmUuXG5cbiAgICAgQG1ldGhvZCByZW1vdmVcbiAgICAgQHBhcmFtIHtRLkdhbWVPYmplY3R9IGl0bSAtIHRoZSBJdGVtIHRvIHJlbW92ZVxuICAgICBAZm9yIFEuU3RhZ2VcbiAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oaXRtKSB7XG4gICAgICB0aGlzLmRlbEdyaWQoaXRtKTtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdC5wdXNoKGl0bSk7XG4gICAgfSxcblxuICAgIGZvcmNlUmVtb3ZlOiBmdW5jdGlvbihpdG0pIHtcbiAgICAgIHZhciBpZHggPSAgdGhpcy5pdGVtcy5pbmRleE9mKGl0bSk7XG4gICAgICBpZihpZHggIT09IC0xKSB7IFxuICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpZHgsMSk7XG5cbiAgICAgICAgaWYoaXRtLmNsYXNzTmFtZSkgeyB0aGlzLnJlbW92ZUZyb21MaXN0KGl0bS5jbGFzc05hbWUsaXRtKTsgfVxuICAgICAgICBpZihpdG0uYWN0aXZlQ29tcG9uZW50cykgeyB0aGlzLnJlbW92ZUZyb21MaXN0cyhpdG0uYWN0aXZlQ29tcG9uZW50cyxpdG0pOyB9XG4gICAgICAgIGlmKGl0bS5jb250YWluZXIpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVySWR4ID0gaXRtLmNvbnRhaW5lci5jaGlsZHJlbi5pbmRleE9mKGl0bSk7XG4gICAgICAgICAgaWYoY29udGFpbmVySWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgaXRtLmNvbnRhaW5lci5jaGlsZHJlbi5zcGxpY2UoY29udGFpbmVySWR4LDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGl0bS5kZXN0cm95KSB7IGl0bS5kZXN0cm95KCk7IH1cbiAgICAgICAgaWYoaXRtLnAuaWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5pbmRleFtpdG0ucC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZW1vdmVkJyxpdG0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgUGF1c2VzIHRoZSBzY2VuZSwgc3ByaXRlcyB3aWxsIG5vIGxvbmdlciBiZSBzdGVwcGVkIGJ1dCBzdGlsbCByZW5kZXJlZC5cblxuICAgICBAbWV0aG9kIHBhdXNlXG4gICAgIEBmb3IgUS5TdGFnZVxuICAgICovXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgVW5wYXVzZXMgdGhlIHNjZW5lLlxuXG4gICAgIEBtZXRob2QgdW5wYXVzZVxuICAgICBAZm9yIFEuU3RhZ2VcbiAgICAqL1xuICAgIHVucGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgX2dyaWRDZWxsQ2hlY2s6IGZ1bmN0aW9uKHR5cGUsaWQsb2JqLGNvbGxpc2lvbk1hc2spIHtcbiAgICAgIGlmKFEuX2lzVW5kZWZpbmVkKGNvbGxpc2lvbk1hc2spIHx8IGNvbGxpc2lvbk1hc2sgJiB0eXBlKSB7XG4gICAgICAgIHZhciBvYmoyID0gdGhpcy5pbmRleFtpZF07XG4gICAgICAgIGlmKG9iajIgJiYgb2JqMiAhPT0gb2JqICYmIFEub3ZlcmxhcChvYmosb2JqMikpIHtcbiAgICAgICAgICB2YXIgY29sPSBRLmNvbGxpc2lvbihvYmosb2JqMik7XG4gICAgICAgICAgaWYoY29sKSB7XG4gICAgICAgICAgICBjb2wub2JqID0gb2JqMjtcbiAgICAgICAgICAgIHJldHVybiBjb2w7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ3JpZFRlc3Q6IGZ1bmN0aW9uKG9iaixjb2xsaXNpb25NYXNrKSB7XG4gICAgICB2YXIgZ3JpZCA9IG9iai5ncmlkLCBncmlkQ2VsbCwgY29sO1xuXG4gICAgICBmb3IodmFyIHkgPSBncmlkLlkxO3kgPD0gZ3JpZC5ZMjt5KyspIHtcbiAgICAgICAgaWYodGhpcy5ncmlkW3ldKSB7XG4gICAgICAgICAgZm9yKHZhciB4ID0gZ3JpZC5YMTt4IDw9IGdyaWQuWDI7eCsrKSB7XG4gICAgICAgICAgICBncmlkQ2VsbCA9IHRoaXMuZ3JpZFt5XVt4XTtcbiAgICAgICAgICAgIGlmKGdyaWRDZWxsKSB7IFxuICAgICAgICAgICAgICBjb2wgPSBRLl9kZXRlY3QoZ3JpZENlbGwsdGhpcy5fZ3JpZENlbGxDaGVjayx0aGlzLG9iaixjb2xsaXNpb25NYXNrKTtcbiAgICAgICAgICAgICAgaWYoY29sKSB7IHJldHVybiBjb2w7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgY29sbGlzaW9uTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICB0aGlzLl9jb2xsaXNpb25MYXllcnMucHVzaChsYXllcik7XG4gICAgICBsYXllci5jb2xsaXNpb25MYXllciA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnQobGF5ZXIpO1xuICAgIH0sXG4gICAgXG4gICAgX2NvbGxpZGVDb2xsaXNpb25MYXllcjogZnVuY3Rpb24ob2JqLGNvbGxpc2lvbk1hc2spIHtcbiAgICAgIHZhciBjb2w7XG5cbiAgICAgIGZvcih2YXIgaSA9IDAsbWF4ID0gdGhpcy5fY29sbGlzaW9uTGF5ZXJzLmxlbmd0aDtpIDwgbWF4O2krKykge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9jb2xsaXNpb25MYXllcnNbaV07XG4gICAgICAgIGlmKGxheWVyLnAudHlwZSAmIGNvbGxpc2lvbk1hc2spIHtcbiAgICAgICAgICBjb2wgPSBsYXllci5jb2xsaWRlKG9iaik7XG4gICAgICAgICAgaWYoY29sKSB7IGNvbC5vYmogPSBsYXllcjsgIHJldHVybiBjb2w7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgU2VhcmNoZXMgdGhlIHNjZW5lIGZvciBhbiBvYmplY3QuXG5cbiAgICAgQG1ldGhvZCBzZWFyY2hcbiAgICAgQHBhcmFtIG9ialxuICAgICBAcGFyYW0gW2NvbGxpc2lvbk1hc2tdIC1cbiAgICAgQGZvciBRLlN0YWdlXG4gICAgKi9cbiAgICBzZWFyY2g6IGZ1bmN0aW9uKG9iaixjb2xsaXNpb25NYXNrKSB7XG4gICAgICB2YXIgY29sO1xuXG4gICAgICAvLyBJZiB0aGUgb2JqZWN0IGRvZXNuJ3QgaGF2ZSBhIGdyaWQsIHJlZ3JpZCBpdFxuICAgICAgLy8gc28gd2Uga25vdyB3aGVyZSB0byBzZWFyY2hcbiAgICAgIC8vIGFuZCBza2lwIGFkZGluZyBpdCB0byB0aGUgZ3JpZCBvbmx5IGlmIGl0J3Mgbm90IG9uIHRoaXMgc3RhZ2VcbiAgICAgIGlmKCFvYmouZ3JpZCkgeyB0aGlzLnJlZ3JpZChvYmosb2JqLnN0YWdlICE9PSB0aGlzKTsgfVxuXG4gICAgICBjb2xsaXNpb25NYXNrID0gUS5faXNVbmRlZmluZWQoY29sbGlzaW9uTWFzaykgPyAob2JqLnAgJiYgb2JqLnAuY29sbGlzaW9uTWFzaykgOiBjb2xsaXNpb25NYXNrO1xuXG4gICAgICBjb2wgPSB0aGlzLl9jb2xsaWRlQ29sbGlzaW9uTGF5ZXIob2JqLGNvbGxpc2lvbk1hc2spO1xuICAgICAgY29sID0gIGNvbCB8fCB0aGlzLmdyaWRUZXN0KG9iaixjb2xsaXNpb25NYXNrKTtcbiAgICAgIHJldHVybiBjb2w7XG4gICAgfSxcblxuICAgIF9sb2NhdGVPYmo6IHtcbiAgICAgIHA6IHsgXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGN4OiAwLFxuICAgICAgICBjeTogMCxcbiAgICAgICAgdzogMSxcbiAgICAgICAgaDogMVxuICAgICAgfSwgZ3JpZDoge31cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIEZpbmRzIGFueSBvYmplY3QgdGhhdCBjb2xsaWRlcyB3aXRoIHRoZSBwb2ludCB4LHkgb24gdGhlIHN0YWdlIChub3Qgb24gdGhlIGNhbnZhcykuXG4gICAgIElmIGBjb2xsaXNpb25NYXNrYCBpcyB1c2VkLCBvbmx5IGNoZWNrcyBmb3IgY29sbGlzaW9ucyB3aXRoIHNwcml0ZXMgb2YgdGhhdCB0eXBlLlxuXG4gICAgIEBtZXRob2QgbG9jYXRlXG4gICAgIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgIEBwYXJhbSBbY29sbGlzaW9uTWFza10gLSB0eXBlIG9mIHRoZSBzcHJpdGVcbiAgICAgQHJldHVybiB0aGUgb2JqZWN0IGlmIG9uZSBpcyBmb3VuZCBvciBmYWxzZVxuICAgICBAZm9yIFEuU3RhZ2VcbiAgICAqL1xuICAgIGxvY2F0ZTogZnVuY3Rpb24oeCx5LGNvbGxpc2lvbk1hc2spIHtcbiAgICAgIHZhciBjb2wgPSBudWxsO1xuXG4gICAgICB0aGlzLl9sb2NhdGVPYmoucC54ID0geDtcbiAgICAgIHRoaXMuX2xvY2F0ZU9iai5wLnkgPSB5O1xuXG4gICAgICB0aGlzLnJlZ3JpZCh0aGlzLl9sb2NhdGVPYmosdHJ1ZSk7XG5cbiAgICAgIGNvbCA9IHRoaXMuX2NvbGxpZGVDb2xsaXNpb25MYXllcih0aGlzLl9sb2NhdGVPYmosY29sbGlzaW9uTWFzayk7XG4gICAgICBjb2wgPSAgY29sIHx8IHRoaXMuZ3JpZFRlc3QodGhpcy5fbG9jYXRlT2JqLGNvbGxpc2lvbk1hc2spO1xuXG4gICAgICBpZihjb2wgJiYgY29sLm9iaikge1xuICAgICAgICByZXR1cm4gY29sLm9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgY2FsY3VsYXRlcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGNvbGxpZGVzIHdpdGggYW55dGhpbmcgaW4gdGhlIHNjZW5lXG5cbiAgICAgQG1ldGhvZCBjb2xsaWRlXG4gICAgIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IG9uIHRoYXQgdGhlIGNvbGxpc2lvbnMgc2hvdWxkIGJlIGNoZWNrZWRcbiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGNvbGxpc2lvbnNNYXNrLCBtYXhDb2wsIHNraXBFdmVudHMgdG8gb3ZlcndyaXRlIGZyb20gb2JqXG4gICAgIEByZXR1cm4gY29sMiB8fCBjb2xcbiAgICAgQGZvciBRLlN0YWdlXG4gICAgKi9cbiAgICBjb2xsaWRlOiBmdW5jdGlvbihvYmosb3B0aW9ucykge1xuICAgICAgdmFyIGNvbCwgY29sMiwgY29sbGlzaW9uTWFzaywgXG4gICAgICAgICAgbWF4Q29sLCBjdXJDb2wsIHNraXBFdmVudHM7XG4gICAgICBpZihRLl9pc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBjb2xsaXNpb25NYXNrID0gb3B0aW9ucy5jb2xsaXNpb25NYXNrO1xuICAgICAgICBtYXhDb2wgPSBvcHRpb25zLm1heENvbDtcbiAgICAgICAgc2tpcEV2ZW50cyA9IG9wdGlvbnMuc2tpcEV2ZW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbGxpc2lvbk1hc2sgPSBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29sbGlzaW9uTWFzayA9IFEuX2lzVW5kZWZpbmVkKGNvbGxpc2lvbk1hc2spID8gKG9iai5wICYmIG9iai5wLmNvbGxpc2lvbk1hc2spIDogY29sbGlzaW9uTWFzaztcbiAgICAgIG1heENvbCA9IG1heENvbCB8fCAzO1xuXG5cbiAgICAgIFEuX2dlbmVyYXRlQ29sbGlzaW9uUG9pbnRzKG9iaik7XG4gICAgICB0aGlzLnJlZ3JpZChvYmopO1xuXG4gICAgICBjdXJDb2wgPSBtYXhDb2w7XG4gICAgICB3aGlsZShjdXJDb2wgPiAwICYmIChjb2wgPSB0aGlzLl9jb2xsaWRlQ29sbGlzaW9uTGF5ZXIob2JqLGNvbGxpc2lvbk1hc2spKSkge1xuICAgICAgICBpZighc2tpcEV2ZW50cykgeyBcbiAgICAgICAgICBvYmoudHJpZ2dlcignaGl0Jyxjb2wpO1xuICAgICAgICAgIG9iai50cmlnZ2VyKCdoaXQuY29sbGlzaW9uJyxjb2wpO1xuICAgICAgICB9XG4gICAgICAgIFEuX2dlbmVyYXRlQ29sbGlzaW9uUG9pbnRzKG9iaik7XG4gICAgICAgIHRoaXMucmVncmlkKG9iaik7XG4gICAgICAgIGN1ckNvbC0tO1xuICAgICAgfVxuXG4gICAgICBjdXJDb2wgPSBtYXhDb2w7XG4gICAgICB3aGlsZShjdXJDb2wgPiAwICYmIChjb2wyID0gdGhpcy5ncmlkVGVzdChvYmosY29sbGlzaW9uTWFzaykpKSB7XG4gICAgICAgIG9iai50cmlnZ2VyKCdoaXQnLGNvbDIpO1xuICAgICAgICBvYmoudHJpZ2dlcignaGl0LnNwcml0ZScsY29sMik7XG5cbiAgICAgICAgLy8gRG8gdGhlIHJlY2lwcmljb2wgY29sbGlzaW9uXG4gICAgICAgIC8vIFRPRE86IGV4dHJhY3RcbiAgICAgICAgaWYoIXNraXBFdmVudHMpIHsgXG4gICAgICAgICAgdmFyIG9iajIgPSBjb2wyLm9iajtcbiAgICAgICAgICBjb2wyLm9iaiA9IG9iajtcbiAgICAgICAgICBjb2wyLm5vcm1hbFggKj0gLTE7XG4gICAgICAgICAgY29sMi5ub3JtYWxZICo9IC0xO1xuICAgICAgICAgIGNvbDIuZGlzdGFuY2UgPSAwO1xuICAgICAgICAgIGNvbDIubWFnbml0dWRlID0gMDtcbiAgICAgICAgICBjb2wyLnNlcGFyYXRlWzBdID0gMDtcbiAgICAgICAgICBjb2wyLnNlcGFyYXRlWzFdID0gMDtcblxuICAgICAgICAgIFxuICAgICAgICAgIG9iajIudHJpZ2dlcignaGl0Jyxjb2wyKTtcbiAgICAgICAgICBvYmoyLnRyaWdnZXIoJ2hpdC5zcHJpdGUnLGNvbDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgUS5fZ2VuZXJhdGVDb2xsaXNpb25Qb2ludHMob2JqKTtcbiAgICAgICAgdGhpcy5yZWdyaWQob2JqKTtcbiAgICAgICAgY3VyQ29sLS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2wyIHx8IGNvbDtcbiAgICB9LFxuXG4gICAgZGVsR3JpZDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdmFyIGdyaWQgPSBpdGVtLmdyaWQ7XG5cbiAgICAgIGZvcih2YXIgeSA9IGdyaWQuWTE7eSA8PSBncmlkLlkyO3krKykge1xuICAgICAgICBpZih0aGlzLmdyaWRbeV0pIHtcbiAgICAgICAgICBmb3IodmFyIHggPSBncmlkLlgxO3ggPD0gZ3JpZC5YMjt4KyspIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JpZFt5XVt4XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ3JpZFt5XVt4XVtpdGVtLnAuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRHcmlkOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICB2YXIgZ3JpZCA9IGl0ZW0uZ3JpZDtcblxuICAgICAgZm9yKHZhciB5ID0gZ3JpZC5ZMTt5IDw9IGdyaWQuWTI7eSsrKSB7XG4gICAgICAgIGlmKCF0aGlzLmdyaWRbeV0pIHsgdGhpcy5ncmlkW3ldID0ge307IH1cbiAgICAgICAgZm9yKHZhciB4ID0gZ3JpZC5YMTt4IDw9IGdyaWQuWDI7eCsrKSB7XG4gICAgICAgICAgaWYoIXRoaXMuZ3JpZFt5XVt4XSkgeyB0aGlzLmdyaWRbeV1beF0gPSB7fTsgfVxuICAgICAgICAgIHRoaXMuZ3JpZFt5XVt4XVtpdGVtLnAuaWRdID0gaXRlbS5wLnR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBBZGQgYW4gaXRlbSBpbnRvIHRoZSBjb2xsaXNpb24gZGV0ZWN0aW9uIGdyaWQsXG4gICAgLy8gSWdub3JlIGNvbGxpc2lvbiBsYXllcnNcbiAgICByZWdyaWQ6IGZ1bmN0aW9uKGl0ZW0sc2tpcEFkZCkge1xuICAgICAgaWYoaXRlbS5jb2xsaXNpb25MYXllcikgeyByZXR1cm47IH1cbiAgICAgIGl0ZW0uZ3JpZCA9IGl0ZW0uZ3JpZCB8fCB7fTtcblxuICAgICAgdmFyIGMgPSBpdGVtLmMgfHwgaXRlbS5wO1xuXG4gICAgICB2YXIgZ3JpZFgxID0gTWF0aC5mbG9vcigoYy54IC0gYy5jeCkgLyB0aGlzLm9wdGlvbnMuZ3JpZFcpLFxuICAgICAgICAgIGdyaWRZMSA9IE1hdGguZmxvb3IoKGMueSAtIGMuY3kpIC8gdGhpcy5vcHRpb25zLmdyaWRIKSxcbiAgICAgICAgICBncmlkWDIgPSBNYXRoLmZsb29yKChjLnggLSBjLmN4ICsgYy53KSAvIHRoaXMub3B0aW9ucy5ncmlkVyksXG4gICAgICAgICAgZ3JpZFkyID0gTWF0aC5mbG9vcigoYy55IC0gYy5jeSArIGMuaCkgLyB0aGlzLm9wdGlvbnMuZ3JpZEgpLFxuICAgICAgICAgIGdyaWQgPSBpdGVtLmdyaWQ7XG5cbiAgICAgIGlmKGdyaWQuWDEgIT09IGdyaWRYMSB8fCBncmlkLlgyICE9PSBncmlkWDIgfHwgXG4gICAgICAgICBncmlkLlkxICE9PSBncmlkWTEgfHwgZ3JpZC5ZMiAhPT0gZ3JpZFkyKSB7XG5cbiAgICAgICAgIGlmKGdyaWQuWDEgIT09IHZvaWQgMCkgeyB0aGlzLmRlbEdyaWQoaXRlbSk7IH1cbiAgICAgICAgIGdyaWQuWDEgPSBncmlkWDE7XG4gICAgICAgICBncmlkLlgyID0gZ3JpZFgyO1xuICAgICAgICAgZ3JpZC5ZMSA9IGdyaWRZMTtcbiAgICAgICAgIGdyaWQuWTIgPSBncmlkWTI7XG5cbiAgICAgICAgIGlmKCFza2lwQWRkKSB7IHRoaXMuYWRkR3JpZChpdGVtKTsgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgbWFya1Nwcml0ZXM6IGZ1bmN0aW9uKGl0ZW1zLHRpbWUpIHtcbiAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQsXG4gICAgICAgICAgc2NhbGUgPSB2aWV3cG9ydCA/IHZpZXdwb3J0LnNjYWxlIDogMSxcbiAgICAgICAgICB4ID0gdmlld3BvcnQgPyB2aWV3cG9ydC54IDogMCxcbiAgICAgICAgICB5ID0gdmlld3BvcnQgPyB2aWV3cG9ydC55IDogMCxcbiAgICAgICAgICB2aWV3VyA9IFEud2lkdGggLyBzY2FsZSxcbiAgICAgICAgICB2aWV3SCA9IFEuaGVpZ2h0IC8gc2NhbGUsXG4gICAgICAgICAgZ3JpZFgxID0gTWF0aC5mbG9vcih4IC8gdGhpcy5vcHRpb25zLmdyaWRXKSxcbiAgICAgICAgICBncmlkWTEgPSBNYXRoLmZsb29yKHkgLyB0aGlzLm9wdGlvbnMuZ3JpZEgpLFxuICAgICAgICAgIGdyaWRYMiA9IE1hdGguZmxvb3IoKHggKyB2aWV3VykgLyB0aGlzLm9wdGlvbnMuZ3JpZFcpLFxuICAgICAgICAgIGdyaWRZMiA9IE1hdGguZmxvb3IoKHkgKyB2aWV3SCkgLyB0aGlzLm9wdGlvbnMuZ3JpZEgpLFxuICAgICAgICAgIGdyaWRSb3csIGdyaWRCbG9jaztcblxuICAgICAgZm9yKHZhciBpeT1ncmlkWTE7IGl5PD1ncmlkWTI7IGl5KyspIHtcbiAgICAgICAgaWYoKGdyaWRSb3cgPSB0aGlzLmdyaWRbaXldKSkgeyBcbiAgICAgICAgICBmb3IodmFyIGl4PWdyaWRYMTsgaXg8PWdyaWRYMjsgaXgrKykge1xuICAgICAgICAgICAgaWYoKGdyaWRCbG9jayA9IGdyaWRSb3dbaXhdKSkge1xuICAgICAgICAgICAgICBmb3IodmFyIGlkIGluIGdyaWRCbG9jaykge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5kZXhbaWRdKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2lkXS5tYXJrID0gdGltZTtcbiAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5kZXhbaWRdLmNvbnRhaW5lcikgeyB0aGlzLmluZGV4W2lkXS5jb250YWluZXIubWFyayA9IHRpbWU7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlU3ByaXRlczogZnVuY3Rpb24oaXRlbXMsZHQsaXNDb250YWluZXIpIHtcbiAgICAgIHZhciBpdGVtO1xuXG4gICAgICBmb3IodmFyIGk9MCxsZW49aXRlbXMubGVuZ3RoO2k8bGVuO2krKykgeyAgICAgICAgICAgICAgXG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgLy8gSWYgc2V0IHRvIHZpc2libGUgb25seSwgZG9uJ3Qgc3RlcCBpZiBzZXQgdG8gdmlzaWJsZU9ubHlcbiAgICAgICAgaWYoIWlzQ29udGFpbmVyICYmIChpdGVtLnAudmlzaWJsZU9ubHkgJiYgKCFpdGVtLm1hcmsgfHwgaXRlbS5tYXJrIDwgdGhpcy50aW1lKSkpIHsgY29udGludWU7IH1cblxuICAgICAgICBpZihpc0NvbnRhaW5lciB8fCAhaXRlbS5jb250YWluZXIpIHsgXG4gICAgICAgICAgaXRlbS51cGRhdGUoZHQpO1xuICAgICAgICAgIFEuX2dlbmVyYXRlQ29sbGlzaW9uUG9pbnRzKGl0ZW0pO1xuICAgICAgICAgIHRoaXMucmVncmlkKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuXG5cbiAgICBzdGVwOmZ1bmN0aW9uKGR0KSB7XG4gICAgICBpZih0aGlzLnBhdXNlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgdGhpcy50aW1lICs9IGR0O1xuICAgICAgdGhpcy5tYXJrU3ByaXRlcyh0aGlzLml0ZW1zLHRoaXMudGltZSk7XG5cbiAgICAgIHRoaXMudHJpZ2dlcihcInByZXN0ZXBcIixkdCk7XG4gICAgICB0aGlzLnVwZGF0ZVNwcml0ZXModGhpcy5pdGVtcyxkdCk7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJzdGVwXCIsZHQpO1xuXG4gICAgICBpZih0aGlzLnJlbW92ZUxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IodmFyIGk9MCxsZW49dGhpcy5yZW1vdmVMaXN0Lmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgICAgICAgICB0aGlzLmZvcmNlUmVtb3ZlKHRoaXMucmVtb3ZlTGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcigncG9zdHN0ZXAnLGR0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIEhpZGVzIHRoZSBzY2VuZS5cblxuICAgICBAbWV0aG9kIGhpZGVcbiAgICAgQGZvciBRLlN0YWdlXG4gICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFVuaGlkZXMgdGhlIHNjZW5lLlxuXG4gICAgIEBtZXRob2Qgc2hvd1xuICAgICBAZm9yIFEuU3RhZ2VcbiAgICAqL1xuICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFN0b3BzIHRoZSBzY2VuZSAoaGlkZXMgYW5kIHBhdXNlcykuXG5cbiAgICAgQG1ldGhvZCBzdG9wXG4gICAgIEBmb3IgUS5TdGFnZVxuICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFN0YXJ0cyB0aGUgc2NlbmUgKHNob3dzIGFuZCB1bnBhdXNlcykuXG5cbiAgICAgQG1ldGhvZCBzdGFydFxuICAgICBAZm9yIFEuU3RhZ2VcbiAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgdGhpcy51bnBhdXNlKCk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZih0aGlzLmhpZGRlbikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGlmKHRoaXMub3B0aW9ucy5zb3J0KSB7XG4gICAgICAgIHRoaXMuaXRlbXMuc29ydCh0aGlzLm9wdGlvbnMuc29ydCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoXCJwcmVyZW5kZXJcIixjdHgpO1xuICAgICAgdGhpcy50cmlnZ2VyKFwiYmVmb3JlcmVuZGVyXCIsY3R4KTtcblxuICAgICAgZm9yKHZhciBpPTAsbGVuPXRoaXMuaXRlbXMubGVuZ3RoO2k8bGVuO2krKykgeyAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgICAgLy8gRG9uJ3QgcmVuZGVyIHNwcml0ZXMgd2l0aCBjb250YWluZXJzIChzcHJpdGVzIGRvIHRoYXQgdGhlbXNlbHZlcylcbiAgICAgICAgLy8gQWxzbyBkb24ndCByZW5kZXIgaWYgbm90IG9uc2NyZWVuXG4gICAgICAgIGlmKCFpdGVtLmNvbnRhaW5lciAmJiAoaXRlbS5wLnJlbmRlckFsd2F5cyB8fCBpdGVtLm1hcmsgPj0gdGhpcy50aW1lKSkge1xuICAgICAgICAgIGl0ZW0ucmVuZGVyKGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihcInJlbmRlclwiLGN0eCk7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJwb3N0cmVuZGVyXCIsY3R4KTtcbiAgICB9XG4gIH0pO1xuXG4gIFEuYWN0aXZlU3RhZ2UgPSAwO1xuXG4gIFEuU3RhZ2VTZWxlY3RvciA9IFEuQ2xhc3MuZXh0ZW5kKHtcbiAgICBlbXB0eUxpc3Q6IFtdLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oc3RhZ2Usc2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuICAgICAgLy8gR2VuZXJhdGUgYW4gb2JqZWN0IGxpc3QgZnJvbSB0aGUgc2VsZWN0b3JcbiAgICAgIC8vIFRPRE86IGhhbmRsZSBhcnJheSBzZWxlY3RvcnNcbiAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLnN0YWdlLmxpc3RzW3RoaXMuc2VsZWN0b3JdIHx8IHRoaXMuZW1wdHlMaXN0O1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgZWFjaDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGZvcih2YXIgaT0wLGxlbj10aGlzLml0ZW1zLmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLml0ZW1zW2ldLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGludm9rZTogZnVuY3Rpb24oZnVuY05hbWUpIHtcbiAgICAgIGZvcih2YXIgaT0wLGxlbj10aGlzLml0ZW1zLmxlbmd0aDtpPGxlbjtpKyspIHsgICAgICAgICAgICAgIFxuICAgICAgICB0aGlzLml0ZW1zW2ldW2Z1bmNOYW1lXS5jYWxsKFxuICAgICAgICAgIHRoaXMuaXRlbXNbaV0sYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUscGFyYW1zKSB7XG4gICAgICB0aGlzLmludm9rZShcInRyaWdnZXJcIixuYW1lLHBhcmFtcyk7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbnZva2UoXCJkZXN0cm95XCIpO1xuICAgIH0sXG5cbiAgICBkZXRlY3Q6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIGZvcih2YXIgaSA9IDAsdmFsPW51bGwsIGxlbj10aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmKGZ1bmMuY2FsbCh0aGlzLml0ZW1zW2ldLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgaWRlbnRpZnk6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgZm9yKHZhciBpID0gMCx2YWw9bnVsbCwgbGVuPXRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYocmVzdWx0ID0gZnVuYy5jYWxsKHRoaXMuaXRlbXNbaV0sYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9LFxuXG4gICAgLy8gVGhpcyBoaWRkZW4gdXRpbGl0eSBtZXRob2QgZXh0ZW5kc1xuICAgIC8vIGFuZCBvYmplY3QncyBwcm9wZXJ0aWVzIHdpdGggYSBzb3VyY2Ugb2JqZWN0LlxuICAgIC8vIFVzZWQgYnkgdGhlIHAgbWV0aG9kIHRvIHNldCBwcm9wZXJ0aWVzLlxuICAgIF9wT2JqZWN0OiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIFEuX2V4dGVuZCh0aGlzLnAsc291cmNlKTtcbiAgICB9LFxuXG4gICAgX3BTaW5nbGU6IGZ1bmN0aW9uKHByb3BlcnR5LHZhbHVlKSB7XG4gICAgICB0aGlzLnBbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAvLyBJcyB2YWx1ZSB1bmRlZmluZWRcbiAgICAgIGlmKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5lYWNoKHRoaXMuX3BPYmplY3QscHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lYWNoKHRoaXMuX3BTaW5nbGUscHJvcGVydHksdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYXQ6IGZ1bmN0aW9uKGlkeCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbaWR4XTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbMF07XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGgtMV07XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIE1heWJlIGFkZCBzdXBwb3J0IGZvciBkaWZmZXJlbnQgdHlwZXNcbiAgLy8gZW50aXR5IC0gYWN0aXZlIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgLy8gIHBhcnRpY2xlIC0gbm8gY29sbGlzaW9uIGRldGVjdGlvbiwgbm8gYWRkaW5nIGNvbXBvbmVudHMgdG8gbGlzdHMgLyBldGNcbiAgLy9cblxuICAvLyBRKFwiUGxheWVyXCIpLmludm9rZShcInNoaW1tZXIpOyAtIG5lZWRzIHRvIHJldHVybiBhIHNlbGVjdG9yXG4gIC8vIFEoXCIuaGFwcHlcIikuaW52b2tlKFwic2FzZGZhXCIsJ2Zkc2FmYXMnLFwiZmFzZGZhc1wiKTtcbiAgLy8gUShcIkVuZW15XCIpLnAoeyBhOiBcImFzZGZhc2ZcIiAgfSk7XG5cbiAgUS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3RvcixzY29wZSkge1xuICAgIHNjb3BlID0gKHNjb3BlID09PSB2b2lkIDApID8gUS5hY3RpdmVTdGFnZSA6IHNjb3BlO1xuICAgIHNjb3BlID0gUS5zdGFnZShzY29wZSk7XG4gICAgaWYoUS5faXNOdW1iZXIoc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gc2NvcGUuaW5kZXhbc2VsZWN0b3JdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFEuU3RhZ2VTZWxlY3RvcihzY29wZSxzZWxlY3Rvcik7XG4gICAgICAvLyBjaGVjayBpZiBpcyBhcnJheVxuICAgICAgLy8gY2hlY2sgaXMgaGFzIGFueSBjb21tYXNcbiAgICAgICAgIC8vIHNwbGl0IGludG8gYXJyYXlzXG4gICAgICAvLyBmaW5kIGVhY2ggb2YgdGhlIGNsYXNzZXNcbiAgICAgIC8vIGZpbmQgYWxsIHRoZSBpbnN0YW5jZXMgb2YgYSBzcGVjaWZpYyBjbGFzc1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgIFJldHVybnMgdGhlIGRlZmF1bHQgb3IgY3VycmVudGx5IGFjdGl2ZSBzdGFnZS5cbiAgIElmIGNhbGxlZCBmcm9tIGEgc3ByaXRlcyBzdGVwKCkgcmV0dXJucyB0aGUgc3RhZ2UgdGhhdCB0aGUgc3ByaXRlIGlzIG1lbWJlciBvZlxuICAgSWYgYSBudW1iZXIgaXMgcGFzc2VkIGluLCB0aGlzIHN0YWdlcyBpcyByZXR1cm5lZFxuICAgKldhcm5pbmcqIG1pZ2h0IHJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGF0IHN0YWdlIGRvZXNudCBleGlzdCFcblxuICAgQG1ldGhvZCBRLnN0YWdlXG4gICBAZm9yIFFcbiAgIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBudW1iZXIgb2YgdGhlIHN0YWdlXG4gICBAcmV0dXJuIHtRLlN0YWdlfSBjdXJyZW50LCBhY3RpdmUsIG9yIG51bWJlcmVkIHN0YWdlXG4gICovXG4gIFEuc3RhZ2UgPSBmdW5jdGlvbihudW0pIHtcbiAgICAvLyBVc2UgYWN0aXZlU3RhZ2UgaXMgbnVtIGlzIHVuZGVmaW5lZFxuICAgIG51bSA9IChudW0gPT09IHZvaWQgMCkgPyBRLmFjdGl2ZVN0YWdlIDogbnVtO1xuICAgIHJldHVybiBRLnN0YWdlc1tudW1dO1xuICB9O1xuXG4gIC8qKlxuICAgU3RhZ2VzIGEgc2NlbmUuIGBudW1gIGlzIGxpa2UgYSB6LWluZGV4LiBIaWdoZXIgbnVtYmVyZWQgc3RhZ2VzIHJlbmRlciBvbiB0b3BcbiAgIG9mIGxvd2VyIG51bWJlcmVkIHN0YWdlcyFcblxuICAgQG1ldGhvZCBRLnN0YWdlU2NlbmVcbiAgIEBwYXJhbSB7US5TY2VuZSBvciBTdHJpbmd9IHNjZW5lIC0gYSBRLlNjZW5lIG9yIHRoZSBzdHJpbmcgZm9yIG5hbWUgb2YgYSBzY2VuZVxuICAgQHBhcmFtIHtudW1iZXJ9IFtudW1dIC0gaW5kZXhcbiAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gc29tZSBvcHRpb25zXG4gICBAZm9yIFF1aW50dXNcbiAgICovXG4gIFEuc3RhZ2VTY2VuZSA9IGZ1bmN0aW9uKHNjZW5lLG51bSxvcHRpb25zKSB7XG4gICAgLy8gSWYgaXQncyBhIHN0cmluZywgZmluZCBhIHJlZ2lzdGVyZWQgc2NlbmUgYnkgdGhhdCBuYW1lXG4gICAgaWYoUS5faXNTdHJpbmcoc2NlbmUpKSB7XG4gICAgICBzY2VuZSA9IFEuc2NlbmUoc2NlbmUpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB1c2VyIHNraXBwZWQgdGhlIG51bSBhcmcgYW5kIHdlbnQgc3RyYWlnaHQgdG8gb3B0aW9ucyxcbiAgICAvLyBzd2FwIHRoZSB0d28gYW5kIGdyYWIgYSBkZWZhdWx0IGZvciBudW1cbiAgICBpZihRLl9pc09iamVjdChudW0pKSB7XG4gICAgICBvcHRpb25zID0gbnVtO1xuICAgICAgbnVtID0gUS5fcG9wUHJvcGVydHkob3B0aW9ucyxcInN0YWdlXCIpIHx8IChzY2VuZSAmJiBzY2VuZS5vcHRzLnN0YWdlKSB8fCAwO1xuICAgIH1cblxuICAgIC8vIENsb25lIHRoZSBvcHRpb25zIGFyZyB0byBwcmV2ZW50IG1vZGlmaWNhdGlvblxuICAgIG9wdGlvbnMgPSBRLl9jbG9uZShvcHRpb25zKTtcblxuICAgIC8vIEdyYWIgdGhlIHN0YWdlIGNsYXNzLCBwdWxsaW5nIGZyb20gb3B0aW9ucywgdGhlIHNjZW5lIGRlZmF1bHQsIG9yIHVzZVxuICAgIC8vIHRoZSBkZWZhdWx0IHN0YWdlXG4gICAgdmFyIFN0YWdlQ2xhc3MgPSAoUS5fcG9wUHJvcGVydHkob3B0aW9ucyxcInN0YWdlQ2xhc3NcIikpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgKHNjZW5lICYmIHNjZW5lLm9wdHMuc3RhZ2VDbGFzcykgfHwgUS5TdGFnZTtcblxuICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggc3RhZ2UgdG8gdXNlXG4gICAgbnVtID0gUS5faXNVbmRlZmluZWQobnVtKSA/ICgoc2NlbmUgJiYgc2NlbmUub3B0cy5zdGFnZSkgfHwgMCkgOiBudW07XG5cbiAgICAvLyBDbGVhbiB1cCBhbiBleGlzdGluZyBzdGFnZSBpZiBuZWNlc3NhcnlcbiAgICBpZihRLnN0YWdlc1tudW1dKSB7XG4gICAgICBRLnN0YWdlc1tudW1dLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHRoaXMgdGhpcyB0aGUgYWN0aXZlIHN0YWdlIGFuZCBpbml0aWFsaXplIHRoZSBzdGFnZSxcbiAgICAvLyBjYWxsaW5nIGxvYWRTY2VuZSB0byBwb3B1cGxhdGUgdGhlIHN0YWdlIGlmIHdlIGhhdmUgYSBzY2VuZS5cbiAgICBRLmFjdGl2ZVN0YWdlID0gbnVtO1xuICAgIHZhciBzdGFnZSA9IFEuc3RhZ2VzW251bV0gPSBuZXcgU3RhZ2VDbGFzcyhzY2VuZSxvcHRpb25zKTtcblxuICAgIC8vIExvYWQgYW4gYXNzZXRzIG9iamVjdCBhcnJheVxuICAgIGlmKHN0YWdlLm9wdGlvbnMuYXNzZXQpIHtcbiAgICAgIHN0YWdlLmxvYWRBc3NldHMoc3RhZ2Uub3B0aW9ucy5hc3NldCk7XG4gICAgfVxuXG4gICAgaWYoc2NlbmUpIHtcbiAgICAgIHN0YWdlLmxvYWRTY2VuZSgpO1xuICAgIH1cbiAgICBRLmFjdGl2ZVN0YWdlID0gMDtcblxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gbG9vcCBhY3RpdmUsIHJ1biB0aGUgZGVmYXVsdCBzdGFnZUdhbWVMb29wXG4gICAgaWYoIVEubG9vcCkge1xuICAgICAgUS5nYW1lTG9vcChRLnN0YWdlR2FtZUxvb3ApO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHkgcmV0dXJuIHRoZSBzdGFnZSB0byB0aGUgdXNlciBmb3IgdXNlIGlmIG5lZWRlZFxuICAgIHJldHVybiBzdGFnZTtcbiAgfTtcblxuICBRLnN0YWdlR2FtZUxvb3AgPSBmdW5jdGlvbihkdCkge1xuICAgIHZhciBpLGxlbixzdGFnZTtcblxuXG4gICAgaWYoZHQgPCAwKSB7IGR0ID0gMS4wLzYwOyB9XG4gICAgaWYoZHQgPiAxLzE1KSB7IGR0ICA9IDEuMC8xNTsgfVxuXG4gICAgZm9yKGkgPTAsbGVuPVEuc3RhZ2VzLmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgICAgIFEuYWN0aXZlU3RhZ2UgPSBpO1xuICAgICAgc3RhZ2UgPSBRLnN0YWdlKCk7XG4gICAgICBpZihzdGFnZSkge1xuICAgICAgICBzdGFnZS5zdGVwKGR0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihRLmN0eCkgeyBRLmNsZWFyKCk7IH1cblxuICAgIGZvcihpID0wLGxlbj1RLnN0YWdlcy5sZW5ndGg7aTxsZW47aSsrKSB7XG4gICAgICBRLmFjdGl2ZVN0YWdlID0gaTtcbiAgICAgIHN0YWdlID0gUS5zdGFnZSgpO1xuICAgICAgaWYoc3RhZ2UpIHtcbiAgICAgICAgc3RhZ2UucmVuZGVyKFEuY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBRLmFjdGl2ZVN0YWdlID0gMDtcblxuICAgIGlmKFEuaW5wdXQgJiYgUS5jdHgpIHsgUS5pbnB1dC5kcmF3Q2FudmFzKFEuY3R4KTsgfVxuICB9O1xuXG4gIC8qKlxuICAgRGVzdHJveXMgdGhlIHN0YWdlIHdpdGggaW5kZXggYG51bWAuXG5cbiAgIEBtZXRob2QgY2xlYXJTdGFnZVxuICAgQHBhcmFtIHtOdW1iZXJ9IG51bVxuICAgQGZvciBRXG4gICovXG4gIFEuY2xlYXJTdGFnZSA9IGZ1bmN0aW9uKG51bSkge1xuICAgIGlmKFEuc3RhZ2VzW251bV0pIHsgXG4gICAgICBRLnN0YWdlc1tudW1dLmRlc3Ryb3koKTsgXG4gICAgICBRLnN0YWdlc1tudW1dID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICBEZXN0cm95cyBhbGwgc3RhZ2VzLlxuXG4gICBAbWV0aG9kIGNsZWFyU3RhZ2VzXG4gICBAZm9yIFFcbiAgKi9cbiAgUS5jbGVhclN0YWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIgaT0wLGxlbj1RLnN0YWdlcy5sZW5ndGg7aTxsZW47aSsrKSB7XG4gICAgICBpZihRLnN0YWdlc1tpXSkgeyBRLnN0YWdlc1tpXS5kZXN0cm95KCk7IH1cbiAgICB9XG4gICAgUS5zdGFnZXMubGVuZ3RoID0gMDtcbiAgfTtcblxuXG59O1xuXG4iLCIvKmdsb2JhbCBRdWludHVzOmZhbHNlICovXG4vKipcblF1aW50dXMgSFRNTDUgR2FtZSBFbmdpbmUgLSBTcHJpdGVzIE1vZHVsZVxuXG5UaGUgY29kZSBpbiBgcXVpbnR1c19zcHJpdGVzLmpzYCBkZWZpbmVzIHRoZSBgUXVpbnR1cy5TcHJpdGVzYCBtb2R1bGUsIHdoaWNoXG5hZGQgc3VwcG9ydCBmb3Igc3ByaXRlIHNoZWV0cyBhbmQgdGhlIGJhc2Ugc3ByaXRlIGNsYXNzLlxuXG5Nb3N0IGdhbWVzIHdpbGwgaW5jbHVkZSBhdCBhIG1pbmltdW0gYFF1aW50dXMuU3ByaXRlc2AgYW5kIGBRdWludHVzLlNjZW5lc2BcblxuQG1vZHVsZSBRdWludHVzLlNwcml0ZXNcbiovXG5cblxuLyoqXG4gKiBRdWludHVzIFNwcml0ZXMgTW9kdWxlIENsYXNzXG4gKlxuICogQGNsYXNzIFF1aW50dXMuU3ByaXRlc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFEpIHtcbiBcbiAgLyoqXG5cbiAgU3ByaXRlIHNoZWV0IGNsYXNzIC0gZ2VuZXJhbGx5IGluc3RhbnRpYXRlZCB3aXRoIGBRLnNoZWV0YCBuZXcgYG5ld2BcblxuXG4gIEBjbGFzcyBRLlNwcml0ZVNoZWV0XG4gIEBleHRlbmRzIFEuQ2xhc3NcbiAgQGZvciBRdWludHVzLlNwcml0ZXNcbiAgKi9cbiAgUS5DbGFzcy5leHRlbmQoXCJTcHJpdGVTaGVldFwiLHtcblxuICAgIC8qKlxuICAgIGNvbnN0cnVjdG9yXG5cbiAgICBPcHRpb25zOlxuXG4gICAgICAqIHRpbGVXIC0gdGlsZSB3aWR0aFxuICAgICAgKiB0aWxlSCAtIHRpbGUgaGVpZ2h0XG4gICAgICAqIHcgICAgIC0gd2lkdGggb2YgdGhlIHNwcml0ZSBibG9ja1xuICAgICAgKiBoICAgICAtIGhlaWdodCBvZiB0aGUgc3ByaXRlIGJsb2NrXG4gICAgICAqIHN4ICAgIC0gc3RhcnQgeFxuICAgICAgKiBzeSAgICAtIHN0YXJ0IHlcbiAgICAgICogc3BhY2luZ1ggLSBzcGFjaW5nIGJldHdlZW4gZWFjaCB0aWxlIHggKGFmdGVyIDFzdClcbiAgICAgICogc3BhY2luZ1kgLSBzcGFjaW5nIGJldHdlZW4gZWFjaCB0aWxlIHlcbiAgICAgICogbWFyZ2luWCAtIG1hcmdpbiBhcm91bmQgZWFjaCB0aWxlIHggXG4gICAgICAqIG1hcmdpblkgLSBtYXJnaW4gYXJvdW5kIGVhY2ggdGlsZSB5XG4gICAgICAqIGNvbHMgIC0gbnVtYmVyIG9mIGNvbHVtbnMgcGVyIHJvd1xuICAgIFxuICAgIEBjb25zdHJ1Y3RvclxuICAgIEBmb3IgUS5TcHJpdGVTaGVldFxuICAgIEBtZXRob2QgaW5pdFxuICAgIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgQHBhcmFtIHtTdHJpbmd9IGFzc2V0IFxuICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihuYW1lLCBhc3NldCxvcHRpb25zKSB7XG4gICAgICBpZighUS5hc3NldChhc3NldCkpIHsgdGhyb3cgXCJJbnZhbGlkIEFzc2V0OlwiICsgYXNzZXQ7IH1cbiAgICAgIFEuX2V4dGVuZCh0aGlzLHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgYXNzZXQ6IGFzc2V0LFxuICAgICAgICB3OiBRLmFzc2V0KGFzc2V0KS53aWR0aCxcbiAgICAgICAgaDogUS5hc3NldChhc3NldCkuaGVpZ2h0LFxuICAgICAgICB0aWxlVzogNjQsXG4gICAgICAgIHRpbGVIOiA2NCxcbiAgICAgICAgc3g6IDAsXG4gICAgICAgIHN5OiAwLFxuICAgICAgICBzcGFjaW5nWDogMCxcbiAgICAgICAgc3BhY2luZ1k6IDAsXG4gICAgICAgIGZyYW1lUHJvcGVydGllczoge31cbiAgICAgICAgfSk7XG4gICAgICBpZihvcHRpb25zKSB7IFEuX2V4dGVuZCh0aGlzLG9wdGlvbnMpOyB9XG4gICAgICAvLyBmaXggZm9yIG9sZCB0aWxldyBpbnN0ZWFkIG9mIHRpbGVXXG4gICAgICBpZih0aGlzLnRpbGV3KSB7IFxuICAgICAgICB0aGlzLnRpbGVXID0gdGhpcy50aWxldzsgXG4gICAgICAgIGRlbGV0ZSB0aGlzWyd0aWxldyddOyBcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMudGlsZWgpIHsgXG4gICAgICAgIHRoaXMudGlsZUggPSB0aGlzLnRpbGVoOyBcbiAgICAgICAgZGVsZXRlIHRoaXNbJ3RpbGVoJ107IFxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbHMgPSB0aGlzLmNvbHMgfHwgXG4gICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMudyAvICh0aGlzLnRpbGVXICsgdGhpcy5zcGFjaW5nWCkpO1xuXG4gICAgICB0aGlzLmZyYW1lcyA9IHRoaXMuY29scyAqIChNYXRoLmZsb29yKHRoaXMuaC8odGhpcy50aWxlSCArIHRoaXMuc3BhY2luZ1kpKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICBSZXR1cm5zIHRoZSBzdGFydGluZyB4IHBvc2l0aW9uIG9mIGEgc2luZ2xlIGZyYW1lXG5cbiAgICAgQG1ldGhvZCBmeFxuICAgICBAZm9yIFEuU3ByaXRlU2hlZXRcbiAgICAgQHBhcmFtIHtJbnRlZ2VyfSBmcmFtZVxuICAgICovXG4gICAgZng6IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoZnJhbWUgJSB0aGlzLmNvbHMpICogKHRoaXMudGlsZVcgKyB0aGlzLnNwYWNpbmdYKSArIHRoaXMuc3gpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgUmV0dXJucyB0aGUgc3RhcnRpbmcgeSBwb3NpdGlvbiBvZiBhIHNpbmdsZSBmcmFtZVxuXG4gICAgIEBtZXRob2QgZnlcbiAgICAgQGZvciBRLlNwcml0ZVNoZWV0XG4gICAgIEBwYXJhbSB7SW50ZWdlcn0gZnJhbWVcbiAgICAqL1xuICAgIGZ5OiBmdW5jdGlvbihmcmFtZSkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5mbG9vcihmcmFtZSAvIHRoaXMuY29scykgKiAodGhpcy50aWxlSCArIHRoaXMuc3BhY2luZ1kpICsgdGhpcy5zeSk7XG4gICAgfSxcblxuICAgIC8qKiBcbiAgICAgRHJhdyBhIHNpbmdsZSBmcmFtZSBhdCB4LHkgb24gdGhlIHByb3ZpZGVkIGNvbnRleHRcblxuICAgICBAbWV0aG9kIGRyYXdcbiAgICAgQGZvciBRLlNwcml0ZVNoZWV0XG4gICAgIEBwYXJhbSB7Q29udGV4dDJEfSBjdHhcbiAgICAgQHBhcmFtIHtGbG9hdH0geFxuICAgICBAcGFyYW0ge0Zsb2F0fSB5XG4gICAgIEBwYXJhbSB7SW50ZWdlcn0gZnJhbWVcbiAgICAqL1xuICAgIGRyYXc6IGZ1bmN0aW9uKGN0eCwgeCwgeSwgZnJhbWUpIHtcbiAgICAgIGlmKCFjdHgpIHsgY3R4ID0gUS5jdHg7IH1cbiAgICAgIGN0eC5kcmF3SW1hZ2UoUS5hc3NldCh0aGlzLmFzc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5meChmcmFtZSksdGhpcy5meShmcmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGlsZVcsIHRoaXMudGlsZUgsXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoeCksTWF0aC5mbG9vcih5KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aWxlVywgdGhpcy50aWxlSCk7XG5cbiAgICB9XG5cbiAgfSk7XG5cblxuICBRLnNoZWV0cyA9IHt9O1xuXG4gIC8qKlxuICAgUmV0dXJuIGEgYFEuU3ByaXRlU2hlZXRgIG9yICBjcmVhdGUgYSBuZXcgc3ByaXRlIHNoZWV0XG5cbiAgIEBtZXRob2QgUS5zaGVldFxuICAgQGZvciBRdWludHVzLlNwcml0ZXNcbiAgIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiBzaGVldCB0byByZXR1cm4gb3IgY3JlYXRlXG4gICBAcGFyYW0ge1N0cmluZ30gW2Fzc2V0XSAtIGlmIHByb3ZpZGVkLCB3aWxsIGNyZWF0ZSBhIHNwcml0ZSBzaGVldCB1c2luZyB0aGlzIGFzc2V0XG4gICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gaWYgcHJvdmlkZWQsIHdpbGwgYmUgcGFzc2VkIGFzIG9wdGlvbnMgdG8gYFEuU3ByaXRlU2hlZXRgXG4gICovXG4gIFEuc2hlZXQgPSBmdW5jdGlvbihuYW1lLGFzc2V0LG9wdGlvbnMpIHtcbiAgICBpZihhc3NldCkge1xuICAgICAgUS5zaGVldHNbbmFtZV0gPSBuZXcgUS5TcHJpdGVTaGVldChuYW1lLGFzc2V0LG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUS5zaGVldHNbbmFtZV07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgQ3JlYXRlIGEgbnVtYmVyIG9mIGBRLlNwcml0ZVNoZWV0YCBvYmplY3RzIGZyb20gYW4gaW1hZ2UgYXNzZXQgYW5kIGEgc3ByaXRlIGRhdGEgSlNPTiBhc3NldFxuXG4gICBAbWV0aG9kIFEuY29tcGlsZVNoZWV0c1xuICAgQGZvciBRdWludHVzLlNwcml0ZXNcbiAgIEBwYXJhbSB7U3RyaW5nfSBpbWFnZUFzc2V0IFxuICAgQHBhcmFtIHtTdHJpbmcgc3ByaXRlRGF0YUFzc2V0XG4gICovXG4gIFEuY29tcGlsZVNoZWV0cyA9IGZ1bmN0aW9uKGltYWdlQXNzZXQsc3ByaXRlRGF0YUFzc2V0KSB7XG4gICAgdmFyIGRhdGEgPSBRLmFzc2V0KHNwcml0ZURhdGFBc3NldCk7XG4gICAgUS5fZWFjaChkYXRhLGZ1bmN0aW9uKHNwcml0ZURhdGEsbmFtZSkge1xuICAgICAgUS5zaGVldChuYW1lLGltYWdlQXNzZXQsc3ByaXRlRGF0YSk7XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgIEJpdG1hc2sgMCB0byBpbmRpY2F0ZSBubyBzcHJpdGVzXG5cbiAgIEBwcm9wZXJ0eSBRLlNQUklURV9OT05FXG4gICBAZm9yIFF1aW50dXMuU3ByaXRlc1xuICAgQGZpbmFsXG4gICovXG4gIFEuU1BSSVRFX05PTkUgICAgID0gMDtcblxuICAvKipcbiAgIGRlZmF1bHQgc3ByaXRlIHR5cGUgMVxuXG4gICBAcHJvcGVydHkgUS5TUFJJVEVfREVGQVVMVFxuICAgQGZvciBRdWludHVzLlNwcml0ZXNcbiAgIEBmaW5hbFxuICAqL1xuICBRLlNQUklURV9ERUZBVUxUICA9IDE7XG5cbiAgLyoqXG4gICBwYXJ0aWNsZSBzcHJpdGUgdHlwZSAyXG5cbiAgIEBwcm9wZXJ0eSBRLlNQUklURV9QQVJUSUNMRVxuICAgQGZvciBRdWludHVzLlNwcml0ZXNcbiAgIEBmaW5hbFxuICAqL1xuICBRLlNQUklURV9QQVJUSUNMRSA9IDI7XG5cbiAgLyoqXG4gICBhY3RpdmUgc3ByaXRlIHR5cGUgNFxuXG4gICBAcHJvcGVydHkgUS5TUFJJVEVfQUNUSVZFXG4gICBAZm9yIFF1aW50dXMuU3ByaXRlc1xuICAgQGZpbmFsXG4gICovXG4gIFEuU1BSSVRFX0FDVElWRSAgID0gNDtcblxuICAvKipcbiAgIGZyaWVuZGx5IHNwcml0ZSB0eXBlIDhcblxuICAgQHByb3BlcnR5IFEuU1BSSVRFX0ZSSUVORExZXG4gICBAZm9yIFF1aW50dXMuU3ByaXRlc1xuICAgQGZpbmFsXG4gICovXG4gIFEuU1BSSVRFX0ZSSUVORExZID0gODtcblxuICAvKipcbiAgIGVuZW15IHNwcml0ZSB0eXBlIDE2XG5cbiAgIEBwcm9wZXJ0eSBRLlNQUklURV9FTkVNWVxuICAgQGZvciBRdWludHVzLlNwcml0ZXNcbiAgIEBmaW5hbFxuICAqL1xuICBRLlNQUklURV9FTkVNWSAgICA9IDE2O1xuXG5cbiAgLyoqXG4gICBwb3dlcnVwIHNwcml0ZSB0eXBlIDMyXG5cbiAgIEBwcm9wZXJ0eSBRLlNQUklURV9QT1dFUlVQXG4gICBAZm9yIFF1aW50dXMuU3ByaXRlc1xuICAgQGZpbmFsXG4gICovXG4gIFEuU1BSSVRFX1BPV0VSVVAgID0gMzI7XG5cblxuICAvKipcbiAgIFVJIHNwcml0ZSB0eXBlIDY0XG5cbiAgIEBwcm9wZXJ0eSBRLlNQUklURV9VSVxuICAgQGZvciBRdWludHVzLlNwcml0ZXNcbiAgIEBmaW5hbFxuICAqL1xuICBRLlNQUklURV9VSSAgICAgICA9IDY0O1xuXG4gIC8qKiBcbiAgIGFsbCBzcHJpdGUgdHlwZSAtIDB4RkZGRlxuXG4gICBAcHJvcGVydHkgUS5TUFJJVEVfQUxMXG4gICBAZm9yIFF1aW50dXMuU3ByaXRlc1xuICAgQGZpbmFsXG4gICovXG4gIFEuU1BSSVRFX0FMTCAgID0gMHhGRkZGO1xuXG5cbiAgLyoqXG4gICBnZW5lcmF0ZSBhIHNxdWFyZSBzZXQgb2YgIGBwLnBvaW50c2Agb24gYW4gb2JqZWN0IGZyb20gYHAud2AgYW5kIGBwLmhgXG5cbiAgIGBwLnBvaW50c2AgcmVwcmVzZW50IHRoZSBjb2xsaXNpb24gcG9pbnRzIGZvciBhbiBvYmplY3QgaW4gb2JqZWN0IGNvb3JkaW5hdGVzLlxuXG5cbiAgICBAbWV0aG9kIHEuX2dlbmVyYXRlUG9pbnRzXG4gICAgQGZvciBRdWludHVzLlNwcml0ZXNcbiAgICBAcGFyYW0ge1EuU3ByaXRlfSBvYmogLSBvYmplY3QgdG8gYWRkIHBvaW50cyB0b1xuICAgIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgLSBpZiBzZXQgdG8gdHJ1ZSwgd2lsbCByZWdlbmVyYXRlIGBwLnBvaW50c2AgZXZlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cywgb3RoZXJ3aXNlICBpZiBwLnBvaW50cyBleGlzdCBpdCdsbCBiZSBsZWZ0IGFsb25lXG4gICovXG4gIFEuX2dlbmVyYXRlUG9pbnRzID0gZnVuY3Rpb24ob2JqLGZvcmNlKSB7XG4gICAgaWYob2JqLnAucG9pbnRzICYmICFmb3JjZSkgeyByZXR1cm47IH1cbiAgICB2YXIgcCA9IG9iai5wLFxuICAgICAgICBoYWxmVyA9IHAudy8yLFxuICAgICAgICBoYWxmSCA9IHAuaC8yO1xuXG4gICAgcC5wb2ludHMgPSBbIFxuICAgICAgWyAtaGFsZlcsIC1oYWxmSCBdLFxuICAgICAgWyAgaGFsZlcsIC1oYWxmSCBdLFxuICAgICAgWyAgaGFsZlcsICBoYWxmSCBdLFxuICAgICAgWyAtaGFsZlcsICBoYWxmSCBdXG4gICAgICBdO1xuICB9O1xuXG5cbiAgLyoqXG4gICBHZW5lcmF0ZSBhIHNxdWFyZSBzZXQgb2YgIGBjLnBvaW50c2Agb24gYW4gb2JqZWN0IGZyb20gdGhlIG9iamVjdCB0cmFuc2Zvcm0gbWF0cml4IGFuZCBgcC5wb2ludHNgXG5cbiAgIGBjLnBvaW50c2AgcmVwcmVzZW50cyB0aGUgY29sbGlzaW9uIHBvaW50cyBvZiBhbiBzcHJpdGUgaW4gd29ybGQgY29vcmRpbmF0ZXMsIHNjYWxlZCwgcm90YXRlIGFuZCB0YWtpbmcgaW50byBhY2NvdW50IGFueSBwYXJlbnQgdHJhbnNmb3Jtcy5cblxuXG4gICAgQG1ldGhvZCBRLl9nZW5lcmF0ZUNvbGxpc2lvblBvaW50c1xuICAgIEBmb3IgUXVpbnR1cy5TcHJpdGVzXG4gICAgQHBhcmFtIHtxLnNwcml0ZX0gb2JqIC0gb2JqZWN0IHRvIGFkZCBjb2xsaXNpb24gcG9pbnRzIHRvXG4gICovXG4gUS5fZ2VuZXJhdGVDb2xsaXNpb25Qb2ludHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZighb2JqLm1hdHJpeCAmJiAhb2JqLnJlZnJlc2hNYXRyaXgpIHsgcmV0dXJuOyB9XG4gICAgaWYoIW9iai5jKSB7IG9iai5jID0geyBwb2ludHM6IFtdIH07IH1cbiAgICB2YXIgcCA9IG9iai5wLCBjID0gb2JqLmM7XG5cbiAgICBpZighcC5tb3ZlZCAmJiBcbiAgICAgICBjLm9yaWdYID09PSBwLnggJiZcbiAgICAgICBjLm9yaWdZID09PSBwLnkgJiZcbiAgICAgICBjLm9yaWdTY2FsZSA9PT0gcC5zY2FsZSAmJlxuICAgICAgIGMub3JpZ0FuZ2xlID09PSBwLmFuZ2xlKSB7IFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYy5vcmlnWCA9IHAueDtcbiAgICBjLm9yaWdZID0gcC55O1xuICAgIGMub3JpZ1NjYWxlID0gcC5zY2FsZTtcbiAgICBjLm9yaWdBbmdsZSA9IHAuYW5nbGU7XG5cbiAgICBvYmoucmVmcmVzaE1hdHJpeCgpO1xuXG4gICAgdmFyIGk7XG5cbiAgICAvLyBFYXJseSBvdXQgaWYgd2UgZG9uJ3QgbmVlZCB0byByb3RhdGUgLyBzY2FsZSAvIGRlYWwgd2l0aCBhIGNvbnRhaW5lclxuICAgIGlmKCFvYmouY29udGFpbmVyICYmICghcC5zY2FsZSB8fCBwLnNjYWxlID09PSAxKSAmJiBwLmFuZ2xlID09PSAwKSB7XG4gICAgICBmb3IoaT0wO2k8b2JqLnAucG9pbnRzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgb2JqLmMucG9pbnRzW2ldID0gb2JqLmMucG9pbnRzW2ldIHx8IFtdO1xuICAgICAgICBvYmouYy5wb2ludHNbaV1bMF0gPSBwLnggKyBvYmoucC5wb2ludHNbaV1bMF07XG4gICAgICAgIG9iai5jLnBvaW50c1tpXVsxXSA9IHAueSArIG9iai5wLnBvaW50c1tpXVsxXTtcbiAgICAgIH1cbiAgICAgIGMueCA9IHAueDsgYy55ID0gcC55O1xuICAgICAgYy5jeCA9IHAuY3g7IGMuY3kgPSBwLmN5O1xuICAgICAgYy53ID0gcC53OyBjLmggPSBwLmg7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb250YWluZXIgPSBvYmouY29udGFpbmVyIHx8IFEuX251bGxDb250YWluZXI7XG5cbiAgICBjLnggPSBjb250YWluZXIubWF0cml4LnRyYW5zZm9ybVgocC54LHAueSk7XG4gICAgYy55ID0gY29udGFpbmVyLm1hdHJpeC50cmFuc2Zvcm1ZKHAueCxwLnkpO1xuICAgIGMuYW5nbGUgPSBwLmFuZ2xlICsgY29udGFpbmVyLmMuYW5nbGU7XG4gICAgYy5zY2FsZSA9IChjb250YWluZXIuYy5zY2FsZSB8fCAxKSAqIChwLnNjYWxlIHx8IDEpO1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eSxcbiAgICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yKGk9MDtpPG9iai5wLnBvaW50cy5sZW5ndGg7aSsrKSB7XG4gICAgICBpZighb2JqLmMucG9pbnRzW2ldKSB7XG4gICAgICAgIG9iai5jLnBvaW50c1tpXSA9IFtdO1xuICAgICAgfVxuICAgICAgb2JqLm1hdHJpeC50cmFuc2Zvcm1BcnIob2JqLnAucG9pbnRzW2ldLG9iai5jLnBvaW50c1tpXSk7XG4gICAgICB2YXIgeCA9IG9iai5jLnBvaW50c1tpXVswXSxcbiAgICAgICAgICB5ID0gb2JqLmMucG9pbnRzW2ldWzFdO1xuXG4gICAgICAgICAgaWYoeCA8IG1pblgpIHsgbWluWCA9IHg7IH1cbiAgICAgICAgICBpZih4ID4gbWF4WCkgeyBtYXhYID0geDsgfVxuICAgICAgICAgIGlmKHkgPCBtaW5ZKSB7IG1pblkgPSB5OyB9XG4gICAgICAgICAgaWYoeSA+IG1heFkpIHsgbWF4WSA9IHk7IH1cbiAgICB9XG5cbiAgICBpZihtaW5YID09PSBtYXhYKSB7IG1heFgrPTE7IH1cbiAgICBpZihtaW5ZID09PSBtYXhZKSB7IG1heFkrPTE7IH1cblxuICAgIGMuY3ggPSBjLnggLSBtaW5YO1xuICAgIGMuY3kgPSBjLnkgLSBtaW5ZO1xuXG4gICAgYy53ID0gbWF4WCAtIG1pblg7XG4gICAgYy5oID0gbWF4WSAtIG1pblk7XG5cbiAgICAvLyBUT0RPOiBJbnZva2UgbW92ZWQgb24gY2hpbGRyZW5cbiAgfTtcbiAgXG4gIFxuICAvKipcbiAgIFxuICAgQmFzaWMgc3ByaXRlIGNsYXNzIC0gd2lsbCByZW5kZXIgZWl0aGVyIGFuZCBhc3NldCBvciBhIGZyYW1lIGZyb20gYSBzcHJpdGUgc2hlZXQuXG5cbiAgIEF1dG8gc2V0cyB0aGUgd2lkdGggYW5kIGhlaWdodCAoYHAud2AgYW5kIGBwLmhgKSBmcm9tIHRoZSBwcm92aWRlZCBpbWFnZSBhc3NldCBhbmRcbiAgIGNlbnRlcnMgdGhlIHNwcml0ZSBzbyAwLDAgaXMgdGhlIGNlbnRlciBvZiB0aGUgcHJvdmlkZSBpbWFnZS5cblxuICAgTW9zdCBvZiB0aGUgdGltZXMgeW91J2xsIHN1Yi1jbGFzcyBgUS5TcHJpdGVgIFxuXG4gICBAZXh0ZW5kcyBRLkdhbWVPYmplY3RcbiAgIEBjbGFzcyBRLlNwcml0ZVxuICAgQGZvciBRdWludHVzLlNwcml0ZXNcbiAgKi9cbiAgUS5HYW1lT2JqZWN0LmV4dGVuZChcIlNwcml0ZVwiLHtcblxuICAgIC8qKlxuICAgICBcbiAgICAgIERlZmF1bHQgc3ByaXRlIGNvbnN0cnVjdG9yLCB0YWtlcyBpbiBhIHNldCBvZiBwcm9wZXJ0aWVzIGFuZCBhIHNldCBvZiBkZWZhdWx0IHByb3BlcnRpZXMgKHVzZWZ1bCB3aGVuIHlvdSBjcmVhdGUgYSBzdWJjbGFzcyBvZiBzcHJpdGUpXG4gICAgIFxuICAgICAgRGVmYXVsdCBwcm9wZXJ0aWVzOlxuXG4gICAgICAgICAgIHtcbiAgICAgICAgICAgIGFzc2V0OiBudWxsLCAgLy8gYXNzZXQgdG8gdXNlXG4gICAgICAgICAgICBzaGVldDogbnVsbCwgIC8vIHNwcml0ZSBzaGVldCB0byB1c2UgKG92ZXJyaWRlcyBhc3NldClcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgejogMCxcbiAgICAgICAgICAgIHc6IDAsICAgICAgICAgLy8gd2lkdGgsIHNldCBmcm9tIHAuYXNzZXQgb3IgcC5zaGVldFxuICAgICAgICAgICAgaDogMCwgICAgICAgICAvLyBoZWlnaHQsIHNldCBmcm9tIHAuYXNzZXQgb3IgcC5zaGVldFxuICAgICAgICAgICAgY3g6IHcvMiwgICAgICAvLyBjZW50ZXIgeCwgZGVmYXVsdHMgdG8gY2VudGVyIG9mIHRoZSBhc3NldCBvciBzaGVldFxuICAgICAgICAgICAgY3k6IGgvMiwgICAgICAvLyBjZW50ZXIgeSwgZGVmYXVsdCBzYW1lIGFzIGN4XG4gICAgICAgICAgICAvLyBwb2ludHMgZGVmaW5lcyB0aGUgY29sbGlzaW9uIHNoYXBlLCBvdmVycmlkZSB0byBjdXN0b21lciB0aGUgY29sbGlzaW9uIHNoYXBlLFxuICAgICAgICAgICAgLy8gbXVzdCBiZSBhIGNvbnZleCBwb2x5Z29uIGluIGNsb2Nrd2lzZSBvcmRlclxuICAgICAgICAgICAgcG9pbnRzOiBbICBbIC13LzIsIC1oLzIgXSwgWyAgdy8yLCAtaC8yIF0sIFsgIHcvMiwgIGgvMiBdLCBbIC13LzIsICBoLzIgXSBdLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgZnJhbWU6IDBcbiAgICAgICAgICAgIHR5cGU6ICBRLlNQUklURV9ERUZBVUxUIHwgUS5TUFJJVEVfQUNUSVZFLFxuICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICBzb3J0OiBmYWxzZSwgICAvLyBzZXQgdG8gdHJ1ZSB0byBmb3JjZSBjaGlsZHJlbiB0byBiZSBzb3J0ZWQgYnkgdGhlaWVyIHAueixcbiAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsICAvLyBzZXQgdG8gdHJ1ZSB0byBoaWRlIHRoZSBzcHJpdGVcbiAgICAgICAgICAgIGZsaXA6IFwiXCIgICAgICAgLy8gc2V0IHRvIFwieFwiLCBcInlcIiwgb3IgXCJ4eVwiIHRvIGZsaXAgc3ByaXRlIG92ZXIgdGhhdCBkaW1lbnNpb25cbiAgICAgICAgICAgfVxuXG4gICAgICBAbWV0aG9kIGluaXRcbiAgICAgIEBmb3IgUS5TcHJpdGVcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIHByb3BlcnR5IGhhcyB0aGF0IHdpbGwgYmUgdHVybmVkIGludG8gYHBgXG4gICAgICBAcGFyYW0ge09iamVjdH0gW2RlZmF1bHRQcm9wc10gLSBkZWZhdWx0IHByb3BlcnRpZXMgdGhhdCBhcmUgYXNzaWduZWQgb25seSBpZiB0aGVyZSdzIG5vdCBhIGNvcnJlc3BvbmRpbmcgdmFsdWUgaW4gYHByb3BzYFxuICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocHJvcHMsZGVmYXVsdFByb3BzKSB7XG4gICAgICB0aGlzLnAgPSBRLl9leHRlbmQoeyBcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgejogMCxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYW5nbGU6IDAsXG4gICAgICAgIGZyYW1lOiAwLFxuICAgICAgICB0eXBlOiBRLlNQUklURV9ERUZBVUxUIHwgUS5TUFJJVEVfQUNUSVZFLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgc3ByaXRlUHJvcGVydGllczoge31cbiAgICAgIH0sZGVmYXVsdFByb3BzKTtcblxuICAgICAgdGhpcy5tYXRyaXggPSBuZXcgUS5NYXRyaXgyRCgpO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICBRLl9leHRlbmQodGhpcy5wLHByb3BzKTsgXG5cbiAgICAgIHRoaXMuc2l6ZSgpO1xuICAgICAgdGhpcy5wLmlkID0gdGhpcy5wLmlkIHx8IFEuX3VuaXF1ZUlkKCk7XG5cbiAgICAgIHRoaXMucmVmcmVzaE1hdHJpeCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBSZXNldHMgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIGNlbnRlciBiYXNlZCBvbiB0aGVcbiAgICAgYXNzZXQgb3Igc3ByaXRlIHNoZWV0XG5cbiAgICBAbWV0aG9kIHNpemVcbiAgICBAZm9yIFEuU3ByaXRlXG4gICAgQHBhcmFtIHtCb29sZWFufSBmb3JjZSAtIGZvcmNlIGEgcmVzZXQgKGNhbGwgaWYgdyBvciBoIGNoYW5nZXMpXG4gICAgKi9cbiAgICBzaXplOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgaWYoZm9yY2UgfHwgKCF0aGlzLnAudyB8fCAhdGhpcy5wLmgpKSB7IFxuICAgICAgICBpZih0aGlzLmFzc2V0KCkpIHtcbiAgICAgICAgICB0aGlzLnAudyA9IHRoaXMuYXNzZXQoKS53aWR0aDtcbiAgICAgICAgICB0aGlzLnAuaCA9IHRoaXMuYXNzZXQoKS5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnNoZWV0KCkpIHtcbiAgICAgICAgICB0aGlzLnAudyA9IHRoaXMuc2hlZXQoKS50aWxlVztcbiAgICAgICAgICB0aGlzLnAuaCA9IHRoaXMuc2hlZXQoKS50aWxlSDtcbiAgICAgICAgfVxuICAgICAgfSBcblxuICAgICAgdGhpcy5wLmN4ID0gKGZvcmNlIHx8IHRoaXMucC5jeCA9PT0gdm9pZCAwKSA/ICh0aGlzLnAudyAvIDIpIDogdGhpcy5wLmN4O1xuICAgICAgdGhpcy5wLmN5ID0gKGZvcmNlIHx8IHRoaXMucC5jeSA9PT0gdm9pZCAwKSA/ICh0aGlzLnAuaCAvIDIpIDogdGhpcy5wLmN5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICBHZXQgb3Igc2V0IHRoZSBhc3NldCBhc3NvY2lhdGUgd2l0aCB0aGlzIHNwcml0ZVxuXG4gICAgQG1ldGhvZCBhc3NldFxuICAgIEBmb3IgUS5TcHJpdGVcbiAgICBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gbGVhdmUgZW1wdHkgdG8gcmV0dXJuIHRoZSBhc3NldCwgYWRkIHRvIHNldCB0aGUgYXNzZXRcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtyZXNpemVdIC0gZm9yY2UgYSBjYWxsIHRvIGBzaXplKClgIGFuZCBgX2dlbmVyYXRlUG9pbnRzYFxuICAgICovXG4gICAgYXNzZXQ6IGZ1bmN0aW9uKG5hbWUscmVzaXplKSB7XG4gICAgICBpZighbmFtZSkgeyByZXR1cm4gUS5hc3NldCh0aGlzLnAuYXNzZXQpOyB9XG5cbiAgICAgIHRoaXMucC5hc3NldCA9IG5hbWU7XG4gICAgICBpZihyZXNpemUpIHtcbiAgICAgICAgdGhpcy5zaXplKHRydWUpO1xuICAgICAgICBRLl9nZW5lcmF0ZVBvaW50cyh0aGlzLHRydWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcblxuICAgICBHZXQgb3Igc2V0IHRoZSBzaGVldCBhc3NvY2lhdGUgd2l0aCB0aGlzIHNwcml0ZVxuXG4gICAgIEBtZXRob2Qgc2hlZXRcbiAgICAgQGZvciBRLlNwcml0ZVxuICAgICBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gbGVhdmUgZW1wdHkgdG8gcmV0dXJuIHRoZSBzcHJpdGUgc2hlZXQsIGFkZCB0byByZXNpemVcbiAgICAgQHBhcmFtIHtCb29sZWFufSBbcmVzaXplXSAtIGZvcmNlIGEgcmVzaXplXG4gICAgKi9cbiAgICBzaGVldDogZnVuY3Rpb24obmFtZSxyZXNpemUpIHtcbiAgICAgIGlmKCFuYW1lKSB7IHJldHVybiBRLnNoZWV0KHRoaXMucC5zaGVldCk7IH1cblxuICAgICAgdGhpcy5wLnNoZWV0ID0gbmFtZTtcbiAgICAgIGlmKHJlc2l6ZSkgeyBcbiAgICAgICAgdGhpcy5zaXplKHRydWUpO1xuICAgICAgICBRLl9nZW5lcmF0ZVBvaW50cyh0aGlzLHRydWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgSGlkZSB0aGUgc3ByaXRlIChyZW5kZXIgcmV0dXJucyB3aXRob3V0IHJlbmRlcmluZylcblxuICAgICBAbWV0aG9kIGhpZGVcbiAgICAgQGZvciBRLlNwcml0ZVxuICAgICovXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnAuaGlkZGVuID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFNob3cgdGhlIHNwcml0ZSBcblxuICAgICBAbWV0aG9kIHNob3dcbiAgICAgQGZvciBRLlNwcml0ZVxuICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnAuaGlkZGVuID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICBTZXQgYSBzZXQgb2YgYHBgIHByb3BlcnRpZXMgb24gYSBTcHJpdGVcblxuICAgICBAbWV0aG9kIHNldFxuICAgICBAZm9yIFEuU3ByaXRlXG4gICAgIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gaGFzaCBvZiBwcm9wZXJ0aWVzIHRvIHNldFxuICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICBRLl9leHRlbmQodGhpcy5wLHByb3BlcnRpZXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zb3J0Q2hpbGQ6IGZ1bmN0aW9uKGEsYikge1xuICAgICAgcmV0dXJuICgoYS5wICYmIGEucC56KSB8fCAtMSkgLSAoKGIucCAmJiBiLnAueikgfHwgLTEpO1xuICAgIH0sXG5cbiAgICBfZmxpcEFyZ3M6IHtcbiAgICAgIFwieFwiOiAgWyAtMSwgIDFdLFxuICAgICAgXCJ5XCI6ICBbICAxLCAtMV0sXG4gICAgICBcInh5XCI6IFsgLTEsIC0xXVxuICAgIH0sXG5cbiAgICAvKiogXG4gICAgIERlZmF1bHQgcmVuZGVyIG1ldGhvZCBmb3IgdGhlIHNwcml0ZS4gRG9uJ3Qgb3ZlcmxvYWQgdGhpcyB1bmxlc3MgeW91IHdhbnQgdG9cbiAgICAgaGFuZGxlIGFsbCB0aGUgdHJhbnNmb3JtIGFuZCBzY2FsZSBzdHVmZiB5b3Vyc2VsZi4gUmF0aGVyIG92ZXJsb2FkIHRoZSBgZHJhd2AgbWV0aG9kLlxuXG4gICAgIEBtZXRob2QgcmVuZGVyXG4gICAgIEBmb3IgUS5TcHJpdGVcbiAgICAgQHBhcmFtIHtDb250ZXh0MkR9IGN0eCAtIGNvbnRleHQgdG8gcmVuZGVyIHRvXG4gICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAgPSB0aGlzLnA7XG5cbiAgICAgIGlmKHAuaGlkZGVuKSB7IHJldHVybjsgfVxuICAgICAgaWYoIWN0eCkgeyBjdHggPSBRLmN0eDsgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3ByZWRyYXcnLGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgaWYodGhpcy5wLm9wYWNpdHkgIT09IHZvaWQgMCAmJiB0aGlzLnAub3BhY2l0eSAhPT0gMSkge1xuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMucC5vcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXRyaXguc2V0Q29udGV4dFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgIGlmKHRoaXMucC5mbGlwKSB7IGN0eC5zY2FsZS5hcHBseShjdHgsdGhpcy5fZmxpcEFyZ3NbdGhpcy5wLmZsaXBdKTsgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlZHJhdycsY3R4KTtcbiAgICAgICAgdGhpcy5kcmF3KGN0eCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZHJhdycsY3R4KTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hpbGRyZW4gc2V0IHVwIHRoZWlyIG93biBjb21wbGV0ZSBtYXRyaXhcbiAgICAgIC8vIGZyb20gdGhlIGJhc2Ugc3RhZ2UgbWF0cml4XG4gICAgICBpZih0aGlzLnAuc29ydCkgeyB0aGlzLmNoaWxkcmVuLnNvcnQodGhpcy5fc29ydENoaWxkKTsgfVxuICAgICAgUS5faW52b2tlKHRoaXMuY2hpbGRyZW4sXCJyZW5kZXJcIixjdHgpO1xuICAgICAgXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Bvc3RkcmF3JyxjdHgpO1xuXG4gICAgICBpZihRLmRlYnVnKSB7IHRoaXMuZGVidWdSZW5kZXIoY3R4KTsgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICBDZW50ZXIgc3ByaXRlIGluc2lkZSBvZiBpdCdzIGNvbnRhaW5lciAob3IgdGhlIHN0YWdlKVxuXG4gICAgIEBtZXRob2QgY2VudGVyXG4gICAgIEBmb3IgUS5TcHJpdGVcbiAgICAqL1xuICAgIGNlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnAueCA9IHRoaXMuY29udGFpbmVyLnAudyAvIDI7XG4gICAgICAgIHRoaXMucC55ID0gdGhpcy5jb250YWluZXIucC5oIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucC54ID0gUS53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMucC55ID0gUS5oZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICBEcmF3IHRoZSBhc3NldCBvbiB0aGUgc3RhZ2UuIHRoZSBjb250ZXh0IHBhc3NlZCBpbiBpcyBhbHJlYXkgdHJhbnNmb3JtZWQuXG5cbiAgICAgQWxsIHlvdSBuZWVkIHRvIGRvIGlzIGEgZHJhdyB0aGUgc3ByaXRlIGNlbnRlcmVkIGF0IDAsMFxuXG4gICAgIEBtZXRob2QgZHJhd1xuICAgICBAZm9yIFEuU3ByaXRlXG4gICAgIEBwYXJhbSB7Q29udGV4dDJEfSBjdHhcbiAgICAqL1xuICAgIGRyYXc6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAgPSB0aGlzLnA7XG4gICAgICBpZihwLnNoZWV0KSB7XG4gICAgICAgIHRoaXMuc2hlZXQoKS5kcmF3KGN0eCwtcC5jeCwtcC5jeSxwLmZyYW1lKTtcbiAgICAgIH0gZWxzZSBpZihwLmFzc2V0KSB7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoUS5hc3NldChwLmFzc2V0KSwtcC5jeCwtcC5jeSk7XG4gICAgICB9IGVsc2UgaWYocC5jb2xvcikge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gcC5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KC1wLmN4LC1wLmN5LHAudyxwLmgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWJ1Z1JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZighdGhpcy5wLnBvaW50cykge1xuICAgICAgICBRLl9nZW5lcmF0ZVBvaW50cyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLm1hdHJpeC5zZXRDb250ZXh0VHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wLmhpdCA/IFwiYmx1ZVwiIDogXCJyZWRcIjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiI0ZGMDAwMFwiO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLDAsMCwwLjUpXCI7XG5cbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5wLnBvaW50c1swXVswXSx0aGlzLnAucG9pbnRzWzBdWzFdKTtcbiAgICAgIGZvcih2YXIgaT0wO2k8dGhpcy5wLnBvaW50cy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy5wLnBvaW50c1tpXVswXSx0aGlzLnAucG9pbnRzW2ldWzFdKTtcbiAgICAgIH1cbiAgICAgIGN0eC5saW5lVG8odGhpcy5wLnBvaW50c1swXVswXSx0aGlzLnAucG9pbnRzWzBdWzFdKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGlmKFEuZGVidWdGaWxsKSB7IGN0eC5maWxsKCk7IH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgaWYodGhpcy5jKSB7IFxuICAgICAgICB2YXIgYyA9IHRoaXMuYztcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiI0ZGMDBGRlwiO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKGMueCAtIGMuY3gsICAgICAgIGMueSAtIGMuY3kpO1xuICAgICAgICAgIGN0eC5saW5lVG8oYy54IC0gYy5jeCArIGMudywgYy55IC0gYy5jeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhjLnggLSBjLmN4ICsgYy53LCBjLnkgLSBjLmN5ICsgYy5oKTtcbiAgICAgICAgICBjdHgubGluZVRvKGMueCAtIGMuY3ggICAgICAsIGMueSAtIGMuY3kgKyBjLmgpO1xuICAgICAgICAgIGN0eC5saW5lVG8oYy54IC0gYy5jeCwgICAgICAgYy55IC0gYy5jeSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogXG4gICAgIFVwZGF0ZSBtZXRob2QgaXMgY2FsbGVkIGVhY2ggc3RlcCB3aXRoIHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGxhc3Qgc3RlcC5cblxuICAgICBEb2Vzbid0IGRvIGFueXRoaW5nIG90aGVyIHRoYW4gdHJpZ2dlciBldmVudHMsIGNhbGwgYSBgc3RlcGAgbWV0aG9kIGlmIGRlZmluZWRcbiAgICAgYW5kIHJ1biB1cGRhdGUgb24gYWxsIGl0cyBjaGlsZHJlbi5cblxuICAgICBHZW5lcmFsbHkgbGVhdmUgdGhpcyBtZXRob2QgYWxvbmUgYW5kIGRlZmluZSBhIGBzdGVwYCBtZXRob2QgdGhhdCB3aWxsIGJlIGNhbGxlZFxuXG4gICAgIEBtZXRob2QgdXBkYXRlXG4gICAgIEBmb3IgUS5TcHJpdGVcbiAgICAgQHBhcmFtIHtGbG9hdH0gZHQgLSB0aW1lIGVsYXBzZWQgc2luY2UgbGFzdCBjYWxsXG4gICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3ByZXN0ZXAnLGR0KTtcbiAgICAgIGlmKHRoaXMuc3RlcCkgeyB0aGlzLnN0ZXAoZHQpOyB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ3N0ZXAnLGR0KTtcbiAgICAgIHRoaXMucmVmcmVzaE1hdHJpeCgpO1xuXG4gICAgICAvLyBVZ2x5IGNvdXBsaW5nIHRvIHN0YWdlIC0gd29ya2Fyb3VuZD9cbiAgICAgIGlmKHRoaXMuc3RhZ2UgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UudXBkYXRlU3ByaXRlcyh0aGlzLmNoaWxkcmVuLGR0LHRydWUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXNldCBjb2xsaXNpb25zIGlmIHdlJ3JlIHRyYWNraW5nIHRoZW1cbiAgICAgIGlmKHRoaXMucC5jb2xsaXNpb25zKSB7IHRoaXMucC5jb2xsaXNpb25zID0gW107IH1cbiAgICB9LFxuXG4gICAgLyogXG4gICAgIFJlZ2VuZXJhdGVzIHRoaXMgc3ByaXRlJ3MgdHJhbnNmb3JtYXRpb24gbWF0cml4XG5cbiAgICAgQG1ldGhvZCByZWZyZXNoTWF0cml4XG4gICAgIEBmb3IgUS5TcHJpdGVcbiAgICAqL1xuICAgIHJlZnJlc2hNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAgPSB0aGlzLnA7XG4gICAgICB0aGlzLm1hdHJpeC5pZGVudGl0eSgpO1xuXG4gICAgICBpZih0aGlzLmNvbnRhaW5lcikgeyB0aGlzLm1hdHJpeC5tdWx0aXBseSh0aGlzLmNvbnRhaW5lci5tYXRyaXgpOyB9XG4gICAgICBcbiAgICAgIHRoaXMubWF0cml4LnRyYW5zbGF0ZShwLngscC55KTtcblxuICAgICAgaWYocC5zY2FsZSkgeyB0aGlzLm1hdHJpeC5zY2FsZShwLnNjYWxlLHAuc2NhbGUpOyB9XG5cbiAgICAgIHRoaXMubWF0cml4LnJvdGF0ZURlZyhwLmFuZ2xlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgU2ltcGxlIHNwcml0ZSB0aGF0IGFkZHMgaW4gYmFzaWMgbmV3dG9uaWFuIHBoeXNpY3Mgb24gZWFjaCBzdGVwOlxuXG4gICAgICAgcC52eCArPSBwLmF4ICogZHQ7XG4gICAgICAgcC52eSArPSBwLmF5ICogZHQ7XG5cbiAgICAgICBwLnggKz0gcC52eCAqIGR0O1xuICAgICAgIHAueSArPSBwLnZ5ICogZHQ7XG5cbiAgIEBjbGFzcyBRLk1vdmluZ1Nwcml0ZVxuICAgQGV4dGVuZHMgUS5TcHJpdGVcbiAgIEBmb3IgUXVpbnR1cy5TcHJpdGVzXG4gICovXG4gIFEuU3ByaXRlLmV4dGVuZChcIk1vdmluZ1Nwcml0ZVwiLHtcbiAgICBpbml0OiBmdW5jdGlvbihwcm9wcyxkZWZhdWx0UHJvcHMpIHtcbiAgICAgIHRoaXMuX3N1cGVyKFEuX2V4dGVuZCh7XG4gICAgICAgIHZ4OiAwLFxuICAgICAgICB2eTogMCxcbiAgICAgICAgYXg6IDAsXG4gICAgICAgIGF5OiAwXG4gICAgICB9LHByb3BzKSxkZWZhdWx0UHJvcHMpO1xuICAgfSxcblxuICAgc3RlcDogZnVuY3Rpb24oZHQpIHtcbiAgICAgdmFyIHAgPSB0aGlzLnA7XG5cbiAgICAgcC52eCArPSBwLmF4ICogZHQ7XG4gICAgIHAudnkgKz0gcC5heSAqIGR0O1xuXG4gICAgIHAueCArPSBwLnZ4ICogZHQ7XG4gICAgIHAueSArPSBwLnZ5ICogZHQ7XG4gICB9XG4gfSk7XG5cblxuXG5cbiAgcmV0dXJuIFE7XG59O1xuXG4iLCIvKmdsb2JhbCBRdWludHVzOmZhbHNlICovXG5cbi8qZ2xvYmFsIFF1aW50dXM6ZmFsc2UgKi9cbi8qKlxuUXVpbnR1cyBIVE1MNSBHYW1lIEVuZ2luZSAtIFRNWCBMb2FkZXIgbW9kdWxlXG5cbk1vZHVsZSByZXNwb25zaWJsZSBmb3IgbG9hZGluZyBUaWxlZCBUTVggZmlsZXNcblxuQG1vZHVsZSBRdWludHVzLklucHV0XG4qL1xuXG4vKipcbiAqIFF1aW50dXMgVE1YIExvYWRpbmcgbW9kdWxlXG4gKlxuICogQGNsYXNzIFF1aW50dXMuVE1YXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUSkge1xuXG5cbiAvLyBBZGQgVE1YIGZpbGUgbG9hZGluZyBzdXBwb3J0IHRvIFF1aW50dXNcbiBRLmFzc2V0VHlwZXNbJ3RteCddID0gJ1RNWCc7XG5cbiAvLyBMb2FkIGEgVE1YIGZpbGUgYXMgYSBwYXJzZWQgWE1MIERPTVxuIFEubG9hZEFzc2V0VE1YID0gIGZ1bmN0aW9uKGtleSxzcmMsY2FsbGJhY2ssZXJyb3JDYWxsYmFjaykge1xuXG4gICAvLyBQaWdneWJhY2sgb24gbG9hZEFzc2V0T3RoZXIncyBBSkFYIGNhbGxcbiAgIFEubG9hZEFzc2V0T3RoZXIoa2V5LHNyYyxmdW5jdGlvbihrZXkscmVzcG9uc2VUZXh0KSB7XG4gICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgIHZhciBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHJlc3BvbnNlVGV4dCwgXCJhcHBsaWNhdGlvbi94bWxcIik7XG4gICAgIC8vIHNhdmUgdGhlIGFzc2V0IGFzIHRoZSBwYXJzZWQgZG9jXG4gICAgIGNhbGxiYWNrKGtleSxkb2MpO1xuICAgfSwgZXJyb3JDYWxsYmFjayk7XG5cbiB9O1xuXG4gUS5fdG14RXh0cmFjdEFzc2V0TmFtZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgdmFyIHNvdXJjZSA9IHJlc3VsdC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIiksXG4gICBzb3VyY2VQYXJ0cyA9IHNvdXJjZS5zcGxpdChcIi9cIik7XG4gICAvLyBvbmx5IHJldHVybiB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBhc3NldCBzdHJpbmdcbiAgIHJldHVybiBzb3VyY2VQYXJ0c1tzb3VyY2VQYXJ0cy5sZW5ndGggLSAxXTtcbiB9O1xuXG5cbiBRLl90bXhFeHRyYWN0U291cmNlcyA9IGZ1bmN0aW9uKGFzc2V0KSB7XG4gICB2YXIgcmVzdWx0cyA9IGFzc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc291cmNlXVwiKTtcbiAgIHJldHVybiBRLl9tYXAocmVzdWx0cyxRLl90bXhFeHRyYWN0QXNzZXROYW1lKTtcblxuIH07XG4gXG5cbiBRLmxvYWRUTVggPSBmdW5jdGlvbihmaWxlcyxjYWxsYmFjayxvcHRpb25zKSB7XG4gICBpZihRLl9pc1N0cmluZyhmaWxlcykpIHtcbiAgICAgZmlsZXMgPSBRLl9ub3JtYWxpemVBcmcoZmlsZXMpO1xuICAgfVxuXG4gICB2YXIgdG14RmlsZXMgPSBbXTtcbiAgIFEuX2VhY2goZmlsZXMsZnVuY3Rpb24oZmlsZSkge1xuICAgICBpZihRLl9maWxlRXh0ZW5zaW9uKGZpbGUpID09PSAndG14Jykge1xuICAgICAgICB0bXhGaWxlcy5wdXNoKGZpbGUpO1xuICAgICB9XG4gICB9KTtcblxuICAgdmFyIGFkZGl0aW9uYWxBc3NldHMgPSBbXTtcblxuICAgUS5sb2FkKGZpbGVzLGZ1bmN0aW9uKCkge1xuICAgICBRLl9lYWNoKHRteEZpbGVzLGZ1bmN0aW9uKHRteEZpbGUpIHtcbiAgICAgICB2YXIgc291cmNlcyA9IFEuX3RteEV4dHJhY3RTb3VyY2VzKFEuYXNzZXQodG14RmlsZSkpO1xuICAgICAgIGFkZGl0aW9uYWxBc3NldHMgPSBhZGRpdGlvbmFsQXNzZXRzLmNvbmNhdChzb3VyY2VzKTtcbiAgICAgfSk7XG5cbiAgICAgaWYoYWRkaXRpb25hbEFzc2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgUS5sb2FkKGFkZGl0aW9uYWxBc3NldHMsY2FsbGJhY2ssb3B0aW9ucyk7XG4gICAgIH0gZWxzZSB7XG4gICAgICAgY2FsbGJhY2soKTtcbiAgICAgfVxuICAgfSk7XG5cbiB9O1xuXG5cblxuIGZ1bmN0aW9uIGF0dHIoZWxlbSxhdHIpIHtcbiAgIHZhciB2YWx1ZSA9IGVsZW0uZ2V0QXR0cmlidXRlKGF0cik7XG4gICByZXR1cm4gaXNOYU4odmFsdWUpID8gdmFsdWUgOiArdmFsdWU7XG4gfVxuXG4gZnVuY3Rpb24gcGFyc2VQcm9wZXJ0aWVzKGVsZW0pIHtcbiAgIHZhciBwcm9wRWxlbXMgPSBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwcm9wZXJ0eVwiKSxcbiAgICAgICBwcm9wcyA9IHt9O1xuXG4gICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcEVsZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgIHZhciBwcm9wRWxlbSA9IHByb3BFbGVtc1tpXTtcbiAgICAgcHJvcHNbYXR0cihwcm9wRWxlbSwnbmFtZScpXSA9IGF0dHIocHJvcEVsZW0sJ3ZhbHVlJyk7XG4gICB9XG4gICByZXR1cm4gcHJvcHM7XG4gfVxuXG4gUS5fdG14TG9hZFRpbGVzZXRzID0gZnVuY3Rpb24odGlsZXNldHMsIHRpbGVQcm9wZXJ0aWVzKSB7XG4gICB2YXIgZ2lkTWFwID0gW107XG5cbiAgIGZ1bmN0aW9uIHBhcnNlUG9pbnQocHQpIHtcbiAgICAgdmFyIHB0cyA9IHB0LnNwbGl0KFwiLFwiKTtcbiAgICAgcmV0dXJuIFsgcGFyc2VGbG9hdChwdHNbMF0pLCBwYXJzZUZsb2F0KHB0c1sxXSkgXTtcbiAgIH1cblxuICAgZm9yKHZhciB0ID0gMDsgdCA8IHRpbGVzZXRzLmxlbmd0aDt0KyspIHtcbiAgICAgdmFyIHRpbGVzZXQgPSB0aWxlc2V0c1t0XSxcbiAgICAgICAgIHNoZWV0TmFtZSA9IGF0dHIodGlsZXNldCxcIm5hbWVcIiksXG4gICAgICAgICBnaWQgPSBhdHRyKHRpbGVzZXQsXCJmaXJzdGdpZFwiKSxcbiAgICAgICAgIGFzc2V0TmFtZSA9IFEuX3RteEV4dHJhY3RBc3NldE5hbWUodGlsZXNldC5xdWVyeVNlbGVjdG9yKFwiaW1hZ2VcIikpLFxuICAgICAgICAgdGlsZXNldFRpbGVQcm9wcyA9IHt9LFxuICAgICAgICAgdGlsZXNldFByb3BzID0geyB0aWxlVzogYXR0cih0aWxlc2V0LFwidGlsZXdpZHRoXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSDogYXR0cih0aWxlc2V0LFwidGlsZWhlaWdodFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2luZ1g6IGF0dHIodGlsZXNldCxcInNwYWNpbmdcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNpbmdZOiBhdHRyKHRpbGVzZXQsXCJzcGFjaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgIHZhciB0aWxlcyA9IHRpbGVzZXQucXVlcnlTZWxlY3RvckFsbChcInRpbGVcIik7XG4gICAgIGZvcih2YXIgaSA9IDA7aSA8IHRpbGVzLmxlbmd0aDtpKyspIHtcbiAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2ldO1xuICAgICAgIHZhciB0aWxlSWQgPSBhdHRyKHRpbGUsXCJpZFwiKTtcbiAgICAgICB2YXIgdGlsZUdpZCA9IGdpZCArIHRpbGVJZDtcblxuICAgICAgIHZhciBwcm9wZXJ0aWVzID0gcGFyc2VQcm9wZXJ0aWVzKHRpbGUpO1xuXG4gICAgICAgaWYocHJvcGVydGllcy5wb2ludHMpIHtcbiAgICAgICAgIHByb3BlcnRpZXMucG9pbnRzID0gUS5fbWFwKHByb3BlcnRpZXMucG9pbnRzLnNwbGl0KFwiIFwiKSxwYXJzZVBvaW50KTtcbiAgICAgICB9XG5cbiAgICAgICAvLyBzYXZlIHRoZSBwcm9wZXJ0aWVzIGluZGV4ZWQgYnkgR0lEIGZvciBjcmVhdGluZyBvYmplY3RzXG4gICAgICAgdGlsZVByb3BlcnRpZXNbdGlsZUdpZF0gPSBwcm9wZXJ0aWVzO1xuXG4gICAgICAgLy8gc2F2ZSB0aGUgcHJvcGVydGllcyBpbmRleGVkIGJ5IHRpbGUgbnVtYmVyIGZvciB0aGUgZnJhbWUgcHJvcGVydGllc1xuICAgICAgIHRpbGVzZXRUaWxlUHJvcHNbdGlsZUlkXSA9IHByb3BlcnRpZXM7XG4gICAgIH1cbiAgICAgdGlsZXNldFByb3BzLmZyYW1lUHJvcGVydGllcyA9IHRpbGVzZXRUaWxlUHJvcHM7XG4gICAgIGdpZE1hcC5wdXNoKFsgZ2lkLCBzaGVldE5hbWUgXSk7XG4gICAgIFEuc2hlZXQoc2hlZXROYW1lLCBhc3NldE5hbWUsICB0aWxlc2V0UHJvcHMpO1xuXG4gICB9XG4gICByZXR1cm4gZ2lkTWFwO1xuIH07XG5cbiBRLl90bXhQcm9jZXNzSW1hZ2VMYXllciA9IGZ1bmN0aW9uKHN0YWdlLGdpZE1hcCx0aWxlUHJvcGVydGllcyxsYXllcikge1xuICAgdmFyIGFzc2V0TmFtZSA9IFEuX3RteEV4dHJhY3RBc3NldE5hbWUobGF5ZXIucXVlcnlTZWxlY3RvcihcImltYWdlXCIpKTtcbiAgIHZhciBwcm9wZXJ0aWVzID0gcGFyc2VQcm9wZXJ0aWVzKGxheWVyKTtcbiAgIHByb3BlcnRpZXMuYXNzZXQgPSBhc3NldE5hbWU7XG5cbiAgIHN0YWdlLmluc2VydChuZXcgUS5SZXBlYXRlcihwcm9wZXJ0aWVzKSk7XG4gfTtcblxuIC8vIGdldCB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIGdpZCBtYXAgdGhhdCBnaXZlc1xuIC8vIGEgZ2lkIG9mZnNldFxuIFEuX2xvb2t1cEdpZCA9IGZ1bmN0aW9uKGdpZCxnaWRNYXApIHtcbiAgIHZhciBpZHggPSAwO1xuXG4gICB3aGlsZShnaWRNYXBbaWR4KzFdICYmIGdpZCA+PSBnaWRNYXBbaWR4KzFdWzBdKSB7XG4gICAgIGlkeCsrO1xuICAgfVxuICAgcmV0dXJuIGdpZE1hcFtpZHhdO1xuIH07XG5cbiBRLl90bXhQcm9jZXNzVGlsZUxheWVyID0gZnVuY3Rpb24oc3RhZ2UsZ2lkTWFwLHRpbGVQcm9wZXJ0aWVzLGxheWVyKSB7XG4gICB2YXIgdGlsZXMgPSBsYXllci5xdWVyeVNlbGVjdG9yQWxsKFwidGlsZVwiKSxcbiAgICAgICB3aWR0aCA9IGF0dHIobGF5ZXIsJ3dpZHRoJyksXG4gICAgICAgaGVpZ2h0ID0gYXR0cihsYXllciwnaGVpZ2h0Jyk7XG5cbiAgICAgICBcbiAgIHZhciBnaWREZXRhaWxzLGdpZE9mZnNldCwgc2hlZXROYW1lO1xuXG4gICB2YXIgZGF0YSA9IFtdLCBpZHg9MDtcbiAgIGZvcih2YXIgeT0wO3k8aGVpZ2h0O3krKykge1xuICAgICBkYXRhW3ldID0gW107XG4gICAgIGZvcih2YXIgeD0wO3g8d2lkdGg7eCsrKSB7XG4gICAgICAgdmFyIGdpZCA9IGF0dHIodGlsZXNbaWR4XSxcImdpZFwiKTtcbiAgICAgICBpZihnaWQgPT09IDApIHtcbiAgICAgICAgIGRhdGFbeV0ucHVzaChudWxsKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gSWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRpbGVzZXQgdGhpcyBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgICAvLyBmaWd1cmUgaXQgb3V0IGJ5IGxvb2tpbmcgdXAgdGhlIGdpZCBvZiB0aGUgdGlsZSB3L1xuICAgICAgICAgLy8gYW5kIG1hdGNoIHRvIHRoZSB0aWxlc2VmXG4gICAgICAgICBpZighZ2lkT2Zmc2V0KSB7XG4gICAgICAgICAgIGdpZERldGFpbHMgPSBRLl9sb29rdXBHaWQoYXR0cih0aWxlc1tpZHhdLFwiZ2lkXCIpLGdpZE1hcCk7XG4gICAgICAgICAgIGdpZE9mZnNldCA9IGdpZERldGFpbHNbMF07XG4gICAgICAgICAgIHNoZWV0TmFtZSA9IGdpZERldGFpbHNbMV07XG4gICAgICAgICB9XG4gICAgICAgICBkYXRhW3ldLnB1c2goZ2lkIC0gZ2lkT2Zmc2V0KTtcbiAgICAgICB9XG4gICAgICAgaWR4Kys7XG4gICAgIH1cbiAgIH1cblxuICAgdmFyIHRpbGVMYXllclByb3BlcnRpZXMgPSBRLl9leHRlbmQoeyAgIFxuICAgICB0aWxlVzogUS5zaGVldChzaGVldE5hbWUpLnRpbGVXLFxuICAgICB0aWxlSDogUS5zaGVldChzaGVldE5hbWUpLnRpbGVILFxuICAgICBzaGVldDogc2hlZXROYW1lLFxuICAgICB0aWxlczogZGF0YVxuICAgICB9LHBhcnNlUHJvcGVydGllcyhsYXllcikpO1xuXG4gICB2YXIgVGlsZUxheWVyQ2xhc3MgPSB0aWxlTGF5ZXJQcm9wZXJ0aWVzLkNsYXNzIHx8ICdUaWxlTGF5ZXInO1xuXG4gICBpZih0aWxlTGF5ZXJQcm9wZXJ0aWVzWydjb2xsaXNpb24nXSkge1xuICAgICBzdGFnZS5jb2xsaXNpb25MYXllcihuZXcgUVtUaWxlTGF5ZXJDbGFzc10odGlsZUxheWVyUHJvcGVydGllcykpO1xuICAgfSBlbHNlIHtcbiAgICAgc3RhZ2UuaW5zZXJ0KG5ldyBRW1RpbGVMYXllckNsYXNzXSh0aWxlTGF5ZXJQcm9wZXJ0aWVzKSk7XG4gICB9XG4gfTtcblxuIFEuX3RteFByb2Nlc3NPYmplY3RMYXllciA9IGZ1bmN0aW9uKHN0YWdlLGdpZE1hcCx0aWxlUHJvcGVydGllcyxsYXllcikge1xuICAgdmFyIG9iamVjdHMgPSBsYXllci5xdWVyeVNlbGVjdG9yQWxsKFwib2JqZWN0XCIpO1xuICAgZm9yKHZhciBpPTA7aSA8IG9iamVjdHMubGVuZ3RoO2krKykge1xuICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXSxcbiAgICAgICAgIGdpZCA9IGF0dHIob2JqLFwiZ2lkXCIpLFxuICAgICAgICAgeCA9IGF0dHIob2JqLCd4JyksXG4gICAgICAgICB5ID0gYXR0cihvYmosJ3knKSxcbiAgICAgICAgIHByb3BlcnRpZXMgPSB0aWxlUHJvcGVydGllc1tnaWRdLFxuICAgICAgICAgb3ZlcnJpZGVQcm9wZXJ0aWVzID0gcGFyc2VQcm9wZXJ0aWVzKG9iaik7XG5cbiAgICAgaWYoIXByb3BlcnRpZXMpIHsgdGhyb3cgXCJJbnZhbGlkIFRNWCBPYmplY3Q6IG1pc3NpbmcgcHJvcGVydGllcyBmb3IgR0lEOlwiICsgZ2lkOyB9XG4gICAgIGlmKCFwcm9wZXJ0aWVzWydDbGFzcyddKSB7IHRocm93IFwiSW52YWxpZCBUTVggT2JqZWN0OiBtaXNzaW5nIENsYXNzIGZvciBHSUQ6XCIgKyBnaWQ7IH1cblxuICAgICB2YXIgY2xhc3NOYW1lID0gcHJvcGVydGllc1snQ2xhc3MnXTtcbiAgICAgaWYoIWNsYXNzTmFtZSkgeyB0aHJvdyBcIkludmFsaWQgVE1YIE9iamVjdCBDbGFzczogXCIgKyBjbGFzc05hbWUgKyBcIiBHSUQ6XCIgKyBnaWQ7IH1cblxuICAgICB2YXIgcCA9IFEuX2V4dGVuZChRLl9leHRlbmQoeyB4OiB4LCB5OiB5IH0sIHByb3BlcnRpZXMpLCBvdmVycmlkZVByb3BlcnRpZXMpO1xuXG4gICAgIC8vIE9mZnNldCB0aGUgc3ByaXRlXG4gICAgIHZhciBzcHJpdGUgPSBuZXcgUVtjbGFzc05hbWVdKHApO1xuICAgICBzcHJpdGUucC54ICs9IHNwcml0ZS5wLncvMjtcbiAgICAgc3ByaXRlLnAueSAtPSBzcHJpdGUucC5oLzI7XG5cbiAgICAgc3RhZ2UuaW5zZXJ0KHNwcml0ZSk7XG4gICB9XG5cbiB9O1xuXG4gUS5fdG14UHJvY2Vzc29ycyA9IHsgJ29iamVjdGdyb3VwJzogUS5fdG14UHJvY2Vzc09iamVjdExheWVyLFxuICAgICAgICAgICAgICAgICAgICAgICdsYXllcic6IFEuX3RteFByb2Nlc3NUaWxlTGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgJ2ltYWdlbGF5ZXInOiBRLl90bXhQcm9jZXNzSW1hZ2VMYXllciB9O1xuXG4gUS5zdGFnZVRNWCA9IGZ1bmN0aW9uKGRhdGFBc3NldCxzdGFnZSkge1xuICAgIHZhciBkYXRhID0gUS5faXNTdHJpbmcoZGF0YUFzc2V0KSA/ICBRLmFzc2V0KGRhdGFBc3NldCkgOiBkYXRhQXNzZXQ7XG5cbiAgICB2YXIgdGlsZVByb3BlcnRpZXMgPSB7fTtcblxuICAgIC8vIExvYWQgVGlsZXNldHNcbiAgICB2YXIgdGlsZXNldHMgPSBkYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGlsZXNldFwiKTtcbiAgICB2YXIgZ2lkTWFwID0gUS5fdG14TG9hZFRpbGVzZXRzKHRpbGVzZXRzLHRpbGVQcm9wZXJ0aWVzKTtcblxuICAgIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgbGF5ZXJzXG4gICAgUS5fZWFjaChkYXRhLmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzLGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICB2YXIgbGF5ZXJUeXBlID0gbGF5ZXIudGFnTmFtZTtcbiAgICAgIGlmKFEuX3RteFByb2Nlc3NvcnNbbGF5ZXJUeXBlXSkge1xuICAgICAgICBRLl90bXhQcm9jZXNzb3JzW2xheWVyVHlwZV0oc3RhZ2UsIGdpZE1hcCwgdGlsZVByb3BlcnRpZXMsIGxheWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxufTtcblxuIiwiLypnbG9iYWwgUXVpbnR1czpmYWxzZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFEpIHtcbiAgaWYoUS5faXNVbmRlZmluZWQoUS5tb2R1bGVzLlNwcml0ZXMpKSB7XG4gICAgdGhyb3cgXCJRdWludHVzLlRvdWNoIHJlcXVpcmVzIFF1aW50dXMuU3ByaXRlcyBNb2R1bGVcIjtcbiAgfVxuXG4gIHZhciBoYXNUb3VjaCA9ICAhISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xuXG4gIHZhciB0b3VjaFN0YWdlID0gWzBdO1xuICB2YXIgdG91Y2hUeXBlID0gMDtcblxuICBRLkV2ZW50ZWQuZXh0ZW5kKFwiVG91Y2hTeXN0ZW1cIix7XG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b3VjaFN5c3RlbSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYm91bmRUb3VjaCA9IGZ1bmN0aW9uKGUpIHsgdG91Y2hTeXN0ZW0udG91Y2goZSk7IH07XG4gICAgICB0aGlzLmJvdW5kRHJhZyA9IGZ1bmN0aW9uKGUpIHsgdG91Y2hTeXN0ZW0uZHJhZyhlKTsgfTtcbiAgICAgIHRoaXMuYm91bmRFbmQgPSBmdW5jdGlvbihlKSB7IHRvdWNoU3lzdGVtLnRvdWNoRW5kKGUpOyB9O1xuXG4gICAgICBRLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLHRoaXMuYm91bmRUb3VjaCk7XG4gICAgICBRLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsdGhpcy5ib3VuZFRvdWNoKTtcblxuICAgICAgUS5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLHRoaXMuYm91bmREcmFnKTtcbiAgICAgIFEuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyx0aGlzLmJvdW5kRHJhZyk7XG5cbiAgICAgIFEuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLHRoaXMuYm91bmRFbmQpO1xuICAgICAgUS5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJyx0aGlzLmJvdW5kRW5kKTtcbiAgICAgIFEuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLHRoaXMuYm91bmRFbmQpO1xuXG4gICAgICB0aGlzLnRvdWNoUG9zID0gbmV3IFEuRXZlbnRlZCgpO1xuICAgICAgdGhpcy50b3VjaFBvcy5ncmlkID0ge307XG4gICAgICB0aGlzLnRvdWNoUG9zLnAgPSB7IHc6MSwgaDoxLCBjeDogMCwgY3k6IDAgfTtcbiAgICAgIHRoaXMuYWN0aXZlVG91Y2hlcyA9IHt9O1xuICAgICAgdGhpcy50b3VjaGVkT2JqZWN0cyA9IHt9O1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIFEuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsdGhpcy5ib3VuZFRvdWNoKTtcbiAgICAgIFEuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyx0aGlzLmJvdW5kVG91Y2gpO1xuXG4gICAgICBRLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsdGhpcy5ib3VuZERyYWcpO1xuICAgICAgUS5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLHRoaXMuYm91bmREcmFnKTtcblxuICAgICAgUS5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsdGhpcy5ib3VuZEVuZCk7XG4gICAgICBRLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLHRoaXMuYm91bmRFbmQpO1xuICAgICAgUS5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsdGhpcy5ib3VuZEVuZCk7XG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZVRvdWNoOiBmdW5jdGlvbih0b3VjaCxzdGFnZSkge1xuICAgICAgdmFyIGNhbnZhc1Bvc1ggPSB0b3VjaC5vZmZzZXRYLFxuICAgICAgICAgIGNhbnZhc1Bvc1kgPSB0b3VjaC5vZmZzZXRZO1xuICAgICAgICAgXG5cbiAgICAgIGlmKFEuX2lzVW5kZWZpbmVkKGNhbnZhc1Bvc1gpIHx8IFEuX2lzVW5kZWZpbmVkKGNhbnZhc1Bvc1kpKSB7XG4gICAgICAgIGNhbnZhc1Bvc1ggPSB0b3VjaC5sYXllclg7XG4gICAgICAgIGNhbnZhc1Bvc1kgPSB0b3VjaC5sYXllclk7XG4gICAgICB9XG5cbiAgICAgIGlmKFEuX2lzVW5kZWZpbmVkKGNhbnZhc1Bvc1gpIHx8IFEuX2lzVW5kZWZpbmVkKGNhbnZhc1Bvc1kpKSB7XG4gICAgICAgIGlmKFEudG91Y2gub2Zmc2V0WCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgUS50b3VjaC5vZmZzZXRYID0gMDtcbiAgICAgICAgICBRLnRvdWNoLm9mZnNldFkgPSAwO1xuICAgICAgICAgIHZhciBlbCA9IFEuZWw7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgUS50b3VjaC5vZmZzZXRYICs9IGVsLm9mZnNldExlZnQ7XG4gICAgICAgICAgICBRLnRvdWNoLm9mZnNldFkgKz0gZWwub2Zmc2V0VG9wO1xuICAgICAgICAgIH0gd2hpbGUoZWwgPSBlbC5vZmZzZXRQYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhc1Bvc1ggPSB0b3VjaC5wYWdlWCAtIFEudG91Y2gub2Zmc2V0WDtcbiAgICAgICAgY2FudmFzUG9zWSA9IHRvdWNoLnBhZ2VZIC0gUS50b3VjaC5vZmZzZXRZO1xuICAgICAgfVxuXG5cbiAgICAgIHRoaXMudG91Y2hQb3MucC5veCA9IHRoaXMudG91Y2hQb3MucC5weCA9IGNhbnZhc1Bvc1ggLyBRLmNzc1dpZHRoICogUS53aWR0aDtcbiAgICAgIHRoaXMudG91Y2hQb3MucC5veSA9IHRoaXMudG91Y2hQb3MucC5weSA9IGNhbnZhc1Bvc1kgLyBRLmNzc0hlaWdodCAqIFEuaGVpZ2h0O1xuICAgICAgXG4gICAgICBpZihzdGFnZS52aWV3cG9ydCkge1xuICAgICAgICB0aGlzLnRvdWNoUG9zLnAucHggLz0gc3RhZ2Uudmlld3BvcnQuc2NhbGU7XG4gICAgICAgIHRoaXMudG91Y2hQb3MucC5weSAvPSBzdGFnZS52aWV3cG9ydC5zY2FsZTtcbiAgICAgICAgdGhpcy50b3VjaFBvcy5wLnB4ICs9IHN0YWdlLnZpZXdwb3J0Lng7XG4gICAgICAgIHRoaXMudG91Y2hQb3MucC5weSArPSBzdGFnZS52aWV3cG9ydC55O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRvdWNoUG9zLnAueCA9IHRoaXMudG91Y2hQb3MucC5weDtcbiAgICAgIHRoaXMudG91Y2hQb3MucC55ID0gdGhpcy50b3VjaFBvcy5wLnB5O1xuXG4gICAgICB0aGlzLnRvdWNoUG9zLm9iaiA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy50b3VjaFBvcztcbiAgICB9LFxuXG4gICAgdG91Y2g6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcyB8fCBbIGUgXTtcblxuICAgICAgZm9yKHZhciBpPTA7aTx0b3VjaGVzLmxlbmd0aDtpKyspIHtcblxuICAgICAgICBmb3IodmFyIHN0YWdlSWR4PTA7c3RhZ2VJZHggPCB0b3VjaFN0YWdlLmxlbmd0aDtzdGFnZUlkeCsrKSB7XG4gICAgICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXSxcbiAgICAgICAgICAgICAgc3RhZ2UgPSBRLnN0YWdlKHRvdWNoU3RhZ2Vbc3RhZ2VJZHhdKTtcblxuICAgICAgICAgIGlmKCFzdGFnZSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdG91Y2guaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXIgfHwgMDtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5ub3JtYWxpemVUb3VjaCh0b3VjaCxzdGFnZSk7XG5cbiAgICAgICAgICBzdGFnZS5yZWdyaWQocG9zLHRydWUpO1xuICAgICAgICAgIHZhciBjb2wgPSBzdGFnZS5zZWFyY2gocG9zLHRvdWNoVHlwZSksIG9iajtcblxuICAgICAgICAgIGlmKGNvbCB8fCBzdGFnZUlkeCA9PT0gdG91Y2hTdGFnZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBvYmogPSBjb2wgJiYgY29sLm9iajtcbiAgICAgICAgICAgIHBvcy5vYmogPSBvYmo7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJ0b3VjaFwiLHBvcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYob2JqICYmICF0aGlzLnRvdWNoZWRPYmplY3RzW29ial0pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVG91Y2hlc1t0b3VjaC5pZGVudGlmaWVyXSA9IHtcbiAgICAgICAgICAgICAgeDogcG9zLnAucHgsXG4gICAgICAgICAgICAgIHk6IHBvcy5wLnB5LFxuICAgICAgICAgICAgICBvcmlnWDogb2JqLnAueCxcbiAgICAgICAgICAgICAgb3JpZ1k6IG9iai5wLnksXG4gICAgICAgICAgICAgIHN4OiBwb3MucC5veCxcbiAgICAgICAgICAgICAgc3k6IHBvcy5wLm95LFxuICAgICAgICAgICAgICBpZGVudGlmaWVyOiB0b3VjaC5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICBvYmo6IG9iaixcbiAgICAgICAgICAgICAgc3RhZ2U6IHN0YWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy50b3VjaGVkT2JqZWN0c1tvYmoucC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgb2JqLnRyaWdnZXIoJ3RvdWNoJywgdGhpcy5hY3RpdmVUb3VjaGVzW3RvdWNoLmlkZW50aWZpZXJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIC8vZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBkcmFnOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXMgfHwgWyBlIF07XG5cbiAgICAgIGZvcih2YXIgaT0wO2k8dG91Y2hlcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICAgIHRvdWNoLmlkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyIHx8IDA7XG5cbiAgICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuYWN0aXZlVG91Y2hlc1t0b3VjaC5pZGVudGlmaWVyXSxcbiAgICAgICAgICAgIHN0YWdlID0gYWN0aXZlICYmIGFjdGl2ZS5zdGFnZTtcblxuICAgICAgICBpZihhY3RpdmUpIHtcbiAgICAgICAgICB2YXIgcG9zID0gdGhpcy5ub3JtYWxpemVUb3VjaCh0b3VjaCxzdGFnZSk7XG4gICAgICAgICAgYWN0aXZlLnggPSBwb3MucC5weDtcbiAgICAgICAgICBhY3RpdmUueSA9IHBvcy5wLnB5O1xuICAgICAgICAgIGFjdGl2ZS5keCA9IHBvcy5wLm94IC0gYWN0aXZlLnN4O1xuICAgICAgICAgIGFjdGl2ZS5keSA9IHBvcy5wLm95IC0gYWN0aXZlLnN5O1xuXG4gICAgICAgICAgYWN0aXZlLm9iai50cmlnZ2VyKCdkcmFnJywgYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICB0b3VjaEVuZDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzIHx8IFsgZSBdO1xuXG4gICAgICBmb3IodmFyIGk9MDtpPHRvdWNoZXMubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuXG4gICAgICAgIHRvdWNoLmlkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyIHx8IDA7XG5cbiAgICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuYWN0aXZlVG91Y2hlc1t0b3VjaC5pZGVudGlmaWVyXTtcblxuICAgICAgICBpZihhY3RpdmUpIHtcbiAgICAgICAgICBhY3RpdmUub2JqLnRyaWdnZXIoJ3RvdWNoRW5kJywgYWN0aXZlKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy50b3VjaGVkT2JqZWN0c1thY3RpdmUub2JqLnAuaWRdO1xuICAgICAgICAgIHRoaXMuYWN0aXZlVG91Y2hlc1t0b3VjaC5pZGVudGlmaWVyXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgUS50b3VjaCA9IGZ1bmN0aW9uKHR5cGUsc3RhZ2UpIHtcbiAgICBRLnVudG91Y2goKTtcbiAgICB0b3VjaFR5cGUgPSB0eXBlIHx8IFEuU1BSSVRFX1VJO1xuICAgIHRvdWNoU3RhZ2UgPSBzdGFnZSB8fCBbMiwxLDBdO1xuICAgIGlmKCFRLl9pc0FycmF5KHRvdWNoU3RhZ2UpKSB7XG4gICAgICB0b3VjaFN0YWdlID0gW3RvdWNoU3RhZ2VdO1xuICAgIH1cblxuICAgIGlmKCFRLl90b3VjaCkge1xuICAgICAgUS50b3VjaElucHV0ID0gbmV3IFEuVG91Y2hTeXN0ZW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIFE7XG4gIH07XG5cbiAgUS51bnRvdWNoID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoUS50b3VjaElucHV0KSB7XG4gICAgICBRLnRvdWNoSW5wdXQuZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIFFbJ3RvdWNoSW5wdXQnXTtcbiAgICB9XG4gICAgcmV0dXJuIFE7XG4gIH07XG5cbn07XG4iLCIvKmdsb2JhbCBRdWludHVzOmZhbHNlICovXG5cblxuLyoqXG5RdWludHVzIEhUTUw1IEdhbWUgRW5naW5lIC0gVUkgTW9kdWxlXG5cblRoZSBjb2RlIGluIGBxdWludHVzX3VpLmpzYCBkZWZpbmVzIHRoZSBgUXVpbnR1cy5VSWAgbW9kdWxlLCB3aGljaFxuYWRkcyBpbiBzb21lIGVhc2lseSBhY2Nlc3NpYmxlIFVJIGVsZW1lbnRzIGludG8gUXVpbnR1cy5cblxuRGVwZW5kcyBvbiB0aGUgYFF1aW50dXMuU3ByaXRlYCBtb2R1bGUuXG5cblVJIGxldHMgeW91IGNyZWF0ZSBVSSBlbGVtZW50cyBsaWtlIGNvbnRhaW5lcnMsIGJ1dHRvbnMgYW5kIHRleHQgZWxlbWVudHMuXG5cbkBtb2R1bGUgUXVpbnR1cy5VSVxuKi9cblxuLyoqXG4gKiBRdWludHVzIFVJIE1vZHVsZSBDbGFzc1xuICpcbiAqIEBjbGFzcyBRdWludHVzLlVJXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUSkge1xuICBpZihRLl9pc1VuZGVmaW5lZChRLm1vZHVsZXMuVG91Y2gpKSB7XG4gICAgdGhyb3cgXCJRdWludHVzLlVJIHJlcXVpcmVzIFF1aW50dXMuVG91Y2ggTW9kdWxlXCI7XG4gIH1cblxuICBRLlVJID0ge307XG5cbiAgLyoqXG4gICBEcmF3cyBhIHJvdW5kZWQgcmVjdGFuZ2xlIGNlbnRlcmVkIG9uIDAsMFxuXG4gICBPcHRpb25zIGZvciBgcmVjdGBcblxuICAgICAqIHJhZGl1cyAtIHJhZGl1cyBvZiB0aGUgcm91bmRlZCBjb3JuZXJzXG4gICAgICogdyAgICAgIC0gd2lkdGggb2YgdGhlIHJlY3RcbiAgICAgKiBoICAgICAgLSBoZWlnaHQgb2YgdGhlIHJlY3RcbiAgICAgKiBjeCAgICAgLSBYIGNvb3JkaW5hdGUgb2YgdG9wIGxlZnQgY29ybmVyXG4gICAgICogY3kgICAgIC0gWSBjb29yZGluYXRlIG9mIHRvcCBsZWZ0IGNvcm5lclxuXG4gICBAbWV0aG9kIHJvdW5kUmVjdFxuICAgQGZvciBRLlVJXG4gICBAcGFyYW0ge2NhbnZhcyBjb250ZXh0fSBjdHhcbiAgIEBwYXJhbSB7T2JqZWN0fSByZWN0IC1cbiAgICovXG4gIFEuVUkucm91bmRSZWN0ID0gZnVuY3Rpb24oY3R4LCByZWN0KSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oLXJlY3QuY3ggKyByZWN0LnJhZGl1cywgLXJlY3QuY3kpO1xuICAgIGN0eC5saW5lVG8oLXJlY3QuY3ggKyByZWN0LncgLSByZWN0LnJhZGl1cywgLXJlY3QuY3kpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKC1yZWN0LmN4ICsgcmVjdC53LCAtcmVjdC5jeSwgLXJlY3QuY3ggKyByZWN0LncsIC1yZWN0LmN5ICsgcmVjdC5yYWRpdXMpO1xuICAgIGN0eC5saW5lVG8oLXJlY3QuY3ggKyByZWN0LncsIC1yZWN0LmN5ICsgcmVjdC5oIC0gcmVjdC5yYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKC1yZWN0LmN4ICsgcmVjdC53LFxuICAgICAgICAgICAgICAgICAgICAgICAgIC1yZWN0LmN5ICsgcmVjdC5oLFxuICAgICAgICAgICAgICAgICAgICAgICAgIC1yZWN0LmN4ICsgcmVjdC53IC0gcmVjdC5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgLXJlY3QuY3kgKyByZWN0LmgpO1xuICAgIGN0eC5saW5lVG8oLXJlY3QuY3ggKyByZWN0LnJhZGl1cywgLXJlY3QuY3kgKyByZWN0LmgpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKC1yZWN0LmN4LCAtcmVjdC5jeSArIHJlY3QuaCwgLXJlY3QuY3gsIC1yZWN0LmN5ICsgcmVjdC5oIC0gcmVjdC5yYWRpdXMpO1xuICAgIGN0eC5saW5lVG8oLXJlY3QuY3gsIC1yZWN0LmN5ICsgcmVjdC5yYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKC1yZWN0LmN4LCAtcmVjdC5jeSwgLXJlY3QuY3ggKyByZWN0LnJhZGl1cywgLXJlY3QuY3kpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICAvKipcbiAgIENyZWF0ZXMgYSBjb250YWluZXIgZm9yIFVJIGVsZW1lbnRzLlxuXG4gICBPcHRpb25zIGZvciBgcGAgYXJlIHZlcnkgc2ltaWxhciB0byB0aGUgb25lcyBmb3IgUS5TcHJpdGUuXG5cbiAgICAgKiBib3JkZXIgLSB3aWR0aCBvZiB0aGUgYm9yZGVyIFswXSAobm8gYm9yZGVyKVxuICAgICAqIHJhZGl1cyAtIHJhZGl1cyBvZiB0aGUgcm91bmRlZCBib3JkZXIgWzVdXG4gICAgICogc3Ryb2tlIC0gY29sb3Igb2YgdGhlIGJvcmRlciBbIzAwMF1cbiAgICAgKiB3ICAgICAgLSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG4gICAgICogaCAgICAgIC0gaGVpZ2h0IG9mIHRoZSBjb250YWluZXJcbiAgICAgKiB4ICAgICAgLSBYIGNvb3JkaW5hdGUgb2YgdG9wIGxlZnQgY29ybmVyXG4gICAgICogeSAgICAgIC0gWSBjb29yZGluYXRlIG9mIHRvcCBsZWZ0IGNvcm5lclxuICAgICAqIGZpbGwgICAtIGJhY2tncm91bmQgY29sb3IgW251bGxdXG4gICAgICogc2hhZG93IC0gaWYgdGhlIGNvbnRhaW5lciBzaG91bGQgaGF2ZSBhIHNoYWRvd1tmYWxzZV1cbiAgICAgKiBzaGFkb3dDb2xvciAtIGByZ2JgIHZhbHVlIG9mIHRoZSBzaGFkb3cgW2ZhbHNlXVxuXG4gICBAY2xhc3MgUS5VSS5Db250YWluZXJcbiAgIEBleHRlbmRzIFEuU3ByaXRlXG4gICBAZm9yIFEuVUlcbiAgIEBwYXJhbSB7T2JqZWN0fSBwIC0gYXMgZGVzY3JpYmVkIGFib3ZlXG4gICAqL1xuICBRLlVJLkNvbnRhaW5lciA9IFEuU3ByaXRlLmV4dGVuZChcIlVJLkNvbnRhaW5lclwiLCB7XG4gICAgaW5pdDogZnVuY3Rpb24ocCxkZWZhdWx0cykge1xuICAgICAgdmFyIGFkanVzdGVkUCA9IFEuX2Nsb25lKHB8fHt9KSxcbiAgICAgICAgICBtYXRjaDtcblxuICAgICAgaWYocCAmJiBRLl9pc1N0cmluZyhwLncpICYmIChtYXRjaCA9IHAudy5tYXRjaCgvXlswLTldKyUkLykpKSB7XG4gICAgICAgIGFkanVzdGVkUC53ID0gcGFyc2VJbnQocC53LDEwKSAqIFEud2lkdGggLyAxMDA7XG4gICAgICAgIGFkanVzdGVkUC54ID0gUS53aWR0aC8yIC0gYWRqdXN0ZWRQLncvMjtcbiAgICAgIH1cblxuICAgICAgaWYocCAmJiBRLl9pc1N0cmluZyhwLmgpICYmIChtYXRjaCA9IHAuaC5tYXRjaCgvXlswLTldKyUkLykpKSB7XG4gICAgICAgIGFkanVzdGVkUC5oID0gcGFyc2VJbnQocC5oLDEwKSAqIFEuaGVpZ2h0IC8gMTAwO1xuICAgICAgICBhZGp1c3RlZFAueSA9IFEuaGVpZ2h0IC8yIC0gYWRqdXN0ZWRQLmgvMjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3VwZXIoUS5fZGVmYXVsdHMoYWRqdXN0ZWRQLGRlZmF1bHRzKSx7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGhpZGRlbjogZmFsc2UsIC8vIFNldCB0byB0cnVlIHRvIG5vdCBzaG93IHRoZSBjb250YWluZXJcbiAgICAgICAgZmlsbDogICBudWxsLCAvLyBTZXQgdG8gY29sb3IgdG8gYWRkIGJhY2tncm91bmRcbiAgICAgICAgaGlnaGxpZ2h0OiAgIG51bGwsIC8vIFNldCB0byBjb2xvciB0byBmb3IgYnV0dG9uXG4gICAgICAgIHJhZGl1czogNSwgLy8gQm9yZGVyIHJhZGl1c1xuICAgICAgICBzdHJva2U6IFwiIzAwMFwiLFxuICAgICAgICBib3JkZXI6IGZhbHNlLCAvLyBTZXQgdG8gYSB3aWR0aCB0byBzaG93IGEgYm9yZGVyXG4gICAgICAgIHNoYWRvdzogZmFsc2UsIC8vIFNldCB0byB0cnVlIG9yIGEgc2hhZG93IG9mZmVzdFxuICAgICAgICBzaGFkb3dDb2xvcjogZmFsc2UsIC8vIFNldCB0byBhIHJnYmEgdmFsdWUgZm9yIHRoZSBzaGFkb3dcbiAgICAgICAgb3V0bGluZVdpZHRoOiBmYWxzZSwgLy8gU2V0IHRvIGEgd2lkdGggdG8gb3V0bGluZSB0ZXh0XG4gICAgICAgIG91dGxpbmVDb2xvcjogXCIjMDAwXCIsXG4gICAgICAgIHR5cGU6IFEuU1BSSVRFX05PTkVcbiAgICAgIH0pO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICBJbnNlcnRzIGFuIG9iamVjdCBpbnRvIHRoZSBjb250YWluZXIuXG4gICAgIFRoZSBvYmplY3QgY2FuIGxhdGVyIGFjY2Vzc2VkIHZpYSBgY2hpbGRyZW5gIHByb3BlcnR5IG9mIHRoZSBjb250YWluZXIuXG5cbiAgICAgQG1ldGhvZCBpbnNlcnRcbiAgICAgQGZvciBRLlVJLkNvbnRhaW5lclxuICAgICBAcGFyYW0ge1EuR2FtZU9iamVjdH0gb2JqIC0gdGhlIEl0ZW0gdG8gaW5zZXJ0XG4gICAgIEByZXR1cm4gdGhlIGluc2VydGVkIG9iamVjdCBmb3IgY2hhaW5pbmdcbiAgICAqL1xuICAgIGluc2VydDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB0aGlzLnN0YWdlLmluc2VydChvYmosdGhpcyk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgRml0cyB0aGUgY29udGFpbmVycyBzaXplIGRlcGVuZGluZyBvbiBpdHMgY2hpbGRyZW4uXG5cbiAgICAgQG1ldGhvZCBmaXRcbiAgICAgQGZvciBRLlVJLkNvbnRhaW5lclxuICAgICBAcGFyYW0ge051bWJlcn0gcGFkZGluZ1kgLSB2ZXJ0aWNhbCBwYWRkaW5nXG4gICAgIEBwYXJhbSB7TnVtYmVyfSBwYWRkaW5nWCAtIGhvcml6b250YWwgcGFkZGluZ1xuICAgICBAcmV0dXJuIHRoZSBpbnNlcnRlZCBvYmplY3QgZm9yIGNoYWluaW5nXG4gICAgKi9cbiAgICBmaXQ6IGZ1bmN0aW9uKHBhZGRpbmdZLHBhZGRpbmdYKSB7XG4gICAgICBpZih0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgaWYocGFkZGluZ1kgPT09IHZvaWQgMCkgeyBwYWRkaW5nWSA9IDA7IH1cbiAgICAgIGlmKHBhZGRpbmdYID09PSB2b2lkIDApIHsgcGFkZGluZ1ggPSBwYWRkaW5nWTsgfVxuXG4gICAgICB2YXIgbWluWCA9IEluZmluaXR5LFxuICAgICAgICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICAgICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgICAgIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgIGZvcih2YXIgaSA9MDtpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7aSsrKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgbWluT2JqWCA9IG9iai5wLnggLSBvYmoucC5jeCxcbiAgICAgICAgICAgIG1pbk9ialkgPSBvYmoucC55IC0gb2JqLnAuY3ksXG4gICAgICAgICAgICBtYXhPYmpYID0gb2JqLnAueCAtIG9iai5wLmN4ICsgb2JqLnAudyxcbiAgICAgICAgICAgIG1heE9ialkgPSBvYmoucC55IC0gb2JqLnAuY3kgKyBvYmoucC5oO1xuXG4gICAgICAgIGlmKG1pbk9ialggPCBtaW5YKSB7IG1pblggPSBtaW5PYmpYOyB9XG4gICAgICAgIGlmKG1pbk9ialkgPCBtaW5ZKSB7IG1pblkgPSBtaW5PYmpZOyB9XG5cbiAgICAgICAgaWYobWF4T2JqWCA+IG1heFgpIHsgbWF4WCA9IG1heE9ialg7IH1cbiAgICAgICAgaWYobWF4T2JqWSA+IG1heFkpIHsgbWF4WSA9IG1heE9ialk7IH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLnAuY3ggPSAtbWluWCArIHBhZGRpbmdYO1xuICAgICAgdGhpcy5wLmN5ID0gLW1pblkgKyBwYWRkaW5nWTtcbiAgICAgIHRoaXMucC53ID0gbWF4WCAtIG1pblggKyBwYWRkaW5nWCAqIDI7XG4gICAgICB0aGlzLnAuaCA9IG1heFkgLSBtaW5ZICsgcGFkZGluZ1kgKiAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgQWRkcyB0aGUgc2hhZG93IHNwZWNpZmllZCBpbiBgcGAgdG8gdGhlIGNvbnRhaW5lci5cblxuICAgICBAbWV0aG9kIGFkZFNoYWRvd1xuICAgICBAcGFyYW0ge2NhbnZhcyBjb250ZXh0fSBjdHggLSB0aGUgY2FudmFzIGNvbnRleHRcbiAgICAgQGZvciBRLlVJLkNvbnRhaW5lclxuICAgICovXG4gICAgYWRkU2hhZG93OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmKHRoaXMucC5zaGFkb3cpIHtcbiAgICAgICAgdmFyIHNoYWRvd0Ftb3VudCA9IFEuX2lzTnVtYmVyKHRoaXMucC5zaGFkb3cpID8gdGhpcy5wLnNoYWRvdyA6IDU7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYPXNoYWRvd0Ftb3VudDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFk9c2hhZG93QW1vdW50O1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB0aGlzLnAuc2hhZG93Q29sb3IgfHwgXCJyZ2JhKDAsMCw1MCwwLjEpXCI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICBTZXRzIHRoZSBzaGFkb3dzIGNvbG9yIHRvIGB0cmFuc3BhcmVudGAuXG5cbiAgICAgQG1ldGhvZCBjbGVhclNoYWRvd1xuICAgICBAcGFyYW0ge2NhbnZhcyBjb250ZXh0fSBjdHggLSB0aGUgY2FudmFzIGNvbnRleHRcbiAgICAgQGZvciBRLlVJLkNvbnRhaW5lclxuICAgICovXG4gICAgY2xlYXJTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKHJlKURyYXdzIHRoZSByb3VuZGVkUmVjdCB3aXRoIHNoYWRvdyBhbmQgYm9yZGVyIG9mIHRoZSBjb250YWluZXIuXG5cbiAgICAgQG1ldGhvZCBkcmF3UmFkaXVzXG4gICAgIEBwYXJhbSB7Y2FudmFzIGNvbnRleHR9IGN0eCAtIHRoZSBjYW52YXMgY29udGV4dFxuICAgICBAZm9yIFEuVUkuQ29udGFpbmVyXG4gICAgKi9cbiAgICBkcmF3UmFkaXVzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIFEuVUkucm91bmRSZWN0KGN0eCx0aGlzLnApO1xuICAgICAgdGhpcy5hZGRTaGFkb3coY3R4KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBpZih0aGlzLnAuYm9yZGVyKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTaGFkb3coY3R4KTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMucC5ib3JkZXI7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZHJhd1NxdWFyZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLmFkZFNoYWRvdyhjdHgpO1xuICAgICAgaWYodGhpcy5wLmZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGxSZWN0KC10aGlzLnAuY3gsLXRoaXMucC5jeSxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnAudyx0aGlzLnAuaCk7XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMucC5ib3JkZXIpIHtcbiAgICAgICAgdGhpcy5jbGVhclNoYWRvdyhjdHgpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5wLmJvcmRlcjtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoLXRoaXMucC5jeCwtdGhpcy5wLmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wLncsdGhpcy5wLmgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmKHRoaXMucC5oaWRkZW4pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZighdGhpcy5wLmJvcmRlciAmJiAhdGhpcy5wLmZpbGwpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMucC5vcGFjaXR5O1xuICAgICAgaWYodGhpcy5wLmZyYW1lID09PSAxICYmIHRoaXMucC5oaWdobGlnaHQpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMucC5oaWdobGlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wLmZpbGw7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnAuc3Ryb2tlO1xuXG4gICAgICBpZih0aGlzLnAucmFkaXVzID4gMCkge1xuICAgICAgICB0aGlzLmRyYXdSYWRpdXMoY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZHJhd1NxdWFyZShjdHgpO1xuICAgICAgfVxuXG4gICAgfVxuICB9KTtcblxuXG4gIC8qKlxuICAgQ3JlYXRlcyBhIFRleHQtVUkgZWxlbWVudC5cblxuICAgT3B0aW9ucyBmb3IgYHBgIGFyZSB2ZXJ5IHNpbWlsYXIgdG8gdGhlIG9uZXMgZm9yIFEuU3ByaXRlLlxuXG4gICAgICogbGFiZWwgICAgICAgIC0gdGV4dCB0byBkaXNwbGF5XG4gICAgICogd2VpZ2h0ICAgICAgIC0gd2VpZ2h0IG9mIHRoZSB0ZXh0IFs4MDBdXG4gICAgICogc2l6ZSAgICAgICAgIC0gc2l6ZSBvZiB0aGUgdGV4dCBpbiBweCBbMjRdXG4gICAgICogYWxpZ24gICAgICAgIC0gaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlIHRleHQgW2xlZnRdXG4gICAgICogZmFtaWx5ICAgICAgIC0gZm9udCBmYW1pbHkgW0FyaWFsXVxuICAgICAqIGNvbG9yICAgICAgICAtIGNvbG9yIG9mIHRoZSB0ZXh0IFtibGFja11cbiAgICAgKiBvdXRsaW5lICAgICAgLSBvdXRsaW5lIGNvbG9yIG9mIHRoZSB0ZXh0IFtibGFja11cbiAgICAgKiBvdXRsaW5lV2lkdGggLSB0aGlja25lc3Mgb2YgdGhlIG91dGxpbmUgWzBdXG5cbiAgIEBjbGFzcyBRLlVJLlRleHRcbiAgIEBleHRlbmRzIFEuU3ByaXRlXG4gICBAZm9yIFEuVUlcbiAgIEBwYXJhbSB7T2JqZWN0fSBwIC0gYXMgZGVzY3JpYmVkIGFib3ZlXG4gICAqL1xuICBRLlVJLlRleHQgPSBRLlNwcml0ZS5leHRlbmQoXCJVSS5UZXh0XCIsIHtcbiAgICBpbml0OiBmdW5jdGlvbihwLGRlZmF1bHRQcm9wcykge1xuICAgICAgdGhpcy5fc3VwZXIoUS5fZGVmYXVsdHMocHx8e30sZGVmYXVsdFByb3BzKSx7XG4gICAgICAgIHR5cGU6IFEuU1BSSVRFX1VJLFxuICAgICAgICBzaXplOiAyNFxuICAgICAgfSk7XG5cbiAgICAgIC8vdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAvL3RoaXMuY3R4ID0gdGhpcy5lbC5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgIGlmKHRoaXMucC5sYWJlbCkge1xuICAgICAgICB0aGlzLmNhbGNTaXplKCk7XG4gICAgICB9XG5cbiAgICAgIC8vdGhpcy5wcmVyZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgY2FsY1NpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRGb250KFEuY3R4KTtcbiAgICAgIHRoaXMuc3BsaXRMYWJlbCA9IHRoaXMucC5sYWJlbC5zcGxpdChcIlxcblwiKTtcbiAgICAgIHZhciBtYXhMYWJlbCA9IFwiXCI7XG4gICAgICBmb3IodmFyIGkgPSAwO2kgPCB0aGlzLnNwbGl0TGFiZWwubGVuZ3RoO2krKykge1xuICAgICAgICBpZih0aGlzLnNwbGl0TGFiZWxbaV0ubGVuZ3RoID4gbWF4TGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgbWF4TGFiZWwgPSB0aGlzLnNwbGl0TGFiZWxbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1ldHJpY3MgPSBRLmN0eC5tZWFzdXJlVGV4dChtYXhMYWJlbCk7XG4gICAgICB0aGlzLnAuaCA9ICh0aGlzLnAuc2l6ZSB8fCAyNCkgKiB0aGlzLnNwbGl0TGFiZWwubGVuZ3RoICogMS4yO1xuICAgICAgdGhpcy5wLncgPSBtZXRyaWNzLndpZHRoO1xuICAgICAgdGhpcy5wLmN4ID0gdGhpcy5wLncgLyAyO1xuICAgICAgdGhpcy5wLmN5ID0gdGhpcy5wLmggLyAyO1xuICAgIH0sXG5cbiAgICBwcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYodGhpcy5wLm9sZExhYmVsID09PSB0aGlzLnAubGFiZWwpIHsgcmV0dXJuOyB9XG4gICAgICB0aGlzLnAub2xkTGFiZWwgPSB0aGlzLnAubGFiZWw7XG4gICAgICB0aGlzLmNhbGNTaXplKCk7XG4gICAgICB0aGlzLmVsLndpZHRoID0gdGhpcy5wLnc7XG4gICAgICB0aGlzLmVsLmhlaWdodCA9IHRoaXMucC5oICogNDtcbiAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLDAsdGhpcy5wLncsdGhpcy5wLmgpO1xuXG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBcIiNGRjBcIjtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsMCx0aGlzLnAudyx0aGlzLnAuaC8yKTtcbiAgICAgIHRoaXMuc2V0Rm9udCh0aGlzLmN0eCk7XG5cbiAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KHRoaXMucC5sYWJlbCwwLDApO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAvL3RoaXMucHJlcmVuZGVyKCk7XG4gICAgICBpZih0aGlzLnAub3BhY2l0eSA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgaWYodGhpcy5wLm9sZExhYmVsICE9PSB0aGlzLnAubGFiZWwpIHsgdGhpcy5jYWxjU2l6ZSgpOyB9XG5cbiAgICAgIHRoaXMuc2V0Rm9udChjdHgpO1xuICAgICAgaWYodGhpcy5wLm9wYWNpdHkgIT09IHZvaWQgMCkgeyBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLnAub3BhY2l0eTsgfVxuICAgICAgZm9yKHZhciBpID0wO2k8dGhpcy5zcGxpdExhYmVsLmxlbmd0aDtpKyspIHtcbiAgICAgICAgaWYodGhpcy5wLmFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIGlmKHRoaXMucC5vdXRsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRoaXMuc3BsaXRMYWJlbFtpXSwwLC10aGlzLnAuY3kgKyBpICogdGhpcy5wLnNpemUgKiAxLjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5zcGxpdExhYmVsW2ldLDAsLXRoaXMucC5jeSArIGkgKiB0aGlzLnAuc2l6ZSAqIDEuMik7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnAuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBpZih0aGlzLnAub3V0bGluZVdpZHRoKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0aGlzLnNwbGl0TGFiZWxbaV0sdGhpcy5wLmN4LC10aGlzLnAuY3kgKyBpICogdGhpcy5wLnNpemUgKiAxLjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5zcGxpdExhYmVsW2ldLHRoaXMucC5jeCwtdGhpcy5wLmN5ICsgaSAqIHRoaXMucC5zaXplICogMS4yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZih0aGlzLnAub3V0bGluZVdpZHRoKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0aGlzLnNwbGl0TGFiZWxbaV0sLXRoaXMucC5jeCwtdGhpcy5wLmN5ICtpICogdGhpcy5wLnNpemUgKiAxLjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5zcGxpdExhYmVsW2ldLC10aGlzLnAuY3gsLXRoaXMucC5jeSAraSAqIHRoaXMucC5zaXplICogMS4yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgUmV0dXJucyB0aGUgYXNzZXQgb2YgdGhlIGVsZW1lbnRcblxuICAgICBAbWV0aG9kIGFzc2V0XG4gICAgIEBmb3IgUS5VSS5UZXh0XG4gICAgKi9cbiAgICBhc3NldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFNldHMgdGhlIHRleHRmb250IHVzaW5nIHBhcmFtZXRlcnMgb2YgYHBgLlxuICAgICBEZWZhdWx0czogc2VlIENsYXNzIGRlc2NyaXB0aW9uIVxuXG4gICAgIEBtZXRob2Qgc2V0Rm9udFxuICAgICBAZm9yIFEuVUkuVGV4dFxuICAgICovXG4gICAgc2V0Rm9udDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgICAgIGN0eC5mb250PSB0aGlzLmZvbnQoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnAuY29sb3IgfHwgXCJibGFja1wiO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMucC5hbGlnbiB8fCBcImxlZnRcIjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMucC5vdXRsaW5lQ29sb3IgfHwgXCJibGFja1wiO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMucC5vdXRsaW5lV2lkdGggfHwgMDtcbiAgICB9LFxuXG4gICAgZm9udDogZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLmZvbnRTdHJpbmcpIHsgcmV0dXJuIHRoaXMuZm9udFN0cmluZzsgfVxuXG4gICAgICB0aGlzLmZvbnRTdHJpbmcgPSAodGhpcy5wLndlaWdodCB8fCBcIjgwMFwiKSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnAuc2l6ZSB8fCAyNCkgKyBcInB4IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnAuZmFtaWx5IHx8IFwiQXJpYWxcIik7XG5cbiAgICAgIHJldHVybiB0aGlzLmZvbnRTdHJpbmc7XG4gICAgfVxuXG4gIH0pO1xuXG5cbiAgLyoqXG4gICBDcmVhdGVzIGEgQnV0dG9uLVVJIGVsZW1lbnQgdGhhdCBjYW4gYmUgcHJlc3NlZC90b3VjaGVkLlxuICAgV2hlbiBgdG91Y2hgIHN0YXJ0cywgaXQgaXMgaGlnaGxpZ2h0ZWQuXG4gICBXaGVuIGB0b3VjaEVuZGAgaXMgdHJpZ2dlcmVkLCB0aGUgYnV0dG9uIGNhbGxzIHRoZSBgY2FsbGJhY2tgIGZ1bmN0aW9uIGFuZCB0cmlnZ2VycyBhIGBjbGlja2AgZXZlbnQuXG4gICBDYW4gYmUgZ2l2ZW4gYSBga2V5QWN0aW9uTmFtZWAuIElmIHNvLCB0aGUgYnV0dG9uIGxpc3RlbnMgZm9yIGBrZXlkb3duYC10cmlnZ2VycyBvZiB0aGlzIGtleS5cblxuICAgT3B0aW9ucyBmb3IgYHBgIGFyZSB2ZXJ5IHNpbWlsYXIgdG8gdGhlIG9uZXMgZm9yIFEuVUkuQ29udGFpbmVyIGFuZCBRLlVJLlRleHQuXG5cbiAgICAgKiBsYWJlbCAgICAgICAgIC0gdGV4dCB0byBkaXNwbGF5XG4gICAgICoga2V5QWN0aW9uTmFtZSAtIF9zZWUgYWJvdmVfXG4gICAgICogZm9udCAgICAgICAgICAtIGZvbnQgZm9yIHRleHQgW3dlaWd0aDogNDAwLCBzaXplOiAyNHB4LCBmYW1pbHk6IGFyaWFsXVxuXG4gICBAY2xhc3MgUS5VSS5CdXR0b25cbiAgIEBleHRlbmRzIFEuQ29udGFpbmVyXG4gICBAZm9yIFEuVUlcbiAgIEBwYXJhbSB7T2JqZWN0fSBwIC0gYXMgZGVzY3JpYmVkIGFib3ZlXG4gICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgcHVzaGAgb3IgYHRvdWNoYFxuICAgQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRQcm9wcyAtIGNvdWxkIGJlIHVzZWQgdG8gb3ZlcndyaXRlIGRlZmF1bHQgcHJvcGVydGllcywgb3RoZXJ3aXNlIHVzZXMgdGhlIG9uZXMgb2YgUS5TcHJpdGVcbiAgICovXG4gIFEuVUkuQnV0dG9uID0gUS5VSS5Db250YWluZXIuZXh0ZW5kKFwiVUkuQnV0dG9uXCIsIHtcbiAgICBpbml0OiBmdW5jdGlvbihwLCBjYWxsYmFjaywgZGVmYXVsdFByb3BzKSB7XG4gICAgICB0aGlzLl9zdXBlcihRLl9kZWZhdWx0cyhwfHx7fSxkZWZhdWx0UHJvcHMpLHtcbiAgICAgICAgdHlwZTogUS5TUFJJVEVfVUkgfCBRLlNQUklURV9ERUZBVUxULFxuICAgICAgICBrZXlBY3Rpb25OYW1lOiBudWxsXG4gICAgICB9KTtcbiAgICAgIGlmKHRoaXMucC5sYWJlbCAmJiAoIXRoaXMucC53IHx8ICF0aGlzLnAuaCkpIHtcbiAgICAgICAgUS5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLnNldEZvbnQoUS5jdHgpO1xuICAgICAgICB2YXIgbWV0cmljcyA9IFEuY3R4Lm1lYXN1cmVUZXh0KHRoaXMucC5sYWJlbCk7XG4gICAgICAgIFEuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgaWYoIXRoaXMucC5oKSB7ICB0aGlzLnAuaCA9IDI0ICsgMjA7IH1cbiAgICAgICAgaWYoIXRoaXMucC53KSB7IHRoaXMucC53ID0gbWV0cmljcy53aWR0aCArIDIwOyB9XG4gICAgICB9XG5cbiAgICAgIGlmKGlzTmFOKHRoaXMucC5jeCkpIHsgdGhpcy5wLmN4ID0gdGhpcy5wLncgLyAyOyB9XG4gICAgICBpZihpc05hTih0aGlzLnAuY3kpKSB7IHRoaXMucC5jeSA9IHRoaXMucC5oIC8gMjsgfVxuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5vbigndG91Y2gnLHRoaXMsXCJoaWdobGlnaHRcIik7XG4gICAgICB0aGlzLm9uKCd0b3VjaEVuZCcsdGhpcyxcInB1c2hcIik7XG4gICAgICBpZih0aGlzLnAua2V5QWN0aW9uTmFtZSkge1xuICAgICAgICBRLmlucHV0Lm9uKHRoaXMucC5rZXlBY3Rpb25OYW1lLHRoaXMsXCJwdXNoXCIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYodHlwZW9mIHRoaXMuc2hlZXQoKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5zaGVldCgpLmZyYW1lcyA+IDEpIHtcbiAgICAgICAgdGhpcy5wLmZyYW1lID0gMTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVzaDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnAuZnJhbWUgPSAwO1xuICAgICAgaWYodGhpcy5jYWxsYmFjaykgeyB0aGlzLmNhbGxiYWNrKCk7IH1cbiAgICAgIHRoaXMudHJpZ2dlcignY2xpY2snKTtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9zdXBlcihjdHgpO1xuXG4gICAgICBpZih0aGlzLnAuYXNzZXQgfHwgdGhpcy5wLnNoZWV0KSB7XG4gICAgICAgIFEuU3ByaXRlLnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcyxjdHgpO1xuICAgICAgfVxuXG4gICAgICBpZih0aGlzLnAubGFiZWwpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5zZXRGb250KGN0eCk7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnAubGFiZWwsMCwwKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIFNldHMgdGhlIHRleHRmb250IHVzaW5nIHBhcmFtZXRlcnMgb2YgYHBgLlxuICAgICBEZWZhdWx0czogc2VlIENsYXNzIGRlc2NyaXB0aW9uIVxuXG4gICAgIEBtZXRob2Qgc2V0Rm9udFxuICAgICBAZm9yIFEuVUkuQnV0dG9uXG4gICAgKi9cbiAgICBzZXRGb250OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgY3R4LmZvbnQgPSB0aGlzLnAuZm9udCB8fCBcIjQwMCAyNHB4IGFyaWFsXCI7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5wLmZvbnRDb2xvciB8fCBcImJsYWNrXCI7XG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLyoqXG4gICBDcmVhdGVzIGEgaHRtbC1pZnJhbWUgaW4gdGhlIGh0bWwtZG9jdW1lbnQuXG4gICBJdCBoYXMgYWxsIG90aGVyIGNhcGFiaWxpdGllcyBvZiBRLlNwcml0ZS5cbiAgIChkZWZhdWx0KSBQcm9wZXJ0aWVzIG9mIHRoZSBodG1sLWVsZW1lbnQ6XG5cbiAgICAgKiBzdHlsZS5wb3NpdGlvbjogYWJvc2x1dGVcbiAgICAgKiBzdHlsZS56SW5kZXg6IDUwMFxuICAgICAqIEF0dHJpYnV0ZSBmcmFtZWJvcmRlcjogMFxuXG4gICBPcHRpb25zIHZpYSBgcGA6XG5cbiAgICAgKiB1cmwgLSBzcmMgZm9yIGlmcmFtZVxuICAgICAqIHcgICAtIHdpZHRoIG9mIHRoZSBpZnJhbWVcbiAgICAgKiBoICAgLSBoZWlnaHQgb2YgdGhlIGlmcmFtZVxuXG4gICBAY2xhc3MgUS5VSS5JRnJhbWVcbiAgIEBleHRlbmRzIFEuU3ByaXRlXG4gICBAZm9yIFEuVUlcbiAgICovXG4gIFEuVUkuSUZyYW1lID0gUS5TcHJpdGUuZXh0ZW5kKFwiVUkuSUZyYW1lXCIsIHtcbiAgICBpbml0OiBmdW5jdGlvbihwKSB7XG4gICAgICB0aGlzLl9zdXBlcihwLCB7IG9wYWNpdHk6IDEsIHR5cGU6IFEuU1BSSVRFX1VJIHwgUS5TUFJJVEVfREVGQVVMVCB9KTtcblxuICAgICAgUS53cmFwcGVyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblxuICAgICAgdGhpcy5pZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSUZSQU1FXCIpO1xuICAgICAgdGhpcy5pZnJhbWUuc2V0QXR0cmlidXRlKFwic3JjXCIsdGhpcy5wLnVybCk7XG4gICAgICB0aGlzLmlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLnpJbmRleCA9IDUwMDtcbiAgICAgIHRoaXMuaWZyYW1lLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsdGhpcy5wLncpO1xuICAgICAgdGhpcy5pZnJhbWUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsdGhpcy5wLmgpO1xuICAgICAgdGhpcy5pZnJhbWUuc2V0QXR0cmlidXRlKFwiZnJhbWVib3JkZXJcIiwwKTtcblxuICAgICAgaWYodGhpcy5wLmJhY2tncm91bmQpIHtcbiAgICAgICAgdGhpcy5pZnJhbWUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5wLmJhY2tncm91bmQ7XG4gICAgICB9XG5cbiAgICAgIFEud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmlmcmFtZSk7XG4gICAgICB0aGlzLm9uKFwiaW5zZXJ0ZWRcIixmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbklGcmFtZSgpO1xuICAgICAgICBwYXJlbnQub24oXCJkZXN0cm95ZWRcIix0aGlzLFwicmVtb3ZlXCIpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHBvc2l0aW9uSUZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gdGhpcy5wLng7XG4gICAgICB2YXIgeSA9IHRoaXMucC55O1xuICAgICAgaWYodGhpcy5zdGFnZS52aWV3cG9ydCkge1xuICAgICAgICB4IC09IHRoaXMuc3RhZ2Uudmlld3BvcnQueDtcbiAgICAgICAgeSAtPSB0aGlzLnN0YWdlLnZpZXdwb3J0Lnk7XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMub2xkWCAhPT0geCB8fCB0aGlzLm9sZFkgIT09IHkgfHwgdGhpcy5vbGRPcGFjaXR5ICE9PSB0aGlzLnAub3BhY2l0eSkge1xuXG4gICAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLnRvcCA9ICh5IC0gdGhpcy5wLmN5KSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5pZnJhbWUuc3R5bGUubGVmdCA9ICh4IC0gdGhpcy5wLmN4KSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5pZnJhbWUuc3R5bGUub3BhY2l0eSA9IHRoaXMucC5vcGFjaXR5O1xuXG4gICAgICAgIHRoaXMub2xkWCA9IHg7XG4gICAgICAgIHRoaXMub2xkWSA9IHk7XG4gICAgICAgIHRoaXMub2xkT3BhY2l0eSA9IHRoaXMucC5vcGFjaXR5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGVwOiBmdW5jdGlvbihkdCkge1xuICAgICAgdGhpcy5fc3VwZXIoZHQpO1xuICAgICAgdGhpcy5wb3NpdGlvbklGcmFtZSgpO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYodGhpcy5pZnJhbWUpIHtcbiAgICAgICAgUS53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuaWZyYW1lKTtcbiAgICAgICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICBDcmVhdGVzIGEgZGl2LUhlbGVtZW50IGluIHRoZSBodG1sLWRvY3VtZW50IHdpdGggZ2l2ZW4gaW5uZXJIVE1MLlxuICAgSXQgaGFzIGFsbCBvdGhlciBjYXBhYmlsaXRpZXMgb2YgUS5TcHJpdGUuXG5cbiAgIE9wdGlvbiB2aWEgYHBgOlxuXG4gICAgICogaHRtbCAtIGlubmVySFRNTCBvZiB0aGUgZGl2XG5cbiAgIEBjbGFzcyBRLlVJLkhUTUxFbGVtZW50XG4gICBAZXh0ZW5kcyBRLlNwcml0ZVxuICAgQGZvciBRLlVJXG4gICAqL1xuICBRLlVJLkhUTUxFbGVtZW50ID0gUS5TcHJpdGUuZXh0ZW5kKFwiVUkuSFRNTEVsZW1lbnRcIiwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgIHRoaXMuX3N1cGVyKHAsIHsgb3BhY2l0eTogMSwgdHlwZTogUS5TUFJJVEVfVUkgIH0pO1xuXG4gICAgICBRLndyYXBwZXIuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXG4gICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gdGhpcy5wLmh0bWw7XG5cbiAgICAgIFEud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICAgIHRoaXMub24oXCJpbnNlcnRlZFwiLGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgIHBhcmVudC5vbihcImRlc3Ryb3llZFwiLHRoaXMsXCJyZW1vdmVcIik7XG4gICAgICAgIHBhcmVudC5vbihcImNsZWFyXCIsdGhpcyxcInJlbW92ZVwiKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgfSxcblxuICAgIHN0ZXA6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICB0aGlzLl9zdXBlcihkdCk7XG4gICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLmVsKSB7XG4gICAgICAgIFEud3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5lbD0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIFEuVUkuVmVydGljYWxMYXlvdXQgPSBRLlNwcml0ZS5leHRlbmQoXCJVSS5WZXJ0aWNhbExheW91dFwiLHtcblxuXG4gICAgaW5pdDogZnVuY3Rpb24ocCkge1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy5fc3VwZXIocCwgeyB0eXBlOiAwIH0pO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKHNwcml0ZSkge1xuICAgICAgdGhpcy5zdGFnZS5pbnNlcnQoc3ByaXRlLHRoaXMpO1xuICAgICAgdGhpcy5yZWxheW91dCgpO1xuICAgICAgLy8gQmluZCB0byBkZXN0cm95XG4gICAgICByZXR1cm4gc3ByaXRlO1xuICAgIH0sXG5cbiAgICByZWxheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuICAgICAgZm9yKHZhciBpPTA7aTx0aGlzLmNoaWxkcmVuLmxlbmd0aDtpKyspIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gdGhpcy5jaGlsZHJlbltpXS5wLmggfHwgMDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2VudGVyP1xuICAgICAgdmFyIHRvdGFsU2VwYXJ0aW9uID0gdGhpcy5wLmggLSB0b3RhbEhlaWdodDtcblxuICAgICAgLy8gTWFrZSBzdXJlIGFsbCBlbGVtZW50cyBoYXZlIHRoZSBzYW1lIHNwYWNlIGJldHdlZW4gdGhlbVxuICAgIH1cbiAgfSk7XG5cblxuXG59O1xuIiwiLyogc29ja2pzLWNsaWVudCB2MS4zLjAgfCBodHRwOi8vc29ja2pzLm9yZyB8IE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5Tb2NrSlMgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHRyYW5zcG9ydExpc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1saXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJykodHJhbnNwb3J0TGlzdCk7XG5cbi8vIFRPRE8gY2FuJ3QgZ2V0IHJpZCBvZiB0aGlzIHVudGlsIGFsbCBzZXJ2ZXJzIGRvXG5pZiAoJ19zb2NranNfb25sb2FkJyBpbiBnbG9iYWwpIHtcbiAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL21haW5cIjoxNCxcIi4vdHJhbnNwb3J0LWxpc3RcIjoxNn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnY2xvc2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gIHRoaXMuY29kZSA9IDA7XG4gIHRoaXMucmVhc29uID0gJyc7XG59XG5cbmluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9zZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50dGFyZ2V0JylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKHR5cGUsIGcpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICBmb3IgKHZhciBhaSA9IDE7IGFpIDwgbDsgYWkrKykge1xuICAgIGFyZ3NbYWkgLSAxXSA9IGFyZ3VtZW50c1thaV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxufSx7XCIuL2V2ZW50dGFyZ2V0XCI6NSxcImluaGVyaXRzXCI6NTd9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRXZlbnQoZXZlbnRUeXBlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbn1cblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgdGhpcy5idWJibGVzID0gY2FuQnViYmxlO1xuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICB0aGlzLnRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbZXZlbnRdIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XG4gIC8vIHRoZWlyIHBsYWNlIGluIGxpbmUgZnJvbSB0aGUgL2ZpcnN0LyB0aW1lIHRoZXkncmUgc2V0IGZyb21cbiAgLy8gbm9uLW51bGwuIEFsdGhvdWdoIFdlYktpdCBidW1wcyBpdCB0byB0aGUgZW5kIGV2ZXJ5IHRpbWUgaXQnc1xuICAvLyBzZXQuXG4gIGlmICh0aGlzWydvbicgKyB0XSkge1xuICAgIHRoaXNbJ29uJyArIHRdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGlmICh0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgIC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gdGhlIGxpc3RlbmVycyBsaXN0LiByZW1vdmVFdmVudExpc3RlbmVyIG1heSBhbHRlciB0aGUgbGlzdC5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5pbmhlcml0cyhUcmFuc3BvcnRNZXNzYWdlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgO1xuXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcbiAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG59XG5cbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ2MnLCBKU09OMy5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgndCcsIGZyYW1lKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGRhdGEpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjYWRlSlM7XG5cbn0se1wiLi91dGlscy9pZnJhbWVcIjo0NyxcImpzb24zXCI6NTh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRmFjYWRlSlMgPSByZXF1aXJlKCcuL2ZhY2FkZScpXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppZnJhbWUtYm9vdHN0cmFwJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHZhciB0cmFuc3BvcnRNYXAgPSB7fTtcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XG4gICAgaWYgKGF0LmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0TWFwW2F0LmZhY2FkZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lXSA9IGF0LmZhY2FkZVRyYW5zcG9ydDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxuICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICB0cmFuc3BvcnRNYXBbSW5mb0lmcmFtZVJlY2VpdmVyLnRyYW5zcG9ydE5hbWVdID0gSW5mb0lmcmFtZVJlY2VpdmVyO1xuICB2YXIgcGFyZW50T3JpZ2luO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgdmFyIGZhY2FkZTtcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuc291cmNlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRPcmlnaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKGUub3JpZ2luICE9PSBwYXJlbnRPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0cmFuc1VybCwgbG9jLmhyZWYpIHx8XG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vZmFjYWRlXCI6NyxcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vbG9jYXRpb25cIjoxMyxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xufVxuXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdHRVQnLCB1cmwpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgdmFyIGluZm8sIHJ0dDtcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJ0dCA9ICgrbmV3IERhdGUoKSkgLSB0MDtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5mbyA9IEpTT04zLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi91dGlscy9vYmplY3RcIjo0OSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcklmcmFtZSh0cmFuc1VybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBzZWxmLmlyID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBKU09OMy5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvaWZyYW1lJylcbiAgLCBJbmZvUmVjZWl2ZXJJZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8taWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcblxuICAgIGlmci5vbmNlKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQgPSBKU09OMy5wYXJzZShtc2cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgbXNnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IGRbMF0sIHJ0dCA9IGRbMV07XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmci5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPIHRoaXMgc2VlbXMgdGhlIHNhbWUgYXMgdGhlICduZWVkQm9keScgZnJvbSB0cmFuc3BvcnRzXG4gIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcbiAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgfSBlbHNlIHtcbiAgICBnbygpO1xuICB9XG59XG5cbmluaGVyaXRzKEluZm9JZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9JZnJhbWUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbn07XG5cbkluZm9JZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlmcikge1xuICAgIHRoaXMuaWZyLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5pZnIgPSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvSWZyYW1lO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL3RyYW5zcG9ydC9pZnJhbWVcIjoyMixcIi4vdXRpbHMvZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL2luZm8taWZyYW1lXCI6MTEsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGRyXCI6MzQsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZVwiOjM2LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICBvcmlnaW46ICdodHRwOi8vbG9jYWxob3N0OjgwJ1xuLCBwcm90b2NvbDogJ2h0dHA6J1xuLCBob3N0OiAnbG9jYWxob3N0J1xuLCBwb3J0OiA4MFxuLCBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nXG4sIGhhc2g6ICcnXG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbXMnKTtcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi91dGlscy9yYW5kb20nKVxuICAsIGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi91dGlscy90cmFuc3BvcnQnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXInKVxuICAsIGxvZyA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnQnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudHRhcmdldCcpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gICwgQ2xvc2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvY2xvc2UnKVxuICAsIFRyYW5zcG9ydE1lc3NhZ2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvdHJhbnMtbWVzc2FnZScpXG4gICwgSW5mb1JlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50Om1haW4nKTtcbn1cblxudmFyIHRyYW5zcG9ydHM7XG5cbi8vIGZvbGxvdyBjb25zdHJ1Y3RvciBzdGVwcyBkZWZpbmVkIGF0IGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnNvY2tldHMvI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG5mdW5jdGlvbiBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tKUykpIHtcbiAgICByZXR1cm4gbmV3IFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1NvY2tKUzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50XCIpO1xuICB9XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNPTk5FQ1RJTkc7XG4gIHRoaXMuZXh0ZW5zaW9ucyA9ICcnO1xuICB0aGlzLnByb3RvY29sID0gJyc7XG5cbiAgLy8gbm9uLXN0YW5kYXJkIGV4dGVuc2lvblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMucHJvdG9jb2xzX3doaXRlbGlzdCkge1xuICAgIGxvZy53YXJuKFwiJ3Byb3RvY29sc193aGl0ZWxpc3QnIGlzIERFUFJFQ0FURUQuIFVzZSAndHJhbnNwb3J0cycgaW5zdGVhZC5cIik7XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCA9IG9wdGlvbnMudHJhbnNwb3J0cztcbiAgdGhpcy5fdHJhbnNwb3J0T3B0aW9ucyA9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc2Vzc2lvbklkID0gb3B0aW9ucy5zZXNzaW9uSWQgfHwgODtcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tLnN0cmluZyhzZXNzaW9uSWQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgc2Vzc2lvbklkIGlzIHVzZWQgaW4gdGhlIG9wdGlvbnMsIGl0IG5lZWRzIHRvIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlciB8fCByYW5kb20ubnVtYmVyU3RyaW5nKDEwMDApO1xuXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XG4gIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmICghcGFyc2VkVXJsLmhvc3QgfHwgIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgbXVzdCBub3QgY29udGFpbiBhIGZyYWdtZW50Jyk7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH1cblxuICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgLy8gU3RlcCAyIC0gZG9uJ3QgYWxsb3cgc2VjdXJlIG9yaWdpbiB3aXRoIGFuIGluc2VjdXJlIHByb3RvY29sXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonICYmICFzZWN1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gIH1cblxuICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAvLyBTdGVwIDQgLSBwYXJzZSBwcm90b2NvbHMgYXJndW1lbnRcbiAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gIH1cblxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcbiAgdmFyIHNvcnRlZFByb3RvY29scyA9IHByb3RvY29scy5zb3J0KCk7XG4gIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvLCBpKSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGR1cGxpY2F0ZWQuXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RlcCA2IC0gY29udmVydCBvcmlnaW5cbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xuICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXG4gIHBhcnNlZFVybC5zZXQoJ3BhdGhuYW1lJywgcGFyc2VkVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpKTtcblxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICBkZWJ1ZygndXNpbmcgdXJsJywgdGhpcy51cmwpO1xuXG4gIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAvLyBvYnRhaW4gc2VydmVyIGluZm9cbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcbiAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICBudWxsT3JpZ2luOiAhYnJvd3Nlci5oYXNEb21haW4oKVxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICAsIHNhbWVTY2hlbWU6IHVybFV0aWxzLmlzU2NoZW1lRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICB9O1xuXG4gIHRoaXMuX2lyID0gbmV3IEluZm9SZWNlaXZlcih0aGlzLnVybCwgdGhpcy5fdXJsSW5mbyk7XG4gIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xufVxuXG5pbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcblxuZnVuY3Rpb24gdXNlclNldENvZGUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgLy8gU3RlcCAxXG4gIGlmIChjb2RlICYmICF1c2VyU2V0Q29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yOiBJbnZhbGlkIGNvZGUnKTtcbiAgfVxuICAvLyBTdGVwIDIuNCBzdGF0ZXMgdGhlIG1heCBpcyAxMjMgYnl0ZXMsIGJ1dCB3ZSBhcmUganVzdCBjaGVja2luZyBsZW5ndGhcbiAgaWYgKHJlYXNvbiAmJiByZWFzb24ubGVuZ3RoID4gMTIzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cblxuICAvLyBTdGVwIDMuMVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XG4gIHRoaXMuX2Nsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8ICdOb3JtYWwgY2xvc3VyZScsIHdhc0NsZWFuKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gIzEzIC0gY29udmVydCBhbnl0aGluZyBub24tc3RyaW5nIHRvIHN0cmluZ1xuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgeWV0Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbn07XG5cblNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9yZWNlaXZlSW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgdGhpcy5faXIgPSBudWxsO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAvLyByb3VuZC10cmlwIHRpbWUgKFJUVClcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xuICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gIHRoaXMuX3RyYW5zVXJsID0gaW5mby5iYXNlX3VybCA/IGluZm8uYmFzZV91cmwgOiB0aGlzLnVybDtcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcbiAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgLy8gZGV0ZXJtaW5lIGxpc3Qgb2YgZGVzaXJlZCBhbmQgc3VwcG9ydGVkIHRyYW5zcG9ydHNcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XG4gIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICBkZWJ1Zyh0aGlzLl90cmFuc3BvcnRzLmxlbmd0aCArICcgZW5hYmxlZCB0cmFuc3BvcnRzJyk7XG5cbiAgdGhpcy5fY29ubmVjdCgpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCk7IFRyYW5zcG9ydDsgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpKSB7XG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgaWYgKFRyYW5zcG9ydC5uZWVkQm9keSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHMudW5zaGlmdChUcmFuc3BvcnQpO1xuICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgdGhpcy5fY29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICB2YXIgdGltZW91dE1zID0gKHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzKSB8fCA1MDAwO1xuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xuICAgIGRlYnVnKCd1c2luZyB0aW1lb3V0JywgdGltZW91dE1zKTtcblxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3RyYW5zcG9ydE9wdGlvbnNbVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdO1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgdXJsJywgdHJhbnNwb3J0VXJsKTtcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsLCBvcHRpb25zKTtcbiAgICB0cmFuc3BvcnRPYmoub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai5vbmNlKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0T2JqO1xuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2Nsb3NlKDIwMDAsICdBbGwgdHJhbnNwb3J0cyBmYWlsZWQnLCBmYWxzZSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRNZXNzYWdlJywgbXNnKTtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gbXNnLnNsaWNlKDAsIDEpXG4gICAgLCBjb250ZW50ID0gbXNnLnNsaWNlKDEpXG4gICAgLCBwYXlsb2FkXG4gICAgO1xuXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgdGhpcy5fb3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xuICAgICAgZGVidWcoJ2hlYXJ0YmVhdCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQgPSBKU09OMy5wYXJzZShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVidWcoJ2VtcHR5IHBheWxvYWQnLCBjb250ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBzZWxmLnRyYW5zcG9ydCwgcCk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCB0aGlzLnRyYW5zcG9ydCwgcGF5bG9hZCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0Q2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXNlclNldENvZGUoY29kZSkgJiYgY29kZSAhPT0gMjAwMCAmJiB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhpcy5fY29ubmVjdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2Nsb3NlKGNvZGUsIHJlYXNvbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfb3BlbicsIHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpO1xuICAgIGRlYnVnKCdjb25uZWN0ZWQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHNlcnZlciBtaWdodCBoYXZlIGJlZW4gcmVzdGFydGVkLCBhbmQgbG9zdCB0cmFjayBvZiBvdXJcbiAgICAvLyBjb25uZWN0aW9uLlxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4sIHRoaXMucmVhZHlTdGF0ZSk7XG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcblxuICBpZiAodGhpcy5faXIpIHtcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xuICAgIHRoaXMuX2lyLmNsb3NlKCk7XG4gICAgdGhpcy5faXIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBTb2NrSlMgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQnKTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TSU5HO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TRUQ7XG5cbiAgICBpZiAoZm9yY2VGYWlsKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKTtcbiAgICB9XG5cbiAgICB2YXIgZSA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpO1xuICAgIGUud2FzQ2xlYW4gPSB3YXNDbGVhbiB8fCBmYWxzZTtcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XG4gICAgZS5yZWFzb24gPSByZWFzb247XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgdGhpcy5vbm1lc3NhZ2UgPSB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIGRlYnVnKCdkaXNjb25uZWN0ZWQnKTtcbiAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cblNvY2tKUy5wcm90b3R5cGUuY291bnRSVE8gPSBmdW5jdGlvbihydHQpIHtcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxuICAvLyB0cmFuc3BvcnQgdGhlIHRpbWUgbmVlZGVkIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gKHRoZSB0aW1lIHRoYXQgcGFzc1xuICAvLyBmcm9tIHRoZSBvcGVuaW5nIG9mIHRoZSB0cmFuc3BvcnQgdG8gdGhlIGNhbGwgb2YgYF9kaXNwYXRjaE9wZW5gKSBpc1xuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXG4gIC8vIGNhdXNlcyBzcHVyaW91cyB0aW1lb3V0cy4gRm9yIHRoaXMgcmVhc29uIHdlIGNhbGN1bGF0ZSBhIHZhbHVlIHNsaWdodGx5XG4gIC8vIGxhcmdlciB0aGFuIHRoYXQgdXNlZCBpbiB0aGUgYXJ0aWNsZS5cbiAgaWYgKHJ0dCA+IDEwMCkge1xuICAgIHJldHVybiA0ICogcnR0OyAvLyBydG8gPiA0MDBtc2VjXG4gIH1cbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdHJhbnNwb3J0cyA9IHRyYW5zcG9ydChhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmVxdWlyZSgnLi9pZnJhbWUtYm9vdHN0cmFwJykoU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmV0dXJuIFNvY2tKUztcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vZXZlbnQvY2xvc2VcIjoyLFwiLi9ldmVudC9ldmVudFwiOjQsXCIuL2V2ZW50L2V2ZW50dGFyZ2V0XCI6NSxcIi4vZXZlbnQvdHJhbnMtbWVzc2FnZVwiOjYsXCIuL2lmcmFtZS1ib290c3RyYXBcIjo4LFwiLi9pbmZvLXJlY2VpdmVyXCI6MTIsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3NoaW1zXCI6MTUsXCIuL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vdXRpbHMvZXNjYXBlXCI6NDUsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2xvZ1wiOjQ4LFwiLi91dGlscy9vYmplY3RcIjo0OSxcIi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuL3V0aWxzL3RyYW5zcG9ydFwiOjUxLFwiLi91dGlscy91cmxcIjo1MixcIi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4LFwidXJsLXBhcnNlXCI6NjF9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoganNjczogZGlzYWJsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBwdWxsZWQgc3BlY2lmaWMgc2hpbXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbnZhciBhcnJheV9zbGljZSA9IEFycmF5UHJvdG90eXBlLnNsaWNlO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxudmFyIGRlZmluZVByb3BlcnR5O1xuaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbn1cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdChvKTtcbn07XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gICAgdmFyIG4gPSArbnVtO1xuICAgIGlmIChuICE9PSBuKSB7IC8vIGlzTmFOXG4gICAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgcmV0dXJuIHggPj4+IDA7XG59XG5cbi8vXG4vLyBGdW5jdGlvblxuLy8gPT09PT09PT1cbi8vXG5cbi8vIEVTLTUgMTUuMy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbmZ1bmN0aW9uIEVtcHR5KCkge31cblxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4xIFtbQ2FsbF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyAgIG9mIHRhcmdldCBwcm92aWRpbmcgYm91bmRUaGlzIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cbiAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAvLyAgICAgICBsYXJnZXIuXG4gICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbn0pO1xuXG4vL1xuLy8gQXJyYXlcbi8vID09PT09XG4vL1xuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cblxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICB9LCAneCcpO1xuICAgIH1cbiAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSB0b0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc291Z2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vXG4vLyBTdHJpbmdcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XG5pZiAoXG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcbiAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4pIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHZvaWQgMDsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSAgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5leHRlbmRlZCAgID8gJ3gnIDogJycpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvci5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHZvaWQgMCA/XG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgICAgVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5UHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbi8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG52YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyBzdHJlYW1pbmcgdHJhbnNwb3J0c1xuICByZXF1aXJlKCcuL3RyYW5zcG9ydC93ZWJzb2NrZXQnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcblxuICAvLyBwb2xsaW5nIHRyYW5zcG9ydHNcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZycpXG5dO1xuXG59LHtcIi4vdHJhbnNwb3J0L2V2ZW50c291cmNlXCI6MjAsXCIuL3RyYW5zcG9ydC9odG1sZmlsZVwiOjIxLFwiLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZ1wiOjIzLFwiLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwXCI6MjYsXCIuL3RyYW5zcG9ydC93ZWJzb2NrZXRcIjozOCxcIi4vdHJhbnNwb3J0L3hkci1wb2xsaW5nXCI6MzksXCIuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nXCI6NDAsXCIuL3RyYW5zcG9ydC94aHItcG9sbGluZ1wiOjQxLFwiLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZ1wiOjQyfV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgWEhSID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0XG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xufVxuXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoQWJzdHJhY3RYSFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLnhociA9IG5ldyBYSFIoKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxuXG4gIGlmICghdGhpcy54aHIpIHtcbiAgICBkZWJ1Zygnbm8geGhyJyk7XG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnbm8geGhyIHN1cHBvcnQnKTtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBicm93c2VycyBjYWNoZSBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgLy8gdGFiIGdldHMgY2xvc2VkOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC81MjgwXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQgY2xlYW51cCcpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIHRoaXMueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XG4gICAgICB0aGlzLnhoci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgdGhpcy54aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcbiAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCghb3B0cyB8fCAhb3B0cy5ub0NyZWRlbnRpYWxzKSAmJiBBYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMpIHtcbiAgICBkZWJ1Zygnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxuICAgIC8vIFwiVGhpcyBuZXZlciBhZmZlY3RzIHNhbWUtc2l0ZSByZXF1ZXN0cy5cIlxuXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0cy5oZWFkZXJzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnhocikge1xuICAgICAgdmFyIHggPSBzZWxmLnhocjtcbiAgICAgIHZhciB0ZXh0LCBzdGF0dXM7XG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcbiAgICAgICAgLy8gb24gTWljcm9zb2Z0LlhNTEhUVFAgYW5kIHJlYWR5c3RhdGU9M1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgIHRleHQgPSB4LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGRvZXMgcmV0dXJuIHJlYWR5c3RhdGUgPT0gMyBmb3IgNDA0IGFuc3dlcnMuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlYnVnKCdjaHVuaycpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnY2h1bmsnLCBzdGF0dXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XG4gICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzODM3NzAodj12cy44NSkuYXNweFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjAwNSB8fCBzdGF0dXMgPT09IDEyMDI5KSB7XG4gICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfVxufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgaWYgKCF0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuICBpZiAodGhpcy54aHIub250aW1lb3V0KSB7XG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhociA9IG51bGw7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XG4vLyBvdmVycmlkZSBYTUxIdHRwUmVxdWVzdCBmb3IgSUU2Lzdcbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKCFBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkICYmIChheG8gaW4gZ2xvYmFsKSkge1xuICBkZWJ1Zygnb3ZlcnJpZGluZyB4bWxodHRwcmVxdWVzdCcpO1xuICBYSFIgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbYXhvXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIEFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIW5ldyBYSFIoKTtcbn1cblxudmFyIGNvcnMgPSBmYWxzZTtcbnRyeSB7XG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XG59IGNhdGNoIChpZ25vcmVkKSB7XG4gIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbn1cblxuQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTID0gY29ycztcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFhIUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuRXZlbnRTb3VyY2U7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcml2ZXIgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5pZiAoRHJpdmVyKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gV2ViU29ja2V0QnJvd3NlckRyaXZlcih1cmwpIHtcblx0XHRyZXR1cm4gbmV3IERyaXZlcih1cmwpO1xuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvZXZlbnRzb3VyY2VcIjoyOSxcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEh0bWxmaWxlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2h0bWxmaWxlJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gIDtcblxuZnVuY3Rpb24gSHRtbEZpbGVUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9odG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIsIFhIUkxvY2FsT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoSHRtbEZpbGVUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkh0bWxGaWxlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIHJldHVybiBIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luO1xufTtcblxuSHRtbEZpbGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdodG1sZmlsZSc7XG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sRmlsZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2h0bWxmaWxlXCI6MzAsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2Vcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXG4vLyByZW1vdGUgZG9tYWluLiBOZXcgYnJvd3NlcnMgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSB1c2luZyBwb3N0TWVzc2FnZSgpLiBJbiBJRSBpdCB3YXMgaW1wbGVtZW50ZWRcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XG4vLyAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MxOTcwMTUodj1WUy44NSkuYXNweFxuLy8gICAgaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dHJhbnNwb3J0OmlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJZnJhbWVUcmFuc3BvcnQodHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCkge1xuICBpZiAoIUlmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMub3JpZ2luID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGJhc2VVcmwpO1xuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB0aGlzLnRyYW5zVXJsID0gdHJhbnNVcmw7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcblxuICB2YXIgaWZyYW1lVXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2lmcmFtZS5odG1sJykgKyAnIycgKyB0aGlzLndpbmRvd0lkO1xuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xuXG4gIHRoaXMuaWZyYW1lT2JqID0gaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lKGlmcmFtZVVybCwgZnVuY3Rpb24ocikge1xuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1VuYWJsZSB0byBsb2FkIGFuIGlmcmFtZSAoJyArIHIgKyAnKScpO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG5cbiAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuX21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xufVxuXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gICAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoZS5vcmlnaW4sIHRoaXMub3JpZ2luKSkge1xuICAgIGRlYnVnKCdub3Qgc2FtZSBvcmlnaW4nLCBlLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xuICB0cnkge1xuICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gIGNhc2UgJ3MnOlxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIC8vIHdpbmRvdyBnbG9iYWwgZGVwZW5kZW5jeVxuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ3MnLCBKU09OMy5zdHJpbmdpZnkoW1xuICAgICAgdmVyc2lvblxuICAgICwgdGhpcy50cmFuc3BvcnRcbiAgICAsIHRoaXMudHJhbnNVcmxcbiAgICAsIHRoaXMuYmFzZVVybFxuICAgIF0pKTtcbiAgICBicmVhaztcbiAgY2FzZSAndCc6XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYyc6XG4gICAgdmFyIGNkYXRhO1xuICAgIHRyeSB7XG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNkYXRhWzBdLCBjZGF0YVsxXSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcbiAgdGhpcy5pZnJhbWVPYmoucG9zdChKU09OMy5zdHJpbmdpZnkoe1xuICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICwgdHlwZTogdHlwZVxuICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgfSksIHRoaXMub3JpZ2luKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5wb3N0TWVzc2FnZSgnbScsIG1lc3NhZ2UpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUnO1xuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZVRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgc2ltcGxlc3QgYW5kIG1vc3Qgcm9idXN0IHRyYW5zcG9ydCwgdXNpbmcgdGhlIHdlbGwta25vdyBjcm9zc1xuLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbi8vIG1lc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3Rcbi8vIGV2ZXJ5d2hlcmUuXG4vLyBLbm93biBsaW1pdGF0aW9uczpcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3Jcbi8vICAgbyBmb3IgS29ucXVlcm9yIGEgZHVtYiB0aW1lciBpcyBuZWVkZWQgdG8gZGV0ZWN0IGVycm9yc1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9zZW5kZXItcmVjZWl2ZXInKVxuICAsIEpzb25wUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2pzb25wJylcbiAgLCBqc29ucFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyL2pzb25wJylcbiAgO1xuXG5mdW5jdGlvbiBKc29uUFRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUpzb25QVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsICcvanNvbnAnLCBqc29ucFNlbmRlciwgSnNvbnBSZWNlaXZlcik7XG59XG5cbmluaGVyaXRzKEpzb25QVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50O1xufTtcblxuSnNvblBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdqc29ucC1wb2xsaW5nJztcbkpzb25QVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAxO1xuSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25QVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcIi4vcmVjZWl2ZXIvanNvbnBcIjozMSxcIi4vc2VuZGVyL2pzb25wXCI6MzMsXCJpbmhlcml0c1wiOjU3fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmFqYXgtYmFzZWQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ2NyZWF0ZSBhamF4IHNlbmRlcicsIHVybCwgcGF5bG9hZCk7XG4gICAgdmFyIG9wdCA9IHt9O1xuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5oZWFkZXJzID0geydDb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbid9O1xuICAgIH1cbiAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XG4gICAgdmFyIHhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCBhamF4VXJsLCBwYXlsb2FkLCBvcHQpO1xuICAgIHhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cyk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIGlmIChzdGF0dXMgIT09IDIwMCAmJiBzdGF0dXMgIT09IDIwNCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdodHRwIHN0YXR1cyAnICsgc3RhdHVzKSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdhYm9ydCcpO1xuICAgICAgeG8uY2xvc2UoKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBBamF4QmFzZWRUcmFuc3BvcnQodHJhbnNVcmwsIHVybFN1ZmZpeCwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgdXJsU3VmZml4LCBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpLCBSZWNlaXZlciwgQWpheE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEFqYXhCYXNlZFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqYXhCYXNlZFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnVmZmVyZWQtc2VuZGVyJyk7XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkU2VuZGVyKHVybCwgc2VuZGVyKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gIHRoaXMudXJsID0gdXJsO1xufVxuXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICBpZiAoIXRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xuICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlV2FpdCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0cmVmO1xuICB0aGlzLnNlbmRTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3NlbmRTdG9wJyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICB9O1xuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XG4gIH0sIDI1KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZScsIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXlsb2FkID0gJ1snICsgdGhpcy5zZW5kQnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSB8fCAxMDA2LCAnU2VuZGluZyBlcnJvcjogJyArIGVycik7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2VuZFNjaGVkdWxlV2FpdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTdG9wKCk7XG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyZWRTZW5kZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXG4gIGZ1bmN0aW9uIElmcmFtZVdyYXBUcmFuc3BvcnQodHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgICBJZnJhbWVUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICB9XG5cbiAgaW5oZXJpdHMoSWZyYW1lV3JhcFRyYW5zcG9ydCwgSWZyYW1lVHJhbnNwb3J0KTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbih1cmwsIGluZm8pIHtcbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcbiAgICBpZnJhbWVJbmZvLnNhbWVPcmlnaW4gPSB0cnVlO1xuICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICB9O1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgKyB0cmFuc3BvcnQucm91bmRUcmlwcyAtIDE7IC8vIGh0bWwsIGphdmFzY3JpcHQgKDIpICsgdHJhbnNwb3J0IC0gbm8gQ09SUyAoMSlcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICByZXR1cm4gSWZyYW1lV3JhcFRyYW5zcG9ydDtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL29iamVjdFwiOjQ5LFwiLi4vaWZyYW1lXCI6MjIsXCJpbmhlcml0c1wiOjU3fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xufVxuXG5mdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xuICB0aGlzLkFqYXhPYmplY3QgPSBBamF4T2JqZWN0O1xuICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG59XG5cbmluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY2VpdmVyID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NoZWR1bGVSZWNlaXZlcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG5cbiAgcG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcbiAgICBzZWxmLnBvbGwgPSBwb2xsID0gbnVsbDtcblxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XG4gICAgICBpZiAocmVhc29uID09PSAnbmV0d29yaycpIHtcbiAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUgfHwgMTAwNiwgcmVhc29uKTtcbiAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMucG9sbElzQ2xvc2luZyA9IHRydWU7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcbiAgLCBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gIGRlYnVnKHBvbGxVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcbiAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ3BvbGwgbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG4gIHRoaXMucG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLnBvbGwgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFNlbmRlclJlY2VpdmVyLCBCdWZmZXJlZFNlbmRlcik7XG5cblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBCdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgICB0aGlzLnBvbGwgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2J1ZmZlcmVkLXNlbmRlclwiOjI1LFwiLi9wb2xsaW5nXCI6MjcsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmV2ZW50c291cmNlJyk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcbiAgfTtcbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcbiAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKHJlYXNvbik7XG4gIH07XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICB2YXIgZXMgPSB0aGlzLmVzO1xuICBpZiAoZXMpIHtcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcbiAgICBlcy5jbG9zZSgpO1xuICAgIHRoaXMuZXMgPSBudWxsO1xuICB9XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LCAyMDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xuICAgICAgaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdGFydCcpO1xuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgfVxuICAsIG1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9XG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RvcCcpO1xuICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmIChheG8gaW4gZ2xvYmFsKSB7XG4gIHRyeSB7XG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxufVxuXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmpzb25wJyk7XG59XG5cbmZ1bmN0aW9uIEpzb25wUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB2YXIgdXJsV2l0aElkID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgdGhpcy5fY3JlYXRlU2NyaXB0KHVybFdpdGhJZCk7XG5cbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XG4gIH0sIEpzb25wUmVjZWl2ZXIudGltZW91dCk7XG59XG5cbmluaGVyaXRzKEpzb25wUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAoZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcbiAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgdGhpcy5fYWJvcnQoZXJyKTtcbiAgfVxufTtcblxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XG5Kc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCA9IDEwMDA7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGVidWcoJ19jYWxsYmFjaycsIGRhdGEpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgaWYgKHRoaXMuYWJvcnRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gIH1cbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbihlcnIpIHtcbiAgZGVidWcoJ19hYm9ydCcsIGVycik7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5hYm9ydGluZyA9IHRydWU7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcbiAgICB0aGlzLnNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdDIpO1xuICAgIHRoaXMuc2NyaXB0MiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcbiAgICAvLyB0aGUgc2NyaXB0LlxuICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbmNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9zY3JpcHRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjcmlwdEVycm9yJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuZXJyb3JUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyb3JUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcbiAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKScpKTtcbiAgICB9XG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgZGVidWcoJ19jcmVhdGVTY3JpcHQnLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgdmFyIHNjcmlwdDI7ICAvLyBPcGVyYSBzeW5jaHJvbm91cyBsb2FkIHRyaWNrLlxuXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLl9zY3JpcHRFcnJvci5iaW5kKHRoaXMpO1xuICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpJykpO1xuICB9O1xuXG4gIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgLy8gVXNlIGxvYWRlZE9rYXkgdG8gZGV0ZXJtaW5lIGlmIGFjdHVhbGx5IGVycm9yZWRcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBzY3JpcHQucmVhZHlTdGF0ZSk7XG4gICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICBzZWxmLmxvYWRlZE9rYXkgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25yZWFkeXN0YXRlY2hhbmdlKScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIElFOiBldmVudC9odG1sRm9yL29uY2xpY2sgdHJpY2suXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAvLyBtYWtlIHN1cmUsIHNldCBhICdodG1sRm9yJyBhbmQgJ2V2ZW50JyBwcm9wZXJ0aWVzLCBzbyB0aGF0XG4gIC8vIHNjcmlwdCBjb2RlIHdpbGwgYmUgaW5zdGFsbGVkIGFzICdvbmNsaWNrJyBoYW5kbGVyIGZvciB0aGVcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gIC8vIGNvZGUuIEZGIGFuZCBDaHJvbWUgZG9lc24ndCB3b3JrIHdpdGggJ2V2ZW50JyBhbmQgJ2h0bWxGb3InXG4gIC8vIHNldC4gRm9yIHJlZmVyZW5jZSBzZWU6XG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gIC8vIEFsc28sIHJlYWQgb24gdGhhdCBhYm91dCBzY3JpcHQgb3JkZXJpbmc6XG4gIC8vICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0R5bmFtaWNfU2NyaXB0X0V4ZWN1dGlvbl9PcmRlclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIG1vemlsbGEgZG9jcywgaW4gcmVjZW50IGJyb3dzZXJzIHNjcmlwdC5hc3luYyBkZWZhdWx0c1xuICAgIC8vIHRvICd0cnVlJywgc28gd2UgbWF5IHVzZSBpdCB0byBkZXRlY3QgYSBnb29kIGJyb3dzZXI6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgIGlmICghYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICB0cnkge1xuICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZDtcbiAgICAgICAgc2NyaXB0LmV2ZW50ID0gJ29uY2xpY2snO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIiArIHNjcmlwdC5pZCArIFwiJyk7IGlmKGEpYS5vbmVycm9yKCk7fWNhdGNoKHgpe307XCI7XG4gICAgICBzY3JpcHQuYXN5bmMgPSBzY3JpcHQyLmFzeW5jID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIH1cblxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIGlmIChzY3JpcHQyKSB7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucFJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5idWZmZXJQb3NpdGlvbiA9IDA7XG5cbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsLCBudWxsKTtcbiAgdGhpcy54by5vbignY2h1bmsnLCB0aGlzLl9jaHVua0hhbmRsZXIuYmluZCh0aGlzKSk7XG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi5fY2h1bmtIYW5kbGVyKHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi54byA9IG51bGw7XG4gICAgdmFyIHJlYXNvbiA9IHN0YXR1cyA9PT0gMjAwID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCc7XG4gICAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhYaHJSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jaHVua0hhbmRsZXIgPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgZGVidWcoJ19jaHVua0hhbmRsZXInLCBzdGF0dXMpO1xuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSAtMTsgOyB0aGlzLmJ1ZmZlclBvc2l0aW9uICs9IGlkeCArIDEpIHtcbiAgICB2YXIgYnVmID0gdGV4dC5zbGljZSh0aGlzLmJ1ZmZlclBvc2l0aW9uKTtcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgbXNnID0gYnVmLnNsaWNlKDAsIGlkeCk7XG4gICAgaWYgKG1zZykge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICd1c2VyJyk7XG4gICAgdGhpcy54byA9IG51bGw7XG4gIH1cbiAgdGhpcy5fY2xlYW51cCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcbn1cblxudmFyIGZvcm0sIGFyZWE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZShpZCkge1xuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xuICB0cnkge1xuICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9ybSgpIHtcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcbiAgZm9ybSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICBmb3JtLmVuY3R5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcblxuICBhcmVhID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIGFyZWEubmFtZSA9ICdkJztcbiAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcblxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIGRlYnVnKHVybCwgcGF5bG9hZCk7XG4gIGlmICghZm9ybSkge1xuICAgIGNyZWF0ZUZvcm0oKTtcbiAgfVxuICB2YXIgaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBmb3JtLnRhcmdldCA9IGlkO1xuICBmb3JtLmFjdGlvbiA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL2pzb25wX3NlbmQnKSwgJ2k9JyArIGlkKTtcblxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcbiAgaWZyYW1lLmlkID0gaWQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHNlcmlvdXNseSBicm9rZW4gYnJvd3NlcnMgZ2V0IGhlcmVcbiAgfVxuICBmb3JtLnN1Ym1pdCgpO1xuXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBkZWJ1ZygnY29tcGxldGVkJywgaWQsIGVycik7XG4gICAgaWYgKCFpZnJhbWUub25lcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICBpZnJhbWUgPSBudWxsO1xuICAgIH0sIDUwMCk7XG4gICAgYXJlYS52YWx1ZSA9ICcnO1xuICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgaWYgdGhlIGlmcmFtZSBzdWNjZWVkZWQgb3JcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xuICAgIGlmIChpZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XG4gICAgY29tcGxldGVkKG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6eGRyJyk7XG59XG5cbi8vIFJlZmVyZW5jZXM6XG4vLyAgIGh0dHA6Ly9hamF4aWFuLmNvbS9hcmNoaXZlcy8xMDAtbGluZS1hamF4LXdyYXBwZXJcbi8vICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMjg4MDYwKHY9VlMuODUpLmFzcHhcblxuZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKFhEUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZygnX3N0YXJ0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhkciA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKTtcbiAgLy8gSUUgY2FjaGVzIGV2ZW4gUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgeGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb250aW1lb3V0Jyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygncHJvZ3Jlc3MnLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLmVtaXQoJ2NodW5rJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgfTtcbiAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdsb2FkJyk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9O1xuICB0aGlzLnhkciA9IHhkcjtcbiAgdGhpcy51bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgIHRoaXMueGRyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMueGRyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMueGRyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB0aGlzLl9lcnJvcigpO1xuICB9XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnLCBhYm9ydCk7XG4gIGlmICghdGhpcy54ZHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgZXZlbnRVdGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIHRoaXMueGRyLm9udGltZW91dCA9IHRoaXMueGRyLm9uZXJyb3IgPSB0aGlzLnhkci5vbnByb2dyZXNzID0gdGhpcy54ZHIub25sb2FkID0gbnVsbDtcbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGRyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGRyID0gbnVsbDtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG4vLyBJRSA4LzkgaWYgdGhlIHJlcXVlc3QgdGFyZ2V0IHVzZXMgdGhlIHNhbWUgc2NoZW1lIC0gIzc5XG5YRFJPYmplY3QuZW5hYmxlZCA9ICEhKGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiBicm93c2VyLmhhc0RvbWFpbigpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBYRFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkZha2UoLyogbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMgKi8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XG4gIH0sIFhIUkZha2UudGltZW91dCk7XG59XG5cbmluaGVyaXRzKFhIUkZha2UsIEV2ZW50RW1pdHRlcik7XG5cblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRvKTtcbn07XG5cblhIUkZha2UudGltZW91dCA9IDIwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcblxufSx7XCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCB7XG4gICAgbm9DcmVkZW50aWFsczogdHJ1ZVxuICB9KTtcbn1cblxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2NhbE9iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBXZWJzb2NrZXREcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlci93ZWJzb2NrZXQnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6d2Vic29ja2V0Jyk7XG59XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydCh0cmFuc1VybCwgaWdub3JlLCBvcHRpb25zKSB7XG4gIGlmICghV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjb25zdHJ1Y3RvcicsIHRyYW5zVXJsKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCAnL3dlYnNvY2tldCcpO1xuICBpZiAodXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgfVxuICB0aGlzLnVybCA9IHVybDtcblxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZSBldmVudCcsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgfTtcbiAgLy8gRmlyZWZveCBoYXMgYW4gaW50ZXJlc3RpbmcgYnVnLiBJZiBhIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzXG4gIC8vIGNyZWF0ZWQgYWZ0ZXIgb251bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXG4gIC8vIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2UuIEluIHN1Y2ggc2l0dWF0aW9uIGxldCdzIGxpZSAtXG4gIC8vIGxldCdzIG5vdCBvcGVuIHRoZSB3cyBjb25uZWN0aW9uIGF0IGFsbC4gU2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NjA4NVxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkJyk7XG4gICAgc2VsZi53cy5jbG9zZSgpO1xuICB9KTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdjbG9zZSBldmVudCcsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3IgZXZlbnQnLCBlKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1dlYlNvY2tldCBjb25uZWN0aW9uIGJyb2tlbicpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBtc2cgPSAnWycgKyBkYXRhICsgJ10nO1xuICBkZWJ1Zygnc2VuZCcsIG1zZyk7XG4gIHRoaXMud3Muc2VuZChtc2cpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAod3MpIHtcbiAgICB3cy5jbG9zZSgpO1xuICB9XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICBpZiAod3MpIHtcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XG4gIH1cbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdlbmFibGVkJyk7XG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcbn07XG5XZWJTb2NrZXRUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi9kcml2ZXIvd2Vic29ja2V0XCI6MTksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3hkci1zdHJlYW1pbmcnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1wb2xsaW5nJztcblhkclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiLi94ZHItc3RyZWFtaW5nXCI6NDAsXCJpbmhlcml0c1wiOjU3fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5mdW5jdGlvbiBYZHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8uY29va2llX25lZWRlZCB8fCBpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFhEUk9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZVNjaGVtZTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1zdHJlYW1pbmcnO1xuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiaW5oZXJpdHNcIjo1N31dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICA7XG5cbmZ1bmN0aW9uIFhoclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXBvbGxpbmcnO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlscy9icm93c2VyJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qgc3VwcG9ydCB4aHItc3RyZWFtaW5nICM2MFxuICAvLyBCdXQgaXQgbWlnaHQgYmUgYWJsZSB0byAjOTJcbiAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1zdHJlYW1pbmcnO1xuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuLy8gU2FmYXJpIGdldHMgY29uZnVzZWQgd2hlbiBhIHN0cmVhbWluZyBhamF4IHJlcXVlc3QgaXMgc3RhcnRlZFxuLy8gYmVmb3JlIG9ubG9hZC4gVGhpcyBjYXVzZXMgdGhlIGxvYWQgaW5kaWNhdG9yIHRvIHNwaW4gaW5kZWZpbmV0ZWx5LlxuLy8gT25seSByZXF1aXJlIGJvZHkgd2hlbiB1c2VkIGluIGEgYnJvd3NlclxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0Lm5lZWRCb2R5ID0gISFnbG9iYWwuZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi91dGlscy9icm93c2VyXCI6NDQsXCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPcGVyYTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAva29ucXVlcm9yL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLyAjMTg3IHdyYXAgZG9jdW1lbnQuZG9tYWluIGluIHRyeS9jYXRjaCBiZWNhdXNlIG9mIFdQOCBmcm9tIGZpbGU6Ly8vXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJyk7XG5cbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxuLy8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHdpcmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcbiAgLCBleHRyYUxvb2t1cDtcblxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxuLy8gY2hhcmFjdGVycy5cbnZhciB1bnJvbGxMb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgdmFyIGk7XG4gIHZhciB1bnJvbGxlZCA9IHt9O1xuICB2YXIgYyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgIGMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICB9XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgdW5yb2xsZWRbIGEgXSA9ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdW5yb2xsZWQ7XG59O1xuXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcbi8vIG9mdGVuIGJyZWFrLiBFc3BlY2lhbGx5LCB0YWtlIGNhcmUgb2YgdW5pY29kZSBzdXJyb2dhdGVzOlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBwaW5nX29mX1VuaWNvZGVfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBxdW90ZWQgPSBKU09OMy5zdHJpbmdpZnkoc3RyaW5nKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGQgYmUgdmVyeSBmYXN0IGFuZCBnb29kIGVub3VnaC5cbiAgICBleHRyYUVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICByZXR1cm4gcXVvdGVkO1xuICAgIH1cblxuICAgIGlmICghZXh0cmFMb29rdXApIHtcbiAgICAgIGV4dHJhTG9va3VwID0gdW5yb2xsTG9va3VwKGV4dHJhRXNjYXBhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvdGVkLnJlcGxhY2UoZXh0cmFFc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcbiAgICB9KTtcbiAgfVxufTtcblxufSx7XCJqc29uM1wiOjU4fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL3JhbmRvbVwiOjUwfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczppZnJhbWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdQcmVmaXg6ICdfanAnXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxuXG4sIHBvbGx1dGVHbG9iYWxOYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xuICAgICAgZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0ge307XG4gICAgfVxuICB9XG5cbiwgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucGFyZW50LnBvc3RNZXNzYWdlKEpTT04zLnN0cmluZ2lmeSh7XG4gICAgICAgIHdpbmRvd0lkOiBtb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93SWRcbiAgICAgICwgdHlwZTogdHlwZVxuICAgICAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gICAgICB9KSwgJyonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0Nhbm5vdCBwb3N0TWVzc2FnZSwgbm8gcGFyZW50IHdpbmRvdy4nLCB0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuLCBjcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgLy8gRXhwbG9yZXIgaGFkIHByb2JsZW1zIHdpdGggdGhhdC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IG1ha2VzIGNocm9tZSBmaXJlIG9uYmVmb3JldW5sb2FkIGV2ZW50XG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cblxuLyogZXNsaW50IG5vLXVuZGVmOiBcIm9mZlwiLCBuZXctY2FwOiBcIm9mZlwiICovXG4sIGNyZWF0ZUh0bWxmaWxlOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbiAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XG4gICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgcik7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvYy5vcGVuKCk7XG4gICAgZG9jLndyaXRlKCc8aHRtbD48cycgKyAnY3JpcHQ+JyArXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZ2xvYmFsLmRvY3VtZW50LmRvbWFpbiArICdcIjsnICtcbiAgICAgICAgICAgICAgJzwvcycgKyAnY3JpcHQ+PC9odG1sPicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIGRvYy5wYXJlbnRXaW5kb3dbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF07XG4gICAgdmFyIGMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGMuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gZmFsc2U7XG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIC8vIHBvc3RNZXNzYWdlIG1pc2JlaGF2ZXMgaW4ga29ucXVlcm9yIDQuNi41IC0gdGhlIG1lc3NhZ2VzIGFyZSBkZWxpdmVyZWQgd2l0aFxuICAvLyBodWdlIGRlbGF5LCBvciBub3QgYXQgYWxsLlxuICBtb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gKHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFicm93c2VyLmlzS29ucXVlcm9yKCkpO1xufVxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2Jyb3dzZXJcIjo0NCxcIi4vZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nT2JqZWN0ID0ge307XG5bJ2xvZycsICdkZWJ1ZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgdmFyIGxldmVsRXhpc3RzO1xuXG4gIHRyeSB7XG4gICAgbGV2ZWxFeGlzdHMgPSBnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0gJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5O1xuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICBsb2dPYmplY3RbbGV2ZWxdID0gbGV2ZWxFeGlzdHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseShnbG9iYWwuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfSA6IChsZXZlbCA9PT0gJ2xvZycgPyBmdW5jdGlvbiAoKSB7fSA6IGxvZ09iamVjdC5sb2cpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nT2JqZWN0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfVxuXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxufSx7fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgY3J5cHRvOnRydWUgKi9cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuLy8gVGhpcyBzdHJpbmcgaGFzIGxlbmd0aCAzMiwgYSBwb3dlciBvZiAyLCBzbyB0aGUgbW9kdWx1cyBkb2Vzbid0IGludHJvZHVjZSBhXG4vLyBiaWFzLlxudmFyIF9yYW5kb21TdHJpbmdDaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NSc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgbWF4ID0gX3JhbmRvbVN0cmluZ0NoYXJzLmxlbmd0aDtcbiAgICB2YXIgYnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmV0LnB1c2goX3JhbmRvbVN0cmluZ0NoYXJzLnN1YnN0cihieXRlc1tpXSAlIG1heCwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9XG5cbiwgbnVtYmVyOiBmdW5jdGlvbihtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbiAgfVxuXG4sIG51bWJlclN0cmluZzogZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcbiAgICB2YXIgcCA9IG5ldyBBcnJheSh0ICsgMSkuam9pbignMCcpO1xuICAgIHJldHVybiAocCArIHRoaXMubnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbiAgfVxufTtcblxufSx7XCJjcnlwdG9cIjo0M31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICByZXR1cm4ge1xuICAgIGZpbHRlclRvRW5hYmxlZDogZnVuY3Rpb24odHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XG4gICAgICAgIG1haW46IFtdXG4gICAgICAsIGZhY2FkZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFtdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgIH1cblxuICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIGlmICghdHJhbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkIGZyb20gc2VydmVyJywgJ3dlYnNvY2tldCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc3BvcnRzV2hpdGVsaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGRlYnVnKCdub3QgaW4gd2hpdGVsaXN0JywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHRyYW5zcG9ydHMubWFpbi5wdXNoKHRyYW5zKTtcbiAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICAgIH1cbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0T3JpZ2luOiBmdW5jdGlvbih1cmwpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHAucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3J0ID0gcC5wb3J0O1xuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IChwLnByb3RvY29sID09PSAnaHR0cHM6JykgPyAnNDQzJyA6ICc4MCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAucHJvdG9jb2wgKyAnLy8nICsgcC5ob3N0bmFtZSArICc6JyArIHBvcnQ7XG4gIH1cblxuLCBpc09yaWdpbkVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZ2V0T3JpZ2luKGEpID09PSB0aGlzLmdldE9yaWdpbihiKTtcbiAgICBkZWJ1Zygnc2FtZScsIGEsIGIsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4sIGlzU2NoZW1lRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuc3BsaXQoJzonKVswXSA9PT0gYi5zcGxpdCgnOicpWzBdKTtcbiAgfVxuXG4sIGFkZFBhdGg6IGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcbiAgICB2YXIgcXMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICByZXR1cm4gcXNbMF0gKyBwYXRoICsgKHFzWzFdID8gJz8nICsgcXNbMV0gOiAnJyk7XG4gIH1cblxuLCBhZGRRdWVyeTogZnVuY3Rpb24gKHVybCwgcSkge1xuICAgIHJldHVybiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAoJz8nICsgcSkgOiAoJyYnICsgcSkpO1xuICB9XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcInVybC1wYXJzZVwiOjYxfV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAnMS4zLjAnO1xuXG59LHt9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLT9cXGQ/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG5cbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cblxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblxuXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xufVxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7IC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluZGV4Kys7XG5cbiAgICBpZiAobWF0Y2ggPT09ICclYycpIHtcbiAgICAgIC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAodHlwZW9mIGNvbnNvbGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25zb2xlKSkgPT09ICdvYmplY3QnICYmIGNvbnNvbGUubG9nICYmIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG5cbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBTd2FsbG93XG4gIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cblxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgLy8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vY29tbW9uXCI6NTZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcbiAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuICB9KTtcbiAgLyoqXG4gICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuICAvKipcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAvKipcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICpcbiAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAvKipcbiAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG4gIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gIC8qKlxuICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzYWJsZWQ/XG4gICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IGRlYnVnOyAvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgfSAvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTsgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXG4gICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblxuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgLy8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICpcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuXG59LHtcIm1zXCI6NTR9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxufSx7fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIHdoaWxlIChwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpKSB7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKVxuICAgICAgLCB2YWx1ZSA9IGRlY29kZShwYXJ0WzJdKTtcblxuICAgIC8vXG4gICAgLy8gUHJldmVudCBvdmVycmlkaW5nIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGJ1aWxkLWluXG4gICAgLy8gbWV0aG9kcyBsaWtlIGB0b1N0cmluZ2Agb3IgX19wcm90b19fIGFyZSBub3Qgb3ZlcnJpZGVuIGJ5IG1hbGljaW91c1xuICAgIC8vIHF1ZXJ5c3RyaW5ncy5cbiAgICAvL1xuICAgIGlmIChrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsnPScrIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG5cbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxTXFxzXSopL2lcbiAgLCBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vO1xuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzKSB7ICAgICAgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBhZGRyZXNzLnJlcGxhY2UoJ1xcXFwnLCAnLycpO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsICYmIGdsb2JhbC5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgc2xhc2hlczogISFtYXRjaFsyXSxcbiAgICByZXN0OiBtYXRjaFszXVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB3ZSBzaG91bGQgbm90IHVzZSBgVVJMYCBhcyBjbGFzcyBuYW1lIHRvIHByZXZlbnRcbiAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvY2F0aW9uIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gcGFyc2VyIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcInF1ZXJ5c3RyaW5naWZ5XCI6NTksXCJyZXF1aXJlcy1wb3J0XCI6NjB9XX0se30sWzFdKSgxKVxufSk7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ja2pzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZVxuICBuby11bnVzZWQtdmFyc1xuKi9cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VDbGllbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VDbGllbnQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VDbGllbnQsIG51bGwsIFt7XG4gICAga2V5OiBcImdldENsaWVudFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UGF0aChvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBuZWVkcyBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlQ2xpZW50O1xufSgpOyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcblxudmFyIEJhc2VDbGllbnQgPSByZXF1aXJlKCcuL0Jhc2VDbGllbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlQ2xpZW50KSB7XG4gIF9pbmhlcml0cyhTb2NrSlNDbGllbnQsIF9CYXNlQ2xpZW50KTtcblxuICBmdW5jdGlvbiBTb2NrSlNDbGllbnQodXJsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tKU0NsaWVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTb2NrSlNDbGllbnQpLmNhbGwodGhpcykpO1xuICAgIF90aGlzLnNvY2sgPSBuZXcgU29ja0pTKHVybCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNvY2tKU0NsaWVudCwgW3tcbiAgICBrZXk6IFwib25PcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbihmKSB7XG4gICAgICB0aGlzLnNvY2sub25vcGVuID0gZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsb3NlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbmNsb3NlID0gZjtcbiAgICB9IC8vIGNhbGwgZiB3aXRoIHRoZSBtZXNzYWdlIHN0cmluZyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcblxuICB9LCB7XG4gICAga2V5OiBcIm9uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2UoZikge1xuICAgICAgdGhpcy5zb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGYoZS5kYXRhKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUoJy4vU29ja0pTQ2xpZW50Jyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvY2tKU0NsaWVudDtcbn0oQmFzZUNsaWVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG5cbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5cbnZhciBzb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpLFxuICAgIGxvZyA9IF9yZXF1aXJlLmxvZyxcbiAgICBzZXRMb2dMZXZlbCA9IF9yZXF1aXJlLnNldExvZ0xldmVsO1xuXG52YXIgc2VuZE1lc3NhZ2UgPSByZXF1aXJlKCcuL3V0aWxzL3NlbmRNZXNzYWdlJyk7XG5cbnZhciByZWxvYWRBcHAgPSByZXF1aXJlKCcuL3V0aWxzL3JlbG9hZEFwcCcpO1xuXG52YXIgY3JlYXRlU29ja2V0VXJsID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVTb2NrZXRVcmwnKTtcblxudmFyIHN0YXR1cyA9IHtcbiAgaXNVbmxvYWRpbmc6IGZhbHNlLFxuICBjdXJyZW50SGFzaDogJydcbn07XG52YXIgb3B0aW9ucyA9IHtcbiAgaG90OiBmYWxzZSxcbiAgaG90UmVsb2FkOiB0cnVlLFxuICBsaXZlUmVsb2FkOiBmYWxzZSxcbiAgaW5pdGlhbDogdHJ1ZSxcbiAgdXNlV2FybmluZ092ZXJsYXk6IGZhbHNlLFxuICB1c2VFcnJvck92ZXJsYXk6IGZhbHNlLFxuICB1c2VQcm9ncmVzczogZmFsc2Vcbn07XG52YXIgc29ja2V0VXJsID0gY3JlYXRlU29ja2V0VXJsKF9fcmVzb3VyY2VRdWVyeSk7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgc3RhdHVzLmlzVW5sb2FkaW5nID0gdHJ1ZTtcbn0pO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHFzID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICBvcHRpb25zLmhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cblxudmFyIG9uU29ja2V0TWVzc2FnZSA9IHtcbiAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGxpdmVSZWxvYWQ6IGZ1bmN0aW9uIGxpdmVSZWxvYWQoKSB7XG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC4nKTtcbiAgfSxcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uJyk7IC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnSW52YWxpZCcpO1xuICB9LFxuICBoYXNoOiBmdW5jdGlvbiBoYXNoKF9oYXNoKSB7XG4gICAgc3RhdHVzLmN1cnJlbnRIYXNoID0gX2hhc2g7XG4gIH0sXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ1N0aWxsT2snKTtcbiAgfSxcbiAgJ2xvZy1sZXZlbCc6IGZ1bmN0aW9uIGxvZ0xldmVsKGxldmVsKSB7XG4gICAgdmFyIGhvdEN0eCA9IHJlcXVpcmUuY29udGV4dCgnd2VicGFjay9ob3QnLCBmYWxzZSwgL15cXC5cXC9sb2ckLyk7XG5cbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9XG5cbiAgICBzZXRMb2dMZXZlbChsZXZlbCk7XG4gIH0sXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgPSBmYWxzZTtcbiAgICAgICAgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlLmVycm9ycztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhfcHJvZ3Jlc3MpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy51c2VQcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgICB9XG4gIH0sXG4gICdwcm9ncmVzcy11cGRhdGUnOiBmdW5jdGlvbiBwcm9ncmVzc1VwZGF0ZShkYXRhKSB7XG4gICAgaWYgKG9wdGlvbnMudXNlUHJvZ3Jlc3MpIHtcbiAgICAgIGxvZy5pbmZvKFwiW1dEU10gXCIuY29uY2F0KGRhdGEucGVyY2VudCwgXCIlIC0gXCIpLmNvbmNhdChkYXRhLm1zZywgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnUHJvZ3Jlc3MnLCBkYXRhKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKCdPaycpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gICdjb250ZW50LWNoYW5nZWQnOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQ29udGVudCBiYXNlIGNoYW5nZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MpIHtcbiAgICBsb2cud2FybignW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5pdGlhbCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKCdFcnJvcnMnLCBzdHJpcHBlZEVycm9ycyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cuZXJyb3Ioc3RyaXBwZWRFcnJvcnNbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBEaXNjb25uZWN0ZWQhJyk7XG4gICAgc2VuZE1lc3NhZ2UoJ0Nsb3NlJyk7XG4gIH1cbn07XG5zb2NrZXQoc29ja2V0VXJsLCBvblNvY2tldE1lc3NhZ2UpOyIsIid1c2Ugc3RyaWN0JzsgLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxuLy8gVGhleSwgaW4gdHVybiwgZ290IGluc3BpcmVkIGJ5IHdlYnBhY2staG90LW1pZGRsZXdhcmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZSkuXG5cbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbCcpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdodG1sLWVudGl0aWVzJyksXG4gICAgQWxsSHRtbEVudGl0aWVzID0gX3JlcXVpcmUuQWxsSHRtbEVudGl0aWVzO1xuXG52YXIgZW50aXRpZXMgPSBuZXcgQWxsSHRtbEVudGl0aWVzKCk7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogWyd0cmFuc3BhcmVudCcsICd0cmFuc3BhcmVudCddLFxuICBibGFjazogJzE4MTgxOCcsXG4gIHJlZDogJ0UzNjA0OScsXG4gIGdyZWVuOiAnQjNDQjc0JyxcbiAgeWVsbG93OiAnRkZEMDgwJyxcbiAgYmx1ZTogJzdDQUZDMicsXG4gIG1hZ2VudGE6ICc3RkFDQ0EnLFxuICBjeWFuOiAnQzNDMkVGJyxcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcbiAgZGFya2dyZXk6ICc2RDc4OTEnXG59O1xudmFyIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xudmFyIG92ZXJsYXlEaXYgPSBudWxsO1xudmFyIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG5hbnNpSFRNTC5zZXRDb2xvcnMoY29sb3JzKTtcblxuZnVuY3Rpb24gY3JlYXRlT3ZlcmxheUlmcmFtZShvbklmcmFtZUxvYWQpIHtcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICBpZnJhbWUuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5JztcbiAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGlmcmFtZS5zdHlsZS5sZWZ0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLnRvcCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5yaWdodCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5ib3R0b20gPSAwO1xuICBpZnJhbWUuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBpZnJhbWUuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgaWZyYW1lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgaWZyYW1lLnN0eWxlLnpJbmRleCA9IDk5OTk5OTk5OTk7XG4gIGlmcmFtZS5vbmxvYWQgPSBvbklmcmFtZUxvYWQ7XG4gIHJldHVybiBpZnJhbWU7XG59XG5cbmZ1bmN0aW9uIGFkZE92ZXJsYXlEaXZUbyhpZnJhbWUpIHtcbiAgdmFyIGRpdiA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXktZGl2JztcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgZGl2LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgZGl2LnN0eWxlLmxlZnQgPSAwO1xuICBkaXYuc3R5bGUudG9wID0gMDtcbiAgZGl2LnN0eWxlLnJpZ2h0ID0gMDtcbiAgZGl2LnN0eWxlLmJvdHRvbSA9IDA7XG4gIGRpdi5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC44NSknO1xuICBkaXYuc3R5bGUuY29sb3IgPSAnI0U4RThFOCc7XG4gIGRpdi5zdHlsZS5mb250RmFtaWx5ID0gJ01lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlJztcbiAgZGl2LnN0eWxlLmZvbnRTaXplID0gJ2xhcmdlJztcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMnJlbSc7XG4gIGRpdi5zdHlsZS5saW5lSGVpZ2h0ID0gJzEuMic7XG4gIGRpdi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICBpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgcmV0dXJuIGRpdjtcbn1cblxuZnVuY3Rpb24gZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhvbk92ZXJsYXlEaXZSZWFkeSkge1xuICBpZiAob3ZlcmxheURpdikge1xuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgb25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0aW5nIGFuIGlmcmFtZSBtYXkgYmUgYXN5bmNocm9ub3VzIHNvIHdlJ2xsIHNjaGVkdWxlIHRoZSBjYWxsYmFjay5cbiAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBjYWxscywgbGFzdCBjYWxsYmFjayB3aW5zLlxuXG5cbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gb25PdmVybGF5RGl2UmVhZHk7XG5cbiAgaWYgKG92ZXJsYXlJZnJhbWUpIHtcbiAgICAvLyBXZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0ZSBpZnJhbWUgYW5kLCB3aGVuIGl0IGlzIHJlYWR5LCBhIGRpdiBpbnNpZGUgaXQuXG5cblxuICBvdmVybGF5SWZyYW1lID0gY3JlYXRlT3ZlcmxheUlmcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgb3ZlcmxheURpdiA9IGFkZE92ZXJsYXlEaXZUbyhvdmVybGF5SWZyYW1lKTsgLy8gTm93IHdlIGNhbiB0YWxrIVxuXG4gICAgbGFzdE9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICB9KTsgLy8gWmFsZ28gYWxlcnQ6IG9uSWZyYW1lTG9hZCgpIHdpbGwgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5XG4gIC8vIG9yIGFzeW5jaHJvbm91c2x5IGRlcGVuZGluZyBvbiB0aGUgYnJvd3Nlci5cbiAgLy8gV2UgZGVsYXkgYWRkaW5nIGl0IHNvIGBvdmVybGF5SWZyYW1lYCBpcyBzZXQgd2hlbiBgb25JZnJhbWVMb2FkYCBmaXJlcy5cblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG92ZXJsYXlJZnJhbWUpO1xufSAvLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuXG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBpZiAoIW92ZXJsYXlEaXYpIHtcbiAgICAvLyBJdCBpcyBub3QgdGhlcmUgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIHJldHVybjtcbiAgfSAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXG5cblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG92ZXJsYXlJZnJhbWUpO1xuICBvdmVybGF5RGl2ID0gbnVsbDtcbiAgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG59IC8vIENvbXBpbGF0aW9uIHdpdGggZXJyb3JzIChlLmcuIHN5bnRheCBlcnJvciBvciBtaXNzaW5nIG1vZHVsZXMpLlxuXG5cbmZ1bmN0aW9uIHNob3dNZXNzYWdlKG1lc3NhZ2VzKSB7XG4gIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMoZnVuY3Rpb24gKGRpdikge1xuICAgIC8vIE1ha2UgaXQgbG9vayBzaW1pbGFyIHRvIG91ciB0ZXJtaW5hbC5cbiAgICBkaXYuaW5uZXJIVE1MID0gXCI8c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNcIi5jb25jYXQoY29sb3JzLnJlZCwgXCJcXFwiPkZhaWxlZCB0byBjb21waWxlLjwvc3Bhbj48YnI+PGJyPlwiKS5jb25jYXQoYW5zaUhUTUwoZW50aXRpZXMuZW5jb2RlKG1lc3NhZ2VzWzBdKSkpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNsZWFyOiBjbGVhcixcbiAgc2hvd01lc3NhZ2U6IHNob3dNZXNzYWdlXG59OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZVxuICBjYW1lbGNhc2VcbiovXG4vLyB0aGlzIFNvY2tKU0NsaWVudCBpcyBoZXJlIGFzIGEgZGVmYXVsdCBmYWxsYmFjaywgaW4gY2FzZSBpbmxpbmUgbW9kZVxuLy8gaXMgb2ZmIG9yIHRoZSBjbGllbnQgaXMgbm90IGluamVjdGVkLiBUaGlzIHdpbGwgYmUgc3dpdGNoZWQgdG9cbi8vIFdlYnNvY2tldENsaWVudCB3aGVuIGl0IGJlY29tZXMgdGhlIGRlZmF1bHRcbi8vIGltcG9ydGFudDogdGhlIHBhdGggdG8gU29ja0pTQ2xpZW50IGhlcmUgaXMgbWFkZSB0byB3b3JrIGluIHRoZSAnY2xpZW50J1xuLy8gZGlyZWN0b3J5LCBidXQgaXMgdXBkYXRlZCB2aWEgdGhlIHdlYnBhY2sgY29tcGlsYXRpb24gd2hlbiBjb21waWxlZCBmcm9tXG4vLyB0aGUgJ2NsaWVudC1zcmMnIGRpcmVjdG9yeVxuXG52YXIgQ2xpZW50ID0gdHlwZW9mIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5yZXF1aXJlKCcuL2NsaWVudHMvU29ja0pTQ2xpZW50Jyk7XG52YXIgcmV0cmllcyA9IDA7XG52YXIgY2xpZW50ID0gbnVsbDtcblxudmFyIHNvY2tldCA9IGZ1bmN0aW9uIGluaXRTb2NrZXQodXJsLCBoYW5kbGVycykge1xuICBjbGllbnQgPSBuZXcgQ2xpZW50KHVybCk7XG4gIGNsaWVudC5vbk9wZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHJpZXMgPSAwO1xuICB9KTtcbiAgY2xpZW50Lm9uQ2xvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXRyaWVzID09PSAwKSB7XG4gICAgICBoYW5kbGVycy5jbG9zZSgpO1xuICAgIH0gLy8gVHJ5IHRvIHJlY29ubmVjdC5cblxuXG4gICAgY2xpZW50ID0gbnVsbDsgLy8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuXG4gICAgaWYgKHJldHJpZXMgPD0gMTApIHtcbiAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXG4gICAgICAvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcbiAgICAgIHZhciByZXRyeUluTXMgPSAxMDAwICogTWF0aC5wb3coMiwgcmV0cmllcykgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvY2tldCh1cmwsIGhhbmRsZXJzKTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9KTtcbiAgY2xpZW50Lm9uTWVzc2FnZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBtc2cgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgaWYgKGhhbmRsZXJzW21zZy50eXBlXSkge1xuICAgICAgaGFuZGxlcnNbbXNnLnR5cGVdKG1zZy5kYXRhKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb2NrZXQ7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIHNlbGYgKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG52YXIgZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSA9IHJlcXVpcmUoJy4vZ2V0Q3VycmVudFNjcmlwdFNvdXJjZScpO1xuXG5mdW5jdGlvbiBjcmVhdGVTb2NrZXRVcmwocmVzb3VyY2VRdWVyeSkge1xuICB2YXIgdXJsUGFydHM7XG5cbiAgaWYgKHR5cGVvZiByZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiByZXNvdXJjZVF1ZXJ5ICE9PSAnJykge1xuICAgIC8vIElmIHRoaXMgYnVuZGxlIGlzIGlubGluZWQsIHVzZSB0aGUgcmVzb3VyY2UgcXVlcnkgdG8gZ2V0IHRoZSBjb3JyZWN0IHVybC5cbiAgICB1cmxQYXJ0cyA9IHVybC5wYXJzZShyZXNvdXJjZVF1ZXJ5LnN1YnN0cigxKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRWxzZSwgZ2V0IHRoZSB1cmwgZnJvbSB0aGUgPHNjcmlwdD4gdGhpcyBmaWxlIHdhcyBjYWxsZWQgd2l0aC5cbiAgICB2YXIgc2NyaXB0SG9zdCA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbiAgICBzY3JpcHRIb3N0ID0gc2NyaXB0SG9zdC5yZXBsYWNlKC9cXC9bXlxcL10rJC8sICcnKTtcbiAgICB1cmxQYXJ0cyA9IHVybC5wYXJzZShzY3JpcHRIb3N0IHx8ICcvJywgZmFsc2UsIHRydWUpO1xuICB9XG5cbiAgaWYgKCF1cmxQYXJ0cy5wb3J0IHx8IHVybFBhcnRzLnBvcnQgPT09ICcwJykge1xuICAgIHVybFBhcnRzLnBvcnQgPSBzZWxmLmxvY2F0aW9uLnBvcnQ7XG4gIH1cblxuICB2YXIgX3VybFBhcnRzID0gdXJsUGFydHMsXG4gICAgICBhdXRoID0gX3VybFBhcnRzLmF1dGgsXG4gICAgICBwYXRoID0gX3VybFBhcnRzLnBhdGg7XG4gIHZhciBfdXJsUGFydHMyID0gdXJsUGFydHMsXG4gICAgICBob3N0bmFtZSA9IF91cmxQYXJ0czIuaG9zdG5hbWUsXG4gICAgICBwcm90b2NvbCA9IF91cmxQYXJ0czIucHJvdG9jb2w7IC8vIGNoZWNrIGlwdjQgYW5kIGlwdjYgYGFsbCBob3N0bmFtZWBcbiAgLy8gd2h5IGRvIHdlIG5lZWQgdGhpcyBjaGVjaz9cbiAgLy8gaG9zdG5hbWUgbi9hIGZvciBmaWxlIHByb3RvY29sIChleGFtcGxlLCB3aGVuIHVzaW5nIGVsZWN0cm9uLCBpb25pYylcbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8zODRcblxuICBpZiAoKGhvc3RuYW1lID09PSAnMC4wLjAuMCcgfHwgaG9zdG5hbWUgPT09ICc6OicpICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgISF+c2VsZi5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykpIHtcbiAgICBob3N0bmFtZSA9IHNlbGYubG9jYXRpb24uaG9zdG5hbWU7XG4gIH0gLy8gYGhvc3RuYW1lYCBjYW4gYmUgZW1wdHkgd2hlbiB0aGUgc2NyaXB0IHBhdGggaXMgcmVsYXRpdmUuIEluIHRoYXQgY2FzZSwgc3BlY2lmeWluZ1xuICAvLyBhIHByb3RvY29sIHdvdWxkIHJlc3VsdCBpbiBhbiBpbnZhbGlkIFVSTC5cbiAgLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWJzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5XG4gIC8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWJzb2NrZXRzLlxuXG5cbiAgaWYgKGhvc3RuYW1lICYmIChzZWxmLmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCB1cmxQYXJ0cy5ob3N0bmFtZSA9PT0gJzAuMC4wLjAnKSkge1xuICAgIHByb3RvY29sID0gc2VsZi5sb2NhdGlvbi5wcm90b2NvbDtcbiAgfSAvLyBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgc29jayB1cmwgaWYgdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cblxuICB2YXIgc29ja0hvc3QgPSBob3N0bmFtZTtcbiAgdmFyIHNvY2tQYXRoID0gJy9zb2NranMtbm9kZSc7XG4gIHZhciBzb2NrUG9ydCA9IHVybFBhcnRzLnBvcnQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcblxuICBpZiAocGF0aCAhPT0gbnVsbCAmJiBwYXRoICE9PSB1bmRlZmluZWQgJiYgcGF0aCAhPT0gJy8nKSB7XG4gICAgdmFyIHBhcnNlZFF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UocGF0aCk7IC8vIGFsbCBvZiB0aGVzZSBzb2NrIHVybCBwYXJhbXMgYXJlIG9wdGlvbmFsbHkgcGFzc2VkIGluIHRocm91Z2hcbiAgICAvLyByZXNvdXJjZVF1ZXJ5LCBzbyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCBpZlxuICAgIC8vIHRoZXkgYXJlIG5vdCBwcm92aWRlZFxuXG4gICAgc29ja0hvc3QgPSBwYXJzZWRRdWVyeS5zb2NrSG9zdCB8fCBzb2NrSG9zdDtcbiAgICBzb2NrUGF0aCA9IHBhcnNlZFF1ZXJ5LnNvY2tQYXRoIHx8IHNvY2tQYXRoO1xuICAgIHNvY2tQb3J0ID0gcGFyc2VkUXVlcnkuc29ja1BvcnQgfHwgc29ja1BvcnQ7XG4gIH1cblxuICByZXR1cm4gdXJsLmZvcm1hdCh7XG4gICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgIGF1dGg6IGF1dGgsXG4gICAgaG9zdG5hbWU6IHNvY2tIb3N0LFxuICAgIHBvcnQ6IHNvY2tQb3J0LFxuICAgIC8vIElmIHNvY2tQYXRoIGlzIHByb3ZpZGVkIGl0J2xsIGJlIHBhc3NlZCBpbiB2aWEgdGhlIHJlc291cmNlUXVlcnkgYXMgYVxuICAgIC8vIHF1ZXJ5IHBhcmFtIHNvIGl0IGhhcyB0byBiZSBwYXJzZWQgb3V0IG9mIHRoZSBxdWVyeXN0cmluZyBpbiBvcmRlciBmb3IgdGhlXG4gICAgLy8gY2xpZW50IHRvIG9wZW4gdGhlIHNvY2tldCB0byB0aGUgY29ycmVjdCBsb2NhdGlvbi5cbiAgICBwYXRobmFtZTogc29ja1BhdGhcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU29ja2V0VXJsOyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcbiAgLy8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFsbCBiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgaW4gdGhlIGRvY3VtZW50LlxuXG5cbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcbiAgdmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1tzY3JpcHRFbGVtZW50cy5sZW5ndGggLSAxXTtcblxuICBpZiAoY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBjdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cblxuXG4gIHRocm93IG5ldyBFcnJvcignW1dEU10gRmFpbGVkIHRvIGdldCBjdXJyZW50IHNjcmlwdCBzb3VyY2UuJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLmdldExvZ2dlcignd2VicGFjay1kZXYtc2VydmVyJyk7XG5cbnZhciBJTkZPID0gJ2luZm8nO1xudmFyIFdBUk4gPSAnd2Fybic7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIERFQlVHID0gJ2RlYnVnJztcbnZhciBUUkFDRSA9ICd0cmFjZSc7XG52YXIgU0lMRU5UID0gJ3NpbGVudCc7IC8vIGRlcHJlY2F0ZWRcbi8vIFRPRE86IHJlbW92ZSB0aGVzZSBhdCBtYWpvciByZWxlYXNlZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMTgyNVxuXG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcbnZhciBOT05FID0gJ25vbmUnOyAvLyBTZXQgdGhlIGRlZmF1bHQgbG9nIGxldmVsXG5cbmxvZy5zZXREZWZhdWx0TGV2ZWwoSU5GTyk7XG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIElORk86XG4gICAgY2FzZSBXQVJOOlxuICAgIGNhc2UgRVJST1I6XG4gICAgY2FzZSBERUJVRzpcbiAgICBjYXNlIFRSQUNFOlxuICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgV0FSTklORzpcbiAgICAgIC8vIGxvZ2xldmVsJ3Mgd2FybmluZyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHdlYnBhY2snc1xuICAgICAgbG9nLnNldExldmVsKCd3YXJuJyk7XG4gICAgICBicmVhaztcbiAgICAvLyBkZXByZWNhdGVkXG5cbiAgICBjYXNlIE5PTkU6XG4gICAgY2FzZSBTSUxFTlQ6XG4gICAgICBsb2cuZGlzYWJsZUFsbCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbG9nLmVycm9yKFwiW1dEU10gVW5rbm93biBjbGllbnRMb2dMZXZlbCAnXCIuY29uY2F0KGxldmVsLCBcIidcIikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2c6IGxvZyxcbiAgc2V0TG9nTGV2ZWw6IHNldExvZ0xldmVsXG59OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vbG9nJyksXG4gICAgbG9nID0gX3JlcXVpcmUubG9nO1xuXG5mdW5jdGlvbiByZWxvYWRBcHAoX3JlZiwgX3JlZjIpIHtcbiAgdmFyIGhvdFJlbG9hZCA9IF9yZWYuaG90UmVsb2FkLFxuICAgICAgaG90ID0gX3JlZi5ob3QsXG4gICAgICBsaXZlUmVsb2FkID0gX3JlZi5saXZlUmVsb2FkO1xuICB2YXIgaXNVbmxvYWRpbmcgPSBfcmVmMi5pc1VubG9hZGluZyxcbiAgICAgIGN1cnJlbnRIYXNoID0gX3JlZjIuY3VycmVudEhhc2g7XG5cbiAgaWYgKGlzVW5sb2FkaW5nIHx8ICFob3RSZWxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaG90KSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCBob3QgdXBkYXRlLi4uJyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuXG4gICAgdmFyIGhvdEVtaXR0ZXIgPSByZXF1aXJlKCd3ZWJwYWNrL2hvdC9lbWl0dGVyJyk7XG5cbiAgICBob3RFbWl0dGVyLmVtaXQoJ3dlYnBhY2tIb3RVcGRhdGUnLCBjdXJyZW50SGFzaCk7XG5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93KSB7XG4gICAgICAvLyBicm9hZGNhc3QgdXBkYXRlIHRvIHdpbmRvd1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZShcIndlYnBhY2tIb3RVcGRhdGVcIi5jb25jYXQoY3VycmVudEhhc2gpLCAnKicpO1xuICAgIH1cbiAgfSAvLyBhbGxvdyByZWZyZXNoaW5nIHRoZSBwYWdlIG9ubHkgaWYgbGl2ZVJlbG9hZCBpc24ndCBkaXNhYmxlZFxuICBlbHNlIGlmIChsaXZlUmVsb2FkKSB7XG4gICAgICB2YXIgcm9vdFdpbmRvdyA9IHNlbGY7IC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxuXG4gICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNlbGYuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocm9vdFdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2Fib3V0OicpIHtcbiAgICAgICAgICAvLyByZWxvYWQgaW1tZWRpYXRlbHkgaWYgcHJvdG9jb2wgaXMgdmFsaWRcbiAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290V2luZG93ID0gcm9vdFdpbmRvdy5wYXJlbnQ7XG5cbiAgICAgICAgICBpZiAocm9vdFdpbmRvdy5wYXJlbnQgPT09IHJvb3RXaW5kb3cpIHtcbiAgICAgICAgICAgIC8vIGlmIHBhcmVudCBlcXVhbHMgY3VycmVudCB3aW5kb3cgd2UndmUgcmVhY2hlZCB0aGUgcm9vdCB3aGljaCB3b3VsZCBjb250aW51ZSBmb3JldmVyLCBzbyB0cmlnZ2VyIGEgcmVsb2FkIGFueXdheXNcbiAgICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgcm9vdFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbG9hZEFwcDsiLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cbi8vIFNlbmQgbWVzc2FnZXMgdG8gdGhlIG91dHNpZGUsIHNvIHBsdWdpbnMgY2FuIGNvbnN1bWUgaXQuXG5cbmZ1bmN0aW9uIHNlbmRNc2codHlwZSwgZGF0YSkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnIHx8ICEoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSkpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwid2VicGFja1wiLmNvbmNhdCh0eXBlKSxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9LCAnKicpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2VuZE1zZzsiLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJ2YXIgbWFwID0ge1xuXHRcIi4vbG9nXCI6IFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLmpzXCJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90IHN5bmMgXlxcXFwuXFxcXC9sb2ckXCI7IiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiIsInZhciBsb2dMZXZlbCA9IFwiaW5mb1wiO1xuXG5mdW5jdGlvbiBkdW1teSgpIHt9XG5cbmZ1bmN0aW9uIHNob3VsZExvZyhsZXZlbCkge1xuXHR2YXIgc2hvdWxkTG9nID1cblx0XHQobG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJlcnJvclwiKTtcblx0cmV0dXJuIHNob3VsZExvZztcbn1cblxuZnVuY3Rpb24gbG9nR3JvdXAobG9nRm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcblx0XHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdFx0bG9nRm4obXNnKTtcblx0XHR9XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdGlmIChsZXZlbCA9PT0gXCJpbmZvXCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHtcblx0XHRcdGNvbnNvbGUud2Fybihtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihtc2cpO1xuXHRcdH1cblx0fVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG52YXIgZ3JvdXAgPSBjb25zb2xlLmdyb3VwIHx8IGR1bW15O1xudmFyIGdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZCB8fCBkdW1teTtcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwRW5kID0gbG9nR3JvdXAoZ3JvdXBFbmQpO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7XG5cdGxvZ0xldmVsID0gbGV2ZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHR2YXIgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuXHR2YXIgc3RhY2sgPSBlcnIuc3RhY2s7XG5cdGlmICghc3RhY2spIHtcblx0XHRyZXR1cm4gbWVzc2FnZTtcblx0fSBlbHNlIGlmIChzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDwgMCkge1xuXHRcdHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzdGFjaztcblx0fVxufTtcbiIsImV4cG9ydCBjb25zdCBCb3hUaHJvd2VyID0ge1xyXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucCA9IHtcclxuICAgICAgbGF1bmNoRGVsYXk6IDEuNzUsXHJcbiAgICAgIGxhdW5jaFJhbmRvbTogMSxcclxuICAgICAgbGF1bmNoOiAyXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuICAgIHRoaXMucC5sYXVuY2ggLT0gZHQ7XHJcblxyXG4gICAgaWYgKHRoaXMucC5sYXVuY2ggPCAwKSB7XHJcbiAgICAgIGxldCBrZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpO1xyXG4gICAgICBsZXQgaG91c2UgPSBuZXcgUS5Cb3goa2V5KTtcclxuICAgICAgUS5ob3VzZXNba2V5XSA9IGhvdXNlO1xyXG4gICAgICB0aGlzLnN0YWdlLmluc2VydChob3VzZSk7XHJcbiAgICAgIHRoaXMucC5sYXVuY2ggPSB0aGlzLnAubGF1bmNoRGVsYXkgKyB0aGlzLnAubGF1bmNoUmFuZG9tICogTWF0aC5yYW5kb20oKTtcclxuICAgIH1cclxuICB9XHJcbn07IiwiaW1wb3J0ICogYXMgUXVpbnR1cyBmcm9tICdxdWludHVzJztcclxuaW1wb3J0IHsgQm94VGhyb3dlciB9IGZyb20gJy4vZ2FtZS1vYmplY3QvYm94LXRocm93ZXInO1xyXG5pbXBvcnQgeyBMZXZlbDEgfSBmcm9tICcuL3NjZW5lL2xldmVsMSc7XHJcbmltcG9ydCB7IEJveCB9IGZyb20gJy4vc3ByaXRlL2JveCc7XHJcbmltcG9ydCB7IERyaXZlciB9IGZyb20gJy4vc3ByaXRlL2RyaXZlcic7XHJcbmltcG9ydCB7IEhvdXNlIH0gZnJvbSAnLi9zcHJpdGUvaG91c2UnO1xyXG5pbXBvcnQgeyBNb25leSB9IGZyb20gJy4vc3ByaXRlL21vbmV5JztcclxuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSAnLi9zcHJpdGUvcGxheWVyJztcclxuaW1wb3J0IHsgV2hlZWwgfSBmcm9tICcuL3Nwcml0ZS93aGVlbCc7XHJcblxyXG53aW5kb3cubG9hZEdhbWUgPSAoKSA9PiB7XHJcbiAgdmFyIHBsYXlCdXR0b24gPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BsYXlCdXR0b24nKTtcclxuICBwbGF5QnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGxheUJ1dHRvbik7XHJcblxyXG4gIHZhciBRID0gd2luZG93LlEgPSBRdWludHVzKHsgYXVkaW9TdXBwb3J0ZWQ6IFsnbXAzJywgJ29nZyddIH0pXHJcbiAgICAuaW5jbHVkZShcIlNwcml0ZXMsIFNjZW5lcywgSW5wdXQsIDJELCBBbmltLCBUb3VjaCwgVUlcIilcclxuICAgIC5zZXR1cCh7IHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAsIHNjYWxlVG9GaXQ6IHRydWUgfSlcclxuICAgIC5jb250cm9scygpLnRvdWNoKCk7XHJcblxyXG4gIFEuZ3Jhdml0eVkgPSAyMDAwO1xyXG5cclxuICBRLmJveGVzID0gMDtcclxuICBRLnNjb3JlID0gMDtcclxuICBRLmhvdXNlcyA9IHt9O1xyXG5cclxuICBRLmluY2x1ZGUoXCJBdWRpb1wiKS5lbmFibGVTb3VuZCgpO1xyXG5cclxuICBRLlNwcml0ZS5leHRlbmQoXCJEcml2ZXJcIiwgRHJpdmVyKTtcclxuXHJcbiAgUS5TcHJpdGUuZXh0ZW5kKFwiUGxheWVyXCIsIFBsYXllcik7XHJcbiAgXHJcbiAgUS5TcHJpdGUuZXh0ZW5kKFwiQm94XCIsIEJveCk7XHJcblxyXG4gIFEuU3ByaXRlLmV4dGVuZChcIk1vbmV5XCIsIE1vbmV5KTtcclxuXHJcbiAgUS5TcHJpdGUuZXh0ZW5kKFwiV2hlZWxcIiwgV2hlZWwpO1xyXG4gIFxyXG4gIFEuR2FtZU9iamVjdC5leHRlbmQoXCJCb3hUaHJvd2VyXCIsIEJveFRocm93ZXIpO1xyXG5cclxuICBRLlNwcml0ZS5leHRlbmQoXCJIb3VzZVwiLCBIb3VzZSk7XHJcblxyXG4gIFEuc2NlbmUoXCJsZXZlbDFcIiwgTGV2ZWwxKTtcclxuXHJcbiAgUS5sb2FkKFtcImRyaXZlci5wbmdcIixcclxuICAgICdwbGF5ZXIucG5nJyxcclxuICAgICd3aGVlbC1zb3VyY2UucG5nJyxcclxuICAgICdza3kucG5nJyxcclxuICAgICdyb2FkLnBuZycsXHJcbiAgICAnY3JhdGVzLnBuZycsXHJcbiAgICAnY3JhdGVzLmpzb24nLFxyXG4gICAgJ2dyYXNzLnBuZycsXHJcbiAgICAndmVoaWNsZS5wbmcnLFxyXG4gICAgJ21vbmV5LnBuZycsXHJcbiAgICAnaG91c2UxLnBuZycsXHJcbiAgICAnaG91c2UxLWRlc3Ryb3llZC5wbmcnLFxyXG4gICAgJ2hvdXNlMi5wbmcnLFxyXG4gICAgJ2hvdXNlMi1kZXN0cm95ZWQucG5nJyxcclxuICAgICdqaW5nbGUubXAzJ10sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgUS5jb21waWxlU2hlZXRzKFwiY3JhdGVzLnBuZ1wiLCBcImNyYXRlcy5qc29uXCIpO1xyXG4gICAgICBRLnN0YWdlU2NlbmUoXCJsZXZlbDFcIik7XHJcblxyXG4gICAgICBmdW5jdGlvbiBwbGF5VGhlbWVTb25nKCkge1xyXG4gICAgICAgIFEuYXVkaW8uc3RvcCgnamluZ2xlLm1wMycpO1xyXG4gICAgICAgIFEuYXVkaW8ucGxheSgnamluZ2xlLm1wMycsIHtcclxuICAgICAgICAgIGxvb3A6IHRydWUsXHJcbiAgICAgICAgICBsb29wU3RhcnQ6IDAsXHJcbiAgICAgICAgICBsb29wRW5kOiA1MVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHBsYXlUaGVtZVNvbmcoKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG5cclxuIiwiZXhwb3J0IGNvbnN0IExldmVsMSA9IGZ1bmN0aW9uIChzdGFnZSkge1xyXG4gIHN0YWdlLmluc2VydChuZXcgUS5SZXBlYXRlcih7XHJcbiAgICBhc3NldDogXCJza3kucG5nXCIsXHJcbiAgICByZXBlYXRZOiBmYWxzZSxcclxuICAgIHNwZWVkWDogMC41LFxyXG4gICAgeTogLTc1XHJcbiAgfSkpO1xyXG4gIDFcclxuICBzdGFnZS5pbnNlcnQobmV3IFEuUmVwZWF0ZXIoe1xyXG4gICAgYXNzZXQ6IFwicm9hZC5wbmdcIixcclxuICAgIHJlcGVhdFk6IGZhbHNlLFxyXG4gICAgc3BlZWRYOiAxLjAsXHJcbiAgICB5OiAzMDBcclxuICB9KSk7XHJcblxyXG4gIHN0YWdlLmluc2VydChuZXcgUS5SZXBlYXRlcih7XHJcbiAgICBhc3NldDogXCJncmFzcy5wbmdcIixcclxuICAgIHJlcGVhdFk6IGZhbHNlLFxyXG4gICAgc3BlZWRYOiAxLjAsXHJcbiAgICB5OiAxNTBcclxuICB9KSk7XHJcbiAgc3RhZ2UuaW5zZXJ0KG5ldyBRLkJveFRocm93ZXIoKSk7XHJcbiAgc3RhZ2UuaW5zZXJ0KG5ldyBRLkRyaXZlcih7ejoxLHNjYWxlOi41fSkpO1xyXG4gIHN0YWdlLmluc2VydChuZXcgUS5QbGF5ZXIoe3o6MTAwfSkpO1xyXG4gIHN0YWdlLmluc2VydChuZXcgUS5XaGVlbCh7eDoyMH0pKTtcclxuICBzdGFnZS5pbnNlcnQobmV3IFEuV2hlZWwoe3g6NTkwfSkpO1xyXG5cclxuICBzdGFnZS5hZGQoXCJ2aWV3cG9ydFwiKTtcclxufTtcclxuIiwiZXhwb3J0IGNvbnN0IEJveCA9IHtcclxuICBpbml0OiBmdW5jdGlvbiAoa2V5KSB7XHJcblxyXG4gICAgdmFyIGxldmVscyA9IFs1NjUsIDU0MCwgNTAwLCA0NTBdO1xyXG5cclxuICAgIHZhciBwbGF5ZXIgPSBRKFwiUGxheWVyXCIpLmZpcnN0KCk7XHJcbiAgICB0aGlzLl9zdXBlcih7XHJcbiAgICAgIGlkOiBrZXksXHJcbiAgICAgIHg6IHBsYXllci5wLnggKyBRLndpZHRoICsgNTAsXHJcbiAgICAgIHk6IDI2NSxcclxuICAgICAgY29sbGlzaW9uTWFzazogMSxcclxuICAgICAgc2NhbGU6IC43LFxyXG4gICAgICBhc3NldDogKE1hdGgucmFuZG9tKCkgPCAwLjUgPyAnaG91c2UxLWRlc3Ryb3llZC5wbmcnIDonaG91c2UyLWRlc3Ryb3llZC5wbmcnKSxcclxuICAgICAgdng6IDAsXHJcbiAgICAgIHZ5OiAwLFxyXG4gICAgICBzeDogNjAwLFxyXG4gICAgICBzeTogNjAwLFxyXG4gICAgICBheTogMFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vbihcImhpdFwiKTtcclxuICB9LFxyXG5cclxuICBzdGVwOiBmdW5jdGlvbiAoZHQpIHtcclxuICAgIHZhciBwbGF5ZXIgPSBRKFwiUGxheWVyXCIpLmZpcnN0KCk7XHJcbiAgICB0aGlzLnAueCArPSB0aGlzLnAudnggKiBkdDtcclxuXHJcblxyXG4gICAgdGhpcy5wLnZ5ICs9IHRoaXMucC5heSAqIGR0O1xyXG4gICAgdGhpcy5wLnkgKz0gdGhpcy5wLnZ5ICogZHQ7XHJcblxyXG4gICAgaWYgKHRoaXMucC54IDwgcGxheWVyLnAueCAtIDExMDApIHtcclxuICAgICAgZGVsZXRlIFEuaG91c2VzW3RoaXMucC5pZF07XHJcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGZpeDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5wLmFzc2V0ID0gJ2hvdXNlMS5wbmcnO1xyXG4gICAgZGVsZXRlIFEuaG91c2VzW3RoaXMucC5pZF07XHJcbiAgICBRLnNjb3JlKys7XHJcbiAgfVxyXG59OyAiLCJleHBvcnQgY29uc3QgRHJpdmVyID1cclxue1xyXG4gIGluaXQ6IGZ1bmN0aW9uIChwKSB7XHJcblxyXG4gICAgdGhpcy5fc3VwZXIocCwge1xyXG4gICAgICBhc3NldDogXCJkcml2ZXIucG5nXCIsXHJcbiAgICAgIGNvbGxpc2lvbk1hc2s6IDAsXHJcbiAgICAgIHg6IDMzMCxcclxuICAgICAgeTogNTAwLFxyXG4gICAgICBzcGVlZDogNTAwLFxyXG4gICAgICBqdW1wOiAtNzUwXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmFkZChcIjJkLCBhbmltYXRpb25cIik7XHJcbiAgfSxcclxuXHJcbiAgc3RlcDogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICB0aGlzLnAudnggKz0gKHRoaXMucC5zcGVlZCAtIHRoaXMucC52eCkgLyA0O1xyXG5cclxuICAgIGlmICh0aGlzLnAueSA+IDUwMCkge1xyXG4gICAgICB0aGlzLnAueSA9IDUwMDtcclxuICAgICAgdGhpcy5wLmxhbmRlZCA9IDE7XHJcbiAgICAgIHRoaXMucC52eSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnAubGFuZGVkID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoUS5pbnB1dHNbJ2FjdGlvbiddICYmIHRoaXMucC5sYW5kZWQgPiAwKSB7XHJcbiAgICAgIHRoaXMucC52eSA9IHRoaXMucC5qdW1wO1xyXG4gICAgICB0aGlzLnAuc2NhbGUgKj0gMS4xO1xyXG4gICAgfVxyXG4gIH1cclxufTsiLCJleHBvcnQgY29uc3QgSG91c2UgPSB7XHJcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBsZXZlbHMgPSBbNTY1LCA1NDAsIDUwMCwgNDUwXTtcclxuXHJcbiAgICB2YXIgcGxheWVyID0gUShcIlBsYXllclwiKS5maXJzdCgpO1xyXG4gICAgdGhpcy5fc3VwZXIoe1xyXG5cclxuICAgICAgeDogcGxheWVyLnAueCxcclxuICAgICAgeTogcGxheWVyLnAueSxcclxuICAgIC8vICBmcmFtZTogTWF0aC5yYW5kb20oKSA8IDAuNSA/IDEgOiAwLFxyXG4gICAgICBhc3NldDogJ0hvdXNlMS5wbmcnLFxyXG4gICAgICB2eDogLTYwMCArIDIwMCAqIE1hdGgucmFuZG9tKCksXHJcbiAgICAgIHZ5OiAwLFxyXG4gICAgICBheTogMCxcclxuICAgICAgdGhldGE6ICgzMDAgKiBNYXRoLnJhbmRvbSgpICsgMjAwKSAqIChNYXRoLnJhbmRvbSgpIDwgMC41ID8gMSA6IC0xKVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8vIHRoaXMub24oXCJoaXRcIik7XHJcbiAgfSxcclxuXHJcbiAgc3RlcDogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICB0aGlzLnAueCArPSB0aGlzLnAudnggKiBkdDtcclxuXHJcblxyXG4gICAgdGhpcy5wLnZ5ICs9IHRoaXMucC5heSAqIGR0O1xyXG4gICAgdGhpcy5wLnkgKz0gdGhpcy5wLnZ5ICogZHQ7XHJcbiAgICBpZiAodGhpcy5wLnkgIT0gNTY1KSB7XHJcbiAgICAgIHRoaXMucC5hbmdsZSArPSB0aGlzLnAudGhldGEgKiBkdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5wLnkgPiA4MDApIHsgdGhpcy5kZXN0cm95KCk7IH1cclxuXHJcbiAgfSxcclxuXHJcbiAgLy8gaGl0OiBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gICB0aGlzLnAudHlwZSA9IDA7XHJcbiAgLy8gICB0aGlzLnAuY29sbGlzaW9uTWFzayA9IFEuU1BSSVRFX05PTkU7XHJcbiAgLy8gICB0aGlzLnAudnggPSAyMDA7XHJcbiAgLy8gICB0aGlzLnAuYXkgPSA0MDA7XHJcbiAgLy8gICB0aGlzLnAudnkgPSAtMzAwO1xyXG4gIC8vICAgdGhpcy5wLm9wYWNpdHkgPSAwLjU7XHJcbiAgLy8gfVxyXG59OyAiLCJleHBvcnQgY29uc3QgTW9uZXkgPSB7XHJcbiAgaW5pdDogZnVuY3Rpb24gKHBsYXllcikge1xyXG4gICAgdGhpcy5fc3VwZXIoe1xyXG4gICAgICBhc3NldDonbW9uZXkucG5nJyxcclxuICAgICAgeDogcGxheWVyLnggKyA1MCxcclxuICAgICAgeTogcGxheWVyLnkgLSAyMCxcclxuICAgICAgc2NhbGU6IC4wNSxcclxuICAgICAgc3BlZWQ6IDUwMCxcclxuICAgICAgcGxheWVyOiBwbGF5ZXIsXHJcbiAgICAgIGNvbGxpc2lvbk1hc2s6IDFcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMub24oJ2hpdCcpO1xyXG4gIH0sXHJcblxyXG4gIHN0ZXA6IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgdGhpcy5wLnkgLT0gNTtcclxuICAgIHRoaXMucC54ID0gdGhpcy5wLnBsYXllci54ICsgNTA7XHJcbiAgICB0aGlzLnAuYW5nbGUgKz0gMTA7XHJcbiAgICB0aGlzLnAuc2NhbGUgKj0gLjk4NTtcclxuXHJcbiAgICBpZiAodGhpcy5wLnkgPCAzNTApIHtcclxuICAgICAgdGhpcy5wLnNjYWxlICo9IC45O1xyXG5cclxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gUS5ob3VzZXMpIHtcclxuICAgICAgICBpZiAoUS5ob3VzZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgaWYgKHRoaXMucC54ID49IFEuaG91c2VzW2tleV0ucC54IC0gMTUwICYmIHRoaXMucC54IDw9IFEuaG91c2VzW2tleV0ucC54ICsgMTUwKSB7XHJcbiAgICAgICAgICAgIFEuaG91c2VzW2tleV0uZml4KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucC55IDwgMzAwKSB7IFxyXG4gICAgICB0aGlzLmRlc3Ryb3koKTsgXHJcbiAgICAgIFEuYm94ZXMtLTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBoaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgY29uc29sZS5sb2coJ0hlbGxvJyk7XHJcbiAgICB0aGlzLnAuc2NhbGUgPSA1O1xyXG4gIH1cclxufTsiLCJleHBvcnQgY29uc3QgUGxheWVyID1cclxue1xyXG4gIGluaXQ6IGZ1bmN0aW9uIChwKSB7XHJcblxyXG4gICAgdGhpcy5fc3VwZXIocCwge1xyXG4gICAgICBhc3NldDogXCJ2ZWhpY2xlLnBuZ1wiLFxyXG4gICAgICBjb2xsaXNpb25NYXNrOiAwLFxyXG4gICAgICB4OiAzMDAsXHJcbiAgICAgIHk6IDU1MCxcclxuICAgICAgc3BlZWQ6IDUwMCxcclxuICAgICAganVtcDogLTc1MFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5wLnBvaW50cyA9IHRoaXMucC5zdGFuZGluZ1BvaW50cztcclxuXHJcbiAgICB0aGlzLmFkZChcIjJkLCBhbmltYXRpb25cIik7XHJcbiAgfSxcclxuXHJcbiAgc3RlcDogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICB0aGlzLnAudnggKz0gKHRoaXMucC5zcGVlZCAtIHRoaXMucC52eCkgLyA0O1xyXG5cclxuICAgIGlmICh0aGlzLnAueSA+IDU1MCkge1xyXG4gICAgICB0aGlzLnAueSA9IDU1MDtcclxuICAgICAgdGhpcy5wLmxhbmRlZCA9IDE7XHJcbiAgICAgIHRoaXMucC52eSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnAubGFuZGVkID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoUS5pbnB1dHNbJ2FjdGlvbiddICYmIHRoaXMucC5sYW5kZWQgPiAwKSB7XHJcbiAgICAgIHRoaXMucC52eSA9IHRoaXMucC5qdW1wO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChRLmlucHV0c1snZmlyZSddKSB7XHJcbiAgICAgIGlmIChRLmJveGVzIDwgMSkge1xyXG4gICAgICAgIHRoaXMuc3RhZ2UuaW5zZXJ0KG5ldyBRLk1vbmV5KHRoaXMucCkpO1xyXG4gICAgICAgIFEuYm94ZXMrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhZ2Uudmlld3BvcnQuY2VudGVyT24odGhpcy5wLnggKyAzMDAsIDQwMCk7XHJcbiAgfVxyXG59OyIsImV4cG9ydCBjb25zdCBXaGVlbCA9XHJcbntcclxuICBpbml0OiBmdW5jdGlvbiAocCkge1xyXG5cclxuICAgIHRoaXMuX3N1cGVyKHAsIHtcclxuICAgICAgYXNzZXQ6IFwid2hlZWwtc291cmNlLnBuZ1wiLFxyXG4gICAgICBjb2xsaXNpb25NYXNrOiAwLFxyXG4gICAgICB5OiA2NjAsXHJcbiAgICAgIHNwZWVkOiA1MDAsXHJcbiAgICAgIGp1bXA6IC03NTBcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuYWRkKFwiMmQsIGFuaW1hdGlvblwiKTtcclxuICB9LFxyXG5cclxuICBzdGVwOiBmdW5jdGlvbiAoZHQpIHtcclxuICAgIHRoaXMucC52eCArPSAodGhpcy5wLnNwZWVkIC0gdGhpcy5wLnZ4KSAvIDQ7XHJcblxyXG4gICAgaWYgKHRoaXMucC55ID4gNjYwKSB7XHJcbiAgICAgIHRoaXMucC55ID0gNjYwO1xyXG4gICAgICB0aGlzLnAubGFuZGVkID0gMTtcclxuICAgICAgdGhpcy5wLnZ5ID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucC5sYW5kZWQgPSAwO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wLmFuZ2xlICs9IDEwO1xyXG5cclxuICB9XHJcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==